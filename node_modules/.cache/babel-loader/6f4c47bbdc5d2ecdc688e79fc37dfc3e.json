{"ast":null,"code":"import \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport Geometry from '../Geometry';\nimport BoundingBox from '../math/BoundingBox';\n/**\n * @constructor clay.geometry.Sphere\n * @extends clay.Geometry\n * @param {Object} [opt]\n * @param {number} [widthSegments]\n * @param {number} [heightSegments]\n * @param {number} [phiStart]\n * @param {number} [phiLength]\n * @param {number} [thetaStart]\n * @param {number} [thetaLength]\n * @param {number} [radius]\n */\n\nvar Sphere = Geometry.extend(\n/** @lends clay.geometry.Sphere# */\n{\n  dynamic: false,\n\n  /**\n   * @type {number}\n   */\n  widthSegments: 40,\n\n  /**\n   * @type {number}\n   */\n  heightSegments: 20,\n\n  /**\n   * @type {number}\n   */\n  phiStart: 0,\n\n  /**\n   * @type {number}\n   */\n  phiLength: Math.PI * 2,\n\n  /**\n   * @type {number}\n   */\n  thetaStart: 0,\n\n  /**\n   * @type {number}\n   */\n  thetaLength: Math.PI,\n\n  /**\n   * @type {number}\n   */\n  radius: 1\n}, function () {\n  this.build();\n},\n/** @lends clay.geometry.Sphere.prototype */\n{\n  /**\n   * Build sphere geometry\n   */\n  build: function () {\n    var heightSegments = this.heightSegments;\n    var widthSegments = this.widthSegments;\n    var positionAttr = this.attributes.position;\n    var texcoordAttr = this.attributes.texcoord0;\n    var normalAttr = this.attributes.normal;\n    var vertexCount = (widthSegments + 1) * (heightSegments + 1);\n    positionAttr.init(vertexCount);\n    texcoordAttr.init(vertexCount);\n    normalAttr.init(vertexCount);\n    var IndicesCtor = vertexCount > 0xffff ? Uint32Array : Uint16Array;\n    var indices = this.indices = new IndicesCtor(widthSegments * heightSegments * 6);\n    var x, y, z, u, v, i, j;\n    var radius = this.radius;\n    var phiStart = this.phiStart;\n    var phiLength = this.phiLength;\n    var thetaStart = this.thetaStart;\n    var thetaLength = this.thetaLength;\n    var radius = this.radius;\n    var pos = [];\n    var uv = [];\n    var offset = 0;\n    var divider = 1 / radius;\n\n    for (j = 0; j <= heightSegments; j++) {\n      for (i = 0; i <= widthSegments; i++) {\n        u = i / widthSegments;\n        v = j / heightSegments; // X axis is inverted so texture can be mapped from left to right\n\n        x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);\n        y = radius * Math.cos(thetaStart + v * thetaLength);\n        z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);\n        pos[0] = x;\n        pos[1] = y;\n        pos[2] = z;\n        uv[0] = u;\n        uv[1] = v;\n        positionAttr.set(offset, pos);\n        texcoordAttr.set(offset, uv);\n        pos[0] *= divider;\n        pos[1] *= divider;\n        pos[2] *= divider;\n        normalAttr.set(offset, pos);\n        offset++;\n      }\n    }\n\n    var i1, i2, i3, i4;\n    var len = widthSegments + 1;\n    var n = 0;\n\n    for (j = 0; j < heightSegments; j++) {\n      for (i = 0; i < widthSegments; i++) {\n        i2 = j * len + i;\n        i1 = j * len + i + 1;\n        i4 = (j + 1) * len + i + 1;\n        i3 = (j + 1) * len + i;\n        indices[n++] = i1;\n        indices[n++] = i2;\n        indices[n++] = i4;\n        indices[n++] = i2;\n        indices[n++] = i3;\n        indices[n++] = i4;\n      }\n    }\n\n    this.boundingBox = new BoundingBox();\n    this.boundingBox.max.set(radius, radius, radius);\n    this.boundingBox.min.set(-radius, -radius, -radius);\n  }\n});\nexport default Sphere;","map":{"version":3,"sources":["C:/Users/Administrator/Desktop/data_view/my_project/vue2_app/myapp/node_modules/claygl/src/geometry/Sphere.js"],"names":["Geometry","BoundingBox","Sphere","extend","dynamic","widthSegments","heightSegments","phiStart","phiLength","Math","PI","thetaStart","thetaLength","radius","build","positionAttr","attributes","position","texcoordAttr","texcoord0","normalAttr","normal","vertexCount","init","IndicesCtor","Uint32Array","Uint16Array","indices","x","y","z","u","v","i","j","pos","uv","offset","divider","cos","sin","set","i1","i2","i3","i4","len","n","boundingBox","max","min"],"mappings":"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","sourcesContent":["import Geometry from '../Geometry';\nimport BoundingBox from '../math/BoundingBox';\n\n/**\n * @constructor clay.geometry.Sphere\n * @extends clay.Geometry\n * @param {Object} [opt]\n * @param {number} [widthSegments]\n * @param {number} [heightSegments]\n * @param {number} [phiStart]\n * @param {number} [phiLength]\n * @param {number} [thetaStart]\n * @param {number} [thetaLength]\n * @param {number} [radius]\n */\nvar Sphere = Geometry.extend(/** @lends clay.geometry.Sphere# */ {\n    dynamic: false,\n    /**\n     * @type {number}\n     */\n    widthSegments: 40,\n    /**\n     * @type {number}\n     */\n    heightSegments: 20,\n\n    /**\n     * @type {number}\n     */\n    phiStart: 0,\n    /**\n     * @type {number}\n     */\n    phiLength: Math.PI * 2,\n\n    /**\n     * @type {number}\n     */\n    thetaStart: 0,\n    /**\n     * @type {number}\n     */\n    thetaLength: Math.PI,\n\n    /**\n     * @type {number}\n     */\n    radius: 1\n\n}, function() {\n    this.build();\n},\n/** @lends clay.geometry.Sphere.prototype */\n{\n    /**\n     * Build sphere geometry\n     */\n    build: function() {\n        var heightSegments = this.heightSegments;\n        var widthSegments = this.widthSegments;\n\n        var positionAttr = this.attributes.position;\n        var texcoordAttr = this.attributes.texcoord0;\n        var normalAttr = this.attributes.normal;\n\n        var vertexCount = (widthSegments + 1) * (heightSegments + 1);\n        positionAttr.init(vertexCount);\n        texcoordAttr.init(vertexCount);\n        normalAttr.init(vertexCount);\n\n        var IndicesCtor = vertexCount > 0xffff ? Uint32Array : Uint16Array;\n        var indices = this.indices = new IndicesCtor(widthSegments * heightSegments * 6);\n\n        var x, y, z,\n            u, v,\n            i, j;\n\n        var radius = this.radius;\n        var phiStart = this.phiStart;\n        var phiLength = this.phiLength;\n        var thetaStart = this.thetaStart;\n        var thetaLength = this.thetaLength;\n        var radius = this.radius;\n\n        var pos = [];\n        var uv = [];\n        var offset = 0;\n        var divider = 1 / radius;\n        for (j = 0; j <= heightSegments; j ++) {\n            for (i = 0; i <= widthSegments; i ++) {\n                u = i / widthSegments;\n                v = j / heightSegments;\n\n                // X axis is inverted so texture can be mapped from left to right\n                x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);\n                y = radius * Math.cos(thetaStart + v * thetaLength);\n                z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);\n\n                pos[0] = x; pos[1] = y; pos[2] = z;\n                uv[0] = u; uv[1] = v;\n                positionAttr.set(offset, pos);\n                texcoordAttr.set(offset, uv);\n                pos[0] *= divider;\n                pos[1] *= divider;\n                pos[2] *= divider;\n                normalAttr.set(offset, pos);\n                offset++;\n            }\n        }\n\n        var i1, i2, i3, i4;\n\n        var len = widthSegments + 1;\n\n        var n = 0;\n        for (j = 0; j < heightSegments; j ++) {\n            for (i = 0; i < widthSegments; i ++) {\n                i2 = j * len + i;\n                i1 = (j * len + i + 1);\n                i4 = (j + 1) * len + i + 1;\n                i3 = (j + 1) * len + i;\n\n                indices[n++] = i1;\n                indices[n++] = i2;\n                indices[n++] = i4;\n\n                indices[n++] = i2;\n                indices[n++] = i3;\n                indices[n++] = i4;\n            }\n        }\n\n        this.boundingBox = new BoundingBox();\n        this.boundingBox.max.set(radius, radius, radius);\n        this.boundingBox.min.set(-radius, -radius, -radius);\n    }\n});\n\nexport default Sphere;\n"]},"metadata":{},"sourceType":"module"}