{"ast":null,"code":"import \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.typed-array.uint16-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/es.typed-array.uint32-array.js\";\nimport \"core-js/modules/es.typed-array.float32-array.js\";\nimport \"core-js/modules/es.string.sub.js\";\n\n/**\n * Lines geometry\n * Use screen space projected lines lineWidth > MAX_LINE_WIDTH\n * https://mattdesl.svbtle.com/drawing-lines-is-hard\n * @module echarts-gl/util/geometry/LinesGeometry\n * @author Yi Shen(http://github.com/pissang)\n */\nimport Geometry from 'claygl/src/Geometry';\nimport * as echarts from 'echarts/lib/echarts';\nimport dynamicConvertMixin from './dynamicConvertMixin';\nimport glmatrix from 'claygl/src/dep/glmatrix';\nvar vec2 = glmatrix.vec2; // var CURVE_RECURSION_LIMIT = 8;\n// var CURVE_COLLINEAR_EPSILON = 40;\n\nvar sampleLinePoints = [[0, 0], [1, 1]];\n/**\n * @constructor\n * @alias module:echarts-gl/util/geometry/LinesGeometry\n * @extends clay.Geometry\n */\n\nvar LinesGeometry = Geometry.extend(function () {\n  return {\n    segmentScale: 4,\n    dynamic: true,\n\n    /**\n     * Need to use mesh to expand lines if lineWidth > MAX_LINE_WIDTH\n     */\n    useNativeLine: true,\n    attributes: {\n      position: new Geometry.Attribute('position', 'float', 2, 'POSITION'),\n      normal: new Geometry.Attribute('normal', 'float', 2),\n      offset: new Geometry.Attribute('offset', 'float', 1),\n      color: new Geometry.Attribute('color', 'float', 4, 'COLOR')\n    }\n  };\n},\n/** @lends module: echarts-gl/util/geometry/LinesGeometry.prototype */\n{\n  /**\n   * Reset offset\n   */\n  resetOffset: function resetOffset() {\n    this._vertexOffset = 0;\n    this._faceOffset = 0;\n    this._itemVertexOffsets = [];\n  },\n\n  /**\n   * @param {number} nVertex\n   */\n  setVertexCount: function setVertexCount(nVertex) {\n    var attributes = this.attributes;\n\n    if (this.vertexCount !== nVertex) {\n      attributes.position.init(nVertex);\n      attributes.color.init(nVertex);\n\n      if (!this.useNativeLine) {\n        attributes.offset.init(nVertex);\n        attributes.normal.init(nVertex);\n      }\n\n      if (nVertex > 0xffff) {\n        if (this.indices instanceof Uint16Array) {\n          this.indices = new Uint32Array(this.indices);\n        }\n      } else {\n        if (this.indices instanceof Uint32Array) {\n          this.indices = new Uint16Array(this.indices);\n        }\n      }\n    }\n  },\n\n  /**\n   * @param {number} nTriangle\n   */\n  setTriangleCount: function setTriangleCount(nTriangle) {\n    if (this.triangleCount !== nTriangle) {\n      if (nTriangle === 0) {\n        this.indices = null;\n      } else {\n        this.indices = this.vertexCount > 0xffff ? new Uint32Array(nTriangle * 3) : new Uint16Array(nTriangle * 3);\n      }\n    }\n  },\n  _getCubicCurveApproxStep: function _getCubicCurveApproxStep(p0, p1, p2, p3) {\n    var len = vec2.dist(p0, p1) + vec2.dist(p2, p1) + vec2.dist(p3, p2);\n    var step = 1 / (len + 1) * this.segmentScale;\n    return step;\n  },\n\n  /**\n   * Get vertex count of cubic curve\n   * @param {Array.<number>} p0\n   * @param {Array.<number>} p1\n   * @param {Array.<number>} p2\n   * @param {Array.<number>} p3\n   * @return number\n   */\n  getCubicCurveVertexCount: function getCubicCurveVertexCount(p0, p1, p2, p3) {\n    var step = this._getCubicCurveApproxStep(p0, p1, p2, p3);\n\n    var segCount = Math.ceil(1 / step);\n\n    if (!this.useNativeLine) {\n      return segCount * 2 + 2;\n    } else {\n      return segCount * 2;\n    }\n  },\n\n  /**\n   * Get face count of cubic curve\n   * @param {Array.<number>} p0\n   * @param {Array.<number>} p1\n   * @param {Array.<number>} p2\n   * @param {Array.<number>} p3\n   * @return number\n   */\n  getCubicCurveTriangleCount: function getCubicCurveTriangleCount(p0, p1, p2, p3) {\n    var step = this._getCubicCurveApproxStep(p0, p1, p2, p3);\n\n    var segCount = Math.ceil(1 / step);\n\n    if (!this.useNativeLine) {\n      return segCount * 2;\n    } else {\n      return 0;\n    }\n  },\n\n  /**\n   * Get vertex count of line\n   * @return {number}\n   */\n  getLineVertexCount: function getLineVertexCount() {\n    return this.getPolylineVertexCount(sampleLinePoints);\n  },\n\n  /**\n   * Get face count of line\n   * @return {number}\n   */\n  getLineTriangleCount: function getLineTriangleCount() {\n    return this.getPolylineTriangleCount(sampleLinePoints);\n  },\n\n  /**\n   * Get how many vertices will polyline take.\n   * @type {number|Array} points Can be a 1d/2d list of points, or a number of points amount.\n   * @return {number}\n   */\n  getPolylineVertexCount: function getPolylineVertexCount(points) {\n    var pointsLen;\n\n    if (typeof points === 'number') {\n      pointsLen = points;\n    } else {\n      var is2DArray = typeof points[0] !== 'number';\n      pointsLen = is2DArray ? points.length : points.length / 2;\n    }\n\n    return !this.useNativeLine ? (pointsLen - 1) * 2 + 2 : (pointsLen - 1) * 2;\n  },\n\n  /**\n   * Get how many triangles will polyline take.\n   * @type {number|Array} points Can be a 1d/2d list of points, or a number of points amount.\n   * @return {number}\n   */\n  getPolylineTriangleCount: function getPolylineTriangleCount(points) {\n    var pointsLen;\n\n    if (typeof points === 'number') {\n      pointsLen = points;\n    } else {\n      var is2DArray = typeof points[0] !== 'number';\n      pointsLen = is2DArray ? points.length : points.length / 2;\n    }\n\n    return !this.useNativeLine ? (pointsLen - 1) * 2 : 0;\n  },\n\n  /**\n   * Add a cubic curve\n   * @param {Array.<number>} p0\n   * @param {Array.<number>} p1\n   * @param {Array.<number>} p2\n   * @param {Array.<number>} p3\n   * @param {Array.<number>} color\n   * @param {number} [lineWidth=1]\n   */\n  addCubicCurve: function addCubicCurve(p0, p1, p2, p3, color, lineWidth) {\n    if (lineWidth == null) {\n      lineWidth = 1;\n    } // incremental interpolation\n    // http://antigrain.com/research/bezier_interpolation/index.html#PAGE_BEZIER_INTERPOLATION\n\n\n    var x0 = p0[0],\n        y0 = p0[1];\n    var x1 = p1[0],\n        y1 = p1[1];\n    var x2 = p2[0],\n        y2 = p2[1];\n    var x3 = p3[0],\n        y3 = p3[1];\n\n    var step = this._getCubicCurveApproxStep(p0, p1, p2, p3);\n\n    var step2 = step * step;\n    var step3 = step2 * step;\n    var pre1 = 3.0 * step;\n    var pre2 = 3.0 * step2;\n    var pre4 = 6.0 * step2;\n    var pre5 = 6.0 * step3;\n    var tmp1x = x0 - x1 * 2.0 + x2;\n    var tmp1y = y0 - y1 * 2.0 + y2;\n    var tmp2x = (x1 - x2) * 3.0 - x0 + x3;\n    var tmp2y = (y1 - y2) * 3.0 - y0 + y3;\n    var fx = x0;\n    var fy = y0;\n    var dfx = (x1 - x0) * pre1 + tmp1x * pre2 + tmp2x * step3;\n    var dfy = (y1 - y0) * pre1 + tmp1y * pre2 + tmp2y * step3;\n    var ddfx = tmp1x * pre4 + tmp2x * pre5;\n    var ddfy = tmp1y * pre4 + tmp2y * pre5;\n    var dddfx = tmp2x * pre5;\n    var dddfy = tmp2y * pre5;\n    var t = 0;\n    var k = 0;\n    var segCount = Math.ceil(1 / step);\n    var points = new Float32Array((segCount + 1) * 3);\n    var points = [];\n    var offset = 0;\n\n    for (var k = 0; k < segCount + 1; k++) {\n      points[offset++] = fx;\n      points[offset++] = fy;\n      fx += dfx;\n      fy += dfy;\n      dfx += ddfx;\n      dfy += ddfy;\n      ddfx += dddfx;\n      ddfy += dddfy;\n      t += step;\n\n      if (t > 1) {\n        fx = dfx > 0 ? Math.min(fx, x3) : Math.max(fx, x3);\n        fy = dfy > 0 ? Math.min(fy, y3) : Math.max(fy, y3);\n      }\n    }\n\n    this.addPolyline(points, color, lineWidth);\n  },\n\n  /**\n   * Add a straight line\n   * @param {Array.<number>} p0\n   * @param {Array.<number>} p1\n   * @param {Array.<number>} color\n   * @param {number} [lineWidth=1]\n   */\n  addLine: function addLine(p0, p1, color, lineWidth) {\n    this.addPolyline([p0, p1], color, lineWidth);\n  },\n\n  /**\n   * Add a straight line\n   * @param {Array.<Array> | Array.<number>} points\n   * @param {Array.<number> | Array.<Array>} color\n   * @param {number} [lineWidth=1]\n   * @param {number} [arrayOffset=0]\n   * @param {number} [pointsCount] Default to be amount of points in the first argument\n   */\n  addPolyline: function () {\n    var dirA = vec2.create();\n    var dirB = vec2.create();\n    var normal = vec2.create();\n    var tangent = vec2.create();\n    var point = [],\n        nextPoint = [],\n        prevPoint = [];\n    return function (points, color, lineWidth, arrayOffset, pointsCount) {\n      if (!points.length) {\n        return;\n      }\n\n      var is2DArray = typeof points[0] !== 'number';\n\n      if (pointsCount == null) {\n        pointsCount = is2DArray ? points.length : points.length / 2;\n      }\n\n      if (pointsCount < 2) {\n        return;\n      }\n\n      if (arrayOffset == null) {\n        arrayOffset = 0;\n      }\n\n      if (lineWidth == null) {\n        lineWidth = 1;\n      }\n\n      this._itemVertexOffsets.push(this._vertexOffset);\n\n      var notSharingColor = is2DArray ? typeof color[0] !== 'number' : color.length / 4 === pointsCount;\n      var positionAttr = this.attributes.position;\n      var colorAttr = this.attributes.color;\n      var offsetAttr = this.attributes.offset;\n      var normalAttr = this.attributes.normal;\n      var indices = this.indices;\n      var vertexOffset = this._vertexOffset;\n      var pointColor;\n\n      for (var k = 0; k < pointsCount; k++) {\n        if (is2DArray) {\n          point = points[k + arrayOffset];\n\n          if (notSharingColor) {\n            pointColor = color[k + arrayOffset];\n          } else {\n            pointColor = color;\n          }\n        } else {\n          var k2 = k * 2 + arrayOffset;\n          point = point || [];\n          point[0] = points[k2];\n          point[1] = points[k2 + 1];\n\n          if (notSharingColor) {\n            var k4 = k * 4 + arrayOffset;\n            pointColor = pointColor || [];\n            pointColor[0] = color[k4];\n            pointColor[1] = color[k4 + 1];\n            pointColor[2] = color[k4 + 2];\n            pointColor[3] = color[k4 + 3];\n          } else {\n            pointColor = color;\n          }\n        }\n\n        if (!this.useNativeLine) {\n          var offset;\n\n          if (k < pointsCount - 1) {\n            if (is2DArray) {\n              vec2.copy(nextPoint, points[k + 1]);\n            } else {\n              var k2 = (k + 1) * 2 + arrayOffset;\n              nextPoint = nextPoint || [];\n              nextPoint[0] = points[k2];\n              nextPoint[1] = points[k2 + 1];\n            } // TODO In case dir is (0, 0)\n            // TODO miterLimit\n\n\n            if (k > 0) {\n              vec2.sub(dirA, point, prevPoint);\n              vec2.sub(dirB, nextPoint, point);\n              vec2.normalize(dirA, dirA);\n              vec2.normalize(dirB, dirB);\n              vec2.add(tangent, dirA, dirB);\n              vec2.normalize(tangent, tangent);\n              var miter = lineWidth / 2 * Math.min(1 / vec2.dot(dirA, tangent), 2);\n              normal[0] = -tangent[1];\n              normal[1] = tangent[0];\n              offset = miter;\n            } else {\n              vec2.sub(dirA, nextPoint, point);\n              vec2.normalize(dirA, dirA);\n              normal[0] = -dirA[1];\n              normal[1] = dirA[0];\n              offset = lineWidth / 2;\n            }\n          } else {\n            vec2.sub(dirA, point, prevPoint);\n            vec2.normalize(dirA, dirA);\n            normal[0] = -dirA[1];\n            normal[1] = dirA[0];\n            offset = lineWidth / 2;\n          }\n\n          normalAttr.set(vertexOffset, normal);\n          normalAttr.set(vertexOffset + 1, normal);\n          offsetAttr.set(vertexOffset, offset);\n          offsetAttr.set(vertexOffset + 1, -offset);\n          vec2.copy(prevPoint, point);\n          positionAttr.set(vertexOffset, point);\n          positionAttr.set(vertexOffset + 1, point);\n          colorAttr.set(vertexOffset, pointColor);\n          colorAttr.set(vertexOffset + 1, pointColor);\n          vertexOffset += 2;\n        } else {\n          if (k > 1) {\n            positionAttr.copy(vertexOffset, vertexOffset - 1);\n            colorAttr.copy(vertexOffset, vertexOffset - 1);\n            vertexOffset++;\n          }\n        }\n\n        if (!this.useNativeLine) {\n          if (k > 0) {\n            var idx3 = this._faceOffset * 3;\n            var indices = this.indices; // 0-----2\n            // 1-----3\n            // 0->1->2, 1->3->2\n\n            indices[idx3] = vertexOffset - 4;\n            indices[idx3 + 1] = vertexOffset - 3;\n            indices[idx3 + 2] = vertexOffset - 2;\n            indices[idx3 + 3] = vertexOffset - 3;\n            indices[idx3 + 4] = vertexOffset - 1;\n            indices[idx3 + 5] = vertexOffset - 2;\n            this._faceOffset += 2;\n          }\n        } else {\n          colorAttr.set(vertexOffset, pointColor);\n          positionAttr.set(vertexOffset, point);\n          vertexOffset++;\n        }\n      }\n\n      this._vertexOffset = vertexOffset;\n    };\n  }(),\n\n  /**\n   * Set color of single line.\n   */\n  setItemColor: function setItemColor(idx, color) {\n    var startOffset = this._itemVertexOffsets[idx];\n    var endOffset = idx < this._itemVertexOffsets.length - 1 ? this._itemVertexOffsets[idx + 1] : this._vertexOffset;\n\n    for (var i = startOffset; i < endOffset; i++) {\n      this.attributes.color.set(i, color);\n    }\n\n    this.dirty('color');\n  }\n});\necharts.util.defaults(LinesGeometry.prototype, dynamicConvertMixin);\nexport default LinesGeometry;","map":{"version":3,"sources":["C:/Users/Administrator/Desktop/data_view/my_project/vue2_app/myapp/node_modules/_echarts-gl@2.0.9@echarts-gl/lib/util/geometry/Lines2D.js"],"names":["Geometry","echarts","dynamicConvertMixin","glmatrix","vec2","sampleLinePoints","LinesGeometry","extend","segmentScale","dynamic","useNativeLine","attributes","position","Attribute","normal","offset","color","resetOffset","_vertexOffset","_faceOffset","_itemVertexOffsets","setVertexCount","nVertex","vertexCount","init","indices","Uint16Array","Uint32Array","setTriangleCount","nTriangle","triangleCount","_getCubicCurveApproxStep","p0","p1","p2","p3","len","dist","step","getCubicCurveVertexCount","segCount","Math","ceil","getCubicCurveTriangleCount","getLineVertexCount","getPolylineVertexCount","getLineTriangleCount","getPolylineTriangleCount","points","pointsLen","is2DArray","length","addCubicCurve","lineWidth","x0","y0","x1","y1","x2","y2","x3","y3","step2","step3","pre1","pre2","pre4","pre5","tmp1x","tmp1y","tmp2x","tmp2y","fx","fy","dfx","dfy","ddfx","ddfy","dddfx","dddfy","t","k","Float32Array","min","max","addPolyline","addLine","dirA","create","dirB","tangent","point","nextPoint","prevPoint","arrayOffset","pointsCount","push","notSharingColor","positionAttr","colorAttr","offsetAttr","normalAttr","vertexOffset","pointColor","k2","k4","copy","sub","normalize","add","miter","dot","set","idx3","setItemColor","idx","startOffset","endOffset","i","dirty","util","defaults","prototype"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAOA,QAAP,MAAqB,qBAArB;AACA,OAAO,KAAKC,OAAZ,MAAyB,qBAAzB;AACA,OAAOC,mBAAP,MAAgC,uBAAhC;AACA,OAAOC,QAAP,MAAqB,yBAArB;AACA,IAAIC,IAAI,GAAGD,QAAQ,CAACC,IAApB,C,CAA0B;AAC1B;;AAEA,IAAIC,gBAAgB,GAAG,CAAC,CAAC,CAAD,EAAI,CAAJ,CAAD,EAAS,CAAC,CAAD,EAAI,CAAJ,CAAT,CAAvB;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAIC,aAAa,GAAGN,QAAQ,CAACO,MAAT,CAAgB,YAAY;AAC9C,SAAO;AACLC,IAAAA,YAAY,EAAE,CADT;AAELC,IAAAA,OAAO,EAAE,IAFJ;;AAIL;AACJ;AACA;AACIC,IAAAA,aAAa,EAAE,IAPV;AAQLC,IAAAA,UAAU,EAAE;AACVC,MAAAA,QAAQ,EAAE,IAAIZ,QAAQ,CAACa,SAAb,CAAuB,UAAvB,EAAmC,OAAnC,EAA4C,CAA5C,EAA+C,UAA/C,CADA;AAEVC,MAAAA,MAAM,EAAE,IAAId,QAAQ,CAACa,SAAb,CAAuB,QAAvB,EAAiC,OAAjC,EAA0C,CAA1C,CAFE;AAGVE,MAAAA,MAAM,EAAE,IAAIf,QAAQ,CAACa,SAAb,CAAuB,QAAvB,EAAiC,OAAjC,EAA0C,CAA1C,CAHE;AAIVG,MAAAA,KAAK,EAAE,IAAIhB,QAAQ,CAACa,SAAb,CAAuB,OAAvB,EAAgC,OAAhC,EAAyC,CAAzC,EAA4C,OAA5C;AAJG;AARP,GAAP;AAeD,CAhBmB;AAiBpB;AACA;AACE;AACF;AACA;AACEI,EAAAA,WAAW,EAAE,uBAAY;AACvB,SAAKC,aAAL,GAAqB,CAArB;AACA,SAAKC,WAAL,GAAmB,CAAnB;AACA,SAAKC,kBAAL,GAA0B,EAA1B;AACD,GARH;;AAUE;AACF;AACA;AACEC,EAAAA,cAAc,EAAE,wBAAUC,OAAV,EAAmB;AACjC,QAAIX,UAAU,GAAG,KAAKA,UAAtB;;AAEA,QAAI,KAAKY,WAAL,KAAqBD,OAAzB,EAAkC;AAChCX,MAAAA,UAAU,CAACC,QAAX,CAAoBY,IAApB,CAAyBF,OAAzB;AACAX,MAAAA,UAAU,CAACK,KAAX,CAAiBQ,IAAjB,CAAsBF,OAAtB;;AAEA,UAAI,CAAC,KAAKZ,aAAV,EAAyB;AACvBC,QAAAA,UAAU,CAACI,MAAX,CAAkBS,IAAlB,CAAuBF,OAAvB;AACAX,QAAAA,UAAU,CAACG,MAAX,CAAkBU,IAAlB,CAAuBF,OAAvB;AACD;;AAED,UAAIA,OAAO,GAAG,MAAd,EAAsB;AACpB,YAAI,KAAKG,OAAL,YAAwBC,WAA5B,EAAyC;AACvC,eAAKD,OAAL,GAAe,IAAIE,WAAJ,CAAgB,KAAKF,OAArB,CAAf;AACD;AACF,OAJD,MAIO;AACL,YAAI,KAAKA,OAAL,YAAwBE,WAA5B,EAAyC;AACvC,eAAKF,OAAL,GAAe,IAAIC,WAAJ,CAAgB,KAAKD,OAArB,CAAf;AACD;AACF;AACF;AACF,GAnCH;;AAqCE;AACF;AACA;AACEG,EAAAA,gBAAgB,EAAE,0BAAUC,SAAV,EAAqB;AACrC,QAAI,KAAKC,aAAL,KAAuBD,SAA3B,EAAsC;AACpC,UAAIA,SAAS,KAAK,CAAlB,EAAqB;AACnB,aAAKJ,OAAL,GAAe,IAAf;AACD,OAFD,MAEO;AACL,aAAKA,OAAL,GAAe,KAAKF,WAAL,GAAmB,MAAnB,GAA4B,IAAII,WAAJ,CAAgBE,SAAS,GAAG,CAA5B,CAA5B,GAA6D,IAAIH,WAAJ,CAAgBG,SAAS,GAAG,CAA5B,CAA5E;AACD;AACF;AACF,GAhDH;AAiDEE,EAAAA,wBAAwB,EAAE,kCAAUC,EAAV,EAAcC,EAAd,EAAkBC,EAAlB,EAAsBC,EAAtB,EAA0B;AAClD,QAAIC,GAAG,GAAGhC,IAAI,CAACiC,IAAL,CAAUL,EAAV,EAAcC,EAAd,IAAoB7B,IAAI,CAACiC,IAAL,CAAUH,EAAV,EAAcD,EAAd,CAApB,GAAwC7B,IAAI,CAACiC,IAAL,CAAUF,EAAV,EAAcD,EAAd,CAAlD;AACA,QAAII,IAAI,GAAG,KAAKF,GAAG,GAAG,CAAX,IAAgB,KAAK5B,YAAhC;AACA,WAAO8B,IAAP;AACD,GArDH;;AAuDE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACEC,EAAAA,wBAAwB,EAAE,kCAAUP,EAAV,EAAcC,EAAd,EAAkBC,EAAlB,EAAsBC,EAAtB,EAA0B;AAClD,QAAIG,IAAI,GAAG,KAAKP,wBAAL,CAA8BC,EAA9B,EAAkCC,EAAlC,EAAsCC,EAAtC,EAA0CC,EAA1C,CAAX;;AAEA,QAAIK,QAAQ,GAAGC,IAAI,CAACC,IAAL,CAAU,IAAIJ,IAAd,CAAf;;AAEA,QAAI,CAAC,KAAK5B,aAAV,EAAyB;AACvB,aAAO8B,QAAQ,GAAG,CAAX,GAAe,CAAtB;AACD,KAFD,MAEO;AACL,aAAOA,QAAQ,GAAG,CAAlB;AACD;AACF,GAzEH;;AA2EE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACEG,EAAAA,0BAA0B,EAAE,oCAAUX,EAAV,EAAcC,EAAd,EAAkBC,EAAlB,EAAsBC,EAAtB,EAA0B;AACpD,QAAIG,IAAI,GAAG,KAAKP,wBAAL,CAA8BC,EAA9B,EAAkCC,EAAlC,EAAsCC,EAAtC,EAA0CC,EAA1C,CAAX;;AAEA,QAAIK,QAAQ,GAAGC,IAAI,CAACC,IAAL,CAAU,IAAIJ,IAAd,CAAf;;AAEA,QAAI,CAAC,KAAK5B,aAAV,EAAyB;AACvB,aAAO8B,QAAQ,GAAG,CAAlB;AACD,KAFD,MAEO;AACL,aAAO,CAAP;AACD;AACF,GA7FH;;AA+FE;AACF;AACA;AACA;AACEI,EAAAA,kBAAkB,EAAE,8BAAY;AAC9B,WAAO,KAAKC,sBAAL,CAA4BxC,gBAA5B,CAAP;AACD,GArGH;;AAuGE;AACF;AACA;AACA;AACEyC,EAAAA,oBAAoB,EAAE,gCAAY;AAChC,WAAO,KAAKC,wBAAL,CAA8B1C,gBAA9B,CAAP;AACD,GA7GH;;AA+GE;AACF;AACA;AACA;AACA;AACEwC,EAAAA,sBAAsB,EAAE,gCAAUG,MAAV,EAAkB;AACxC,QAAIC,SAAJ;;AAEA,QAAI,OAAOD,MAAP,KAAkB,QAAtB,EAAgC;AAC9BC,MAAAA,SAAS,GAAGD,MAAZ;AACD,KAFD,MAEO;AACL,UAAIE,SAAS,GAAG,OAAOF,MAAM,CAAC,CAAD,CAAb,KAAqB,QAArC;AACAC,MAAAA,SAAS,GAAGC,SAAS,GAAGF,MAAM,CAACG,MAAV,GAAmBH,MAAM,CAACG,MAAP,GAAgB,CAAxD;AACD;;AAED,WAAO,CAAC,KAAKzC,aAAN,GAAsB,CAACuC,SAAS,GAAG,CAAb,IAAkB,CAAlB,GAAsB,CAA5C,GAAgD,CAACA,SAAS,GAAG,CAAb,IAAkB,CAAzE;AACD,GA/HH;;AAiIE;AACF;AACA;AACA;AACA;AACEF,EAAAA,wBAAwB,EAAE,kCAAUC,MAAV,EAAkB;AAC1C,QAAIC,SAAJ;;AAEA,QAAI,OAAOD,MAAP,KAAkB,QAAtB,EAAgC;AAC9BC,MAAAA,SAAS,GAAGD,MAAZ;AACD,KAFD,MAEO;AACL,UAAIE,SAAS,GAAG,OAAOF,MAAM,CAAC,CAAD,CAAb,KAAqB,QAArC;AACAC,MAAAA,SAAS,GAAGC,SAAS,GAAGF,MAAM,CAACG,MAAV,GAAmBH,MAAM,CAACG,MAAP,GAAgB,CAAxD;AACD;;AAED,WAAO,CAAC,KAAKzC,aAAN,GAAsB,CAACuC,SAAS,GAAG,CAAb,IAAkB,CAAxC,GAA4C,CAAnD;AACD,GAjJH;;AAmJE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACEG,EAAAA,aAAa,EAAE,uBAAUpB,EAAV,EAAcC,EAAd,EAAkBC,EAAlB,EAAsBC,EAAtB,EAA0BnB,KAA1B,EAAiCqC,SAAjC,EAA4C;AACzD,QAAIA,SAAS,IAAI,IAAjB,EAAuB;AACrBA,MAAAA,SAAS,GAAG,CAAZ;AACD,KAHwD,CAGvD;AACF;;;AAGA,QAAIC,EAAE,GAAGtB,EAAE,CAAC,CAAD,CAAX;AAAA,QACIuB,EAAE,GAAGvB,EAAE,CAAC,CAAD,CADX;AAEA,QAAIwB,EAAE,GAAGvB,EAAE,CAAC,CAAD,CAAX;AAAA,QACIwB,EAAE,GAAGxB,EAAE,CAAC,CAAD,CADX;AAEA,QAAIyB,EAAE,GAAGxB,EAAE,CAAC,CAAD,CAAX;AAAA,QACIyB,EAAE,GAAGzB,EAAE,CAAC,CAAD,CADX;AAEA,QAAI0B,EAAE,GAAGzB,EAAE,CAAC,CAAD,CAAX;AAAA,QACI0B,EAAE,GAAG1B,EAAE,CAAC,CAAD,CADX;;AAGA,QAAIG,IAAI,GAAG,KAAKP,wBAAL,CAA8BC,EAA9B,EAAkCC,EAAlC,EAAsCC,EAAtC,EAA0CC,EAA1C,CAAX;;AAEA,QAAI2B,KAAK,GAAGxB,IAAI,GAAGA,IAAnB;AACA,QAAIyB,KAAK,GAAGD,KAAK,GAAGxB,IAApB;AACA,QAAI0B,IAAI,GAAG,MAAM1B,IAAjB;AACA,QAAI2B,IAAI,GAAG,MAAMH,KAAjB;AACA,QAAII,IAAI,GAAG,MAAMJ,KAAjB;AACA,QAAIK,IAAI,GAAG,MAAMJ,KAAjB;AACA,QAAIK,KAAK,GAAGd,EAAE,GAAGE,EAAE,GAAG,GAAV,GAAgBE,EAA5B;AACA,QAAIW,KAAK,GAAGd,EAAE,GAAGE,EAAE,GAAG,GAAV,GAAgBE,EAA5B;AACA,QAAIW,KAAK,GAAG,CAACd,EAAE,GAAGE,EAAN,IAAY,GAAZ,GAAkBJ,EAAlB,GAAuBM,EAAnC;AACA,QAAIW,KAAK,GAAG,CAACd,EAAE,GAAGE,EAAN,IAAY,GAAZ,GAAkBJ,EAAlB,GAAuBM,EAAnC;AACA,QAAIW,EAAE,GAAGlB,EAAT;AACA,QAAImB,EAAE,GAAGlB,EAAT;AACA,QAAImB,GAAG,GAAG,CAAClB,EAAE,GAAGF,EAAN,IAAYU,IAAZ,GAAmBI,KAAK,GAAGH,IAA3B,GAAkCK,KAAK,GAAGP,KAApD;AACA,QAAIY,GAAG,GAAG,CAAClB,EAAE,GAAGF,EAAN,IAAYS,IAAZ,GAAmBK,KAAK,GAAGJ,IAA3B,GAAkCM,KAAK,GAAGR,KAApD;AACA,QAAIa,IAAI,GAAGR,KAAK,GAAGF,IAAR,GAAeI,KAAK,GAAGH,IAAlC;AACA,QAAIU,IAAI,GAAGR,KAAK,GAAGH,IAAR,GAAeK,KAAK,GAAGJ,IAAlC;AACA,QAAIW,KAAK,GAAGR,KAAK,GAAGH,IAApB;AACA,QAAIY,KAAK,GAAGR,KAAK,GAAGJ,IAApB;AACA,QAAIa,CAAC,GAAG,CAAR;AACA,QAAIC,CAAC,GAAG,CAAR;AACA,QAAIzC,QAAQ,GAAGC,IAAI,CAACC,IAAL,CAAU,IAAIJ,IAAd,CAAf;AACA,QAAIU,MAAM,GAAG,IAAIkC,YAAJ,CAAiB,CAAC1C,QAAQ,GAAG,CAAZ,IAAiB,CAAlC,CAAb;AACA,QAAIQ,MAAM,GAAG,EAAb;AACA,QAAIjC,MAAM,GAAG,CAAb;;AAEA,SAAK,IAAIkE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGzC,QAAQ,GAAG,CAA/B,EAAkCyC,CAAC,EAAnC,EAAuC;AACrCjC,MAAAA,MAAM,CAACjC,MAAM,EAAP,CAAN,GAAmByD,EAAnB;AACAxB,MAAAA,MAAM,CAACjC,MAAM,EAAP,CAAN,GAAmB0D,EAAnB;AACAD,MAAAA,EAAE,IAAIE,GAAN;AACAD,MAAAA,EAAE,IAAIE,GAAN;AACAD,MAAAA,GAAG,IAAIE,IAAP;AACAD,MAAAA,GAAG,IAAIE,IAAP;AACAD,MAAAA,IAAI,IAAIE,KAAR;AACAD,MAAAA,IAAI,IAAIE,KAAR;AACAC,MAAAA,CAAC,IAAI1C,IAAL;;AAEA,UAAI0C,CAAC,GAAG,CAAR,EAAW;AACTR,QAAAA,EAAE,GAAGE,GAAG,GAAG,CAAN,GAAUjC,IAAI,CAAC0C,GAAL,CAASX,EAAT,EAAaZ,EAAb,CAAV,GAA6BnB,IAAI,CAAC2C,GAAL,CAASZ,EAAT,EAAaZ,EAAb,CAAlC;AACAa,QAAAA,EAAE,GAAGE,GAAG,GAAG,CAAN,GAAUlC,IAAI,CAAC0C,GAAL,CAASV,EAAT,EAAaZ,EAAb,CAAV,GAA6BpB,IAAI,CAAC2C,GAAL,CAASX,EAAT,EAAaZ,EAAb,CAAlC;AACD;AACF;;AAED,SAAKwB,WAAL,CAAiBrC,MAAjB,EAAyBhC,KAAzB,EAAgCqC,SAAhC;AACD,GAzNH;;AA2NE;AACF;AACA;AACA;AACA;AACA;AACA;AACEiC,EAAAA,OAAO,EAAE,iBAAUtD,EAAV,EAAcC,EAAd,EAAkBjB,KAAlB,EAAyBqC,SAAzB,EAAoC;AAC3C,SAAKgC,WAAL,CAAiB,CAACrD,EAAD,EAAKC,EAAL,CAAjB,EAA2BjB,KAA3B,EAAkCqC,SAAlC;AACD,GApOH;;AAsOE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACEgC,EAAAA,WAAW,EAAE,YAAY;AACvB,QAAIE,IAAI,GAAGnF,IAAI,CAACoF,MAAL,EAAX;AACA,QAAIC,IAAI,GAAGrF,IAAI,CAACoF,MAAL,EAAX;AACA,QAAI1E,MAAM,GAAGV,IAAI,CAACoF,MAAL,EAAb;AACA,QAAIE,OAAO,GAAGtF,IAAI,CAACoF,MAAL,EAAd;AACA,QAAIG,KAAK,GAAG,EAAZ;AAAA,QACIC,SAAS,GAAG,EADhB;AAAA,QAEIC,SAAS,GAAG,EAFhB;AAGA,WAAO,UAAU7C,MAAV,EAAkBhC,KAAlB,EAAyBqC,SAAzB,EAAoCyC,WAApC,EAAiDC,WAAjD,EAA8D;AACnE,UAAI,CAAC/C,MAAM,CAACG,MAAZ,EAAoB;AAClB;AACD;;AAED,UAAID,SAAS,GAAG,OAAOF,MAAM,CAAC,CAAD,CAAb,KAAqB,QAArC;;AAEA,UAAI+C,WAAW,IAAI,IAAnB,EAAyB;AACvBA,QAAAA,WAAW,GAAG7C,SAAS,GAAGF,MAAM,CAACG,MAAV,GAAmBH,MAAM,CAACG,MAAP,GAAgB,CAA1D;AACD;;AAED,UAAI4C,WAAW,GAAG,CAAlB,EAAqB;AACnB;AACD;;AAED,UAAID,WAAW,IAAI,IAAnB,EAAyB;AACvBA,QAAAA,WAAW,GAAG,CAAd;AACD;;AAED,UAAIzC,SAAS,IAAI,IAAjB,EAAuB;AACrBA,QAAAA,SAAS,GAAG,CAAZ;AACD;;AAED,WAAKjC,kBAAL,CAAwB4E,IAAxB,CAA6B,KAAK9E,aAAlC;;AAEA,UAAI+E,eAAe,GAAG/C,SAAS,GAAG,OAAOlC,KAAK,CAAC,CAAD,CAAZ,KAAoB,QAAvB,GAAkCA,KAAK,CAACmC,MAAN,GAAe,CAAf,KAAqB4C,WAAtF;AACA,UAAIG,YAAY,GAAG,KAAKvF,UAAL,CAAgBC,QAAnC;AACA,UAAIuF,SAAS,GAAG,KAAKxF,UAAL,CAAgBK,KAAhC;AACA,UAAIoF,UAAU,GAAG,KAAKzF,UAAL,CAAgBI,MAAjC;AACA,UAAIsF,UAAU,GAAG,KAAK1F,UAAL,CAAgBG,MAAjC;AACA,UAAIW,OAAO,GAAG,KAAKA,OAAnB;AACA,UAAI6E,YAAY,GAAG,KAAKpF,aAAxB;AACA,UAAIqF,UAAJ;;AAEA,WAAK,IAAItB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGc,WAApB,EAAiCd,CAAC,EAAlC,EAAsC;AACpC,YAAI/B,SAAJ,EAAe;AACbyC,UAAAA,KAAK,GAAG3C,MAAM,CAACiC,CAAC,GAAGa,WAAL,CAAd;;AAEA,cAAIG,eAAJ,EAAqB;AACnBM,YAAAA,UAAU,GAAGvF,KAAK,CAACiE,CAAC,GAAGa,WAAL,CAAlB;AACD,WAFD,MAEO;AACLS,YAAAA,UAAU,GAAGvF,KAAb;AACD;AACF,SARD,MAQO;AACL,cAAIwF,EAAE,GAAGvB,CAAC,GAAG,CAAJ,GAAQa,WAAjB;AACAH,UAAAA,KAAK,GAAGA,KAAK,IAAI,EAAjB;AACAA,UAAAA,KAAK,CAAC,CAAD,CAAL,GAAW3C,MAAM,CAACwD,EAAD,CAAjB;AACAb,UAAAA,KAAK,CAAC,CAAD,CAAL,GAAW3C,MAAM,CAACwD,EAAE,GAAG,CAAN,CAAjB;;AAEA,cAAIP,eAAJ,EAAqB;AACnB,gBAAIQ,EAAE,GAAGxB,CAAC,GAAG,CAAJ,GAAQa,WAAjB;AACAS,YAAAA,UAAU,GAAGA,UAAU,IAAI,EAA3B;AACAA,YAAAA,UAAU,CAAC,CAAD,CAAV,GAAgBvF,KAAK,CAACyF,EAAD,CAArB;AACAF,YAAAA,UAAU,CAAC,CAAD,CAAV,GAAgBvF,KAAK,CAACyF,EAAE,GAAG,CAAN,CAArB;AACAF,YAAAA,UAAU,CAAC,CAAD,CAAV,GAAgBvF,KAAK,CAACyF,EAAE,GAAG,CAAN,CAArB;AACAF,YAAAA,UAAU,CAAC,CAAD,CAAV,GAAgBvF,KAAK,CAACyF,EAAE,GAAG,CAAN,CAArB;AACD,WAPD,MAOO;AACLF,YAAAA,UAAU,GAAGvF,KAAb;AACD;AACF;;AAED,YAAI,CAAC,KAAKN,aAAV,EAAyB;AACvB,cAAIK,MAAJ;;AAEA,cAAIkE,CAAC,GAAGc,WAAW,GAAG,CAAtB,EAAyB;AACvB,gBAAI7C,SAAJ,EAAe;AACb9C,cAAAA,IAAI,CAACsG,IAAL,CAAUd,SAAV,EAAqB5C,MAAM,CAACiC,CAAC,GAAG,CAAL,CAA3B;AACD,aAFD,MAEO;AACL,kBAAIuB,EAAE,GAAG,CAACvB,CAAC,GAAG,CAAL,IAAU,CAAV,GAAca,WAAvB;AACAF,cAAAA,SAAS,GAAGA,SAAS,IAAI,EAAzB;AACAA,cAAAA,SAAS,CAAC,CAAD,CAAT,GAAe5C,MAAM,CAACwD,EAAD,CAArB;AACAZ,cAAAA,SAAS,CAAC,CAAD,CAAT,GAAe5C,MAAM,CAACwD,EAAE,GAAG,CAAN,CAArB;AACD,aARsB,CAQrB;AACF;;;AAGA,gBAAIvB,CAAC,GAAG,CAAR,EAAW;AACT7E,cAAAA,IAAI,CAACuG,GAAL,CAASpB,IAAT,EAAeI,KAAf,EAAsBE,SAAtB;AACAzF,cAAAA,IAAI,CAACuG,GAAL,CAASlB,IAAT,EAAeG,SAAf,EAA0BD,KAA1B;AACAvF,cAAAA,IAAI,CAACwG,SAAL,CAAerB,IAAf,EAAqBA,IAArB;AACAnF,cAAAA,IAAI,CAACwG,SAAL,CAAenB,IAAf,EAAqBA,IAArB;AACArF,cAAAA,IAAI,CAACyG,GAAL,CAASnB,OAAT,EAAkBH,IAAlB,EAAwBE,IAAxB;AACArF,cAAAA,IAAI,CAACwG,SAAL,CAAelB,OAAf,EAAwBA,OAAxB;AACA,kBAAIoB,KAAK,GAAGzD,SAAS,GAAG,CAAZ,GAAgBZ,IAAI,CAAC0C,GAAL,CAAS,IAAI/E,IAAI,CAAC2G,GAAL,CAASxB,IAAT,EAAeG,OAAf,CAAb,EAAsC,CAAtC,CAA5B;AACA5E,cAAAA,MAAM,CAAC,CAAD,CAAN,GAAY,CAAC4E,OAAO,CAAC,CAAD,CAApB;AACA5E,cAAAA,MAAM,CAAC,CAAD,CAAN,GAAY4E,OAAO,CAAC,CAAD,CAAnB;AACA3E,cAAAA,MAAM,GAAG+F,KAAT;AACD,aAXD,MAWO;AACL1G,cAAAA,IAAI,CAACuG,GAAL,CAASpB,IAAT,EAAeK,SAAf,EAA0BD,KAA1B;AACAvF,cAAAA,IAAI,CAACwG,SAAL,CAAerB,IAAf,EAAqBA,IAArB;AACAzE,cAAAA,MAAM,CAAC,CAAD,CAAN,GAAY,CAACyE,IAAI,CAAC,CAAD,CAAjB;AACAzE,cAAAA,MAAM,CAAC,CAAD,CAAN,GAAYyE,IAAI,CAAC,CAAD,CAAhB;AACAxE,cAAAA,MAAM,GAAGsC,SAAS,GAAG,CAArB;AACD;AACF,WA9BD,MA8BO;AACLjD,YAAAA,IAAI,CAACuG,GAAL,CAASpB,IAAT,EAAeI,KAAf,EAAsBE,SAAtB;AACAzF,YAAAA,IAAI,CAACwG,SAAL,CAAerB,IAAf,EAAqBA,IAArB;AACAzE,YAAAA,MAAM,CAAC,CAAD,CAAN,GAAY,CAACyE,IAAI,CAAC,CAAD,CAAjB;AACAzE,YAAAA,MAAM,CAAC,CAAD,CAAN,GAAYyE,IAAI,CAAC,CAAD,CAAhB;AACAxE,YAAAA,MAAM,GAAGsC,SAAS,GAAG,CAArB;AACD;;AAEDgD,UAAAA,UAAU,CAACW,GAAX,CAAeV,YAAf,EAA6BxF,MAA7B;AACAuF,UAAAA,UAAU,CAACW,GAAX,CAAeV,YAAY,GAAG,CAA9B,EAAiCxF,MAAjC;AACAsF,UAAAA,UAAU,CAACY,GAAX,CAAeV,YAAf,EAA6BvF,MAA7B;AACAqF,UAAAA,UAAU,CAACY,GAAX,CAAeV,YAAY,GAAG,CAA9B,EAAiC,CAACvF,MAAlC;AACAX,UAAAA,IAAI,CAACsG,IAAL,CAAUb,SAAV,EAAqBF,KAArB;AACAO,UAAAA,YAAY,CAACc,GAAb,CAAiBV,YAAjB,EAA+BX,KAA/B;AACAO,UAAAA,YAAY,CAACc,GAAb,CAAiBV,YAAY,GAAG,CAAhC,EAAmCX,KAAnC;AACAQ,UAAAA,SAAS,CAACa,GAAV,CAAcV,YAAd,EAA4BC,UAA5B;AACAJ,UAAAA,SAAS,CAACa,GAAV,CAAcV,YAAY,GAAG,CAA7B,EAAgCC,UAAhC;AACAD,UAAAA,YAAY,IAAI,CAAhB;AACD,SAnDD,MAmDO;AACL,cAAIrB,CAAC,GAAG,CAAR,EAAW;AACTiB,YAAAA,YAAY,CAACQ,IAAb,CAAkBJ,YAAlB,EAAgCA,YAAY,GAAG,CAA/C;AACAH,YAAAA,SAAS,CAACO,IAAV,CAAeJ,YAAf,EAA6BA,YAAY,GAAG,CAA5C;AACAA,YAAAA,YAAY;AACb;AACF;;AAED,YAAI,CAAC,KAAK5F,aAAV,EAAyB;AACvB,cAAIuE,CAAC,GAAG,CAAR,EAAW;AACT,gBAAIgC,IAAI,GAAG,KAAK9F,WAAL,GAAmB,CAA9B;AACA,gBAAIM,OAAO,GAAG,KAAKA,OAAnB,CAFS,CAEmB;AAC5B;AACA;;AAEAA,YAAAA,OAAO,CAACwF,IAAD,CAAP,GAAgBX,YAAY,GAAG,CAA/B;AACA7E,YAAAA,OAAO,CAACwF,IAAI,GAAG,CAAR,CAAP,GAAoBX,YAAY,GAAG,CAAnC;AACA7E,YAAAA,OAAO,CAACwF,IAAI,GAAG,CAAR,CAAP,GAAoBX,YAAY,GAAG,CAAnC;AACA7E,YAAAA,OAAO,CAACwF,IAAI,GAAG,CAAR,CAAP,GAAoBX,YAAY,GAAG,CAAnC;AACA7E,YAAAA,OAAO,CAACwF,IAAI,GAAG,CAAR,CAAP,GAAoBX,YAAY,GAAG,CAAnC;AACA7E,YAAAA,OAAO,CAACwF,IAAI,GAAG,CAAR,CAAP,GAAoBX,YAAY,GAAG,CAAnC;AACA,iBAAKnF,WAAL,IAAoB,CAApB;AACD;AACF,SAfD,MAeO;AACLgF,UAAAA,SAAS,CAACa,GAAV,CAAcV,YAAd,EAA4BC,UAA5B;AACAL,UAAAA,YAAY,CAACc,GAAb,CAAiBV,YAAjB,EAA+BX,KAA/B;AACAW,UAAAA,YAAY;AACb;AACF;;AAED,WAAKpF,aAAL,GAAqBoF,YAArB;AACD,KA/ID;AAgJD,GAxJY,EA9Of;;AAwYE;AACF;AACA;AACEY,EAAAA,YAAY,EAAE,sBAAUC,GAAV,EAAenG,KAAf,EAAsB;AAClC,QAAIoG,WAAW,GAAG,KAAKhG,kBAAL,CAAwB+F,GAAxB,CAAlB;AACA,QAAIE,SAAS,GAAGF,GAAG,GAAG,KAAK/F,kBAAL,CAAwB+B,MAAxB,GAAiC,CAAvC,GAA2C,KAAK/B,kBAAL,CAAwB+F,GAAG,GAAG,CAA9B,CAA3C,GAA8E,KAAKjG,aAAnG;;AAEA,SAAK,IAAIoG,CAAC,GAAGF,WAAb,EAA0BE,CAAC,GAAGD,SAA9B,EAAyCC,CAAC,EAA1C,EAA8C;AAC5C,WAAK3G,UAAL,CAAgBK,KAAhB,CAAsBgG,GAAtB,CAA0BM,CAA1B,EAA6BtG,KAA7B;AACD;;AAED,SAAKuG,KAAL,CAAW,OAAX;AACD;AApZH,CAlBoB,CAApB;AAwaAtH,OAAO,CAACuH,IAAR,CAAaC,QAAb,CAAsBnH,aAAa,CAACoH,SAApC,EAA+CxH,mBAA/C;AACA,eAAeI,aAAf","sourcesContent":["/**\n * Lines geometry\n * Use screen space projected lines lineWidth > MAX_LINE_WIDTH\n * https://mattdesl.svbtle.com/drawing-lines-is-hard\n * @module echarts-gl/util/geometry/LinesGeometry\n * @author Yi Shen(http://github.com/pissang)\n */\nimport Geometry from 'claygl/src/Geometry';\nimport * as echarts from 'echarts/lib/echarts';\nimport dynamicConvertMixin from './dynamicConvertMixin';\nimport glmatrix from 'claygl/src/dep/glmatrix';\nvar vec2 = glmatrix.vec2; // var CURVE_RECURSION_LIMIT = 8;\n// var CURVE_COLLINEAR_EPSILON = 40;\n\nvar sampleLinePoints = [[0, 0], [1, 1]];\n/**\n * @constructor\n * @alias module:echarts-gl/util/geometry/LinesGeometry\n * @extends clay.Geometry\n */\n\nvar LinesGeometry = Geometry.extend(function () {\n  return {\n    segmentScale: 4,\n    dynamic: true,\n\n    /**\n     * Need to use mesh to expand lines if lineWidth > MAX_LINE_WIDTH\n     */\n    useNativeLine: true,\n    attributes: {\n      position: new Geometry.Attribute('position', 'float', 2, 'POSITION'),\n      normal: new Geometry.Attribute('normal', 'float', 2),\n      offset: new Geometry.Attribute('offset', 'float', 1),\n      color: new Geometry.Attribute('color', 'float', 4, 'COLOR')\n    }\n  };\n},\n/** @lends module: echarts-gl/util/geometry/LinesGeometry.prototype */\n{\n  /**\n   * Reset offset\n   */\n  resetOffset: function () {\n    this._vertexOffset = 0;\n    this._faceOffset = 0;\n    this._itemVertexOffsets = [];\n  },\n\n  /**\n   * @param {number} nVertex\n   */\n  setVertexCount: function (nVertex) {\n    var attributes = this.attributes;\n\n    if (this.vertexCount !== nVertex) {\n      attributes.position.init(nVertex);\n      attributes.color.init(nVertex);\n\n      if (!this.useNativeLine) {\n        attributes.offset.init(nVertex);\n        attributes.normal.init(nVertex);\n      }\n\n      if (nVertex > 0xffff) {\n        if (this.indices instanceof Uint16Array) {\n          this.indices = new Uint32Array(this.indices);\n        }\n      } else {\n        if (this.indices instanceof Uint32Array) {\n          this.indices = new Uint16Array(this.indices);\n        }\n      }\n    }\n  },\n\n  /**\n   * @param {number} nTriangle\n   */\n  setTriangleCount: function (nTriangle) {\n    if (this.triangleCount !== nTriangle) {\n      if (nTriangle === 0) {\n        this.indices = null;\n      } else {\n        this.indices = this.vertexCount > 0xffff ? new Uint32Array(nTriangle * 3) : new Uint16Array(nTriangle * 3);\n      }\n    }\n  },\n  _getCubicCurveApproxStep: function (p0, p1, p2, p3) {\n    var len = vec2.dist(p0, p1) + vec2.dist(p2, p1) + vec2.dist(p3, p2);\n    var step = 1 / (len + 1) * this.segmentScale;\n    return step;\n  },\n\n  /**\n   * Get vertex count of cubic curve\n   * @param {Array.<number>} p0\n   * @param {Array.<number>} p1\n   * @param {Array.<number>} p2\n   * @param {Array.<number>} p3\n   * @return number\n   */\n  getCubicCurveVertexCount: function (p0, p1, p2, p3) {\n    var step = this._getCubicCurveApproxStep(p0, p1, p2, p3);\n\n    var segCount = Math.ceil(1 / step);\n\n    if (!this.useNativeLine) {\n      return segCount * 2 + 2;\n    } else {\n      return segCount * 2;\n    }\n  },\n\n  /**\n   * Get face count of cubic curve\n   * @param {Array.<number>} p0\n   * @param {Array.<number>} p1\n   * @param {Array.<number>} p2\n   * @param {Array.<number>} p3\n   * @return number\n   */\n  getCubicCurveTriangleCount: function (p0, p1, p2, p3) {\n    var step = this._getCubicCurveApproxStep(p0, p1, p2, p3);\n\n    var segCount = Math.ceil(1 / step);\n\n    if (!this.useNativeLine) {\n      return segCount * 2;\n    } else {\n      return 0;\n    }\n  },\n\n  /**\n   * Get vertex count of line\n   * @return {number}\n   */\n  getLineVertexCount: function () {\n    return this.getPolylineVertexCount(sampleLinePoints);\n  },\n\n  /**\n   * Get face count of line\n   * @return {number}\n   */\n  getLineTriangleCount: function () {\n    return this.getPolylineTriangleCount(sampleLinePoints);\n  },\n\n  /**\n   * Get how many vertices will polyline take.\n   * @type {number|Array} points Can be a 1d/2d list of points, or a number of points amount.\n   * @return {number}\n   */\n  getPolylineVertexCount: function (points) {\n    var pointsLen;\n\n    if (typeof points === 'number') {\n      pointsLen = points;\n    } else {\n      var is2DArray = typeof points[0] !== 'number';\n      pointsLen = is2DArray ? points.length : points.length / 2;\n    }\n\n    return !this.useNativeLine ? (pointsLen - 1) * 2 + 2 : (pointsLen - 1) * 2;\n  },\n\n  /**\n   * Get how many triangles will polyline take.\n   * @type {number|Array} points Can be a 1d/2d list of points, or a number of points amount.\n   * @return {number}\n   */\n  getPolylineTriangleCount: function (points) {\n    var pointsLen;\n\n    if (typeof points === 'number') {\n      pointsLen = points;\n    } else {\n      var is2DArray = typeof points[0] !== 'number';\n      pointsLen = is2DArray ? points.length : points.length / 2;\n    }\n\n    return !this.useNativeLine ? (pointsLen - 1) * 2 : 0;\n  },\n\n  /**\n   * Add a cubic curve\n   * @param {Array.<number>} p0\n   * @param {Array.<number>} p1\n   * @param {Array.<number>} p2\n   * @param {Array.<number>} p3\n   * @param {Array.<number>} color\n   * @param {number} [lineWidth=1]\n   */\n  addCubicCurve: function (p0, p1, p2, p3, color, lineWidth) {\n    if (lineWidth == null) {\n      lineWidth = 1;\n    } // incremental interpolation\n    // http://antigrain.com/research/bezier_interpolation/index.html#PAGE_BEZIER_INTERPOLATION\n\n\n    var x0 = p0[0],\n        y0 = p0[1];\n    var x1 = p1[0],\n        y1 = p1[1];\n    var x2 = p2[0],\n        y2 = p2[1];\n    var x3 = p3[0],\n        y3 = p3[1];\n\n    var step = this._getCubicCurveApproxStep(p0, p1, p2, p3);\n\n    var step2 = step * step;\n    var step3 = step2 * step;\n    var pre1 = 3.0 * step;\n    var pre2 = 3.0 * step2;\n    var pre4 = 6.0 * step2;\n    var pre5 = 6.0 * step3;\n    var tmp1x = x0 - x1 * 2.0 + x2;\n    var tmp1y = y0 - y1 * 2.0 + y2;\n    var tmp2x = (x1 - x2) * 3.0 - x0 + x3;\n    var tmp2y = (y1 - y2) * 3.0 - y0 + y3;\n    var fx = x0;\n    var fy = y0;\n    var dfx = (x1 - x0) * pre1 + tmp1x * pre2 + tmp2x * step3;\n    var dfy = (y1 - y0) * pre1 + tmp1y * pre2 + tmp2y * step3;\n    var ddfx = tmp1x * pre4 + tmp2x * pre5;\n    var ddfy = tmp1y * pre4 + tmp2y * pre5;\n    var dddfx = tmp2x * pre5;\n    var dddfy = tmp2y * pre5;\n    var t = 0;\n    var k = 0;\n    var segCount = Math.ceil(1 / step);\n    var points = new Float32Array((segCount + 1) * 3);\n    var points = [];\n    var offset = 0;\n\n    for (var k = 0; k < segCount + 1; k++) {\n      points[offset++] = fx;\n      points[offset++] = fy;\n      fx += dfx;\n      fy += dfy;\n      dfx += ddfx;\n      dfy += ddfy;\n      ddfx += dddfx;\n      ddfy += dddfy;\n      t += step;\n\n      if (t > 1) {\n        fx = dfx > 0 ? Math.min(fx, x3) : Math.max(fx, x3);\n        fy = dfy > 0 ? Math.min(fy, y3) : Math.max(fy, y3);\n      }\n    }\n\n    this.addPolyline(points, color, lineWidth);\n  },\n\n  /**\n   * Add a straight line\n   * @param {Array.<number>} p0\n   * @param {Array.<number>} p1\n   * @param {Array.<number>} color\n   * @param {number} [lineWidth=1]\n   */\n  addLine: function (p0, p1, color, lineWidth) {\n    this.addPolyline([p0, p1], color, lineWidth);\n  },\n\n  /**\n   * Add a straight line\n   * @param {Array.<Array> | Array.<number>} points\n   * @param {Array.<number> | Array.<Array>} color\n   * @param {number} [lineWidth=1]\n   * @param {number} [arrayOffset=0]\n   * @param {number} [pointsCount] Default to be amount of points in the first argument\n   */\n  addPolyline: function () {\n    var dirA = vec2.create();\n    var dirB = vec2.create();\n    var normal = vec2.create();\n    var tangent = vec2.create();\n    var point = [],\n        nextPoint = [],\n        prevPoint = [];\n    return function (points, color, lineWidth, arrayOffset, pointsCount) {\n      if (!points.length) {\n        return;\n      }\n\n      var is2DArray = typeof points[0] !== 'number';\n\n      if (pointsCount == null) {\n        pointsCount = is2DArray ? points.length : points.length / 2;\n      }\n\n      if (pointsCount < 2) {\n        return;\n      }\n\n      if (arrayOffset == null) {\n        arrayOffset = 0;\n      }\n\n      if (lineWidth == null) {\n        lineWidth = 1;\n      }\n\n      this._itemVertexOffsets.push(this._vertexOffset);\n\n      var notSharingColor = is2DArray ? typeof color[0] !== 'number' : color.length / 4 === pointsCount;\n      var positionAttr = this.attributes.position;\n      var colorAttr = this.attributes.color;\n      var offsetAttr = this.attributes.offset;\n      var normalAttr = this.attributes.normal;\n      var indices = this.indices;\n      var vertexOffset = this._vertexOffset;\n      var pointColor;\n\n      for (var k = 0; k < pointsCount; k++) {\n        if (is2DArray) {\n          point = points[k + arrayOffset];\n\n          if (notSharingColor) {\n            pointColor = color[k + arrayOffset];\n          } else {\n            pointColor = color;\n          }\n        } else {\n          var k2 = k * 2 + arrayOffset;\n          point = point || [];\n          point[0] = points[k2];\n          point[1] = points[k2 + 1];\n\n          if (notSharingColor) {\n            var k4 = k * 4 + arrayOffset;\n            pointColor = pointColor || [];\n            pointColor[0] = color[k4];\n            pointColor[1] = color[k4 + 1];\n            pointColor[2] = color[k4 + 2];\n            pointColor[3] = color[k4 + 3];\n          } else {\n            pointColor = color;\n          }\n        }\n\n        if (!this.useNativeLine) {\n          var offset;\n\n          if (k < pointsCount - 1) {\n            if (is2DArray) {\n              vec2.copy(nextPoint, points[k + 1]);\n            } else {\n              var k2 = (k + 1) * 2 + arrayOffset;\n              nextPoint = nextPoint || [];\n              nextPoint[0] = points[k2];\n              nextPoint[1] = points[k2 + 1];\n            } // TODO In case dir is (0, 0)\n            // TODO miterLimit\n\n\n            if (k > 0) {\n              vec2.sub(dirA, point, prevPoint);\n              vec2.sub(dirB, nextPoint, point);\n              vec2.normalize(dirA, dirA);\n              vec2.normalize(dirB, dirB);\n              vec2.add(tangent, dirA, dirB);\n              vec2.normalize(tangent, tangent);\n              var miter = lineWidth / 2 * Math.min(1 / vec2.dot(dirA, tangent), 2);\n              normal[0] = -tangent[1];\n              normal[1] = tangent[0];\n              offset = miter;\n            } else {\n              vec2.sub(dirA, nextPoint, point);\n              vec2.normalize(dirA, dirA);\n              normal[0] = -dirA[1];\n              normal[1] = dirA[0];\n              offset = lineWidth / 2;\n            }\n          } else {\n            vec2.sub(dirA, point, prevPoint);\n            vec2.normalize(dirA, dirA);\n            normal[0] = -dirA[1];\n            normal[1] = dirA[0];\n            offset = lineWidth / 2;\n          }\n\n          normalAttr.set(vertexOffset, normal);\n          normalAttr.set(vertexOffset + 1, normal);\n          offsetAttr.set(vertexOffset, offset);\n          offsetAttr.set(vertexOffset + 1, -offset);\n          vec2.copy(prevPoint, point);\n          positionAttr.set(vertexOffset, point);\n          positionAttr.set(vertexOffset + 1, point);\n          colorAttr.set(vertexOffset, pointColor);\n          colorAttr.set(vertexOffset + 1, pointColor);\n          vertexOffset += 2;\n        } else {\n          if (k > 1) {\n            positionAttr.copy(vertexOffset, vertexOffset - 1);\n            colorAttr.copy(vertexOffset, vertexOffset - 1);\n            vertexOffset++;\n          }\n        }\n\n        if (!this.useNativeLine) {\n          if (k > 0) {\n            var idx3 = this._faceOffset * 3;\n            var indices = this.indices; // 0-----2\n            // 1-----3\n            // 0->1->2, 1->3->2\n\n            indices[idx3] = vertexOffset - 4;\n            indices[idx3 + 1] = vertexOffset - 3;\n            indices[idx3 + 2] = vertexOffset - 2;\n            indices[idx3 + 3] = vertexOffset - 3;\n            indices[idx3 + 4] = vertexOffset - 1;\n            indices[idx3 + 5] = vertexOffset - 2;\n            this._faceOffset += 2;\n          }\n        } else {\n          colorAttr.set(vertexOffset, pointColor);\n          positionAttr.set(vertexOffset, point);\n          vertexOffset++;\n        }\n      }\n\n      this._vertexOffset = vertexOffset;\n    };\n  }(),\n\n  /**\n   * Set color of single line.\n   */\n  setItemColor: function (idx, color) {\n    var startOffset = this._itemVertexOffsets[idx];\n    var endOffset = idx < this._itemVertexOffsets.length - 1 ? this._itemVertexOffsets[idx + 1] : this._vertexOffset;\n\n    for (var i = startOffset; i < endOffset; i++) {\n      this.attributes.color.set(i, color);\n    }\n\n    this.dirty('color');\n  }\n});\necharts.util.defaults(LinesGeometry.prototype, dynamicConvertMixin);\nexport default LinesGeometry;"]},"metadata":{},"sourceType":"module"}