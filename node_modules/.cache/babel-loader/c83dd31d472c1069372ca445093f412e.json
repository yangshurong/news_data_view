{"ast":null,"code":"import Base from '../core/Base'; // PENDING\n// Use topological sort ?\n\n/**\n * Node of graph based post processing.\n *\n * @constructor clay.compositor.CompositorNode\n * @extends clay.core.Base\n *\n */\n\nvar CompositorNode = Base.extend(function () {\n  return (\n    /** @lends clay.compositor.CompositorNode# */\n    {\n      /**\n       * @type {string}\n       */\n      name: '',\n\n      /**\n       * Input links, will be updated by the graph\n       * @example:\n       *     inputName: {\n       *         node: someNode,\n       *         pin: 'xxxx'\n       *     }\n       * @type {Object}\n       */\n      inputLinks: {},\n\n      /**\n       * Output links, will be updated by the graph\n       * @example:\n       *     outputName: {\n       *         node: someNode,\n       *         pin: 'xxxx'\n       *     }\n       * @type {Object}\n       */\n      outputLinks: {},\n      // Save the output texture of previous frame\n      // Will be used when there exist a circular reference\n      _prevOutputTextures: {},\n      _outputTextures: {},\n      // Example: { name: 2 }\n      _outputReferences: {},\n      _rendering: false,\n      // If rendered in this frame\n      _rendered: false,\n      _compositor: null\n    }\n  );\n},\n/** @lends clay.compositor.CompositorNode.prototype */\n{\n  // TODO Remove parameter function callback\n  updateParameter: function (outputName, renderer) {\n    var outputInfo = this.outputs[outputName];\n    var parameters = outputInfo.parameters;\n    var parametersCopy = outputInfo._parametersCopy;\n\n    if (!parametersCopy) {\n      parametersCopy = outputInfo._parametersCopy = {};\n    }\n\n    if (parameters) {\n      for (var key in parameters) {\n        if (key !== 'width' && key !== 'height') {\n          parametersCopy[key] = parameters[key];\n        }\n      }\n    }\n\n    var width, height;\n\n    if (parameters.width instanceof Function) {\n      width = parameters.width.call(this, renderer);\n    } else {\n      width = parameters.width;\n    }\n\n    if (parameters.height instanceof Function) {\n      height = parameters.height.call(this, renderer);\n    } else {\n      height = parameters.height;\n    }\n\n    if (parametersCopy.width !== width || parametersCopy.height !== height) {\n      if (this._outputTextures[outputName]) {\n        this._outputTextures[outputName].dispose(renderer.gl);\n      }\n    }\n\n    parametersCopy.width = width;\n    parametersCopy.height = height;\n    return parametersCopy;\n  },\n\n  /**\n   * Set parameter\n   * @param {string} name\n   * @param {} value\n   */\n  setParameter: function (name, value) {},\n\n  /**\n   * Get parameter value\n   * @param  {string} name\n   * @return {}\n   */\n  getParameter: function (name) {},\n\n  /**\n   * Set parameters\n   * @param {Object} obj\n   */\n  setParameters: function (obj) {\n    for (var name in obj) {\n      this.setParameter(name, obj[name]);\n    }\n  },\n  render: function () {},\n  getOutput: function (renderer\n  /*optional*/\n  , name) {\n    if (name == null) {\n      // Return the output texture without rendering\n      name = renderer;\n      return this._outputTextures[name];\n    }\n\n    var outputInfo = this.outputs[name];\n\n    if (!outputInfo) {\n      return;\n    } // Already been rendered in this frame\n\n\n    if (this._rendered) {\n      // Force return texture in last frame\n      if (outputInfo.outputLastFrame) {\n        return this._prevOutputTextures[name];\n      } else {\n        return this._outputTextures[name];\n      }\n    } else if ( // TODO\n    this._rendering // Solve Circular Reference\n    ) {\n      if (!this._prevOutputTextures[name]) {\n        // Create a blank texture at first pass\n        this._prevOutputTextures[name] = this._compositor.allocateTexture(outputInfo.parameters || {});\n      }\n\n      return this._prevOutputTextures[name];\n    }\n\n    this.render(renderer);\n    return this._outputTextures[name];\n  },\n  removeReference: function (outputName) {\n    this._outputReferences[outputName]--;\n\n    if (this._outputReferences[outputName] === 0) {\n      var outputInfo = this.outputs[outputName];\n\n      if (outputInfo.keepLastFrame) {\n        if (this._prevOutputTextures[outputName]) {\n          this._compositor.releaseTexture(this._prevOutputTextures[outputName]);\n        }\n\n        this._prevOutputTextures[outputName] = this._outputTextures[outputName];\n      } else {\n        // Output of this node have alreay been used by all other nodes\n        // Put the texture back to the pool.\n        this._compositor.releaseTexture(this._outputTextures[outputName]);\n      }\n    }\n  },\n  link: function (inputPinName, fromNode, fromPinName) {\n    // The relationship from output pin to input pin is one-on-multiple\n    this.inputLinks[inputPinName] = {\n      node: fromNode,\n      pin: fromPinName\n    };\n\n    if (!fromNode.outputLinks[fromPinName]) {\n      fromNode.outputLinks[fromPinName] = [];\n    }\n\n    fromNode.outputLinks[fromPinName].push({\n      node: this,\n      pin: inputPinName\n    }); // Enabled the pin texture in shader\n\n    this.pass.material.enableTexture(inputPinName);\n  },\n  clear: function () {\n    this.inputLinks = {};\n    this.outputLinks = {};\n  },\n  updateReference: function (outputName) {\n    if (!this._rendering) {\n      this._rendering = true;\n\n      for (var inputName in this.inputLinks) {\n        var link = this.inputLinks[inputName];\n        link.node.updateReference(link.pin);\n      }\n\n      this._rendering = false;\n    }\n\n    if (outputName) {\n      this._outputReferences[outputName]++;\n    }\n  },\n  beforeFrame: function () {\n    this._rendered = false;\n\n    for (var name in this.outputLinks) {\n      this._outputReferences[name] = 0;\n    }\n  },\n  afterFrame: function () {\n    // Put back all the textures to pool\n    for (var name in this.outputLinks) {\n      if (this._outputReferences[name] > 0) {\n        var outputInfo = this.outputs[name];\n\n        if (outputInfo.keepLastFrame) {\n          if (this._prevOutputTextures[name]) {\n            this._compositor.releaseTexture(this._prevOutputTextures[name]);\n          }\n\n          this._prevOutputTextures[name] = this._outputTextures[name];\n        } else {\n          this._compositor.releaseTexture(this._outputTextures[name]);\n        }\n      }\n    }\n  }\n});\nexport default CompositorNode;","map":{"version":3,"sources":["C:/Users/Administrator/Desktop/data_view/my_project/vue2_app/myapp/node_modules/claygl/src/compositor/CompositorNode.js"],"names":["Base","CompositorNode","extend","name","inputLinks","outputLinks","_prevOutputTextures","_outputTextures","_outputReferences","_rendering","_rendered","_compositor","updateParameter","outputName","renderer","outputInfo","outputs","parameters","parametersCopy","_parametersCopy","key","width","height","Function","call","dispose","gl","setParameter","value","getParameter","setParameters","obj","render","getOutput","outputLastFrame","allocateTexture","removeReference","keepLastFrame","releaseTexture","link","inputPinName","fromNode","fromPinName","node","pin","push","pass","material","enableTexture","clear","updateReference","inputName","beforeFrame","afterFrame"],"mappings":"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","sourcesContent":["import Base from '../core/Base';\n\n// PENDING\n// Use topological sort ?\n\n/**\n * Node of graph based post processing.\n *\n * @constructor clay.compositor.CompositorNode\n * @extends clay.core.Base\n *\n */\nvar CompositorNode = Base.extend(function () {\n    return /** @lends clay.compositor.CompositorNode# */ {\n        /**\n         * @type {string}\n         */\n        name: '',\n\n        /**\n         * Input links, will be updated by the graph\n         * @example:\n         *     inputName: {\n         *         node: someNode,\n         *         pin: 'xxxx'\n         *     }\n         * @type {Object}\n         */\n        inputLinks: {},\n\n        /**\n         * Output links, will be updated by the graph\n         * @example:\n         *     outputName: {\n         *         node: someNode,\n         *         pin: 'xxxx'\n         *     }\n         * @type {Object}\n         */\n        outputLinks: {},\n\n        // Save the output texture of previous frame\n        // Will be used when there exist a circular reference\n        _prevOutputTextures: {},\n        _outputTextures: {},\n\n        // Example: { name: 2 }\n        _outputReferences: {},\n\n        _rendering: false,\n        // If rendered in this frame\n        _rendered: false,\n\n        _compositor: null\n    };\n},\n/** @lends clay.compositor.CompositorNode.prototype */\n{\n\n    // TODO Remove parameter function callback\n    updateParameter: function (outputName, renderer) {\n        var outputInfo = this.outputs[outputName];\n        var parameters = outputInfo.parameters;\n        var parametersCopy = outputInfo._parametersCopy;\n        if (!parametersCopy) {\n            parametersCopy = outputInfo._parametersCopy = {};\n        }\n        if (parameters) {\n            for (var key in parameters) {\n                if (key !== 'width' && key !== 'height') {\n                    parametersCopy[key] = parameters[key];\n                }\n            }\n        }\n        var width, height;\n        if (parameters.width instanceof Function) {\n            width = parameters.width.call(this, renderer);\n        }\n        else {\n            width = parameters.width;\n        }\n        if (parameters.height instanceof Function) {\n            height = parameters.height.call(this, renderer);\n        }\n        else {\n            height = parameters.height;\n        }\n        if (\n            parametersCopy.width !== width\n            || parametersCopy.height !== height\n        ) {\n            if (this._outputTextures[outputName]) {\n                this._outputTextures[outputName].dispose(renderer.gl);\n            }\n        }\n        parametersCopy.width = width;\n        parametersCopy.height = height;\n\n        return parametersCopy;\n    },\n\n    /**\n     * Set parameter\n     * @param {string} name\n     * @param {} value\n     */\n    setParameter: function (name, value) {},\n    /**\n     * Get parameter value\n     * @param  {string} name\n     * @return {}\n     */\n    getParameter: function (name) {},\n    /**\n     * Set parameters\n     * @param {Object} obj\n     */\n    setParameters: function (obj) {\n        for (var name in obj) {\n            this.setParameter(name, obj[name]);\n        }\n    },\n\n    render: function () {},\n\n    getOutput: function (renderer /*optional*/, name) {\n        if (name == null) {\n            // Return the output texture without rendering\n            name = renderer;\n            return this._outputTextures[name];\n        }\n        var outputInfo = this.outputs[name];\n        if (!outputInfo) {\n            return ;\n        }\n\n        // Already been rendered in this frame\n        if (this._rendered) {\n            // Force return texture in last frame\n            if (outputInfo.outputLastFrame) {\n                return this._prevOutputTextures[name];\n            }\n            else {\n                return this._outputTextures[name];\n            }\n        }\n        else if (\n            // TODO\n            this._rendering   // Solve Circular Reference\n        ) {\n            if (!this._prevOutputTextures[name]) {\n                // Create a blank texture at first pass\n                this._prevOutputTextures[name] = this._compositor.allocateTexture(outputInfo.parameters || {});\n            }\n            return this._prevOutputTextures[name];\n        }\n\n        this.render(renderer);\n\n        return this._outputTextures[name];\n    },\n\n    removeReference: function (outputName) {\n        this._outputReferences[outputName]--;\n        if (this._outputReferences[outputName] === 0) {\n            var outputInfo = this.outputs[outputName];\n            if (outputInfo.keepLastFrame) {\n                if (this._prevOutputTextures[outputName]) {\n                    this._compositor.releaseTexture(this._prevOutputTextures[outputName]);\n                }\n                this._prevOutputTextures[outputName] = this._outputTextures[outputName];\n            }\n            else {\n                // Output of this node have alreay been used by all other nodes\n                // Put the texture back to the pool.\n                this._compositor.releaseTexture(this._outputTextures[outputName]);\n            }\n        }\n    },\n\n    link: function (inputPinName, fromNode, fromPinName) {\n\n        // The relationship from output pin to input pin is one-on-multiple\n        this.inputLinks[inputPinName] = {\n            node: fromNode,\n            pin: fromPinName\n        };\n        if (!fromNode.outputLinks[fromPinName]) {\n            fromNode.outputLinks[fromPinName] = [];\n        }\n        fromNode.outputLinks[fromPinName].push({\n            node: this,\n            pin: inputPinName\n        });\n\n        // Enabled the pin texture in shader\n        this.pass.material.enableTexture(inputPinName);\n    },\n\n    clear: function () {\n        this.inputLinks = {};\n        this.outputLinks = {};\n    },\n\n    updateReference: function (outputName) {\n        if (!this._rendering) {\n            this._rendering = true;\n            for (var inputName in this.inputLinks) {\n                var link = this.inputLinks[inputName];\n                link.node.updateReference(link.pin);\n            }\n            this._rendering = false;\n        }\n        if (outputName) {\n            this._outputReferences[outputName] ++;\n        }\n    },\n\n    beforeFrame: function () {\n        this._rendered = false;\n\n        for (var name in this.outputLinks) {\n            this._outputReferences[name] = 0;\n        }\n    },\n\n    afterFrame: function () {\n        // Put back all the textures to pool\n        for (var name in this.outputLinks) {\n            if (this._outputReferences[name] > 0) {\n                var outputInfo = this.outputs[name];\n                if (outputInfo.keepLastFrame) {\n                    if (this._prevOutputTextures[name]) {\n                        this._compositor.releaseTexture(this._prevOutputTextures[name]);\n                    }\n                    this._prevOutputTextures[name] = this._outputTextures[name];\n                }\n                else {\n                    this._compositor.releaseTexture(this._outputTextures[name]);\n                }\n            }\n        }\n    }\n});\n\nexport default CompositorNode;\n"]},"metadata":{},"sourceType":"module"}