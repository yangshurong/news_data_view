{"ast":null,"code":"import * as echarts from 'echarts/lib/echarts';\nimport graphicGL from '../../util/graphicGL';\nimport OrbitControl from '../../util/OrbitControl';\nimport SceneHelper from '../../component/common/SceneHelper';\nimport Geo3DBuilder from '../../component/common/Geo3DBuilder';\nexport default echarts.ChartView.extend({\n  type: 'map3D',\n  __ecgl__: true,\n  init: function init(ecModel, api) {\n    this._geo3DBuilder = new Geo3DBuilder(api);\n    this.groupGL = new graphicGL.Node();\n  },\n  render: function render(map3DModel, ecModel, api) {\n    var coordSys = map3DModel.coordinateSystem;\n\n    if (!coordSys || !coordSys.viewGL) {\n      return;\n    }\n\n    this.groupGL.add(this._geo3DBuilder.rootNode);\n    coordSys.viewGL.add(this.groupGL);\n    var geo3D;\n\n    if (coordSys.type === 'geo3D') {\n      geo3D = coordSys;\n\n      if (!this._sceneHelper) {\n        this._sceneHelper = new SceneHelper();\n\n        this._sceneHelper.initLight(this.groupGL);\n      }\n\n      this._sceneHelper.setScene(coordSys.viewGL.scene);\n\n      this._sceneHelper.updateLight(map3DModel); // Set post effect\n\n\n      coordSys.viewGL.setPostEffect(map3DModel.getModel('postEffect'), api);\n      coordSys.viewGL.setTemporalSuperSampling(map3DModel.getModel('temporalSuperSampling'));\n      var control = this._control;\n\n      if (!control) {\n        control = this._control = new OrbitControl({\n          zr: api.getZr()\n        });\n\n        this._control.init();\n      }\n\n      var viewControlModel = map3DModel.getModel('viewControl');\n      control.setViewGL(coordSys.viewGL);\n      control.setFromViewControlModel(viewControlModel, 0);\n      control.off('update');\n      control.on('update', function () {\n        api.dispatchAction({\n          type: 'map3DChangeCamera',\n          alpha: control.getAlpha(),\n          beta: control.getBeta(),\n          distance: control.getDistance(),\n          from: this.uid,\n          map3DId: map3DModel.id\n        });\n      });\n      this._geo3DBuilder.extrudeY = true;\n    } else {\n      if (this._control) {\n        this._control.dispose();\n\n        this._control = null;\n      }\n\n      if (this._sceneHelper) {\n        this._sceneHelper.dispose();\n\n        this._sceneHelper = null;\n      }\n\n      geo3D = map3DModel.getData().getLayout('geo3D');\n      this._geo3DBuilder.extrudeY = false;\n    }\n\n    this._geo3DBuilder.update(map3DModel, ecModel, api, 0, map3DModel.getData().count()); // Must update after geo3D.viewGL.setPostEffect to determine linear space\n\n\n    var srgbDefineMethod = coordSys.viewGL.isLinearSpace() ? 'define' : 'undefine';\n\n    this._geo3DBuilder.rootNode.traverse(function (mesh) {\n      if (mesh.material) {\n        mesh.material[srgbDefineMethod]('fragment', 'SRGB_DECODE');\n      }\n    });\n  },\n  afterRender: function afterRender(map3DModel, ecModel, api, layerGL) {\n    var renderer = layerGL.renderer;\n    var coordSys = map3DModel.coordinateSystem;\n\n    if (coordSys && coordSys.type === 'geo3D') {\n      this._sceneHelper.updateAmbientCubemap(renderer, map3DModel, api);\n\n      this._sceneHelper.updateSkybox(renderer, map3DModel, api);\n    }\n  },\n  dispose: function dispose() {\n    this.groupGL.removeAll();\n\n    this._control.dispose();\n\n    this._geo3DBuilder.dispose();\n  }\n});","map":{"version":3,"sources":["C:/Users/Administrator/Desktop/data_view/my_project/vue2_app/myapp/node_modules/echarts-gl/lib/chart/map3D/Map3DView.js"],"names":["echarts","graphicGL","OrbitControl","SceneHelper","Geo3DBuilder","ChartView","extend","type","__ecgl__","init","ecModel","api","_geo3DBuilder","groupGL","Node","render","map3DModel","coordSys","coordinateSystem","viewGL","add","rootNode","geo3D","_sceneHelper","initLight","setScene","scene","updateLight","setPostEffect","getModel","setTemporalSuperSampling","control","_control","zr","getZr","viewControlModel","setViewGL","setFromViewControlModel","off","on","dispatchAction","alpha","getAlpha","beta","getBeta","distance","getDistance","from","uid","map3DId","id","extrudeY","dispose","getData","getLayout","update","count","srgbDefineMethod","isLinearSpace","traverse","mesh","material","afterRender","layerGL","renderer","updateAmbientCubemap","updateSkybox","removeAll"],"mappings":"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","sourcesContent":["import * as echarts from 'echarts/lib/echarts';\nimport graphicGL from '../../util/graphicGL';\nimport OrbitControl from '../../util/OrbitControl';\nimport SceneHelper from '../../component/common/SceneHelper';\nimport Geo3DBuilder from '../../component/common/Geo3DBuilder';\nexport default echarts.ChartView.extend({\n  type: 'map3D',\n  __ecgl__: true,\n  init: function (ecModel, api) {\n    this._geo3DBuilder = new Geo3DBuilder(api);\n    this.groupGL = new graphicGL.Node();\n  },\n  render: function (map3DModel, ecModel, api) {\n    var coordSys = map3DModel.coordinateSystem;\n\n    if (!coordSys || !coordSys.viewGL) {\n      return;\n    }\n\n    this.groupGL.add(this._geo3DBuilder.rootNode);\n    coordSys.viewGL.add(this.groupGL);\n    var geo3D;\n\n    if (coordSys.type === 'geo3D') {\n      geo3D = coordSys;\n\n      if (!this._sceneHelper) {\n        this._sceneHelper = new SceneHelper();\n\n        this._sceneHelper.initLight(this.groupGL);\n      }\n\n      this._sceneHelper.setScene(coordSys.viewGL.scene);\n\n      this._sceneHelper.updateLight(map3DModel); // Set post effect\n\n\n      coordSys.viewGL.setPostEffect(map3DModel.getModel('postEffect'), api);\n      coordSys.viewGL.setTemporalSuperSampling(map3DModel.getModel('temporalSuperSampling'));\n      var control = this._control;\n\n      if (!control) {\n        control = this._control = new OrbitControl({\n          zr: api.getZr()\n        });\n\n        this._control.init();\n      }\n\n      var viewControlModel = map3DModel.getModel('viewControl');\n      control.setViewGL(coordSys.viewGL);\n      control.setFromViewControlModel(viewControlModel, 0);\n      control.off('update');\n      control.on('update', function () {\n        api.dispatchAction({\n          type: 'map3DChangeCamera',\n          alpha: control.getAlpha(),\n          beta: control.getBeta(),\n          distance: control.getDistance(),\n          from: this.uid,\n          map3DId: map3DModel.id\n        });\n      });\n      this._geo3DBuilder.extrudeY = true;\n    } else {\n      if (this._control) {\n        this._control.dispose();\n\n        this._control = null;\n      }\n\n      if (this._sceneHelper) {\n        this._sceneHelper.dispose();\n\n        this._sceneHelper = null;\n      }\n\n      geo3D = map3DModel.getData().getLayout('geo3D');\n      this._geo3DBuilder.extrudeY = false;\n    }\n\n    this._geo3DBuilder.update(map3DModel, ecModel, api, 0, map3DModel.getData().count()); // Must update after geo3D.viewGL.setPostEffect to determine linear space\n\n\n    var srgbDefineMethod = coordSys.viewGL.isLinearSpace() ? 'define' : 'undefine';\n\n    this._geo3DBuilder.rootNode.traverse(function (mesh) {\n      if (mesh.material) {\n        mesh.material[srgbDefineMethod]('fragment', 'SRGB_DECODE');\n      }\n    });\n  },\n  afterRender: function (map3DModel, ecModel, api, layerGL) {\n    var renderer = layerGL.renderer;\n    var coordSys = map3DModel.coordinateSystem;\n\n    if (coordSys && coordSys.type === 'geo3D') {\n      this._sceneHelper.updateAmbientCubemap(renderer, map3DModel, api);\n\n      this._sceneHelper.updateSkybox(renderer, map3DModel, api);\n    }\n  },\n  dispose: function () {\n    this.groupGL.removeAll();\n\n    this._control.dispose();\n\n    this._geo3DBuilder.dispose();\n  }\n});"]},"metadata":{},"sourceType":"module"}