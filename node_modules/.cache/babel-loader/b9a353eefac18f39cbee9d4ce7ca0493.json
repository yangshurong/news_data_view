{"ast":null,"code":"import \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.typed-array.float32-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/es.typed-array.uint32-array.js\";\nimport \"core-js/modules/es.typed-array.uint16-array.js\";\nimport \"core-js/modules/es.string.sub.js\";\nimport * as echarts from 'echarts/lib/echarts';\nimport graphicGL from '../../util/graphicGL';\nimport glmatrix from 'claygl/src/dep/glmatrix';\nimport trianglesSortMixin from '../../util/geometry/trianglesSortMixin';\nimport { getItemVisualColor, getItemVisualOpacity } from '../../util/visual';\nvar vec3 = glmatrix.vec3;\n\nfunction isPointsNaN(pt) {\n  return isNaN(pt[0]) || isNaN(pt[1]) || isNaN(pt[2]);\n}\n\nexport default echarts.ChartView.extend({\n  type: 'surface',\n  __ecgl__: true,\n  init: function init(ecModel, api) {\n    this.groupGL = new graphicGL.Node();\n  },\n  render: function render(seriesModel, ecModel, api) {\n    // Swap surfaceMesh\n    var tmp = this._prevSurfaceMesh;\n    this._prevSurfaceMesh = this._surfaceMesh;\n    this._surfaceMesh = tmp;\n\n    if (!this._surfaceMesh) {\n      this._surfaceMesh = this._createSurfaceMesh();\n    }\n\n    this.groupGL.remove(this._prevSurfaceMesh);\n    this.groupGL.add(this._surfaceMesh);\n    var coordSys = seriesModel.coordinateSystem;\n    var shading = seriesModel.get('shading');\n    var data = seriesModel.getData();\n    var shadingPrefix = 'ecgl.' + shading;\n\n    if (!this._surfaceMesh.material || this._surfaceMesh.material.shader.name !== shadingPrefix) {\n      this._surfaceMesh.material = graphicGL.createMaterial(shadingPrefix, ['VERTEX_COLOR', 'DOUBLE_SIDED']);\n    }\n\n    graphicGL.setMaterialFromModel(shading, this._surfaceMesh.material, seriesModel, api);\n\n    if (coordSys && coordSys.viewGL) {\n      coordSys.viewGL.add(this.groupGL);\n      var methodName = coordSys.viewGL.isLinearSpace() ? 'define' : 'undefine';\n\n      this._surfaceMesh.material[methodName]('fragment', 'SRGB_DECODE');\n    }\n\n    var isParametric = seriesModel.get('parametric');\n    var dataShape = seriesModel.get('dataShape');\n\n    if (!dataShape) {\n      dataShape = this._getDataShape(data, isParametric);\n\n      if (process.env.NODE_ENV !== 'production') {\n        if (seriesModel.get('data')) {\n          console.warn('dataShape is not provided. Guess it is ', dataShape);\n        }\n      }\n    }\n\n    var wireframeModel = seriesModel.getModel('wireframe');\n    var wireframeLineWidth = wireframeModel.get('lineStyle.width');\n    var showWireframe = wireframeModel.get('show') && wireframeLineWidth > 0;\n\n    this._updateSurfaceMesh(this._surfaceMesh, seriesModel, dataShape, showWireframe);\n\n    var material = this._surfaceMesh.material;\n\n    if (showWireframe) {\n      material.define('WIREFRAME_QUAD');\n      material.set('wireframeLineWidth', wireframeLineWidth);\n      material.set('wireframeLineColor', graphicGL.parseColor(wireframeModel.get('lineStyle.color')));\n    } else {\n      material.undefine('WIREFRAME_QUAD');\n    }\n\n    this._initHandler(seriesModel, api);\n\n    this._updateAnimation(seriesModel);\n  },\n  _updateAnimation: function _updateAnimation(seriesModel) {\n    graphicGL.updateVertexAnimation([['prevPosition', 'position'], ['prevNormal', 'normal']], this._prevSurfaceMesh, this._surfaceMesh, seriesModel);\n  },\n  _createSurfaceMesh: function _createSurfaceMesh() {\n    var mesh = new graphicGL.Mesh({\n      geometry: new graphicGL.Geometry({\n        dynamic: true,\n        sortTriangles: true\n      }),\n      shadowDepthMaterial: new graphicGL.Material({\n        shader: new graphicGL.Shader(graphicGL.Shader.source('ecgl.sm.depth.vertex'), graphicGL.Shader.source('ecgl.sm.depth.fragment'))\n      }),\n      culling: false,\n      // Render after axes\n      renderOrder: 10,\n      // Render normal in normal pass\n      renderNormal: true\n    });\n    mesh.geometry.createAttribute('barycentric', 'float', 4);\n    mesh.geometry.createAttribute('prevPosition', 'float', 3);\n    mesh.geometry.createAttribute('prevNormal', 'float', 3);\n    Object.assign(mesh.geometry, trianglesSortMixin);\n    return mesh;\n  },\n  _initHandler: function _initHandler(seriesModel, api) {\n    var data = seriesModel.getData();\n    var surfaceMesh = this._surfaceMesh;\n    var coordSys = seriesModel.coordinateSystem;\n\n    function getNearestPointIdx(triangle, point) {\n      var nearestDist = Infinity;\n      var nearestIdx = -1;\n      var pos = [];\n\n      for (var i = 0; i < triangle.length; i++) {\n        surfaceMesh.geometry.attributes.position.get(triangle[i], pos);\n        var dist = vec3.dist(point.array, pos);\n\n        if (dist < nearestDist) {\n          nearestDist = dist;\n          nearestIdx = triangle[i];\n        }\n      }\n\n      return nearestIdx;\n    }\n\n    surfaceMesh.seriesIndex = seriesModel.seriesIndex;\n    var lastDataIndex = -1;\n    surfaceMesh.off('mousemove');\n    surfaceMesh.off('mouseout');\n    surfaceMesh.on('mousemove', function (e) {\n      var idx = getNearestPointIdx(e.triangle, e.point);\n\n      if (idx >= 0) {\n        var point = [];\n        surfaceMesh.geometry.attributes.position.get(idx, point);\n        var value = coordSys.pointToData(point);\n        var minDist = Infinity;\n        var dataIndex = -1;\n        var item = [];\n\n        for (var i = 0; i < data.count(); i++) {\n          item[0] = data.get('x', i);\n          item[1] = data.get('y', i);\n          item[2] = data.get('z', i);\n          var dist = vec3.squaredDistance(item, value);\n\n          if (dist < minDist) {\n            dataIndex = i;\n            minDist = dist;\n          }\n        }\n\n        if (dataIndex !== lastDataIndex) {\n          api.dispatchAction({\n            type: 'grid3DShowAxisPointer',\n            value: value\n          });\n        }\n\n        lastDataIndex = dataIndex;\n        surfaceMesh.dataIndex = dataIndex;\n      } else {\n        surfaceMesh.dataIndex = -1;\n      }\n    }, this);\n    surfaceMesh.on('mouseout', function (e) {\n      lastDataIndex = -1;\n      surfaceMesh.dataIndex = -1;\n      api.dispatchAction({\n        type: 'grid3DHideAxisPointer'\n      });\n    }, this);\n  },\n  _updateSurfaceMesh: function _updateSurfaceMesh(surfaceMesh, seriesModel, dataShape, showWireframe) {\n    var geometry = surfaceMesh.geometry;\n    var data = seriesModel.getData();\n    var pointsArr = data.getLayout('points');\n    var invalidDataCount = 0;\n    data.each(function (idx) {\n      if (!data.hasValue(idx)) {\n        invalidDataCount++;\n      }\n    });\n    var needsSplitQuad = invalidDataCount || showWireframe;\n    var positionAttr = geometry.attributes.position;\n    var normalAttr = geometry.attributes.normal;\n    var texcoordAttr = geometry.attributes.texcoord0;\n    var barycentricAttr = geometry.attributes.barycentric;\n    var colorAttr = geometry.attributes.color;\n    var row = dataShape[0];\n    var column = dataShape[1];\n    var shading = seriesModel.get('shading');\n    var needsNormal = shading !== 'color';\n\n    if (needsSplitQuad) {\n      // TODO, If needs remove the invalid points, or set color transparent.\n      var vertexCount = (row - 1) * (column - 1) * 4;\n      positionAttr.init(vertexCount);\n\n      if (showWireframe) {\n        barycentricAttr.init(vertexCount);\n      }\n    } else {\n      positionAttr.value = new Float32Array(pointsArr);\n    }\n\n    colorAttr.init(geometry.vertexCount);\n    texcoordAttr.init(geometry.vertexCount);\n    var quadToTriangle = [0, 3, 1, 1, 3, 2]; // 3----2\n    // 0----1\n    // Make sure pixels on 1---3 edge will not have channel 0.\n    // And pixels on four edges have at least one channel 0.\n\n    var quadBarycentric = [[1, 1, 0, 0], [0, 1, 0, 1], [1, 0, 0, 1], [1, 0, 1, 0]];\n    var indices = geometry.indices = new (geometry.vertexCount > 0xffff ? Uint32Array : Uint16Array)((row - 1) * (column - 1) * 6);\n\n    var getQuadIndices = function getQuadIndices(i, j, out) {\n      out[1] = i * column + j;\n      out[0] = i * column + j + 1;\n      out[3] = (i + 1) * column + j + 1;\n      out[2] = (i + 1) * column + j;\n    };\n\n    var isTransparent = false;\n\n    if (needsSplitQuad) {\n      var quadIndices = [];\n      var pos = [];\n      var faceOffset = 0;\n\n      if (needsNormal) {\n        normalAttr.init(geometry.vertexCount);\n      } else {\n        normalAttr.value = null;\n      }\n\n      var pts = [[], [], []];\n      var v21 = [],\n          v32 = [];\n      var normal = vec3.create();\n\n      var getFromArray = function getFromArray(arr, idx, out) {\n        var idx3 = idx * 3;\n        out[0] = arr[idx3];\n        out[1] = arr[idx3 + 1];\n        out[2] = arr[idx3 + 2];\n        return out;\n      };\n\n      var vertexNormals = new Float32Array(pointsArr.length);\n      var vertexColors = new Float32Array(pointsArr.length / 3 * 4);\n\n      for (var i = 0; i < data.count(); i++) {\n        if (data.hasValue(i)) {\n          var rgbaArr = graphicGL.parseColor(getItemVisualColor(data, i));\n          var opacity = getItemVisualOpacity(data, i);\n          opacity != null && (rgbaArr[3] *= opacity);\n\n          if (rgbaArr[3] < 0.99) {\n            isTransparent = true;\n          }\n\n          for (var k = 0; k < 4; k++) {\n            vertexColors[i * 4 + k] = rgbaArr[k];\n          }\n        }\n      }\n\n      var farPoints = [1e7, 1e7, 1e7];\n\n      for (var i = 0; i < row - 1; i++) {\n        for (var j = 0; j < column - 1; j++) {\n          var dataIndex = i * (column - 1) + j;\n          var vertexOffset = dataIndex * 4;\n          getQuadIndices(i, j, quadIndices);\n          var invisibleQuad = false;\n\n          for (var k = 0; k < 4; k++) {\n            getFromArray(pointsArr, quadIndices[k], pos);\n\n            if (isPointsNaN(pos)) {\n              // Quad is invisible if any point is NaN\n              invisibleQuad = true;\n            }\n          }\n\n          for (var k = 0; k < 4; k++) {\n            if (invisibleQuad) {\n              // Move point far away\n              positionAttr.set(vertexOffset + k, farPoints);\n            } else {\n              getFromArray(pointsArr, quadIndices[k], pos);\n              positionAttr.set(vertexOffset + k, pos);\n            }\n\n            if (showWireframe) {\n              barycentricAttr.set(vertexOffset + k, quadBarycentric[k]);\n            }\n          }\n\n          for (var k = 0; k < 6; k++) {\n            indices[faceOffset++] = quadToTriangle[k] + vertexOffset;\n          } // Vertex normals\n\n\n          if (needsNormal && !invisibleQuad) {\n            for (var k = 0; k < 2; k++) {\n              var k3 = k * 3;\n\n              for (var m = 0; m < 3; m++) {\n                var idx = quadIndices[quadToTriangle[k3] + m];\n                getFromArray(pointsArr, idx, pts[m]);\n              }\n\n              vec3.sub(v21, pts[0], pts[1]);\n              vec3.sub(v32, pts[1], pts[2]);\n              vec3.cross(normal, v21, v32); // Weighted by the triangle area\n\n              for (var m = 0; m < 3; m++) {\n                var idx3 = quadIndices[quadToTriangle[k3] + m] * 3;\n                vertexNormals[idx3] = vertexNormals[idx3] + normal[0];\n                vertexNormals[idx3 + 1] = vertexNormals[idx3 + 1] + normal[1];\n                vertexNormals[idx3 + 2] = vertexNormals[idx3 + 2] + normal[2];\n              }\n            }\n          }\n        }\n      }\n\n      if (needsNormal) {\n        for (var i = 0; i < vertexNormals.length / 3; i++) {\n          getFromArray(vertexNormals, i, normal);\n          vec3.normalize(normal, normal);\n          vertexNormals[i * 3] = normal[0];\n          vertexNormals[i * 3 + 1] = normal[1];\n          vertexNormals[i * 3 + 2] = normal[2];\n        }\n      } // Split normal and colors, write to the attributes.\n\n\n      var rgbaArr = [];\n      var uvArr = [];\n\n      for (var i = 0; i < row - 1; i++) {\n        for (var j = 0; j < column - 1; j++) {\n          var dataIndex = i * (column - 1) + j;\n          var vertexOffset = dataIndex * 4;\n          getQuadIndices(i, j, quadIndices);\n\n          for (var k = 0; k < 4; k++) {\n            for (var m = 0; m < 4; m++) {\n              rgbaArr[m] = vertexColors[quadIndices[k] * 4 + m];\n            }\n\n            colorAttr.set(vertexOffset + k, rgbaArr);\n\n            if (needsNormal) {\n              getFromArray(vertexNormals, quadIndices[k], normal);\n              normalAttr.set(vertexOffset + k, normal);\n            }\n\n            var idx = quadIndices[k];\n            uvArr[0] = idx % column / (column - 1);\n            uvArr[1] = Math.floor(idx / column) / (row - 1);\n            texcoordAttr.set(vertexOffset + k, uvArr);\n          }\n\n          dataIndex++;\n        }\n      }\n    } else {\n      var uvArr = [];\n\n      for (var i = 0; i < data.count(); i++) {\n        uvArr[0] = i % column / (column - 1);\n        uvArr[1] = Math.floor(i / column) / (row - 1);\n        var rgbaArr = graphicGL.parseColor(getItemVisualColor(data, i));\n        var opacity = getItemVisualOpacity(data, i);\n        opacity != null && (rgbaArr[3] *= opacity);\n\n        if (rgbaArr[3] < 0.99) {\n          isTransparent = true;\n        }\n\n        colorAttr.set(i, rgbaArr);\n        texcoordAttr.set(i, uvArr);\n      }\n\n      var quadIndices = []; // Triangles\n\n      var cursor = 0;\n\n      for (var i = 0; i < row - 1; i++) {\n        for (var j = 0; j < column - 1; j++) {\n          getQuadIndices(i, j, quadIndices);\n\n          for (var k = 0; k < 6; k++) {\n            indices[cursor++] = quadIndices[quadToTriangle[k]];\n          }\n        }\n      }\n\n      if (needsNormal) {\n        geometry.generateVertexNormals();\n      } else {\n        normalAttr.value = null;\n      }\n    }\n\n    if (surfaceMesh.material.get('normalMap')) {\n      geometry.generateTangents();\n    }\n\n    geometry.updateBoundingBox();\n    geometry.dirty();\n    surfaceMesh.material.transparent = isTransparent;\n    surfaceMesh.material.depthMask = !isTransparent;\n  },\n  _getDataShape: function _getDataShape(data, isParametric) {\n    var prevX = -Infinity;\n    var rowCount = 0;\n    var columnCount = 0;\n    var prevColumnCount = 0;\n    var mayInvalid = false;\n    var rowDim = isParametric ? 'u' : 'x';\n    var dataCount = data.count(); // Check data format\n\n    for (var i = 0; i < dataCount; i++) {\n      var x = data.get(rowDim, i);\n\n      if (x < prevX) {\n        if (prevColumnCount && prevColumnCount !== columnCount) {\n          if (process.env.NODE_ENV !== 'production') {\n            mayInvalid = true;\n          }\n        } // A new row.\n\n\n        prevColumnCount = columnCount;\n        columnCount = 0;\n        rowCount++;\n      }\n\n      prevX = x;\n      columnCount++;\n    }\n\n    if (!rowCount || columnCount === 1) {\n      mayInvalid = true;\n    }\n\n    if (!mayInvalid) {\n      return [rowCount + 1, columnCount];\n    }\n\n    var rows = Math.floor(Math.sqrt(dataCount));\n\n    while (rows > 0) {\n      if (Math.floor(dataCount / rows) === dataCount / rows) {\n        // Can be divided\n        return [rows, dataCount / rows];\n      }\n\n      rows--;\n    } // Bailout\n\n\n    rows = Math.floor(Math.sqrt(dataCount));\n    return [rows, rows];\n  },\n  dispose: function dispose() {\n    this.groupGL.removeAll();\n  },\n  remove: function remove() {\n    this.groupGL.removeAll();\n  }\n});","map":{"version":3,"sources":["C:/Users/Administrator/Desktop/data_view/my_project/vue2_app/myapp/node_modules/_echarts-gl@2.0.9@echarts-gl/lib/chart/surface/SurfaceView.js"],"names":["echarts","graphicGL","glmatrix","trianglesSortMixin","getItemVisualColor","getItemVisualOpacity","vec3","isPointsNaN","pt","isNaN","ChartView","extend","type","__ecgl__","init","ecModel","api","groupGL","Node","render","seriesModel","tmp","_prevSurfaceMesh","_surfaceMesh","_createSurfaceMesh","remove","add","coordSys","coordinateSystem","shading","get","data","getData","shadingPrefix","material","shader","name","createMaterial","setMaterialFromModel","viewGL","methodName","isLinearSpace","isParametric","dataShape","_getDataShape","process","env","NODE_ENV","console","warn","wireframeModel","getModel","wireframeLineWidth","showWireframe","_updateSurfaceMesh","define","set","parseColor","undefine","_initHandler","_updateAnimation","updateVertexAnimation","mesh","Mesh","geometry","Geometry","dynamic","sortTriangles","shadowDepthMaterial","Material","Shader","source","culling","renderOrder","renderNormal","createAttribute","Object","assign","surfaceMesh","getNearestPointIdx","triangle","point","nearestDist","Infinity","nearestIdx","pos","i","length","attributes","position","dist","array","seriesIndex","lastDataIndex","off","on","e","idx","value","pointToData","minDist","dataIndex","item","count","squaredDistance","dispatchAction","pointsArr","getLayout","invalidDataCount","each","hasValue","needsSplitQuad","positionAttr","normalAttr","normal","texcoordAttr","texcoord0","barycentricAttr","barycentric","colorAttr","color","row","column","needsNormal","vertexCount","Float32Array","quadToTriangle","quadBarycentric","indices","Uint32Array","Uint16Array","getQuadIndices","j","out","isTransparent","quadIndices","faceOffset","pts","v21","v32","create","getFromArray","arr","idx3","vertexNormals","vertexColors","rgbaArr","opacity","k","farPoints","vertexOffset","invisibleQuad","k3","m","sub","cross","normalize","uvArr","Math","floor","cursor","generateVertexNormals","generateTangents","updateBoundingBox","dirty","transparent","depthMask","prevX","rowCount","columnCount","prevColumnCount","mayInvalid","rowDim","dataCount","x","rows","sqrt","dispose","removeAll"],"mappings":"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","sourcesContent":["import * as echarts from 'echarts/lib/echarts';\nimport graphicGL from '../../util/graphicGL';\nimport glmatrix from 'claygl/src/dep/glmatrix';\nimport trianglesSortMixin from '../../util/geometry/trianglesSortMixin';\nimport { getItemVisualColor, getItemVisualOpacity } from '../../util/visual';\nvar vec3 = glmatrix.vec3;\n\nfunction isPointsNaN(pt) {\n  return isNaN(pt[0]) || isNaN(pt[1]) || isNaN(pt[2]);\n}\n\nexport default echarts.ChartView.extend({\n  type: 'surface',\n  __ecgl__: true,\n  init: function (ecModel, api) {\n    this.groupGL = new graphicGL.Node();\n  },\n  render: function (seriesModel, ecModel, api) {\n    // Swap surfaceMesh\n    var tmp = this._prevSurfaceMesh;\n    this._prevSurfaceMesh = this._surfaceMesh;\n    this._surfaceMesh = tmp;\n\n    if (!this._surfaceMesh) {\n      this._surfaceMesh = this._createSurfaceMesh();\n    }\n\n    this.groupGL.remove(this._prevSurfaceMesh);\n    this.groupGL.add(this._surfaceMesh);\n    var coordSys = seriesModel.coordinateSystem;\n    var shading = seriesModel.get('shading');\n    var data = seriesModel.getData();\n    var shadingPrefix = 'ecgl.' + shading;\n\n    if (!this._surfaceMesh.material || this._surfaceMesh.material.shader.name !== shadingPrefix) {\n      this._surfaceMesh.material = graphicGL.createMaterial(shadingPrefix, ['VERTEX_COLOR', 'DOUBLE_SIDED']);\n    }\n\n    graphicGL.setMaterialFromModel(shading, this._surfaceMesh.material, seriesModel, api);\n\n    if (coordSys && coordSys.viewGL) {\n      coordSys.viewGL.add(this.groupGL);\n      var methodName = coordSys.viewGL.isLinearSpace() ? 'define' : 'undefine';\n\n      this._surfaceMesh.material[methodName]('fragment', 'SRGB_DECODE');\n    }\n\n    var isParametric = seriesModel.get('parametric');\n    var dataShape = seriesModel.get('dataShape');\n\n    if (!dataShape) {\n      dataShape = this._getDataShape(data, isParametric);\n\n      if (process.env.NODE_ENV !== 'production') {\n        if (seriesModel.get('data')) {\n          console.warn('dataShape is not provided. Guess it is ', dataShape);\n        }\n      }\n    }\n\n    var wireframeModel = seriesModel.getModel('wireframe');\n    var wireframeLineWidth = wireframeModel.get('lineStyle.width');\n    var showWireframe = wireframeModel.get('show') && wireframeLineWidth > 0;\n\n    this._updateSurfaceMesh(this._surfaceMesh, seriesModel, dataShape, showWireframe);\n\n    var material = this._surfaceMesh.material;\n\n    if (showWireframe) {\n      material.define('WIREFRAME_QUAD');\n      material.set('wireframeLineWidth', wireframeLineWidth);\n      material.set('wireframeLineColor', graphicGL.parseColor(wireframeModel.get('lineStyle.color')));\n    } else {\n      material.undefine('WIREFRAME_QUAD');\n    }\n\n    this._initHandler(seriesModel, api);\n\n    this._updateAnimation(seriesModel);\n  },\n  _updateAnimation: function (seriesModel) {\n    graphicGL.updateVertexAnimation([['prevPosition', 'position'], ['prevNormal', 'normal']], this._prevSurfaceMesh, this._surfaceMesh, seriesModel);\n  },\n  _createSurfaceMesh: function () {\n    var mesh = new graphicGL.Mesh({\n      geometry: new graphicGL.Geometry({\n        dynamic: true,\n        sortTriangles: true\n      }),\n      shadowDepthMaterial: new graphicGL.Material({\n        shader: new graphicGL.Shader(graphicGL.Shader.source('ecgl.sm.depth.vertex'), graphicGL.Shader.source('ecgl.sm.depth.fragment'))\n      }),\n      culling: false,\n      // Render after axes\n      renderOrder: 10,\n      // Render normal in normal pass\n      renderNormal: true\n    });\n    mesh.geometry.createAttribute('barycentric', 'float', 4);\n    mesh.geometry.createAttribute('prevPosition', 'float', 3);\n    mesh.geometry.createAttribute('prevNormal', 'float', 3);\n    Object.assign(mesh.geometry, trianglesSortMixin);\n    return mesh;\n  },\n  _initHandler: function (seriesModel, api) {\n    var data = seriesModel.getData();\n    var surfaceMesh = this._surfaceMesh;\n    var coordSys = seriesModel.coordinateSystem;\n\n    function getNearestPointIdx(triangle, point) {\n      var nearestDist = Infinity;\n      var nearestIdx = -1;\n      var pos = [];\n\n      for (var i = 0; i < triangle.length; i++) {\n        surfaceMesh.geometry.attributes.position.get(triangle[i], pos);\n        var dist = vec3.dist(point.array, pos);\n\n        if (dist < nearestDist) {\n          nearestDist = dist;\n          nearestIdx = triangle[i];\n        }\n      }\n\n      return nearestIdx;\n    }\n\n    surfaceMesh.seriesIndex = seriesModel.seriesIndex;\n    var lastDataIndex = -1;\n    surfaceMesh.off('mousemove');\n    surfaceMesh.off('mouseout');\n    surfaceMesh.on('mousemove', function (e) {\n      var idx = getNearestPointIdx(e.triangle, e.point);\n\n      if (idx >= 0) {\n        var point = [];\n        surfaceMesh.geometry.attributes.position.get(idx, point);\n        var value = coordSys.pointToData(point);\n        var minDist = Infinity;\n        var dataIndex = -1;\n        var item = [];\n\n        for (var i = 0; i < data.count(); i++) {\n          item[0] = data.get('x', i);\n          item[1] = data.get('y', i);\n          item[2] = data.get('z', i);\n          var dist = vec3.squaredDistance(item, value);\n\n          if (dist < minDist) {\n            dataIndex = i;\n            minDist = dist;\n          }\n        }\n\n        if (dataIndex !== lastDataIndex) {\n          api.dispatchAction({\n            type: 'grid3DShowAxisPointer',\n            value: value\n          });\n        }\n\n        lastDataIndex = dataIndex;\n        surfaceMesh.dataIndex = dataIndex;\n      } else {\n        surfaceMesh.dataIndex = -1;\n      }\n    }, this);\n    surfaceMesh.on('mouseout', function (e) {\n      lastDataIndex = -1;\n      surfaceMesh.dataIndex = -1;\n      api.dispatchAction({\n        type: 'grid3DHideAxisPointer'\n      });\n    }, this);\n  },\n  _updateSurfaceMesh: function (surfaceMesh, seriesModel, dataShape, showWireframe) {\n    var geometry = surfaceMesh.geometry;\n    var data = seriesModel.getData();\n    var pointsArr = data.getLayout('points');\n    var invalidDataCount = 0;\n    data.each(function (idx) {\n      if (!data.hasValue(idx)) {\n        invalidDataCount++;\n      }\n    });\n    var needsSplitQuad = invalidDataCount || showWireframe;\n    var positionAttr = geometry.attributes.position;\n    var normalAttr = geometry.attributes.normal;\n    var texcoordAttr = geometry.attributes.texcoord0;\n    var barycentricAttr = geometry.attributes.barycentric;\n    var colorAttr = geometry.attributes.color;\n    var row = dataShape[0];\n    var column = dataShape[1];\n    var shading = seriesModel.get('shading');\n    var needsNormal = shading !== 'color';\n\n    if (needsSplitQuad) {\n      // TODO, If needs remove the invalid points, or set color transparent.\n      var vertexCount = (row - 1) * (column - 1) * 4;\n      positionAttr.init(vertexCount);\n\n      if (showWireframe) {\n        barycentricAttr.init(vertexCount);\n      }\n    } else {\n      positionAttr.value = new Float32Array(pointsArr);\n    }\n\n    colorAttr.init(geometry.vertexCount);\n    texcoordAttr.init(geometry.vertexCount);\n    var quadToTriangle = [0, 3, 1, 1, 3, 2]; // 3----2\n    // 0----1\n    // Make sure pixels on 1---3 edge will not have channel 0.\n    // And pixels on four edges have at least one channel 0.\n\n    var quadBarycentric = [[1, 1, 0, 0], [0, 1, 0, 1], [1, 0, 0, 1], [1, 0, 1, 0]];\n    var indices = geometry.indices = new (geometry.vertexCount > 0xffff ? Uint32Array : Uint16Array)((row - 1) * (column - 1) * 6);\n\n    var getQuadIndices = function (i, j, out) {\n      out[1] = i * column + j;\n      out[0] = i * column + j + 1;\n      out[3] = (i + 1) * column + j + 1;\n      out[2] = (i + 1) * column + j;\n    };\n\n    var isTransparent = false;\n\n    if (needsSplitQuad) {\n      var quadIndices = [];\n      var pos = [];\n      var faceOffset = 0;\n\n      if (needsNormal) {\n        normalAttr.init(geometry.vertexCount);\n      } else {\n        normalAttr.value = null;\n      }\n\n      var pts = [[], [], []];\n      var v21 = [],\n          v32 = [];\n      var normal = vec3.create();\n\n      var getFromArray = function (arr, idx, out) {\n        var idx3 = idx * 3;\n        out[0] = arr[idx3];\n        out[1] = arr[idx3 + 1];\n        out[2] = arr[idx3 + 2];\n        return out;\n      };\n\n      var vertexNormals = new Float32Array(pointsArr.length);\n      var vertexColors = new Float32Array(pointsArr.length / 3 * 4);\n\n      for (var i = 0; i < data.count(); i++) {\n        if (data.hasValue(i)) {\n          var rgbaArr = graphicGL.parseColor(getItemVisualColor(data, i));\n          var opacity = getItemVisualOpacity(data, i);\n          opacity != null && (rgbaArr[3] *= opacity);\n\n          if (rgbaArr[3] < 0.99) {\n            isTransparent = true;\n          }\n\n          for (var k = 0; k < 4; k++) {\n            vertexColors[i * 4 + k] = rgbaArr[k];\n          }\n        }\n      }\n\n      var farPoints = [1e7, 1e7, 1e7];\n\n      for (var i = 0; i < row - 1; i++) {\n        for (var j = 0; j < column - 1; j++) {\n          var dataIndex = i * (column - 1) + j;\n          var vertexOffset = dataIndex * 4;\n          getQuadIndices(i, j, quadIndices);\n          var invisibleQuad = false;\n\n          for (var k = 0; k < 4; k++) {\n            getFromArray(pointsArr, quadIndices[k], pos);\n\n            if (isPointsNaN(pos)) {\n              // Quad is invisible if any point is NaN\n              invisibleQuad = true;\n            }\n          }\n\n          for (var k = 0; k < 4; k++) {\n            if (invisibleQuad) {\n              // Move point far away\n              positionAttr.set(vertexOffset + k, farPoints);\n            } else {\n              getFromArray(pointsArr, quadIndices[k], pos);\n              positionAttr.set(vertexOffset + k, pos);\n            }\n\n            if (showWireframe) {\n              barycentricAttr.set(vertexOffset + k, quadBarycentric[k]);\n            }\n          }\n\n          for (var k = 0; k < 6; k++) {\n            indices[faceOffset++] = quadToTriangle[k] + vertexOffset;\n          } // Vertex normals\n\n\n          if (needsNormal && !invisibleQuad) {\n            for (var k = 0; k < 2; k++) {\n              var k3 = k * 3;\n\n              for (var m = 0; m < 3; m++) {\n                var idx = quadIndices[quadToTriangle[k3] + m];\n                getFromArray(pointsArr, idx, pts[m]);\n              }\n\n              vec3.sub(v21, pts[0], pts[1]);\n              vec3.sub(v32, pts[1], pts[2]);\n              vec3.cross(normal, v21, v32); // Weighted by the triangle area\n\n              for (var m = 0; m < 3; m++) {\n                var idx3 = quadIndices[quadToTriangle[k3] + m] * 3;\n                vertexNormals[idx3] = vertexNormals[idx3] + normal[0];\n                vertexNormals[idx3 + 1] = vertexNormals[idx3 + 1] + normal[1];\n                vertexNormals[idx3 + 2] = vertexNormals[idx3 + 2] + normal[2];\n              }\n            }\n          }\n        }\n      }\n\n      if (needsNormal) {\n        for (var i = 0; i < vertexNormals.length / 3; i++) {\n          getFromArray(vertexNormals, i, normal);\n          vec3.normalize(normal, normal);\n          vertexNormals[i * 3] = normal[0];\n          vertexNormals[i * 3 + 1] = normal[1];\n          vertexNormals[i * 3 + 2] = normal[2];\n        }\n      } // Split normal and colors, write to the attributes.\n\n\n      var rgbaArr = [];\n      var uvArr = [];\n\n      for (var i = 0; i < row - 1; i++) {\n        for (var j = 0; j < column - 1; j++) {\n          var dataIndex = i * (column - 1) + j;\n          var vertexOffset = dataIndex * 4;\n          getQuadIndices(i, j, quadIndices);\n\n          for (var k = 0; k < 4; k++) {\n            for (var m = 0; m < 4; m++) {\n              rgbaArr[m] = vertexColors[quadIndices[k] * 4 + m];\n            }\n\n            colorAttr.set(vertexOffset + k, rgbaArr);\n\n            if (needsNormal) {\n              getFromArray(vertexNormals, quadIndices[k], normal);\n              normalAttr.set(vertexOffset + k, normal);\n            }\n\n            var idx = quadIndices[k];\n            uvArr[0] = idx % column / (column - 1);\n            uvArr[1] = Math.floor(idx / column) / (row - 1);\n            texcoordAttr.set(vertexOffset + k, uvArr);\n          }\n\n          dataIndex++;\n        }\n      }\n    } else {\n      var uvArr = [];\n\n      for (var i = 0; i < data.count(); i++) {\n        uvArr[0] = i % column / (column - 1);\n        uvArr[1] = Math.floor(i / column) / (row - 1);\n        var rgbaArr = graphicGL.parseColor(getItemVisualColor(data, i));\n        var opacity = getItemVisualOpacity(data, i);\n        opacity != null && (rgbaArr[3] *= opacity);\n\n        if (rgbaArr[3] < 0.99) {\n          isTransparent = true;\n        }\n\n        colorAttr.set(i, rgbaArr);\n        texcoordAttr.set(i, uvArr);\n      }\n\n      var quadIndices = []; // Triangles\n\n      var cursor = 0;\n\n      for (var i = 0; i < row - 1; i++) {\n        for (var j = 0; j < column - 1; j++) {\n          getQuadIndices(i, j, quadIndices);\n\n          for (var k = 0; k < 6; k++) {\n            indices[cursor++] = quadIndices[quadToTriangle[k]];\n          }\n        }\n      }\n\n      if (needsNormal) {\n        geometry.generateVertexNormals();\n      } else {\n        normalAttr.value = null;\n      }\n    }\n\n    if (surfaceMesh.material.get('normalMap')) {\n      geometry.generateTangents();\n    }\n\n    geometry.updateBoundingBox();\n    geometry.dirty();\n    surfaceMesh.material.transparent = isTransparent;\n    surfaceMesh.material.depthMask = !isTransparent;\n  },\n  _getDataShape: function (data, isParametric) {\n    var prevX = -Infinity;\n    var rowCount = 0;\n    var columnCount = 0;\n    var prevColumnCount = 0;\n    var mayInvalid = false;\n    var rowDim = isParametric ? 'u' : 'x';\n    var dataCount = data.count(); // Check data format\n\n    for (var i = 0; i < dataCount; i++) {\n      var x = data.get(rowDim, i);\n\n      if (x < prevX) {\n        if (prevColumnCount && prevColumnCount !== columnCount) {\n          if (process.env.NODE_ENV !== 'production') {\n            mayInvalid = true;\n          }\n        } // A new row.\n\n\n        prevColumnCount = columnCount;\n        columnCount = 0;\n        rowCount++;\n      }\n\n      prevX = x;\n      columnCount++;\n    }\n\n    if (!rowCount || columnCount === 1) {\n      mayInvalid = true;\n    }\n\n    if (!mayInvalid) {\n      return [rowCount + 1, columnCount];\n    }\n\n    var rows = Math.floor(Math.sqrt(dataCount));\n\n    while (rows > 0) {\n      if (Math.floor(dataCount / rows) === dataCount / rows) {\n        // Can be divided\n        return [rows, dataCount / rows];\n      }\n\n      rows--;\n    } // Bailout\n\n\n    rows = Math.floor(Math.sqrt(dataCount));\n    return [rows, rows];\n  },\n  dispose: function () {\n    this.groupGL.removeAll();\n  },\n  remove: function () {\n    this.groupGL.removeAll();\n  }\n});"]},"metadata":{},"sourceType":"module"}