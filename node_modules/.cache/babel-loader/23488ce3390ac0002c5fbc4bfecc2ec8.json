{"ast":null,"code":"import \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.typed-array.uint16-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/es.typed-array.uint32-array.js\";\nimport \"core-js/modules/es.typed-array.float32-array.js\";\n\n/**\n * Lines geometry\n * Use screen space projected lines lineWidth > MAX_LINE_WIDTH\n * https://mattdesl.svbtle.com/drawing-lines-is-hard\n * @module echarts-gl/util/geometry/LinesGeometry\n * @author Yi Shen(http://github.com/pissang)\n */\nimport Geometry from 'claygl/src/Geometry';\nimport * as echarts from 'echarts/lib/echarts';\nimport dynamicConvertMixin from './dynamicConvertMixin';\nimport glmatrix from 'claygl/src/dep/glmatrix';\nvar vec3 = glmatrix.vec3; // var CURVE_RECURSION_LIMIT = 8;\n// var CURVE_COLLINEAR_EPSILON = 40;\n\nvar sampleLinePoints = [[0, 0], [1, 1]];\n/**\n * @constructor\n * @alias module:echarts-gl/util/geometry/LinesGeometry\n * @extends clay.Geometry\n */\n\nvar LinesGeometry = Geometry.extend(function () {\n  return {\n    segmentScale: 1,\n    dynamic: true,\n\n    /**\n     * Need to use mesh to expand lines if lineWidth > MAX_LINE_WIDTH\n     */\n    useNativeLine: true,\n    attributes: {\n      position: new Geometry.Attribute('position', 'float', 3, 'POSITION'),\n      positionPrev: new Geometry.Attribute('positionPrev', 'float', 3),\n      positionNext: new Geometry.Attribute('positionNext', 'float', 3),\n      prevPositionPrev: new Geometry.Attribute('prevPositionPrev', 'float', 3),\n      prevPosition: new Geometry.Attribute('prevPosition', 'float', 3),\n      prevPositionNext: new Geometry.Attribute('prevPositionNext', 'float', 3),\n      offset: new Geometry.Attribute('offset', 'float', 1),\n      color: new Geometry.Attribute('color', 'float', 4, 'COLOR')\n    }\n  };\n},\n/** @lends module: echarts-gl/util/geometry/LinesGeometry.prototype */\n{\n  /**\n   * Reset offset\n   */\n  resetOffset: function resetOffset() {\n    this._vertexOffset = 0;\n    this._triangleOffset = 0;\n    this._itemVertexOffsets = [];\n  },\n\n  /**\n   * @param {number} nVertex\n   */\n  setVertexCount: function setVertexCount(nVertex) {\n    var attributes = this.attributes;\n\n    if (this.vertexCount !== nVertex) {\n      attributes.position.init(nVertex);\n      attributes.color.init(nVertex);\n\n      if (!this.useNativeLine) {\n        attributes.positionPrev.init(nVertex);\n        attributes.positionNext.init(nVertex);\n        attributes.offset.init(nVertex);\n      }\n\n      if (nVertex > 0xffff) {\n        if (this.indices instanceof Uint16Array) {\n          this.indices = new Uint32Array(this.indices);\n        }\n      } else {\n        if (this.indices instanceof Uint32Array) {\n          this.indices = new Uint16Array(this.indices);\n        }\n      }\n    }\n  },\n\n  /**\n   * @param {number} nTriangle\n   */\n  setTriangleCount: function setTriangleCount(nTriangle) {\n    if (this.triangleCount !== nTriangle) {\n      if (nTriangle === 0) {\n        this.indices = null;\n      } else {\n        this.indices = this.vertexCount > 0xffff ? new Uint32Array(nTriangle * 3) : new Uint16Array(nTriangle * 3);\n      }\n    }\n  },\n  _getCubicCurveApproxStep: function _getCubicCurveApproxStep(p0, p1, p2, p3) {\n    var len = vec3.dist(p0, p1) + vec3.dist(p2, p1) + vec3.dist(p3, p2);\n    var step = 1 / (len + 1) * this.segmentScale;\n    return step;\n  },\n\n  /**\n   * Get vertex count of cubic curve\n   * @param {Array.<number>} p0\n   * @param {Array.<number>} p1\n   * @param {Array.<number>} p2\n   * @param {Array.<number>} p3\n   * @return number\n   */\n  getCubicCurveVertexCount: function getCubicCurveVertexCount(p0, p1, p2, p3) {\n    var step = this._getCubicCurveApproxStep(p0, p1, p2, p3);\n\n    var segCount = Math.ceil(1 / step);\n\n    if (!this.useNativeLine) {\n      return segCount * 2 + 2;\n    } else {\n      return segCount * 2;\n    }\n  },\n\n  /**\n   * Get face count of cubic curve\n   * @param {Array.<number>} p0\n   * @param {Array.<number>} p1\n   * @param {Array.<number>} p2\n   * @param {Array.<number>} p3\n   * @return number\n   */\n  getCubicCurveTriangleCount: function getCubicCurveTriangleCount(p0, p1, p2, p3) {\n    var step = this._getCubicCurveApproxStep(p0, p1, p2, p3);\n\n    var segCount = Math.ceil(1 / step);\n\n    if (!this.useNativeLine) {\n      return segCount * 2;\n    } else {\n      return 0;\n    }\n  },\n\n  /**\n   * Get vertex count of line\n   * @return {number}\n   */\n  getLineVertexCount: function getLineVertexCount() {\n    return this.getPolylineVertexCount(sampleLinePoints);\n  },\n\n  /**\n   * Get face count of line\n   * @return {number}\n   */\n  getLineTriangleCount: function getLineTriangleCount() {\n    return this.getPolylineTriangleCount(sampleLinePoints);\n  },\n\n  /**\n   * Get how many vertices will polyline take.\n   * @type {number|Array} points Can be a 1d/2d list of points, or a number of points amount.\n   * @return {number}\n   */\n  getPolylineVertexCount: function getPolylineVertexCount(points) {\n    var pointsLen;\n\n    if (typeof points === 'number') {\n      pointsLen = points;\n    } else {\n      var is2DArray = typeof points[0] !== 'number';\n      pointsLen = is2DArray ? points.length : points.length / 3;\n    }\n\n    return !this.useNativeLine ? (pointsLen - 1) * 2 + 2 : (pointsLen - 1) * 2;\n  },\n\n  /**\n   * Get how many triangles will polyline take.\n   * @type {number|Array} points Can be a 1d/2d list of points, or a number of points amount.\n   * @return {number}\n   */\n  getPolylineTriangleCount: function getPolylineTriangleCount(points) {\n    var pointsLen;\n\n    if (typeof points === 'number') {\n      pointsLen = points;\n    } else {\n      var is2DArray = typeof points[0] !== 'number';\n      pointsLen = is2DArray ? points.length : points.length / 3;\n    }\n\n    return !this.useNativeLine ? Math.max(pointsLen - 1, 0) * 2 : 0;\n  },\n\n  /**\n   * Add a cubic curve\n   * @param {Array.<number>} p0\n   * @param {Array.<number>} p1\n   * @param {Array.<number>} p2\n   * @param {Array.<number>} p3\n   * @param {Array.<number>} color\n   * @param {number} [lineWidth=1]\n   */\n  addCubicCurve: function addCubicCurve(p0, p1, p2, p3, color, lineWidth) {\n    if (lineWidth == null) {\n      lineWidth = 1;\n    } // incremental interpolation\n    // http://antigrain.com/research/bezier_interpolation/index.html#PAGE_BEZIER_INTERPOLATION\n\n\n    var x0 = p0[0],\n        y0 = p0[1],\n        z0 = p0[2];\n    var x1 = p1[0],\n        y1 = p1[1],\n        z1 = p1[2];\n    var x2 = p2[0],\n        y2 = p2[1],\n        z2 = p2[2];\n    var x3 = p3[0],\n        y3 = p3[1],\n        z3 = p3[2];\n\n    var step = this._getCubicCurveApproxStep(p0, p1, p2, p3);\n\n    var step2 = step * step;\n    var step3 = step2 * step;\n    var pre1 = 3.0 * step;\n    var pre2 = 3.0 * step2;\n    var pre4 = 6.0 * step2;\n    var pre5 = 6.0 * step3;\n    var tmp1x = x0 - x1 * 2.0 + x2;\n    var tmp1y = y0 - y1 * 2.0 + y2;\n    var tmp1z = z0 - z1 * 2.0 + z2;\n    var tmp2x = (x1 - x2) * 3.0 - x0 + x3;\n    var tmp2y = (y1 - y2) * 3.0 - y0 + y3;\n    var tmp2z = (z1 - z2) * 3.0 - z0 + z3;\n    var fx = x0;\n    var fy = y0;\n    var fz = z0;\n    var dfx = (x1 - x0) * pre1 + tmp1x * pre2 + tmp2x * step3;\n    var dfy = (y1 - y0) * pre1 + tmp1y * pre2 + tmp2y * step3;\n    var dfz = (z1 - z0) * pre1 + tmp1z * pre2 + tmp2z * step3;\n    var ddfx = tmp1x * pre4 + tmp2x * pre5;\n    var ddfy = tmp1y * pre4 + tmp2y * pre5;\n    var ddfz = tmp1z * pre4 + tmp2z * pre5;\n    var dddfx = tmp2x * pre5;\n    var dddfy = tmp2y * pre5;\n    var dddfz = tmp2z * pre5;\n    var t = 0;\n    var k = 0;\n    var segCount = Math.ceil(1 / step);\n    var points = new Float32Array((segCount + 1) * 3);\n    var points = [];\n    var offset = 0;\n\n    for (var k = 0; k < segCount + 1; k++) {\n      points[offset++] = fx;\n      points[offset++] = fy;\n      points[offset++] = fz;\n      fx += dfx;\n      fy += dfy;\n      fz += dfz;\n      dfx += ddfx;\n      dfy += ddfy;\n      dfz += ddfz;\n      ddfx += dddfx;\n      ddfy += dddfy;\n      ddfz += dddfz;\n      t += step;\n\n      if (t > 1) {\n        fx = dfx > 0 ? Math.min(fx, x3) : Math.max(fx, x3);\n        fy = dfy > 0 ? Math.min(fy, y3) : Math.max(fy, y3);\n        fz = dfz > 0 ? Math.min(fz, z3) : Math.max(fz, z3);\n      }\n    }\n\n    return this.addPolyline(points, color, lineWidth);\n  },\n\n  /**\n   * Add a straight line\n   * @param {Array.<number>} p0\n   * @param {Array.<number>} p1\n   * @param {Array.<number>} color\n   * @param {number} [lineWidth=1]\n   */\n  addLine: function addLine(p0, p1, color, lineWidth) {\n    return this.addPolyline([p0, p1], color, lineWidth);\n  },\n\n  /**\n   * Add a straight line\n   * @param {Array.<Array> | Array.<number>} points\n   * @param {Array.<number> | Array.<Array>} color\n   * @param {number} [lineWidth=1]\n   * @param {number} [startOffset=0]\n   * @param {number} [pointsCount] Default to be amount of points in the first argument\n   */\n  addPolyline: function addPolyline(points, color, lineWidth, startOffset, pointsCount) {\n    if (!points.length) {\n      return;\n    }\n\n    var is2DArray = typeof points[0] !== 'number';\n\n    if (pointsCount == null) {\n      pointsCount = is2DArray ? points.length : points.length / 3;\n    }\n\n    if (pointsCount < 2) {\n      return;\n    }\n\n    if (startOffset == null) {\n      startOffset = 0;\n    }\n\n    if (lineWidth == null) {\n      lineWidth = 1;\n    }\n\n    this._itemVertexOffsets.push(this._vertexOffset);\n\n    var is2DArray = typeof points[0] !== 'number';\n    var notSharingColor = is2DArray ? typeof color[0] !== 'number' : color.length / 4 === pointsCount;\n    var positionAttr = this.attributes.position;\n    var positionPrevAttr = this.attributes.positionPrev;\n    var positionNextAttr = this.attributes.positionNext;\n    var colorAttr = this.attributes.color;\n    var offsetAttr = this.attributes.offset;\n    var indices = this.indices;\n    var vertexOffset = this._vertexOffset;\n    var point;\n    var pointColor;\n    lineWidth = Math.max(lineWidth, 0.01);\n\n    for (var k = startOffset; k < pointsCount; k++) {\n      if (is2DArray) {\n        point = points[k];\n\n        if (notSharingColor) {\n          pointColor = color[k];\n        } else {\n          pointColor = color;\n        }\n      } else {\n        var k3 = k * 3;\n        point = point || [];\n        point[0] = points[k3];\n        point[1] = points[k3 + 1];\n        point[2] = points[k3 + 2];\n\n        if (notSharingColor) {\n          var k4 = k * 4;\n          pointColor = pointColor || [];\n          pointColor[0] = color[k4];\n          pointColor[1] = color[k4 + 1];\n          pointColor[2] = color[k4 + 2];\n          pointColor[3] = color[k4 + 3];\n        } else {\n          pointColor = color;\n        }\n      }\n\n      if (!this.useNativeLine) {\n        if (k < pointsCount - 1) {\n          // Set to next two points\n          positionPrevAttr.set(vertexOffset + 2, point);\n          positionPrevAttr.set(vertexOffset + 3, point);\n        }\n\n        if (k > 0) {\n          // Set to previous two points\n          positionNextAttr.set(vertexOffset - 2, point);\n          positionNextAttr.set(vertexOffset - 1, point);\n        }\n\n        positionAttr.set(vertexOffset, point);\n        positionAttr.set(vertexOffset + 1, point);\n        colorAttr.set(vertexOffset, pointColor);\n        colorAttr.set(vertexOffset + 1, pointColor);\n        offsetAttr.set(vertexOffset, lineWidth / 2);\n        offsetAttr.set(vertexOffset + 1, -lineWidth / 2);\n        vertexOffset += 2;\n      } else {\n        if (k > 1) {\n          positionAttr.copy(vertexOffset, vertexOffset - 1);\n          colorAttr.copy(vertexOffset, vertexOffset - 1);\n          vertexOffset++;\n        }\n      }\n\n      if (!this.useNativeLine) {\n        if (k > 0) {\n          var idx3 = this._triangleOffset * 3;\n          var indices = this.indices; // 0-----2\n          // 1-----3\n          // 0->1->2, 1->3->2\n\n          indices[idx3] = vertexOffset - 4;\n          indices[idx3 + 1] = vertexOffset - 3;\n          indices[idx3 + 2] = vertexOffset - 2;\n          indices[idx3 + 3] = vertexOffset - 3;\n          indices[idx3 + 4] = vertexOffset - 1;\n          indices[idx3 + 5] = vertexOffset - 2;\n          this._triangleOffset += 2;\n        }\n      } else {\n        colorAttr.set(vertexOffset, pointColor);\n        positionAttr.set(vertexOffset, point);\n        vertexOffset++;\n      }\n    }\n\n    if (!this.useNativeLine) {\n      var start = this._vertexOffset;\n      var end = this._vertexOffset + pointsCount * 2;\n      positionPrevAttr.copy(start, start + 2);\n      positionPrevAttr.copy(start + 1, start + 3);\n      positionNextAttr.copy(end - 1, end - 3);\n      positionNextAttr.copy(end - 2, end - 4);\n    }\n\n    this._vertexOffset = vertexOffset;\n    return this._vertexOffset;\n  },\n\n  /**\n   * Set color of single line.\n   */\n  setItemColor: function setItemColor(idx, color) {\n    var startOffset = this._itemVertexOffsets[idx];\n    var endOffset = idx < this._itemVertexOffsets.length - 1 ? this._itemVertexOffsets[idx + 1] : this._vertexOffset;\n\n    for (var i = startOffset; i < endOffset; i++) {\n      this.attributes.color.set(i, color);\n    }\n\n    this.dirty('color');\n  },\n\n  /**\n   * @return {number}\n   */\n  currentTriangleOffset: function currentTriangleOffset() {\n    return this._triangleOffset;\n  },\n\n  /**\n   * @return {number}\n   */\n  currentVertexOffset: function currentVertexOffset() {\n    return this._vertexOffset;\n  }\n});\necharts.util.defaults(LinesGeometry.prototype, dynamicConvertMixin);\nexport default LinesGeometry;","map":{"version":3,"sources":["C:/Users/Administrator/Desktop/data_view/my_project/vue2_app/myapp/node_modules/_echarts-gl@2.0.9@echarts-gl/lib/util/geometry/Lines3D.js"],"names":["Geometry","echarts","dynamicConvertMixin","glmatrix","vec3","sampleLinePoints","LinesGeometry","extend","segmentScale","dynamic","useNativeLine","attributes","position","Attribute","positionPrev","positionNext","prevPositionPrev","prevPosition","prevPositionNext","offset","color","resetOffset","_vertexOffset","_triangleOffset","_itemVertexOffsets","setVertexCount","nVertex","vertexCount","init","indices","Uint16Array","Uint32Array","setTriangleCount","nTriangle","triangleCount","_getCubicCurveApproxStep","p0","p1","p2","p3","len","dist","step","getCubicCurveVertexCount","segCount","Math","ceil","getCubicCurveTriangleCount","getLineVertexCount","getPolylineVertexCount","getLineTriangleCount","getPolylineTriangleCount","points","pointsLen","is2DArray","length","max","addCubicCurve","lineWidth","x0","y0","z0","x1","y1","z1","x2","y2","z2","x3","y3","z3","step2","step3","pre1","pre2","pre4","pre5","tmp1x","tmp1y","tmp1z","tmp2x","tmp2y","tmp2z","fx","fy","fz","dfx","dfy","dfz","ddfx","ddfy","ddfz","dddfx","dddfy","dddfz","t","k","Float32Array","min","addPolyline","addLine","startOffset","pointsCount","push","notSharingColor","positionAttr","positionPrevAttr","positionNextAttr","colorAttr","offsetAttr","vertexOffset","point","pointColor","k3","k4","set","copy","idx3","start","end","setItemColor","idx","endOffset","i","dirty","currentTriangleOffset","currentVertexOffset","util","defaults","prototype"],"mappings":"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","sourcesContent":["/**\n * Lines geometry\n * Use screen space projected lines lineWidth > MAX_LINE_WIDTH\n * https://mattdesl.svbtle.com/drawing-lines-is-hard\n * @module echarts-gl/util/geometry/LinesGeometry\n * @author Yi Shen(http://github.com/pissang)\n */\nimport Geometry from 'claygl/src/Geometry';\nimport * as echarts from 'echarts/lib/echarts';\nimport dynamicConvertMixin from './dynamicConvertMixin';\nimport glmatrix from 'claygl/src/dep/glmatrix';\nvar vec3 = glmatrix.vec3; // var CURVE_RECURSION_LIMIT = 8;\n// var CURVE_COLLINEAR_EPSILON = 40;\n\nvar sampleLinePoints = [[0, 0], [1, 1]];\n/**\n * @constructor\n * @alias module:echarts-gl/util/geometry/LinesGeometry\n * @extends clay.Geometry\n */\n\nvar LinesGeometry = Geometry.extend(function () {\n  return {\n    segmentScale: 1,\n    dynamic: true,\n\n    /**\n     * Need to use mesh to expand lines if lineWidth > MAX_LINE_WIDTH\n     */\n    useNativeLine: true,\n    attributes: {\n      position: new Geometry.Attribute('position', 'float', 3, 'POSITION'),\n      positionPrev: new Geometry.Attribute('positionPrev', 'float', 3),\n      positionNext: new Geometry.Attribute('positionNext', 'float', 3),\n      prevPositionPrev: new Geometry.Attribute('prevPositionPrev', 'float', 3),\n      prevPosition: new Geometry.Attribute('prevPosition', 'float', 3),\n      prevPositionNext: new Geometry.Attribute('prevPositionNext', 'float', 3),\n      offset: new Geometry.Attribute('offset', 'float', 1),\n      color: new Geometry.Attribute('color', 'float', 4, 'COLOR')\n    }\n  };\n},\n/** @lends module: echarts-gl/util/geometry/LinesGeometry.prototype */\n{\n  /**\n   * Reset offset\n   */\n  resetOffset: function () {\n    this._vertexOffset = 0;\n    this._triangleOffset = 0;\n    this._itemVertexOffsets = [];\n  },\n\n  /**\n   * @param {number} nVertex\n   */\n  setVertexCount: function (nVertex) {\n    var attributes = this.attributes;\n\n    if (this.vertexCount !== nVertex) {\n      attributes.position.init(nVertex);\n      attributes.color.init(nVertex);\n\n      if (!this.useNativeLine) {\n        attributes.positionPrev.init(nVertex);\n        attributes.positionNext.init(nVertex);\n        attributes.offset.init(nVertex);\n      }\n\n      if (nVertex > 0xffff) {\n        if (this.indices instanceof Uint16Array) {\n          this.indices = new Uint32Array(this.indices);\n        }\n      } else {\n        if (this.indices instanceof Uint32Array) {\n          this.indices = new Uint16Array(this.indices);\n        }\n      }\n    }\n  },\n\n  /**\n   * @param {number} nTriangle\n   */\n  setTriangleCount: function (nTriangle) {\n    if (this.triangleCount !== nTriangle) {\n      if (nTriangle === 0) {\n        this.indices = null;\n      } else {\n        this.indices = this.vertexCount > 0xffff ? new Uint32Array(nTriangle * 3) : new Uint16Array(nTriangle * 3);\n      }\n    }\n  },\n  _getCubicCurveApproxStep: function (p0, p1, p2, p3) {\n    var len = vec3.dist(p0, p1) + vec3.dist(p2, p1) + vec3.dist(p3, p2);\n    var step = 1 / (len + 1) * this.segmentScale;\n    return step;\n  },\n\n  /**\n   * Get vertex count of cubic curve\n   * @param {Array.<number>} p0\n   * @param {Array.<number>} p1\n   * @param {Array.<number>} p2\n   * @param {Array.<number>} p3\n   * @return number\n   */\n  getCubicCurveVertexCount: function (p0, p1, p2, p3) {\n    var step = this._getCubicCurveApproxStep(p0, p1, p2, p3);\n\n    var segCount = Math.ceil(1 / step);\n\n    if (!this.useNativeLine) {\n      return segCount * 2 + 2;\n    } else {\n      return segCount * 2;\n    }\n  },\n\n  /**\n   * Get face count of cubic curve\n   * @param {Array.<number>} p0\n   * @param {Array.<number>} p1\n   * @param {Array.<number>} p2\n   * @param {Array.<number>} p3\n   * @return number\n   */\n  getCubicCurveTriangleCount: function (p0, p1, p2, p3) {\n    var step = this._getCubicCurveApproxStep(p0, p1, p2, p3);\n\n    var segCount = Math.ceil(1 / step);\n\n    if (!this.useNativeLine) {\n      return segCount * 2;\n    } else {\n      return 0;\n    }\n  },\n\n  /**\n   * Get vertex count of line\n   * @return {number}\n   */\n  getLineVertexCount: function () {\n    return this.getPolylineVertexCount(sampleLinePoints);\n  },\n\n  /**\n   * Get face count of line\n   * @return {number}\n   */\n  getLineTriangleCount: function () {\n    return this.getPolylineTriangleCount(sampleLinePoints);\n  },\n\n  /**\n   * Get how many vertices will polyline take.\n   * @type {number|Array} points Can be a 1d/2d list of points, or a number of points amount.\n   * @return {number}\n   */\n  getPolylineVertexCount: function (points) {\n    var pointsLen;\n\n    if (typeof points === 'number') {\n      pointsLen = points;\n    } else {\n      var is2DArray = typeof points[0] !== 'number';\n      pointsLen = is2DArray ? points.length : points.length / 3;\n    }\n\n    return !this.useNativeLine ? (pointsLen - 1) * 2 + 2 : (pointsLen - 1) * 2;\n  },\n\n  /**\n   * Get how many triangles will polyline take.\n   * @type {number|Array} points Can be a 1d/2d list of points, or a number of points amount.\n   * @return {number}\n   */\n  getPolylineTriangleCount: function (points) {\n    var pointsLen;\n\n    if (typeof points === 'number') {\n      pointsLen = points;\n    } else {\n      var is2DArray = typeof points[0] !== 'number';\n      pointsLen = is2DArray ? points.length : points.length / 3;\n    }\n\n    return !this.useNativeLine ? Math.max(pointsLen - 1, 0) * 2 : 0;\n  },\n\n  /**\n   * Add a cubic curve\n   * @param {Array.<number>} p0\n   * @param {Array.<number>} p1\n   * @param {Array.<number>} p2\n   * @param {Array.<number>} p3\n   * @param {Array.<number>} color\n   * @param {number} [lineWidth=1]\n   */\n  addCubicCurve: function (p0, p1, p2, p3, color, lineWidth) {\n    if (lineWidth == null) {\n      lineWidth = 1;\n    } // incremental interpolation\n    // http://antigrain.com/research/bezier_interpolation/index.html#PAGE_BEZIER_INTERPOLATION\n\n\n    var x0 = p0[0],\n        y0 = p0[1],\n        z0 = p0[2];\n    var x1 = p1[0],\n        y1 = p1[1],\n        z1 = p1[2];\n    var x2 = p2[0],\n        y2 = p2[1],\n        z2 = p2[2];\n    var x3 = p3[0],\n        y3 = p3[1],\n        z3 = p3[2];\n\n    var step = this._getCubicCurveApproxStep(p0, p1, p2, p3);\n\n    var step2 = step * step;\n    var step3 = step2 * step;\n    var pre1 = 3.0 * step;\n    var pre2 = 3.0 * step2;\n    var pre4 = 6.0 * step2;\n    var pre5 = 6.0 * step3;\n    var tmp1x = x0 - x1 * 2.0 + x2;\n    var tmp1y = y0 - y1 * 2.0 + y2;\n    var tmp1z = z0 - z1 * 2.0 + z2;\n    var tmp2x = (x1 - x2) * 3.0 - x0 + x3;\n    var tmp2y = (y1 - y2) * 3.0 - y0 + y3;\n    var tmp2z = (z1 - z2) * 3.0 - z0 + z3;\n    var fx = x0;\n    var fy = y0;\n    var fz = z0;\n    var dfx = (x1 - x0) * pre1 + tmp1x * pre2 + tmp2x * step3;\n    var dfy = (y1 - y0) * pre1 + tmp1y * pre2 + tmp2y * step3;\n    var dfz = (z1 - z0) * pre1 + tmp1z * pre2 + tmp2z * step3;\n    var ddfx = tmp1x * pre4 + tmp2x * pre5;\n    var ddfy = tmp1y * pre4 + tmp2y * pre5;\n    var ddfz = tmp1z * pre4 + tmp2z * pre5;\n    var dddfx = tmp2x * pre5;\n    var dddfy = tmp2y * pre5;\n    var dddfz = tmp2z * pre5;\n    var t = 0;\n    var k = 0;\n    var segCount = Math.ceil(1 / step);\n    var points = new Float32Array((segCount + 1) * 3);\n    var points = [];\n    var offset = 0;\n\n    for (var k = 0; k < segCount + 1; k++) {\n      points[offset++] = fx;\n      points[offset++] = fy;\n      points[offset++] = fz;\n      fx += dfx;\n      fy += dfy;\n      fz += dfz;\n      dfx += ddfx;\n      dfy += ddfy;\n      dfz += ddfz;\n      ddfx += dddfx;\n      ddfy += dddfy;\n      ddfz += dddfz;\n      t += step;\n\n      if (t > 1) {\n        fx = dfx > 0 ? Math.min(fx, x3) : Math.max(fx, x3);\n        fy = dfy > 0 ? Math.min(fy, y3) : Math.max(fy, y3);\n        fz = dfz > 0 ? Math.min(fz, z3) : Math.max(fz, z3);\n      }\n    }\n\n    return this.addPolyline(points, color, lineWidth);\n  },\n\n  /**\n   * Add a straight line\n   * @param {Array.<number>} p0\n   * @param {Array.<number>} p1\n   * @param {Array.<number>} color\n   * @param {number} [lineWidth=1]\n   */\n  addLine: function (p0, p1, color, lineWidth) {\n    return this.addPolyline([p0, p1], color, lineWidth);\n  },\n\n  /**\n   * Add a straight line\n   * @param {Array.<Array> | Array.<number>} points\n   * @param {Array.<number> | Array.<Array>} color\n   * @param {number} [lineWidth=1]\n   * @param {number} [startOffset=0]\n   * @param {number} [pointsCount] Default to be amount of points in the first argument\n   */\n  addPolyline: function (points, color, lineWidth, startOffset, pointsCount) {\n    if (!points.length) {\n      return;\n    }\n\n    var is2DArray = typeof points[0] !== 'number';\n\n    if (pointsCount == null) {\n      pointsCount = is2DArray ? points.length : points.length / 3;\n    }\n\n    if (pointsCount < 2) {\n      return;\n    }\n\n    if (startOffset == null) {\n      startOffset = 0;\n    }\n\n    if (lineWidth == null) {\n      lineWidth = 1;\n    }\n\n    this._itemVertexOffsets.push(this._vertexOffset);\n\n    var is2DArray = typeof points[0] !== 'number';\n    var notSharingColor = is2DArray ? typeof color[0] !== 'number' : color.length / 4 === pointsCount;\n    var positionAttr = this.attributes.position;\n    var positionPrevAttr = this.attributes.positionPrev;\n    var positionNextAttr = this.attributes.positionNext;\n    var colorAttr = this.attributes.color;\n    var offsetAttr = this.attributes.offset;\n    var indices = this.indices;\n    var vertexOffset = this._vertexOffset;\n    var point;\n    var pointColor;\n    lineWidth = Math.max(lineWidth, 0.01);\n\n    for (var k = startOffset; k < pointsCount; k++) {\n      if (is2DArray) {\n        point = points[k];\n\n        if (notSharingColor) {\n          pointColor = color[k];\n        } else {\n          pointColor = color;\n        }\n      } else {\n        var k3 = k * 3;\n        point = point || [];\n        point[0] = points[k3];\n        point[1] = points[k3 + 1];\n        point[2] = points[k3 + 2];\n\n        if (notSharingColor) {\n          var k4 = k * 4;\n          pointColor = pointColor || [];\n          pointColor[0] = color[k4];\n          pointColor[1] = color[k4 + 1];\n          pointColor[2] = color[k4 + 2];\n          pointColor[3] = color[k4 + 3];\n        } else {\n          pointColor = color;\n        }\n      }\n\n      if (!this.useNativeLine) {\n        if (k < pointsCount - 1) {\n          // Set to next two points\n          positionPrevAttr.set(vertexOffset + 2, point);\n          positionPrevAttr.set(vertexOffset + 3, point);\n        }\n\n        if (k > 0) {\n          // Set to previous two points\n          positionNextAttr.set(vertexOffset - 2, point);\n          positionNextAttr.set(vertexOffset - 1, point);\n        }\n\n        positionAttr.set(vertexOffset, point);\n        positionAttr.set(vertexOffset + 1, point);\n        colorAttr.set(vertexOffset, pointColor);\n        colorAttr.set(vertexOffset + 1, pointColor);\n        offsetAttr.set(vertexOffset, lineWidth / 2);\n        offsetAttr.set(vertexOffset + 1, -lineWidth / 2);\n        vertexOffset += 2;\n      } else {\n        if (k > 1) {\n          positionAttr.copy(vertexOffset, vertexOffset - 1);\n          colorAttr.copy(vertexOffset, vertexOffset - 1);\n          vertexOffset++;\n        }\n      }\n\n      if (!this.useNativeLine) {\n        if (k > 0) {\n          var idx3 = this._triangleOffset * 3;\n          var indices = this.indices; // 0-----2\n          // 1-----3\n          // 0->1->2, 1->3->2\n\n          indices[idx3] = vertexOffset - 4;\n          indices[idx3 + 1] = vertexOffset - 3;\n          indices[idx3 + 2] = vertexOffset - 2;\n          indices[idx3 + 3] = vertexOffset - 3;\n          indices[idx3 + 4] = vertexOffset - 1;\n          indices[idx3 + 5] = vertexOffset - 2;\n          this._triangleOffset += 2;\n        }\n      } else {\n        colorAttr.set(vertexOffset, pointColor);\n        positionAttr.set(vertexOffset, point);\n        vertexOffset++;\n      }\n    }\n\n    if (!this.useNativeLine) {\n      var start = this._vertexOffset;\n      var end = this._vertexOffset + pointsCount * 2;\n      positionPrevAttr.copy(start, start + 2);\n      positionPrevAttr.copy(start + 1, start + 3);\n      positionNextAttr.copy(end - 1, end - 3);\n      positionNextAttr.copy(end - 2, end - 4);\n    }\n\n    this._vertexOffset = vertexOffset;\n    return this._vertexOffset;\n  },\n\n  /**\n   * Set color of single line.\n   */\n  setItemColor: function (idx, color) {\n    var startOffset = this._itemVertexOffsets[idx];\n    var endOffset = idx < this._itemVertexOffsets.length - 1 ? this._itemVertexOffsets[idx + 1] : this._vertexOffset;\n\n    for (var i = startOffset; i < endOffset; i++) {\n      this.attributes.color.set(i, color);\n    }\n\n    this.dirty('color');\n  },\n\n  /**\n   * @return {number}\n   */\n  currentTriangleOffset: function () {\n    return this._triangleOffset;\n  },\n\n  /**\n   * @return {number}\n   */\n  currentVertexOffset: function () {\n    return this._vertexOffset;\n  }\n});\necharts.util.defaults(LinesGeometry.prototype, dynamicConvertMixin);\nexport default LinesGeometry;"]},"metadata":{},"sourceType":"module"}