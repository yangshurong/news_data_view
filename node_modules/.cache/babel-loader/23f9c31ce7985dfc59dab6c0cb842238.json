{"ast":null,"code":"import \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.typed-array.float32-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.string.sub.js\";\nimport Base from '../core/Base';\nimport glenum from '../core/glenum';\nimport Vector3 from '../math/Vector3';\nimport BoundingBox from '../math/BoundingBox';\nimport Frustum from '../math/Frustum';\nimport Matrix4 from '../math/Matrix4';\nimport Renderer from '../Renderer';\nimport Shader from '../Shader';\nimport Material from '../Material';\nimport FrameBuffer from '../FrameBuffer';\nimport Texture from '../Texture';\nimport Texture2D from '../Texture2D';\nimport TextureCube from '../TextureCube';\nimport PerspectiveCamera from '../camera/Perspective';\nimport OrthoCamera from '../camera/Orthographic';\nimport Pass from '../compositor/Pass';\nimport TexturePool from '../compositor/TexturePool';\nimport mat4 from '../glmatrix/mat4';\nvar targets = ['px', 'nx', 'py', 'ny', 'pz', 'nz'];\nimport shadowmapEssl from '../shader/source/shadowmap.glsl.js';\nShader['import'](shadowmapEssl);\n\nfunction getDepthMaterialUniform(renderable, depthMaterial, symbol) {\n  if (symbol === 'alphaMap') {\n    return renderable.material.get('diffuseMap');\n  } else if (symbol === 'alphaCutoff') {\n    if (renderable.material.isDefined('fragment', 'ALPHA_TEST') && renderable.material.get('diffuseMap')) {\n      var alphaCutoff = renderable.material.get('alphaCutoff');\n      return alphaCutoff || 0;\n    }\n\n    return 0;\n  } else if (symbol === 'uvRepeat') {\n    return renderable.material.get('uvRepeat');\n  } else if (symbol === 'uvOffset') {\n    return renderable.material.get('uvOffset');\n  } else {\n    return depthMaterial.get(symbol);\n  }\n}\n\nfunction isDepthMaterialChanged(renderable, prevRenderable) {\n  var matA = renderable.material;\n  var matB = prevRenderable.material;\n  return matA.get('diffuseMap') !== matB.get('diffuseMap') || (matA.get('alphaCutoff') || 0) !== (matB.get('alphaCutoff') || 0);\n}\n/**\n * Pass rendering shadow map.\n *\n * @constructor clay.prePass.ShadowMap\n * @extends clay.core.Base\n * @example\n *     var shadowMapPass = new clay.prePass.ShadowMap({\n *         softShadow: clay.prePass.ShadowMap.VSM\n *     });\n *     ...\n *     animation.on('frame', function (frameTime) {\n *         shadowMapPass.render(renderer, scene, camera);\n *         renderer.render(scene, camera);\n *     });\n */\n\n\nvar ShadowMapPass = Base.extend(function () {\n  return (\n    /** @lends clay.prePass.ShadowMap# */\n    {\n      /**\n       * Soft shadow technique.\n       * Can be {@link clay.prePass.ShadowMap.PCF} or {@link clay.prePass.ShadowMap.VSM}\n       * @type {number}\n       */\n      softShadow: ShadowMapPass.PCF,\n\n      /**\n       * Soft shadow blur size\n       * @type {number}\n       */\n      shadowBlur: 1.0,\n      lightFrustumBias: 'auto',\n      kernelPCF: new Float32Array([1, 0, 1, 1, -1, 1, 0, 1, -1, 0, -1, -1, 1, -1, 0, -1]),\n      precision: 'highp',\n      _lastRenderNotCastShadow: false,\n      _frameBuffer: new FrameBuffer(),\n      _textures: {},\n      _shadowMapNumber: {\n        'POINT_LIGHT': 0,\n        'DIRECTIONAL_LIGHT': 0,\n        'SPOT_LIGHT': 0\n      },\n      _depthMaterials: {},\n      _distanceMaterials: {},\n      _receivers: [],\n      _lightsCastShadow: [],\n      _lightCameras: {},\n      _lightMaterials: {},\n      _texturePool: new TexturePool()\n    }\n  );\n}, function () {\n  // Gaussian filter pass for VSM\n  this._gaussianPassH = new Pass({\n    fragment: Shader.source('clay.compositor.gaussian_blur')\n  });\n  this._gaussianPassV = new Pass({\n    fragment: Shader.source('clay.compositor.gaussian_blur')\n  });\n\n  this._gaussianPassH.setUniform('blurSize', this.shadowBlur);\n\n  this._gaussianPassH.setUniform('blurDir', 0.0);\n\n  this._gaussianPassV.setUniform('blurSize', this.shadowBlur);\n\n  this._gaussianPassV.setUniform('blurDir', 1.0);\n\n  this._outputDepthPass = new Pass({\n    fragment: Shader.source('clay.sm.debug_depth')\n  });\n}, {\n  /**\n   * Render scene to shadow textures\n   * @param  {clay.Renderer} renderer\n   * @param  {clay.Scene} scene\n   * @param  {clay.Camera} sceneCamera\n   * @param  {boolean} [notUpdateScene=false]\n   * @memberOf clay.prePass.ShadowMap.prototype\n   */\n  render: function render(renderer, scene, sceneCamera, notUpdateScene) {\n    if (!sceneCamera) {\n      sceneCamera = scene.getMainCamera();\n    }\n\n    this.trigger('beforerender', this, renderer, scene, sceneCamera);\n\n    this._renderShadowPass(renderer, scene, sceneCamera, notUpdateScene);\n\n    this.trigger('afterrender', this, renderer, scene, sceneCamera);\n  },\n\n  /**\n   * Debug rendering of shadow textures\n   * @param  {clay.Renderer} renderer\n   * @param  {number} size\n   * @memberOf clay.prePass.ShadowMap.prototype\n   */\n  renderDebug: function renderDebug(renderer, size) {\n    renderer.saveClear();\n    var viewport = renderer.viewport;\n    var x = 0,\n        y = 0;\n    var width = size || viewport.width / 4;\n    var height = width;\n\n    if (this.softShadow === ShadowMapPass.VSM) {\n      this._outputDepthPass.material.define('fragment', 'USE_VSM');\n    } else {\n      this._outputDepthPass.material.undefine('fragment', 'USE_VSM');\n    }\n\n    for (var name in this._textures) {\n      var texture = this._textures[name];\n      renderer.setViewport(x, y, width * texture.width / texture.height, height);\n\n      this._outputDepthPass.setUniform('depthMap', texture);\n\n      this._outputDepthPass.render(renderer);\n\n      x += width * texture.width / texture.height;\n    }\n\n    renderer.setViewport(viewport);\n    renderer.restoreClear();\n  },\n  _updateReceivers: function _updateReceivers(renderer, mesh) {\n    if (mesh.receiveShadow) {\n      this._receivers.push(mesh);\n\n      mesh.material.set('shadowEnabled', 1);\n      mesh.material.set('pcfKernel', this.kernelPCF);\n    } else {\n      mesh.material.set('shadowEnabled', 0);\n    }\n\n    if (this.softShadow === ShadowMapPass.VSM) {\n      mesh.material.define('fragment', 'USE_VSM');\n      mesh.material.undefine('fragment', 'PCF_KERNEL_SIZE');\n    } else {\n      mesh.material.undefine('fragment', 'USE_VSM');\n      var kernelPCF = this.kernelPCF;\n\n      if (kernelPCF && kernelPCF.length) {\n        mesh.material.define('fragment', 'PCF_KERNEL_SIZE', kernelPCF.length / 2);\n      } else {\n        mesh.material.undefine('fragment', 'PCF_KERNEL_SIZE');\n      }\n    }\n  },\n  _update: function _update(renderer, scene) {\n    var self = this;\n    scene.traverse(function (renderable) {\n      if (renderable.isRenderable()) {\n        self._updateReceivers(renderer, renderable);\n      }\n    });\n\n    for (var i = 0; i < scene.lights.length; i++) {\n      var light = scene.lights[i];\n\n      if (light.castShadow && !light.invisible) {\n        this._lightsCastShadow.push(light);\n      }\n    }\n  },\n  _renderShadowPass: function _renderShadowPass(renderer, scene, sceneCamera, notUpdateScene) {\n    // reset\n    for (var name in this._shadowMapNumber) {\n      this._shadowMapNumber[name] = 0;\n    }\n\n    this._lightsCastShadow.length = 0;\n    this._receivers.length = 0;\n    var _gl = renderer.gl;\n\n    if (!notUpdateScene) {\n      scene.update();\n    }\n\n    if (sceneCamera) {\n      sceneCamera.update();\n    }\n\n    scene.updateLights();\n\n    this._update(renderer, scene); // Needs to update the receivers again if shadows come from 1 to 0.\n\n\n    if (!this._lightsCastShadow.length && this._lastRenderNotCastShadow) {\n      return;\n    }\n\n    this._lastRenderNotCastShadow = this._lightsCastShadow === 0;\n\n    _gl.enable(_gl.DEPTH_TEST);\n\n    _gl.depthMask(true);\n\n    _gl.disable(_gl.BLEND); // Clear with high-z, so the part not rendered will not been shadowed\n    // TODO\n    // TODO restore\n\n\n    _gl.clearColor(1.0, 1.0, 1.0, 1.0); // Shadow uniforms\n\n\n    var spotLightShadowMaps = [];\n    var spotLightMatrices = [];\n    var directionalLightShadowMaps = [];\n    var directionalLightMatrices = [];\n    var shadowCascadeClips = [];\n    var pointLightShadowMaps = [];\n    var dirLightHasCascade; // Create textures for shadow map\n\n    for (var i = 0; i < this._lightsCastShadow.length; i++) {\n      var light = this._lightsCastShadow[i];\n\n      if (light.type === 'DIRECTIONAL_LIGHT') {\n        if (dirLightHasCascade) {\n          console.warn('Only one direectional light supported with shadow cascade');\n          continue;\n        }\n\n        if (light.shadowCascade > 4) {\n          console.warn('Support at most 4 cascade');\n          continue;\n        }\n\n        if (light.shadowCascade > 1) {\n          dirLightHasCascade = light;\n        }\n\n        this.renderDirectionalLightShadow(renderer, scene, sceneCamera, light, shadowCascadeClips, directionalLightMatrices, directionalLightShadowMaps);\n      } else if (light.type === 'SPOT_LIGHT') {\n        this.renderSpotLightShadow(renderer, scene, light, spotLightMatrices, spotLightShadowMaps);\n      } else if (light.type === 'POINT_LIGHT') {\n        this.renderPointLightShadow(renderer, scene, light, pointLightShadowMaps);\n      }\n\n      this._shadowMapNumber[light.type]++;\n    }\n\n    for (var lightType in this._shadowMapNumber) {\n      var number = this._shadowMapNumber[lightType];\n      var key = lightType + '_SHADOWMAP_COUNT';\n\n      for (var i = 0; i < this._receivers.length; i++) {\n        var mesh = this._receivers[i];\n        var material = mesh.material;\n\n        if (material.fragmentDefines[key] !== number) {\n          if (number > 0) {\n            material.define('fragment', key, number);\n          } else if (material.isDefined('fragment', key)) {\n            material.undefine('fragment', key);\n          }\n        }\n      }\n    }\n\n    for (var i = 0; i < this._receivers.length; i++) {\n      var mesh = this._receivers[i];\n      var material = mesh.material;\n\n      if (dirLightHasCascade) {\n        material.define('fragment', 'SHADOW_CASCADE', dirLightHasCascade.shadowCascade);\n      } else {\n        material.undefine('fragment', 'SHADOW_CASCADE');\n      }\n    }\n\n    var shadowUniforms = scene.shadowUniforms;\n\n    function getSize(texture) {\n      return texture.height;\n    }\n\n    if (directionalLightShadowMaps.length > 0) {\n      var directionalLightShadowMapSizes = directionalLightShadowMaps.map(getSize);\n      shadowUniforms.directionalLightShadowMaps = {\n        value: directionalLightShadowMaps,\n        type: 'tv'\n      };\n      shadowUniforms.directionalLightMatrices = {\n        value: directionalLightMatrices,\n        type: 'm4v'\n      };\n      shadowUniforms.directionalLightShadowMapSizes = {\n        value: directionalLightShadowMapSizes,\n        type: '1fv'\n      };\n\n      if (dirLightHasCascade) {\n        var shadowCascadeClipsNear = shadowCascadeClips.slice();\n        var shadowCascadeClipsFar = shadowCascadeClips.slice();\n        shadowCascadeClipsNear.pop();\n        shadowCascadeClipsFar.shift(); // Iterate from far to near\n\n        shadowCascadeClipsNear.reverse();\n        shadowCascadeClipsFar.reverse(); // directionalLightShadowMaps.reverse();\n\n        directionalLightMatrices.reverse();\n        shadowUniforms.shadowCascadeClipsNear = {\n          value: shadowCascadeClipsNear,\n          type: '1fv'\n        };\n        shadowUniforms.shadowCascadeClipsFar = {\n          value: shadowCascadeClipsFar,\n          type: '1fv'\n        };\n      }\n    }\n\n    if (spotLightShadowMaps.length > 0) {\n      var spotLightShadowMapSizes = spotLightShadowMaps.map(getSize);\n      var shadowUniforms = scene.shadowUniforms;\n      shadowUniforms.spotLightShadowMaps = {\n        value: spotLightShadowMaps,\n        type: 'tv'\n      };\n      shadowUniforms.spotLightMatrices = {\n        value: spotLightMatrices,\n        type: 'm4v'\n      };\n      shadowUniforms.spotLightShadowMapSizes = {\n        value: spotLightShadowMapSizes,\n        type: '1fv'\n      };\n    }\n\n    if (pointLightShadowMaps.length > 0) {\n      shadowUniforms.pointLightShadowMaps = {\n        value: pointLightShadowMaps,\n        type: 'tv'\n      };\n    }\n  },\n  renderDirectionalLightShadow: function () {\n    var splitFrustum = new Frustum();\n    var splitProjMatrix = new Matrix4();\n    var cropBBox = new BoundingBox();\n    var cropMatrix = new Matrix4();\n    var lightViewMatrix = new Matrix4();\n    var lightViewProjMatrix = new Matrix4();\n    var lightProjMatrix = new Matrix4();\n    return function (renderer, scene, sceneCamera, light, shadowCascadeClips, directionalLightMatrices, directionalLightShadowMaps) {\n      var defaultShadowMaterial = this._getDepthMaterial(light);\n\n      var passConfig = {\n        getMaterial: function getMaterial(renderable) {\n          return renderable.shadowDepthMaterial || defaultShadowMaterial;\n        },\n        isMaterialChanged: isDepthMaterialChanged,\n        getUniform: getDepthMaterialUniform,\n        ifRender: function ifRender(renderable) {\n          return renderable.castShadow;\n        },\n        sortCompare: Renderer.opaqueSortCompare\n      }; // First frame\n\n      if (!scene.viewBoundingBoxLastFrame.isFinite()) {\n        var boundingBox = scene.getBoundingBox();\n        scene.viewBoundingBoxLastFrame.copy(boundingBox).applyTransform(sceneCamera.viewMatrix);\n      } // Considering moving speed since the bounding box is from last frame\n      // TODO: add a bias\n\n\n      var clippedFar = Math.min(-scene.viewBoundingBoxLastFrame.min.z, sceneCamera.far);\n      var clippedNear = Math.max(-scene.viewBoundingBoxLastFrame.max.z, sceneCamera.near);\n\n      var lightCamera = this._getDirectionalLightCamera(light, scene, sceneCamera);\n\n      var lvpMat4Arr = lightViewProjMatrix.array;\n      lightProjMatrix.copy(lightCamera.projectionMatrix);\n      mat4.invert(lightViewMatrix.array, lightCamera.worldTransform.array);\n      mat4.multiply(lightViewMatrix.array, lightViewMatrix.array, sceneCamera.worldTransform.array);\n      mat4.multiply(lvpMat4Arr, lightProjMatrix.array, lightViewMatrix.array);\n      var clipPlanes = [];\n      var isPerspective = sceneCamera instanceof PerspectiveCamera;\n      var scaleZ = (sceneCamera.near + sceneCamera.far) / (sceneCamera.near - sceneCamera.far);\n      var offsetZ = 2 * sceneCamera.near * sceneCamera.far / (sceneCamera.near - sceneCamera.far);\n\n      for (var i = 0; i <= light.shadowCascade; i++) {\n        var clog = clippedNear * Math.pow(clippedFar / clippedNear, i / light.shadowCascade);\n        var cuni = clippedNear + (clippedFar - clippedNear) * i / light.shadowCascade;\n        var c = clog * light.cascadeSplitLogFactor + cuni * (1 - light.cascadeSplitLogFactor);\n        clipPlanes.push(c);\n        shadowCascadeClips.push(-(-c * scaleZ + offsetZ) / -c);\n      }\n\n      var texture = this._getTexture(light, light.shadowCascade);\n\n      directionalLightShadowMaps.push(texture);\n      var viewport = renderer.viewport;\n      var _gl = renderer.gl;\n\n      this._frameBuffer.attach(texture);\n\n      this._frameBuffer.bind(renderer);\n\n      _gl.clear(_gl.COLOR_BUFFER_BIT | _gl.DEPTH_BUFFER_BIT);\n\n      for (var i = 0; i < light.shadowCascade; i++) {\n        // Get the splitted frustum\n        var nearPlane = clipPlanes[i];\n        var farPlane = clipPlanes[i + 1];\n\n        if (isPerspective) {\n          mat4.perspective(splitProjMatrix.array, sceneCamera.fov / 180 * Math.PI, sceneCamera.aspect, nearPlane, farPlane);\n        } else {\n          mat4.ortho(splitProjMatrix.array, sceneCamera.left, sceneCamera.right, sceneCamera.bottom, sceneCamera.top, nearPlane, farPlane);\n        }\n\n        splitFrustum.setFromProjection(splitProjMatrix);\n        splitFrustum.getTransformedBoundingBox(cropBBox, lightViewMatrix);\n        cropBBox.applyProjection(lightProjMatrix);\n        var _min = cropBBox.min.array;\n        var _max = cropBBox.max.array;\n        _min[0] = Math.max(_min[0], -1);\n        _min[1] = Math.max(_min[1], -1);\n        _max[0] = Math.min(_max[0], 1);\n        _max[1] = Math.min(_max[1], 1);\n        cropMatrix.ortho(_min[0], _max[0], _min[1], _max[1], 1, -1);\n        lightCamera.projectionMatrix.multiplyLeft(cropMatrix);\n        var shadowSize = light.shadowResolution || 512; // Reversed, left to right => far to near\n\n        renderer.setViewport((light.shadowCascade - i - 1) * shadowSize, 0, shadowSize, shadowSize, 1);\n        var renderList = scene.updateRenderList(lightCamera);\n        renderer.renderPass(renderList.opaque, lightCamera, passConfig); // Filter for VSM\n\n        if (this.softShadow === ShadowMapPass.VSM) {\n          this._gaussianFilter(renderer, texture, texture.width);\n        }\n\n        var matrix = new Matrix4();\n        matrix.copy(lightCamera.viewMatrix).multiplyLeft(lightCamera.projectionMatrix);\n        directionalLightMatrices.push(matrix.array);\n        lightCamera.projectionMatrix.copy(lightProjMatrix);\n      }\n\n      this._frameBuffer.unbind(renderer);\n\n      renderer.setViewport(viewport);\n    };\n  }(),\n  renderSpotLightShadow: function renderSpotLightShadow(renderer, scene, light, spotLightMatrices, spotLightShadowMaps) {\n    var texture = this._getTexture(light);\n\n    var lightCamera = this._getSpotLightCamera(light);\n\n    var _gl = renderer.gl;\n\n    this._frameBuffer.attach(texture);\n\n    this._frameBuffer.bind(renderer);\n\n    _gl.clear(_gl.COLOR_BUFFER_BIT | _gl.DEPTH_BUFFER_BIT);\n\n    var defaultShadowMaterial = this._getDepthMaterial(light);\n\n    var passConfig = {\n      getMaterial: function getMaterial(renderable) {\n        return renderable.shadowDepthMaterial || defaultShadowMaterial;\n      },\n      isMaterialChanged: isDepthMaterialChanged,\n      getUniform: getDepthMaterialUniform,\n      ifRender: function ifRender(renderable) {\n        return renderable.castShadow;\n      },\n      sortCompare: Renderer.opaqueSortCompare\n    };\n    var renderList = scene.updateRenderList(lightCamera);\n    renderer.renderPass(renderList.opaque, lightCamera, passConfig);\n\n    this._frameBuffer.unbind(renderer); // Filter for VSM\n\n\n    if (this.softShadow === ShadowMapPass.VSM) {\n      this._gaussianFilter(renderer, texture, texture.width);\n    }\n\n    var matrix = new Matrix4();\n    matrix.copy(lightCamera.worldTransform).invert().multiplyLeft(lightCamera.projectionMatrix);\n    spotLightShadowMaps.push(texture);\n    spotLightMatrices.push(matrix.array);\n  },\n  renderPointLightShadow: function renderPointLightShadow(renderer, scene, light, pointLightShadowMaps) {\n    var texture = this._getTexture(light);\n\n    var _gl = renderer.gl;\n    pointLightShadowMaps.push(texture);\n\n    var defaultShadowMaterial = this._getDepthMaterial(light);\n\n    var passConfig = {\n      getMaterial: function getMaterial(renderable) {\n        return renderable.shadowDepthMaterial || defaultShadowMaterial;\n      },\n      getUniform: getDepthMaterialUniform,\n      sortCompare: Renderer.opaqueSortCompare\n    };\n    var renderListEachSide = {\n      px: [],\n      py: [],\n      pz: [],\n      nx: [],\n      ny: [],\n      nz: []\n    };\n    var bbox = new BoundingBox();\n    var lightWorldPosition = light.getWorldPosition().array;\n    var lightBBox = new BoundingBox();\n    var range = light.range;\n    lightBBox.min.setArray(lightWorldPosition);\n    lightBBox.max.setArray(lightWorldPosition);\n    var extent = new Vector3(range, range, range);\n    lightBBox.max.add(extent);\n    lightBBox.min.sub(extent);\n    var targetsNeedRender = {\n      px: false,\n      py: false,\n      pz: false,\n      nx: false,\n      ny: false,\n      nz: false\n    };\n    scene.traverse(function (renderable) {\n      if (renderable.isRenderable() && renderable.castShadow) {\n        var geometry = renderable.geometry;\n\n        if (!geometry.boundingBox) {\n          for (var i = 0; i < targets.length; i++) {\n            renderListEachSide[targets[i]].push(renderable);\n          }\n\n          return;\n        }\n\n        bbox.transformFrom(geometry.boundingBox, renderable.worldTransform);\n\n        if (!bbox.intersectBoundingBox(lightBBox)) {\n          return;\n        }\n\n        bbox.updateVertices();\n\n        for (var i = 0; i < targets.length; i++) {\n          targetsNeedRender[targets[i]] = false;\n        }\n\n        for (var i = 0; i < 8; i++) {\n          var vtx = bbox.vertices[i];\n          var x = vtx[0] - lightWorldPosition[0];\n          var y = vtx[1] - lightWorldPosition[1];\n          var z = vtx[2] - lightWorldPosition[2];\n          var absx = Math.abs(x);\n          var absy = Math.abs(y);\n          var absz = Math.abs(z);\n\n          if (absx > absy) {\n            if (absx > absz) {\n              targetsNeedRender[x > 0 ? 'px' : 'nx'] = true;\n            } else {\n              targetsNeedRender[z > 0 ? 'pz' : 'nz'] = true;\n            }\n          } else {\n            if (absy > absz) {\n              targetsNeedRender[y > 0 ? 'py' : 'ny'] = true;\n            } else {\n              targetsNeedRender[z > 0 ? 'pz' : 'nz'] = true;\n            }\n          }\n        }\n\n        for (var i = 0; i < targets.length; i++) {\n          if (targetsNeedRender[targets[i]]) {\n            renderListEachSide[targets[i]].push(renderable);\n          }\n        }\n      }\n    });\n\n    for (var i = 0; i < 6; i++) {\n      var target = targets[i];\n\n      var camera = this._getPointLightCamera(light, target);\n\n      this._frameBuffer.attach(texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i);\n\n      this._frameBuffer.bind(renderer);\n\n      _gl.clear(_gl.COLOR_BUFFER_BIT | _gl.DEPTH_BUFFER_BIT);\n\n      renderer.renderPass(renderListEachSide[target], camera, passConfig);\n    }\n\n    this._frameBuffer.unbind(renderer);\n  },\n  _getDepthMaterial: function _getDepthMaterial(light) {\n    var shadowMaterial = this._lightMaterials[light.__uid__];\n    var isPointLight = light.type === 'POINT_LIGHT';\n\n    if (!shadowMaterial) {\n      var shaderPrefix = isPointLight ? 'clay.sm.distance.' : 'clay.sm.depth.';\n      shadowMaterial = new Material({\n        precision: this.precision,\n        shader: new Shader(Shader.source(shaderPrefix + 'vertex'), Shader.source(shaderPrefix + 'fragment'))\n      });\n      this._lightMaterials[light.__uid__] = shadowMaterial;\n    }\n\n    if (light.shadowSlopeScale != null) {\n      shadowMaterial.setUniform('slopeScale', light.shadowSlopeScale);\n    }\n\n    if (light.shadowBias != null) {\n      shadowMaterial.setUniform('bias', light.shadowBias);\n    }\n\n    if (this.softShadow === ShadowMapPass.VSM) {\n      shadowMaterial.define('fragment', 'USE_VSM');\n    } else {\n      shadowMaterial.undefine('fragment', 'USE_VSM');\n    }\n\n    if (isPointLight) {\n      shadowMaterial.set('lightPosition', light.getWorldPosition().array);\n      shadowMaterial.set('range', light.range);\n    }\n\n    return shadowMaterial;\n  },\n  _gaussianFilter: function _gaussianFilter(renderer, texture, size) {\n    var parameter = {\n      width: size,\n      height: size,\n      type: Texture.FLOAT\n    };\n\n    var tmpTexture = this._texturePool.get(parameter);\n\n    this._frameBuffer.attach(tmpTexture);\n\n    this._frameBuffer.bind(renderer);\n\n    this._gaussianPassH.setUniform('texture', texture);\n\n    this._gaussianPassH.setUniform('textureWidth', size);\n\n    this._gaussianPassH.render(renderer);\n\n    this._frameBuffer.attach(texture);\n\n    this._gaussianPassV.setUniform('texture', tmpTexture);\n\n    this._gaussianPassV.setUniform('textureHeight', size);\n\n    this._gaussianPassV.render(renderer);\n\n    this._frameBuffer.unbind(renderer);\n\n    this._texturePool.put(tmpTexture);\n  },\n  _getTexture: function _getTexture(light, cascade) {\n    var key = light.__uid__;\n    var texture = this._textures[key];\n    var resolution = light.shadowResolution || 512;\n    cascade = cascade || 1;\n\n    if (!texture) {\n      if (light.type === 'POINT_LIGHT') {\n        texture = new TextureCube();\n      } else {\n        texture = new Texture2D();\n      } // At most 4 cascade\n      // TODO share with height ?\n\n\n      texture.width = resolution * cascade;\n      texture.height = resolution;\n\n      if (this.softShadow === ShadowMapPass.VSM) {\n        texture.type = Texture.FLOAT;\n        texture.anisotropic = 4;\n      } else {\n        texture.minFilter = glenum.NEAREST;\n        texture.magFilter = glenum.NEAREST;\n        texture.useMipmap = false;\n      }\n\n      this._textures[key] = texture;\n    }\n\n    return texture;\n  },\n  _getPointLightCamera: function _getPointLightCamera(light, target) {\n    if (!this._lightCameras.point) {\n      this._lightCameras.point = {\n        px: new PerspectiveCamera(),\n        nx: new PerspectiveCamera(),\n        py: new PerspectiveCamera(),\n        ny: new PerspectiveCamera(),\n        pz: new PerspectiveCamera(),\n        nz: new PerspectiveCamera()\n      };\n    }\n\n    var camera = this._lightCameras.point[target];\n    camera.far = light.range;\n    camera.fov = 90;\n    camera.position.set(0, 0, 0);\n\n    switch (target) {\n      case 'px':\n        camera.lookAt(Vector3.POSITIVE_X, Vector3.NEGATIVE_Y);\n        break;\n\n      case 'nx':\n        camera.lookAt(Vector3.NEGATIVE_X, Vector3.NEGATIVE_Y);\n        break;\n\n      case 'py':\n        camera.lookAt(Vector3.POSITIVE_Y, Vector3.POSITIVE_Z);\n        break;\n\n      case 'ny':\n        camera.lookAt(Vector3.NEGATIVE_Y, Vector3.NEGATIVE_Z);\n        break;\n\n      case 'pz':\n        camera.lookAt(Vector3.POSITIVE_Z, Vector3.NEGATIVE_Y);\n        break;\n\n      case 'nz':\n        camera.lookAt(Vector3.NEGATIVE_Z, Vector3.NEGATIVE_Y);\n        break;\n    }\n\n    light.getWorldPosition(camera.position);\n    camera.update();\n    return camera;\n  },\n  _getDirectionalLightCamera: function () {\n    var lightViewMatrix = new Matrix4();\n    var sceneViewBoundingBox = new BoundingBox();\n    var lightViewBBox = new BoundingBox(); // Camera of directional light will be adjusted\n    // to contain the view frustum and scene bounding box as tightly as possible\n\n    return function (light, scene, sceneCamera) {\n      if (!this._lightCameras.directional) {\n        this._lightCameras.directional = new OrthoCamera();\n      }\n\n      var camera = this._lightCameras.directional;\n      sceneViewBoundingBox.copy(scene.viewBoundingBoxLastFrame);\n      sceneViewBoundingBox.intersection(sceneCamera.frustum.boundingBox); // Move to the center of frustum(in world space)\n\n      camera.position.copy(sceneViewBoundingBox.min).add(sceneViewBoundingBox.max).scale(0.5).transformMat4(sceneCamera.worldTransform);\n      camera.rotation.copy(light.rotation);\n      camera.scale.copy(light.scale);\n      camera.updateWorldTransform(); // Transform to light view space\n\n      Matrix4.invert(lightViewMatrix, camera.worldTransform);\n      Matrix4.multiply(lightViewMatrix, lightViewMatrix, sceneCamera.worldTransform);\n      lightViewBBox.copy(sceneViewBoundingBox).applyTransform(lightViewMatrix);\n      var min = lightViewBBox.min.array;\n      var max = lightViewBBox.max.array; // Move camera to adjust the near to 0\n\n      camera.position.set((min[0] + max[0]) / 2, (min[1] + max[1]) / 2, max[2]).transformMat4(camera.worldTransform);\n      camera.near = 0;\n      camera.far = -min[2] + max[2]; // Make sure receivers not in the frustum will stil receive the shadow.\n\n      if (isNaN(this.lightFrustumBias)) {\n        camera.far *= 4;\n      } else {\n        camera.far += this.lightFrustumBias;\n      }\n\n      camera.left = min[0];\n      camera.right = max[0];\n      camera.top = max[1];\n      camera.bottom = min[1];\n      camera.update(true);\n      return camera;\n    };\n  }(),\n  _getSpotLightCamera: function _getSpotLightCamera(light) {\n    if (!this._lightCameras.spot) {\n      this._lightCameras.spot = new PerspectiveCamera();\n    }\n\n    var camera = this._lightCameras.spot; // Update properties\n\n    camera.fov = light.penumbraAngle * 2;\n    camera.far = light.range;\n    camera.worldTransform.copy(light.worldTransform);\n    camera.updateProjectionMatrix();\n    mat4.invert(camera.viewMatrix.array, camera.worldTransform.array);\n    return camera;\n  },\n\n  /**\n   * @param  {clay.Renderer|WebGLRenderingContext} [renderer]\n   * @memberOf clay.prePass.ShadowMap.prototype\n   */\n  // PENDING Renderer or WebGLRenderingContext\n  dispose: function dispose(renderer) {\n    var _gl = renderer.gl || renderer;\n\n    if (this._frameBuffer) {\n      this._frameBuffer.dispose(_gl);\n    }\n\n    for (var name in this._textures) {\n      this._textures[name].dispose(_gl);\n    }\n\n    this._texturePool.clear(renderer.gl);\n\n    this._depthMaterials = {};\n    this._distanceMaterials = {};\n    this._textures = {};\n    this._lightCameras = {};\n    this._shadowMapNumber = {\n      'POINT_LIGHT': 0,\n      'DIRECTIONAL_LIGHT': 0,\n      'SPOT_LIGHT': 0\n    };\n    this._meshMaterials = {};\n\n    for (var i = 0; i < this._receivers.length; i++) {\n      var mesh = this._receivers[i]; // Mesh may be disposed\n\n      if (mesh.material) {\n        var material = mesh.material;\n        material.undefine('fragment', 'POINT_LIGHT_SHADOW_COUNT');\n        material.undefine('fragment', 'DIRECTIONAL_LIGHT_SHADOW_COUNT');\n        material.undefine('fragment', 'AMBIENT_LIGHT_SHADOW_COUNT');\n        material.set('shadowEnabled', 0);\n      }\n    }\n\n    this._receivers = [];\n    this._lightsCastShadow = [];\n  }\n});\n/**\n * @name clay.prePass.ShadowMap.VSM\n * @type {number}\n */\n\nShadowMapPass.VSM = 1;\n/**\n * @name clay.prePass.ShadowMap.PCF\n * @type {number}\n */\n\nShadowMapPass.PCF = 2;\nexport default ShadowMapPass;","map":{"version":3,"sources":["C:/Users/Administrator/Desktop/data_view/my_project/vue2_app/myapp/node_modules/_claygl@1.3.0@claygl/src/prePass/ShadowMap.js"],"names":["Base","glenum","Vector3","BoundingBox","Frustum","Matrix4","Renderer","Shader","Material","FrameBuffer","Texture","Texture2D","TextureCube","PerspectiveCamera","OrthoCamera","Pass","TexturePool","mat4","targets","shadowmapEssl","getDepthMaterialUniform","renderable","depthMaterial","symbol","material","get","isDefined","alphaCutoff","isDepthMaterialChanged","prevRenderable","matA","matB","ShadowMapPass","extend","softShadow","PCF","shadowBlur","lightFrustumBias","kernelPCF","Float32Array","precision","_lastRenderNotCastShadow","_frameBuffer","_textures","_shadowMapNumber","_depthMaterials","_distanceMaterials","_receivers","_lightsCastShadow","_lightCameras","_lightMaterials","_texturePool","_gaussianPassH","fragment","source","_gaussianPassV","setUniform","_outputDepthPass","render","renderer","scene","sceneCamera","notUpdateScene","getMainCamera","trigger","_renderShadowPass","renderDebug","size","saveClear","viewport","x","y","width","height","VSM","define","undefine","name","texture","setViewport","restoreClear","_updateReceivers","mesh","receiveShadow","push","set","length","_update","self","traverse","isRenderable","i","lights","light","castShadow","invisible","_gl","gl","update","updateLights","enable","DEPTH_TEST","depthMask","disable","BLEND","clearColor","spotLightShadowMaps","spotLightMatrices","directionalLightShadowMaps","directionalLightMatrices","shadowCascadeClips","pointLightShadowMaps","dirLightHasCascade","type","console","warn","shadowCascade","renderDirectionalLightShadow","renderSpotLightShadow","renderPointLightShadow","lightType","number","key","fragmentDefines","shadowUniforms","getSize","directionalLightShadowMapSizes","map","value","shadowCascadeClipsNear","slice","shadowCascadeClipsFar","pop","shift","reverse","spotLightShadowMapSizes","splitFrustum","splitProjMatrix","cropBBox","cropMatrix","lightViewMatrix","lightViewProjMatrix","lightProjMatrix","defaultShadowMaterial","_getDepthMaterial","passConfig","getMaterial","shadowDepthMaterial","isMaterialChanged","getUniform","ifRender","sortCompare","opaqueSortCompare","viewBoundingBoxLastFrame","isFinite","boundingBox","getBoundingBox","copy","applyTransform","viewMatrix","clippedFar","Math","min","z","far","clippedNear","max","near","lightCamera","_getDirectionalLightCamera","lvpMat4Arr","array","projectionMatrix","invert","worldTransform","multiply","clipPlanes","isPerspective","scaleZ","offsetZ","clog","pow","cuni","c","cascadeSplitLogFactor","_getTexture","attach","bind","clear","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","nearPlane","farPlane","perspective","fov","PI","aspect","ortho","left","right","bottom","top","setFromProjection","getTransformedBoundingBox","applyProjection","_min","_max","multiplyLeft","shadowSize","shadowResolution","renderList","updateRenderList","renderPass","opaque","_gaussianFilter","matrix","unbind","_getSpotLightCamera","renderListEachSide","px","py","pz","nx","ny","nz","bbox","lightWorldPosition","getWorldPosition","lightBBox","range","setArray","extent","add","sub","targetsNeedRender","geometry","transformFrom","intersectBoundingBox","updateVertices","vtx","vertices","absx","abs","absy","absz","target","camera","_getPointLightCamera","COLOR_ATTACHMENT0","TEXTURE_CUBE_MAP_POSITIVE_X","shadowMaterial","__uid__","isPointLight","shaderPrefix","shader","shadowSlopeScale","shadowBias","parameter","FLOAT","tmpTexture","put","cascade","resolution","anisotropic","minFilter","NEAREST","magFilter","useMipmap","point","position","lookAt","POSITIVE_X","NEGATIVE_Y","NEGATIVE_X","POSITIVE_Y","POSITIVE_Z","NEGATIVE_Z","sceneViewBoundingBox","lightViewBBox","directional","intersection","frustum","scale","transformMat4","rotation","updateWorldTransform","isNaN","spot","penumbraAngle","updateProjectionMatrix","dispose","_meshMaterials"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,OAAOA,IAAP,MAAiB,cAAjB;AACA,OAAOC,MAAP,MAAmB,gBAAnB;AACA,OAAOC,OAAP,MAAoB,iBAApB;AACA,OAAOC,WAAP,MAAwB,qBAAxB;AACA,OAAOC,OAAP,MAAoB,iBAApB;AACA,OAAOC,OAAP,MAAoB,iBAApB;AACA,OAAOC,QAAP,MAAqB,aAArB;AACA,OAAOC,MAAP,MAAmB,WAAnB;AACA,OAAOC,QAAP,MAAqB,aAArB;AACA,OAAOC,WAAP,MAAwB,gBAAxB;AACA,OAAOC,OAAP,MAAoB,YAApB;AACA,OAAOC,SAAP,MAAsB,cAAtB;AACA,OAAOC,WAAP,MAAwB,gBAAxB;AACA,OAAOC,iBAAP,MAA8B,uBAA9B;AACA,OAAOC,WAAP,MAAwB,wBAAxB;AAEA,OAAOC,IAAP,MAAiB,oBAAjB;AACA,OAAOC,WAAP,MAAwB,2BAAxB;AAEA,OAAOC,IAAP,MAAiB,kBAAjB;AAEA,IAAIC,OAAO,GAAG,CAAC,IAAD,EAAO,IAAP,EAAa,IAAb,EAAmB,IAAnB,EAAyB,IAAzB,EAA+B,IAA/B,CAAd;AAEA,OAAOC,aAAP,MAA0B,oCAA1B;AACAZ,MAAM,CAAC,QAAD,CAAN,CAAiBY,aAAjB;;AAEA,SAASC,uBAAT,CAAiCC,UAAjC,EAA6CC,aAA7C,EAA4DC,MAA5D,EAAoE;AAChE,MAAIA,MAAM,KAAK,UAAf,EAA2B;AACvB,WAAOF,UAAU,CAACG,QAAX,CAAoBC,GAApB,CAAwB,YAAxB,CAAP;AACH,GAFD,MAGK,IAAIF,MAAM,KAAK,aAAf,EAA8B;AAC/B,QAAIF,UAAU,CAACG,QAAX,CAAoBE,SAApB,CAA8B,UAA9B,EAA0C,YAA1C,KACGL,UAAU,CAACG,QAAX,CAAoBC,GAApB,CAAwB,YAAxB,CADP,EAEE;AACE,UAAIE,WAAW,GAAGN,UAAU,CAACG,QAAX,CAAoBC,GAApB,CAAwB,aAAxB,CAAlB;AACA,aAAOE,WAAW,IAAI,CAAtB;AACH;;AACD,WAAO,CAAP;AACH,GARI,MASA,IAAIJ,MAAM,KAAK,UAAf,EAA2B;AAC5B,WAAOF,UAAU,CAACG,QAAX,CAAoBC,GAApB,CAAwB,UAAxB,CAAP;AACH,GAFI,MAGA,IAAIF,MAAM,KAAK,UAAf,EAA2B;AAC5B,WAAOF,UAAU,CAACG,QAAX,CAAoBC,GAApB,CAAwB,UAAxB,CAAP;AACH,GAFI,MAGA;AACD,WAAOH,aAAa,CAACG,GAAd,CAAkBF,MAAlB,CAAP;AACH;AACJ;;AAED,SAASK,sBAAT,CAAgCP,UAAhC,EAA4CQ,cAA5C,EAA4D;AACxD,MAAIC,IAAI,GAAGT,UAAU,CAACG,QAAtB;AACA,MAAIO,IAAI,GAAGF,cAAc,CAACL,QAA1B;AACA,SAAOM,IAAI,CAACL,GAAL,CAAS,YAAT,MAA2BM,IAAI,CAACN,GAAL,CAAS,YAAT,CAA3B,IACA,CAACK,IAAI,CAACL,GAAL,CAAS,aAAT,KAA2B,CAA5B,OAAoCM,IAAI,CAACN,GAAL,CAAS,aAAT,KAA2B,CAA/D,CADP;AAEH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAIO,aAAa,GAAGhC,IAAI,CAACiC,MAAL,CAAY,YAAY;AACxC;AAAO;AAAsC;AACzC;AACR;AACA;AACA;AACA;AACQC,MAAAA,UAAU,EAAEF,aAAa,CAACG,GANe;;AAQzC;AACR;AACA;AACA;AACQC,MAAAA,UAAU,EAAE,GAZ6B;AAczCC,MAAAA,gBAAgB,EAAE,MAduB;AAgBzCC,MAAAA,SAAS,EAAE,IAAIC,YAAJ,CAAiB,CACxB,CADwB,EACrB,CADqB,EAExB,CAFwB,EAErB,CAFqB,EAGxB,CAAC,CAHuB,EAGpB,CAHoB,EAIxB,CAJwB,EAIrB,CAJqB,EAKxB,CAAC,CALuB,EAKpB,CALoB,EAMxB,CAAC,CANuB,EAMpB,CAAC,CANmB,EAOxB,CAPwB,EAOrB,CAAC,CAPoB,EAQxB,CARwB,EAQrB,CAAC,CARoB,CAAjB,CAhB8B;AA2BzCC,MAAAA,SAAS,EAAE,OA3B8B;AA6BzCC,MAAAA,wBAAwB,EAAE,KA7Be;AA+BzCC,MAAAA,YAAY,EAAE,IAAIjC,WAAJ,EA/B2B;AAiCzCkC,MAAAA,SAAS,EAAE,EAjC8B;AAkCzCC,MAAAA,gBAAgB,EAAE;AACd,uBAAe,CADD;AAEd,6BAAqB,CAFP;AAGd,sBAAc;AAHA,OAlCuB;AAwCzCC,MAAAA,eAAe,EAAE,EAxCwB;AAyCzCC,MAAAA,kBAAkB,EAAE,EAzCqB;AA2CzCC,MAAAA,UAAU,EAAE,EA3C6B;AA4CzCC,MAAAA,iBAAiB,EAAE,EA5CsB;AA8CzCC,MAAAA,aAAa,EAAE,EA9C0B;AA+CzCC,MAAAA,eAAe,EAAE,EA/CwB;AAiDzCC,MAAAA,YAAY,EAAE,IAAInC,WAAJ;AAjD2B;AAA7C;AAmDH,CApDmB,EAoDjB,YAAY;AACX;AACA,OAAKoC,cAAL,GAAsB,IAAIrC,IAAJ,CAAS;AAC3BsC,IAAAA,QAAQ,EAAE9C,MAAM,CAAC+C,MAAP,CAAc,+BAAd;AADiB,GAAT,CAAtB;AAGA,OAAKC,cAAL,GAAsB,IAAIxC,IAAJ,CAAS;AAC3BsC,IAAAA,QAAQ,EAAE9C,MAAM,CAAC+C,MAAP,CAAc,+BAAd;AADiB,GAAT,CAAtB;;AAGA,OAAKF,cAAL,CAAoBI,UAApB,CAA+B,UAA/B,EAA2C,KAAKpB,UAAhD;;AACA,OAAKgB,cAAL,CAAoBI,UAApB,CAA+B,SAA/B,EAA0C,GAA1C;;AACA,OAAKD,cAAL,CAAoBC,UAApB,CAA+B,UAA/B,EAA2C,KAAKpB,UAAhD;;AACA,OAAKmB,cAAL,CAAoBC,UAApB,CAA+B,SAA/B,EAA0C,GAA1C;;AAEA,OAAKC,gBAAL,GAAwB,IAAI1C,IAAJ,CAAS;AAC7BsC,IAAAA,QAAQ,EAAE9C,MAAM,CAAC+C,MAAP,CAAc,qBAAd;AADmB,GAAT,CAAxB;AAGH,CApEmB,EAoEjB;AACC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACII,EAAAA,MAAM,EAAE,gBAAUC,QAAV,EAAoBC,KAApB,EAA2BC,WAA3B,EAAwCC,cAAxC,EAAwD;AAC5D,QAAI,CAACD,WAAL,EAAkB;AACdA,MAAAA,WAAW,GAAGD,KAAK,CAACG,aAAN,EAAd;AACH;;AACD,SAAKC,OAAL,CAAa,cAAb,EAA6B,IAA7B,EAAmCL,QAAnC,EAA6CC,KAA7C,EAAoDC,WAApD;;AACA,SAAKI,iBAAL,CAAuBN,QAAvB,EAAiCC,KAAjC,EAAwCC,WAAxC,EAAqDC,cAArD;;AACA,SAAKE,OAAL,CAAa,aAAb,EAA4B,IAA5B,EAAkCL,QAAlC,EAA4CC,KAA5C,EAAmDC,WAAnD;AACH,GAhBF;;AAkBC;AACJ;AACA;AACA;AACA;AACA;AACIK,EAAAA,WAAW,EAAE,qBAAUP,QAAV,EAAoBQ,IAApB,EAA0B;AACnCR,IAAAA,QAAQ,CAACS,SAAT;AACA,QAAIC,QAAQ,GAAGV,QAAQ,CAACU,QAAxB;AACA,QAAIC,CAAC,GAAG,CAAR;AAAA,QAAWC,CAAC,GAAG,CAAf;AACA,QAAIC,KAAK,GAAGL,IAAI,IAAIE,QAAQ,CAACG,KAAT,GAAiB,CAArC;AACA,QAAIC,MAAM,GAAGD,KAAb;;AACA,QAAI,KAAKtC,UAAL,KAAoBF,aAAa,CAAC0C,GAAtC,EAA2C;AACvC,WAAKjB,gBAAL,CAAsBjC,QAAtB,CAA+BmD,MAA/B,CAAsC,UAAtC,EAAkD,SAAlD;AACH,KAFD,MAGK;AACD,WAAKlB,gBAAL,CAAsBjC,QAAtB,CAA+BoD,QAA/B,CAAwC,UAAxC,EAAoD,SAApD;AACH;;AACD,SAAK,IAAIC,IAAT,IAAiB,KAAKlC,SAAtB,EAAiC;AAC7B,UAAImC,OAAO,GAAG,KAAKnC,SAAL,CAAekC,IAAf,CAAd;AACAlB,MAAAA,QAAQ,CAACoB,WAAT,CAAqBT,CAArB,EAAwBC,CAAxB,EAA2BC,KAAK,GAAGM,OAAO,CAACN,KAAhB,GAAwBM,OAAO,CAACL,MAA3D,EAAmEA,MAAnE;;AACA,WAAKhB,gBAAL,CAAsBD,UAAtB,CAAiC,UAAjC,EAA6CsB,OAA7C;;AACA,WAAKrB,gBAAL,CAAsBC,MAAtB,CAA6BC,QAA7B;;AACAW,MAAAA,CAAC,IAAIE,KAAK,GAAGM,OAAO,CAACN,KAAhB,GAAwBM,OAAO,CAACL,MAArC;AACH;;AACDd,IAAAA,QAAQ,CAACoB,WAAT,CAAqBV,QAArB;AACAV,IAAAA,QAAQ,CAACqB,YAAT;AACH,GA7CF;AA+CCC,EAAAA,gBAAgB,EAAE,0BAAUtB,QAAV,EAAoBuB,IAApB,EAA0B;AACxC,QAAIA,IAAI,CAACC,aAAT,EAAwB;AACpB,WAAKpC,UAAL,CAAgBqC,IAAhB,CAAqBF,IAArB;;AACAA,MAAAA,IAAI,CAAC1D,QAAL,CAAc6D,GAAd,CAAkB,eAAlB,EAAmC,CAAnC;AAEAH,MAAAA,IAAI,CAAC1D,QAAL,CAAc6D,GAAd,CAAkB,WAAlB,EAA+B,KAAK/C,SAApC;AACH,KALD,MAMK;AACD4C,MAAAA,IAAI,CAAC1D,QAAL,CAAc6D,GAAd,CAAkB,eAAlB,EAAmC,CAAnC;AACH;;AAED,QAAI,KAAKnD,UAAL,KAAoBF,aAAa,CAAC0C,GAAtC,EAA2C;AACvCQ,MAAAA,IAAI,CAAC1D,QAAL,CAAcmD,MAAd,CAAqB,UAArB,EAAiC,SAAjC;AACAO,MAAAA,IAAI,CAAC1D,QAAL,CAAcoD,QAAd,CAAuB,UAAvB,EAAmC,iBAAnC;AACH,KAHD,MAIK;AACDM,MAAAA,IAAI,CAAC1D,QAAL,CAAcoD,QAAd,CAAuB,UAAvB,EAAmC,SAAnC;AACA,UAAItC,SAAS,GAAG,KAAKA,SAArB;;AACA,UAAIA,SAAS,IAAIA,SAAS,CAACgD,MAA3B,EAAmC;AAC/BJ,QAAAA,IAAI,CAAC1D,QAAL,CAAcmD,MAAd,CAAqB,UAArB,EAAiC,iBAAjC,EAAoDrC,SAAS,CAACgD,MAAV,GAAmB,CAAvE;AACH,OAFD,MAGK;AACDJ,QAAAA,IAAI,CAAC1D,QAAL,CAAcoD,QAAd,CAAuB,UAAvB,EAAmC,iBAAnC;AACH;AACJ;AACJ,GAxEF;AA0ECW,EAAAA,OAAO,EAAE,iBAAU5B,QAAV,EAAoBC,KAApB,EAA2B;AAChC,QAAI4B,IAAI,GAAG,IAAX;AACA5B,IAAAA,KAAK,CAAC6B,QAAN,CAAe,UAAUpE,UAAV,EAAsB;AACjC,UAAIA,UAAU,CAACqE,YAAX,EAAJ,EAA+B;AAC3BF,QAAAA,IAAI,CAACP,gBAAL,CAAsBtB,QAAtB,EAAgCtC,UAAhC;AACH;AACJ,KAJD;;AAMA,SAAK,IAAIsE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG/B,KAAK,CAACgC,MAAN,CAAaN,MAAjC,EAAyCK,CAAC,EAA1C,EAA8C;AAC1C,UAAIE,KAAK,GAAGjC,KAAK,CAACgC,MAAN,CAAaD,CAAb,CAAZ;;AACA,UAAIE,KAAK,CAACC,UAAN,IAAoB,CAACD,KAAK,CAACE,SAA/B,EAA0C;AACtC,aAAK/C,iBAAL,CAAuBoC,IAAvB,CAA4BS,KAA5B;AACH;AACJ;AACJ,GAxFF;AA0FC5B,EAAAA,iBAAiB,EAAE,2BAAUN,QAAV,EAAoBC,KAApB,EAA2BC,WAA3B,EAAwCC,cAAxC,EAAwD;AACvE;AACA,SAAK,IAAIe,IAAT,IAAiB,KAAKjC,gBAAtB,EAAwC;AACpC,WAAKA,gBAAL,CAAsBiC,IAAtB,IAA8B,CAA9B;AACH;;AACD,SAAK7B,iBAAL,CAAuBsC,MAAvB,GAAgC,CAAhC;AACA,SAAKvC,UAAL,CAAgBuC,MAAhB,GAAyB,CAAzB;AAEA,QAAIU,GAAG,GAAGrC,QAAQ,CAACsC,EAAnB;;AAEA,QAAI,CAACnC,cAAL,EAAqB;AACjBF,MAAAA,KAAK,CAACsC,MAAN;AACH;;AACD,QAAIrC,WAAJ,EAAiB;AACbA,MAAAA,WAAW,CAACqC,MAAZ;AACH;;AAEDtC,IAAAA,KAAK,CAACuC,YAAN;;AACA,SAAKZ,OAAL,CAAa5B,QAAb,EAAuBC,KAAvB,EAlBuE,CAoBvE;;;AACA,QAAI,CAAC,KAAKZ,iBAAL,CAAuBsC,MAAxB,IAAkC,KAAK7C,wBAA3C,EAAqE;AACjE;AACH;;AAED,SAAKA,wBAAL,GAAgC,KAAKO,iBAAL,KAA2B,CAA3D;;AAEAgD,IAAAA,GAAG,CAACI,MAAJ,CAAWJ,GAAG,CAACK,UAAf;;AACAL,IAAAA,GAAG,CAACM,SAAJ,CAAc,IAAd;;AACAN,IAAAA,GAAG,CAACO,OAAJ,CAAYP,GAAG,CAACQ,KAAhB,EA7BuE,CA+BvE;AACA;AACA;;;AACAR,IAAAA,GAAG,CAACS,UAAJ,CAAe,GAAf,EAAoB,GAApB,EAAyB,GAAzB,EAA8B,GAA9B,EAlCuE,CAoCvE;;;AACA,QAAIC,mBAAmB,GAAG,EAA1B;AACA,QAAIC,iBAAiB,GAAG,EAAxB;AACA,QAAIC,0BAA0B,GAAG,EAAjC;AACA,QAAIC,wBAAwB,GAAG,EAA/B;AACA,QAAIC,kBAAkB,GAAG,EAAzB;AACA,QAAIC,oBAAoB,GAAG,EAA3B;AAEA,QAAIC,kBAAJ,CA5CuE,CA6CvE;;AACA,SAAK,IAAIrB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAK3C,iBAAL,CAAuBsC,MAA3C,EAAmDK,CAAC,EAApD,EAAwD;AACpD,UAAIE,KAAK,GAAG,KAAK7C,iBAAL,CAAuB2C,CAAvB,CAAZ;;AACA,UAAIE,KAAK,CAACoB,IAAN,KAAe,mBAAnB,EAAwC;AAEpC,YAAID,kBAAJ,EAAwB;AACpBE,UAAAA,OAAO,CAACC,IAAR,CAAa,2DAAb;AACA;AACH;;AACD,YAAItB,KAAK,CAACuB,aAAN,GAAsB,CAA1B,EAA6B;AACzBF,UAAAA,OAAO,CAACC,IAAR,CAAa,2BAAb;AACA;AACH;;AACD,YAAItB,KAAK,CAACuB,aAAN,GAAsB,CAA1B,EAA6B;AACzBJ,UAAAA,kBAAkB,GAAGnB,KAArB;AACH;;AAED,aAAKwB,4BAAL,CACI1D,QADJ,EAEIC,KAFJ,EAGIC,WAHJ,EAIIgC,KAJJ,EAKIiB,kBALJ,EAMID,wBANJ,EAOID,0BAPJ;AASH,OAvBD,MAwBK,IAAIf,KAAK,CAACoB,IAAN,KAAe,YAAnB,EAAiC;AAClC,aAAKK,qBAAL,CACI3D,QADJ,EAEIC,KAFJ,EAGIiC,KAHJ,EAIIc,iBAJJ,EAKID,mBALJ;AAOH,OARI,MASA,IAAIb,KAAK,CAACoB,IAAN,KAAe,aAAnB,EAAkC;AACnC,aAAKM,sBAAL,CACI5D,QADJ,EAEIC,KAFJ,EAGIiC,KAHJ,EAIIkB,oBAJJ;AAMH;;AAED,WAAKnE,gBAAL,CAAsBiD,KAAK,CAACoB,IAA5B;AACH;;AAED,SAAK,IAAIO,SAAT,IAAsB,KAAK5E,gBAA3B,EAA6C;AACzC,UAAI6E,MAAM,GAAG,KAAK7E,gBAAL,CAAsB4E,SAAtB,CAAb;AACA,UAAIE,GAAG,GAAGF,SAAS,GAAG,kBAAtB;;AACA,WAAK,IAAI7B,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAK5C,UAAL,CAAgBuC,MAApC,EAA4CK,CAAC,EAA7C,EAAiD;AAC7C,YAAIT,IAAI,GAAG,KAAKnC,UAAL,CAAgB4C,CAAhB,CAAX;AACA,YAAInE,QAAQ,GAAG0D,IAAI,CAAC1D,QAApB;;AACA,YAAIA,QAAQ,CAACmG,eAAT,CAAyBD,GAAzB,MAAkCD,MAAtC,EAA8C;AAC1C,cAAIA,MAAM,GAAG,CAAb,EAAgB;AACZjG,YAAAA,QAAQ,CAACmD,MAAT,CAAgB,UAAhB,EAA4B+C,GAA5B,EAAiCD,MAAjC;AACH,WAFD,MAGK,IAAIjG,QAAQ,CAACE,SAAT,CAAmB,UAAnB,EAA+BgG,GAA/B,CAAJ,EAAyC;AAC1ClG,YAAAA,QAAQ,CAACoD,QAAT,CAAkB,UAAlB,EAA8B8C,GAA9B;AACH;AACJ;AACJ;AACJ;;AACD,SAAK,IAAI/B,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAK5C,UAAL,CAAgBuC,MAApC,EAA4CK,CAAC,EAA7C,EAAiD;AAC7C,UAAIT,IAAI,GAAG,KAAKnC,UAAL,CAAgB4C,CAAhB,CAAX;AACA,UAAInE,QAAQ,GAAG0D,IAAI,CAAC1D,QAApB;;AACA,UAAIwF,kBAAJ,EAAwB;AACpBxF,QAAAA,QAAQ,CAACmD,MAAT,CAAgB,UAAhB,EAA4B,gBAA5B,EAA8CqC,kBAAkB,CAACI,aAAjE;AACH,OAFD,MAGK;AACD5F,QAAAA,QAAQ,CAACoD,QAAT,CAAkB,UAAlB,EAA8B,gBAA9B;AACH;AACJ;;AAED,QAAIgD,cAAc,GAAGhE,KAAK,CAACgE,cAA3B;;AAEA,aAASC,OAAT,CAAiB/C,OAAjB,EAA0B;AACtB,aAAOA,OAAO,CAACL,MAAf;AACH;;AACD,QAAImC,0BAA0B,CAACtB,MAA3B,GAAoC,CAAxC,EAA2C;AACvC,UAAIwC,8BAA8B,GAAGlB,0BAA0B,CAACmB,GAA3B,CAA+BF,OAA/B,CAArC;AACAD,MAAAA,cAAc,CAAChB,0BAAf,GAA4C;AAAEoB,QAAAA,KAAK,EAAEpB,0BAAT;AAAqCK,QAAAA,IAAI,EAAE;AAA3C,OAA5C;AACAW,MAAAA,cAAc,CAACf,wBAAf,GAA0C;AAAEmB,QAAAA,KAAK,EAAEnB,wBAAT;AAAmCI,QAAAA,IAAI,EAAE;AAAzC,OAA1C;AACAW,MAAAA,cAAc,CAACE,8BAAf,GAAgD;AAAEE,QAAAA,KAAK,EAAEF,8BAAT;AAAyCb,QAAAA,IAAI,EAAE;AAA/C,OAAhD;;AACA,UAAID,kBAAJ,EAAwB;AACpB,YAAIiB,sBAAsB,GAAGnB,kBAAkB,CAACoB,KAAnB,EAA7B;AACA,YAAIC,qBAAqB,GAAGrB,kBAAkB,CAACoB,KAAnB,EAA5B;AACAD,QAAAA,sBAAsB,CAACG,GAAvB;AACAD,QAAAA,qBAAqB,CAACE,KAAtB,GAJoB,CAMpB;;AACAJ,QAAAA,sBAAsB,CAACK,OAAvB;AACAH,QAAAA,qBAAqB,CAACG,OAAtB,GARoB,CASpB;;AACAzB,QAAAA,wBAAwB,CAACyB,OAAzB;AACAV,QAAAA,cAAc,CAACK,sBAAf,GAAwC;AAAED,UAAAA,KAAK,EAAEC,sBAAT;AAAiChB,UAAAA,IAAI,EAAE;AAAvC,SAAxC;AACAW,QAAAA,cAAc,CAACO,qBAAf,GAAuC;AAAEH,UAAAA,KAAK,EAAEG,qBAAT;AAAgClB,UAAAA,IAAI,EAAE;AAAtC,SAAvC;AACH;AACJ;;AAED,QAAIP,mBAAmB,CAACpB,MAApB,GAA6B,CAAjC,EAAoC;AAChC,UAAIiD,uBAAuB,GAAG7B,mBAAmB,CAACqB,GAApB,CAAwBF,OAAxB,CAA9B;AACA,UAAID,cAAc,GAAGhE,KAAK,CAACgE,cAA3B;AACAA,MAAAA,cAAc,CAAClB,mBAAf,GAAqC;AAAEsB,QAAAA,KAAK,EAAEtB,mBAAT;AAA8BO,QAAAA,IAAI,EAAE;AAApC,OAArC;AACAW,MAAAA,cAAc,CAACjB,iBAAf,GAAmC;AAAEqB,QAAAA,KAAK,EAAErB,iBAAT;AAA4BM,QAAAA,IAAI,EAAE;AAAlC,OAAnC;AACAW,MAAAA,cAAc,CAACW,uBAAf,GAAyC;AAAEP,QAAAA,KAAK,EAAEO,uBAAT;AAAkCtB,QAAAA,IAAI,EAAE;AAAxC,OAAzC;AACH;;AAED,QAAIF,oBAAoB,CAACzB,MAArB,GAA8B,CAAlC,EAAqC;AACjCsC,MAAAA,cAAc,CAACb,oBAAf,GAAsC;AAAEiB,QAAAA,KAAK,EAAEjB,oBAAT;AAA+BE,QAAAA,IAAI,EAAE;AAArC,OAAtC;AACH;AACJ,GAvPF;AAyPCI,EAAAA,4BAA4B,EAAG,YAAY;AAEvC,QAAImB,YAAY,GAAG,IAAIpI,OAAJ,EAAnB;AACA,QAAIqI,eAAe,GAAG,IAAIpI,OAAJ,EAAtB;AACA,QAAIqI,QAAQ,GAAG,IAAIvI,WAAJ,EAAf;AACA,QAAIwI,UAAU,GAAG,IAAItI,OAAJ,EAAjB;AACA,QAAIuI,eAAe,GAAG,IAAIvI,OAAJ,EAAtB;AACA,QAAIwI,mBAAmB,GAAG,IAAIxI,OAAJ,EAA1B;AACA,QAAIyI,eAAe,GAAG,IAAIzI,OAAJ,EAAtB;AAEA,WAAO,UAAUsD,QAAV,EAAoBC,KAApB,EAA2BC,WAA3B,EAAwCgC,KAAxC,EAA+CiB,kBAA/C,EAAmED,wBAAnE,EAA6FD,0BAA7F,EAAyH;AAE5H,UAAImC,qBAAqB,GAAG,KAAKC,iBAAL,CAAuBnD,KAAvB,CAA5B;;AACA,UAAIoD,UAAU,GAAG;AACbC,QAAAA,WAAW,EAAE,qBAAU7H,UAAV,EAAsB;AAC/B,iBAAOA,UAAU,CAAC8H,mBAAX,IAAkCJ,qBAAzC;AACH,SAHY;AAIbK,QAAAA,iBAAiB,EAAExH,sBAJN;AAKbyH,QAAAA,UAAU,EAAEjI,uBALC;AAMbkI,QAAAA,QAAQ,EAAE,kBAAUjI,UAAV,EAAsB;AAC5B,iBAAOA,UAAU,CAACyE,UAAlB;AACH,SARY;AASbyD,QAAAA,WAAW,EAAEjJ,QAAQ,CAACkJ;AATT,OAAjB,CAH4H,CAe5H;;AACA,UAAI,CAAC5F,KAAK,CAAC6F,wBAAN,CAA+BC,QAA/B,EAAL,EAAgD;AAC5C,YAAIC,WAAW,GAAG/F,KAAK,CAACgG,cAAN,EAAlB;AACAhG,QAAAA,KAAK,CAAC6F,wBAAN,CACKI,IADL,CACUF,WADV,EACuBG,cADvB,CACsCjG,WAAW,CAACkG,UADlD;AAEH,OApB2H,CAqB5H;AACA;;;AACA,UAAIC,UAAU,GAAGC,IAAI,CAACC,GAAL,CAAS,CAACtG,KAAK,CAAC6F,wBAAN,CAA+BS,GAA/B,CAAmCC,CAA7C,EAAgDtG,WAAW,CAACuG,GAA5D,CAAjB;AACA,UAAIC,WAAW,GAAGJ,IAAI,CAACK,GAAL,CAAS,CAAC1G,KAAK,CAAC6F,wBAAN,CAA+Ba,GAA/B,CAAmCH,CAA7C,EAAgDtG,WAAW,CAAC0G,IAA5D,CAAlB;;AAEA,UAAIC,WAAW,GAAG,KAAKC,0BAAL,CAAgC5E,KAAhC,EAAuCjC,KAAvC,EAA8CC,WAA9C,CAAlB;;AAEA,UAAI6G,UAAU,GAAG7B,mBAAmB,CAAC8B,KAArC;AACA7B,MAAAA,eAAe,CAACe,IAAhB,CAAqBW,WAAW,CAACI,gBAAjC;AACA3J,MAAAA,IAAI,CAAC4J,MAAL,CAAYjC,eAAe,CAAC+B,KAA5B,EAAmCH,WAAW,CAACM,cAAZ,CAA2BH,KAA9D;AACA1J,MAAAA,IAAI,CAAC8J,QAAL,CAAcnC,eAAe,CAAC+B,KAA9B,EAAqC/B,eAAe,CAAC+B,KAArD,EAA4D9G,WAAW,CAACiH,cAAZ,CAA2BH,KAAvF;AACA1J,MAAAA,IAAI,CAAC8J,QAAL,CAAcL,UAAd,EAA0B5B,eAAe,CAAC6B,KAA1C,EAAiD/B,eAAe,CAAC+B,KAAjE;AAEA,UAAIK,UAAU,GAAG,EAAjB;AACA,UAAIC,aAAa,GAAGpH,WAAW,YAAYhD,iBAA3C;AAEA,UAAIqK,MAAM,GAAG,CAACrH,WAAW,CAAC0G,IAAZ,GAAmB1G,WAAW,CAACuG,GAAhC,KAAwCvG,WAAW,CAAC0G,IAAZ,GAAmB1G,WAAW,CAACuG,GAAvE,CAAb;AACA,UAAIe,OAAO,GAAG,IAAItH,WAAW,CAAC0G,IAAhB,GAAuB1G,WAAW,CAACuG,GAAnC,IAA0CvG,WAAW,CAAC0G,IAAZ,GAAmB1G,WAAW,CAACuG,GAAzE,CAAd;;AACA,WAAK,IAAIzE,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAIE,KAAK,CAACuB,aAA3B,EAA0CzB,CAAC,EAA3C,EAA+C;AAC3C,YAAIyF,IAAI,GAAGf,WAAW,GAAGJ,IAAI,CAACoB,GAAL,CAASrB,UAAU,GAAGK,WAAtB,EAAmC1E,CAAC,GAAGE,KAAK,CAACuB,aAA7C,CAAzB;AACA,YAAIkE,IAAI,GAAGjB,WAAW,GAAG,CAACL,UAAU,GAAGK,WAAd,IAA6B1E,CAA7B,GAAiCE,KAAK,CAACuB,aAAhE;AACA,YAAImE,CAAC,GAAGH,IAAI,GAAGvF,KAAK,CAAC2F,qBAAb,GAAqCF,IAAI,IAAI,IAAIzF,KAAK,CAAC2F,qBAAd,CAAjD;AACAR,QAAAA,UAAU,CAAC5F,IAAX,CAAgBmG,CAAhB;AACAzE,QAAAA,kBAAkB,CAAC1B,IAAnB,CAAwB,EAAE,CAACmG,CAAD,GAAKL,MAAL,GAAcC,OAAhB,IAA2B,CAACI,CAApD;AACH;;AACD,UAAIzG,OAAO,GAAG,KAAK2G,WAAL,CAAiB5F,KAAjB,EAAwBA,KAAK,CAACuB,aAA9B,CAAd;;AACAR,MAAAA,0BAA0B,CAACxB,IAA3B,CAAgCN,OAAhC;AAEA,UAAIT,QAAQ,GAAGV,QAAQ,CAACU,QAAxB;AAEA,UAAI2B,GAAG,GAAGrC,QAAQ,CAACsC,EAAnB;;AACA,WAAKvD,YAAL,CAAkBgJ,MAAlB,CAAyB5G,OAAzB;;AACA,WAAKpC,YAAL,CAAkBiJ,IAAlB,CAAuBhI,QAAvB;;AACAqC,MAAAA,GAAG,CAAC4F,KAAJ,CAAU5F,GAAG,CAAC6F,gBAAJ,GAAuB7F,GAAG,CAAC8F,gBAArC;;AAEA,WAAK,IAAInG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGE,KAAK,CAACuB,aAA1B,EAAyCzB,CAAC,EAA1C,EAA8C;AAC1C;AACA,YAAIoG,SAAS,GAAGf,UAAU,CAACrF,CAAD,CAA1B;AACA,YAAIqG,QAAQ,GAAGhB,UAAU,CAACrF,CAAC,GAAG,CAAL,CAAzB;;AACA,YAAIsF,aAAJ,EAAmB;AACfhK,UAAAA,IAAI,CAACgL,WAAL,CAAiBxD,eAAe,CAACkC,KAAjC,EAAwC9G,WAAW,CAACqI,GAAZ,GAAkB,GAAlB,GAAwBjC,IAAI,CAACkC,EAArE,EAAyEtI,WAAW,CAACuI,MAArF,EAA6FL,SAA7F,EAAwGC,QAAxG;AACH,SAFD,MAGK;AACD/K,UAAAA,IAAI,CAACoL,KAAL,CACI5D,eAAe,CAACkC,KADpB,EAEI9G,WAAW,CAACyI,IAFhB,EAEsBzI,WAAW,CAAC0I,KAFlC,EAEyC1I,WAAW,CAAC2I,MAFrD,EAE6D3I,WAAW,CAAC4I,GAFzE,EAGIV,SAHJ,EAGeC,QAHf;AAKH;;AACDxD,QAAAA,YAAY,CAACkE,iBAAb,CAA+BjE,eAA/B;AACAD,QAAAA,YAAY,CAACmE,yBAAb,CAAuCjE,QAAvC,EAAiDE,eAAjD;AACAF,QAAAA,QAAQ,CAACkE,eAAT,CAAyB9D,eAAzB;AACA,YAAI+D,IAAI,GAAGnE,QAAQ,CAACwB,GAAT,CAAaS,KAAxB;AACA,YAAImC,IAAI,GAAGpE,QAAQ,CAAC4B,GAAT,CAAaK,KAAxB;AACAkC,QAAAA,IAAI,CAAC,CAAD,CAAJ,GAAU5C,IAAI,CAACK,GAAL,CAASuC,IAAI,CAAC,CAAD,CAAb,EAAkB,CAAC,CAAnB,CAAV;AACAA,QAAAA,IAAI,CAAC,CAAD,CAAJ,GAAU5C,IAAI,CAACK,GAAL,CAASuC,IAAI,CAAC,CAAD,CAAb,EAAkB,CAAC,CAAnB,CAAV;AACAC,QAAAA,IAAI,CAAC,CAAD,CAAJ,GAAU7C,IAAI,CAACC,GAAL,CAAS4C,IAAI,CAAC,CAAD,CAAb,EAAkB,CAAlB,CAAV;AACAA,QAAAA,IAAI,CAAC,CAAD,CAAJ,GAAU7C,IAAI,CAACC,GAAL,CAAS4C,IAAI,CAAC,CAAD,CAAb,EAAkB,CAAlB,CAAV;AACAnE,QAAAA,UAAU,CAAC0D,KAAX,CAAiBQ,IAAI,CAAC,CAAD,CAArB,EAA0BC,IAAI,CAAC,CAAD,CAA9B,EAAmCD,IAAI,CAAC,CAAD,CAAvC,EAA4CC,IAAI,CAAC,CAAD,CAAhD,EAAqD,CAArD,EAAwD,CAAC,CAAzD;AACAtC,QAAAA,WAAW,CAACI,gBAAZ,CAA6BmC,YAA7B,CAA0CpE,UAA1C;AAEA,YAAIqE,UAAU,GAAGnH,KAAK,CAACoH,gBAAN,IAA0B,GAA3C,CA1B0C,CA4B1C;;AACAtJ,QAAAA,QAAQ,CAACoB,WAAT,CAAqB,CAACc,KAAK,CAACuB,aAAN,GAAsBzB,CAAtB,GAA0B,CAA3B,IAAgCqH,UAArD,EAAiE,CAAjE,EAAoEA,UAApE,EAAgFA,UAAhF,EAA4F,CAA5F;AAEA,YAAIE,UAAU,GAAGtJ,KAAK,CAACuJ,gBAAN,CAAuB3C,WAAvB,CAAjB;AACA7G,QAAAA,QAAQ,CAACyJ,UAAT,CAAoBF,UAAU,CAACG,MAA/B,EAAuC7C,WAAvC,EAAoDvB,UAApD,EAhC0C,CAkC1C;;AACA,YAAI,KAAK/G,UAAL,KAAoBF,aAAa,CAAC0C,GAAtC,EAA2C;AACvC,eAAK4I,eAAL,CAAqB3J,QAArB,EAA+BmB,OAA/B,EAAwCA,OAAO,CAACN,KAAhD;AACH;;AAED,YAAI+I,MAAM,GAAG,IAAIlN,OAAJ,EAAb;AACAkN,QAAAA,MAAM,CAAC1D,IAAP,CAAYW,WAAW,CAACT,UAAxB,EACKgD,YADL,CACkBvC,WAAW,CAACI,gBAD9B;AAGA/D,QAAAA,wBAAwB,CAACzB,IAAzB,CAA8BmI,MAAM,CAAC5C,KAArC;AAEAH,QAAAA,WAAW,CAACI,gBAAZ,CAA6Bf,IAA7B,CAAkCf,eAAlC;AACH;;AAED,WAAKpG,YAAL,CAAkB8K,MAAlB,CAAyB7J,QAAzB;;AAEAA,MAAAA,QAAQ,CAACoB,WAAT,CAAqBV,QAArB;AACH,KA3GD;AA4GH,GAtH6B,EAzP/B;AAiXCiD,EAAAA,qBAAqB,EAAE,+BAAU3D,QAAV,EAAoBC,KAApB,EAA2BiC,KAA3B,EAAkCc,iBAAlC,EAAqDD,mBAArD,EAA0E;AAE7F,QAAI5B,OAAO,GAAG,KAAK2G,WAAL,CAAiB5F,KAAjB,CAAd;;AACA,QAAI2E,WAAW,GAAG,KAAKiD,mBAAL,CAAyB5H,KAAzB,CAAlB;;AACA,QAAIG,GAAG,GAAGrC,QAAQ,CAACsC,EAAnB;;AAEA,SAAKvD,YAAL,CAAkBgJ,MAAlB,CAAyB5G,OAAzB;;AACA,SAAKpC,YAAL,CAAkBiJ,IAAlB,CAAuBhI,QAAvB;;AAEAqC,IAAAA,GAAG,CAAC4F,KAAJ,CAAU5F,GAAG,CAAC6F,gBAAJ,GAAuB7F,GAAG,CAAC8F,gBAArC;;AAEA,QAAI/C,qBAAqB,GAAG,KAAKC,iBAAL,CAAuBnD,KAAvB,CAA5B;;AACA,QAAIoD,UAAU,GAAG;AACbC,MAAAA,WAAW,EAAE,qBAAU7H,UAAV,EAAsB;AAC/B,eAAOA,UAAU,CAAC8H,mBAAX,IAAkCJ,qBAAzC;AACH,OAHY;AAIbK,MAAAA,iBAAiB,EAAExH,sBAJN;AAKbyH,MAAAA,UAAU,EAAEjI,uBALC;AAMbkI,MAAAA,QAAQ,EAAE,kBAAUjI,UAAV,EAAsB;AAC5B,eAAOA,UAAU,CAACyE,UAAlB;AACH,OARY;AASbyD,MAAAA,WAAW,EAAEjJ,QAAQ,CAACkJ;AATT,KAAjB;AAYA,QAAI0D,UAAU,GAAGtJ,KAAK,CAACuJ,gBAAN,CAAuB3C,WAAvB,CAAjB;AACA7G,IAAAA,QAAQ,CAACyJ,UAAT,CAAoBF,UAAU,CAACG,MAA/B,EAAuC7C,WAAvC,EAAoDvB,UAApD;;AAEA,SAAKvG,YAAL,CAAkB8K,MAAlB,CAAyB7J,QAAzB,EA3B6F,CA6B7F;;;AACA,QAAI,KAAKzB,UAAL,KAAoBF,aAAa,CAAC0C,GAAtC,EAA2C;AACvC,WAAK4I,eAAL,CAAqB3J,QAArB,EAA+BmB,OAA/B,EAAwCA,OAAO,CAACN,KAAhD;AACH;;AAED,QAAI+I,MAAM,GAAG,IAAIlN,OAAJ,EAAb;AACAkN,IAAAA,MAAM,CAAC1D,IAAP,CAAYW,WAAW,CAACM,cAAxB,EACKD,MADL,GAEKkC,YAFL,CAEkBvC,WAAW,CAACI,gBAF9B;AAIAlE,IAAAA,mBAAmB,CAACtB,IAApB,CAAyBN,OAAzB;AACA6B,IAAAA,iBAAiB,CAACvB,IAAlB,CAAuBmI,MAAM,CAAC5C,KAA9B;AACH,GA1ZF;AA4ZCpD,EAAAA,sBAAsB,EAAE,gCAAU5D,QAAV,EAAoBC,KAApB,EAA2BiC,KAA3B,EAAkCkB,oBAAlC,EAAwD;AAC5E,QAAIjC,OAAO,GAAG,KAAK2G,WAAL,CAAiB5F,KAAjB,CAAd;;AACA,QAAIG,GAAG,GAAGrC,QAAQ,CAACsC,EAAnB;AACAc,IAAAA,oBAAoB,CAAC3B,IAArB,CAA0BN,OAA1B;;AAEA,QAAIiE,qBAAqB,GAAG,KAAKC,iBAAL,CAAuBnD,KAAvB,CAA5B;;AACA,QAAIoD,UAAU,GAAG;AACbC,MAAAA,WAAW,EAAE,qBAAU7H,UAAV,EAAsB;AAC/B,eAAOA,UAAU,CAAC8H,mBAAX,IAAkCJ,qBAAzC;AACH,OAHY;AAIbM,MAAAA,UAAU,EAAEjI,uBAJC;AAKbmI,MAAAA,WAAW,EAAEjJ,QAAQ,CAACkJ;AALT,KAAjB;AAQA,QAAIkE,kBAAkB,GAAG;AACrBC,MAAAA,EAAE,EAAE,EADiB;AACbC,MAAAA,EAAE,EAAE,EADS;AACLC,MAAAA,EAAE,EAAE,EADC;AACGC,MAAAA,EAAE,EAAE,EADP;AACWC,MAAAA,EAAE,EAAE,EADf;AACmBC,MAAAA,EAAE,EAAE;AADvB,KAAzB;AAGA,QAAIC,IAAI,GAAG,IAAI9N,WAAJ,EAAX;AACA,QAAI+N,kBAAkB,GAAGrI,KAAK,CAACsI,gBAAN,GAAyBxD,KAAlD;AACA,QAAIyD,SAAS,GAAG,IAAIjO,WAAJ,EAAhB;AACA,QAAIkO,KAAK,GAAGxI,KAAK,CAACwI,KAAlB;AACAD,IAAAA,SAAS,CAAClE,GAAV,CAAcoE,QAAd,CAAuBJ,kBAAvB;AACAE,IAAAA,SAAS,CAAC9D,GAAV,CAAcgE,QAAd,CAAuBJ,kBAAvB;AACA,QAAIK,MAAM,GAAG,IAAIrO,OAAJ,CAAYmO,KAAZ,EAAmBA,KAAnB,EAA0BA,KAA1B,CAAb;AACAD,IAAAA,SAAS,CAAC9D,GAAV,CAAckE,GAAd,CAAkBD,MAAlB;AACAH,IAAAA,SAAS,CAAClE,GAAV,CAAcuE,GAAd,CAAkBF,MAAlB;AAEA,QAAIG,iBAAiB,GAAG;AAAEf,MAAAA,EAAE,EAAE,KAAN;AAAaC,MAAAA,EAAE,EAAE,KAAjB;AAAwBC,MAAAA,EAAE,EAAE,KAA5B;AAAmCC,MAAAA,EAAE,EAAE,KAAvC;AAA8CC,MAAAA,EAAE,EAAE,KAAlD;AAAyDC,MAAAA,EAAE,EAAE;AAA7D,KAAxB;AACApK,IAAAA,KAAK,CAAC6B,QAAN,CAAe,UAAUpE,UAAV,EAAsB;AACjC,UAAIA,UAAU,CAACqE,YAAX,MAA6BrE,UAAU,CAACyE,UAA5C,EAAwD;AACpD,YAAI6I,QAAQ,GAAGtN,UAAU,CAACsN,QAA1B;;AACA,YAAI,CAACA,QAAQ,CAAChF,WAAd,EAA2B;AACvB,eAAK,IAAIhE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGzE,OAAO,CAACoE,MAA5B,EAAoCK,CAAC,EAArC,EAAyC;AACrC+H,YAAAA,kBAAkB,CAACxM,OAAO,CAACyE,CAAD,CAAR,CAAlB,CAA+BP,IAA/B,CAAoC/D,UAApC;AACH;;AACD;AACH;;AACD4M,QAAAA,IAAI,CAACW,aAAL,CAAmBD,QAAQ,CAAChF,WAA5B,EAAyCtI,UAAU,CAACyJ,cAApD;;AACA,YAAI,CAACmD,IAAI,CAACY,oBAAL,CAA0BT,SAA1B,CAAL,EAA2C;AACvC;AACH;;AAEDH,QAAAA,IAAI,CAACa,cAAL;;AACA,aAAK,IAAInJ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGzE,OAAO,CAACoE,MAA5B,EAAoCK,CAAC,EAArC,EAAyC;AACrC+I,UAAAA,iBAAiB,CAACxN,OAAO,CAACyE,CAAD,CAAR,CAAjB,GAAgC,KAAhC;AACH;;AACD,aAAK,IAAIA,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,CAApB,EAAuBA,CAAC,EAAxB,EAA4B;AACxB,cAAIoJ,GAAG,GAAGd,IAAI,CAACe,QAAL,CAAcrJ,CAAd,CAAV;AACA,cAAIrB,CAAC,GAAGyK,GAAG,CAAC,CAAD,CAAH,GAASb,kBAAkB,CAAC,CAAD,CAAnC;AACA,cAAI3J,CAAC,GAAGwK,GAAG,CAAC,CAAD,CAAH,GAASb,kBAAkB,CAAC,CAAD,CAAnC;AACA,cAAI/D,CAAC,GAAG4E,GAAG,CAAC,CAAD,CAAH,GAASb,kBAAkB,CAAC,CAAD,CAAnC;AACA,cAAIe,IAAI,GAAGhF,IAAI,CAACiF,GAAL,CAAS5K,CAAT,CAAX;AACA,cAAI6K,IAAI,GAAGlF,IAAI,CAACiF,GAAL,CAAS3K,CAAT,CAAX;AACA,cAAI6K,IAAI,GAAGnF,IAAI,CAACiF,GAAL,CAAS/E,CAAT,CAAX;;AACA,cAAI8E,IAAI,GAAGE,IAAX,EAAiB;AACb,gBAAIF,IAAI,GAAGG,IAAX,EAAiB;AACbV,cAAAA,iBAAiB,CAACpK,CAAC,GAAG,CAAJ,GAAQ,IAAR,GAAe,IAAhB,CAAjB,GAAyC,IAAzC;AACH,aAFD,MAGK;AACDoK,cAAAA,iBAAiB,CAACvE,CAAC,GAAG,CAAJ,GAAQ,IAAR,GAAe,IAAhB,CAAjB,GAAyC,IAAzC;AACH;AACJ,WAPD,MAQK;AACD,gBAAIgF,IAAI,GAAGC,IAAX,EAAiB;AACbV,cAAAA,iBAAiB,CAACnK,CAAC,GAAG,CAAJ,GAAQ,IAAR,GAAe,IAAhB,CAAjB,GAAyC,IAAzC;AACH,aAFD,MAGK;AACDmK,cAAAA,iBAAiB,CAACvE,CAAC,GAAG,CAAJ,GAAQ,IAAR,GAAe,IAAhB,CAAjB,GAAyC,IAAzC;AACH;AACJ;AACJ;;AACD,aAAK,IAAIxE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGzE,OAAO,CAACoE,MAA5B,EAAoCK,CAAC,EAArC,EAAyC;AACrC,cAAI+I,iBAAiB,CAACxN,OAAO,CAACyE,CAAD,CAAR,CAArB,EAAmC;AAC/B+H,YAAAA,kBAAkB,CAACxM,OAAO,CAACyE,CAAD,CAAR,CAAlB,CAA+BP,IAA/B,CAAoC/D,UAApC;AACH;AACJ;AACJ;AACJ,KAjDD;;AAmDA,SAAK,IAAIsE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,CAApB,EAAuBA,CAAC,EAAxB,EAA4B;AACxB,UAAI0J,MAAM,GAAGnO,OAAO,CAACyE,CAAD,CAApB;;AACA,UAAI2J,MAAM,GAAG,KAAKC,oBAAL,CAA0B1J,KAA1B,EAAiCwJ,MAAjC,CAAb;;AAEA,WAAK3M,YAAL,CAAkBgJ,MAAlB,CAAyB5G,OAAzB,EAAkCkB,GAAG,CAACwJ,iBAAtC,EAAyDxJ,GAAG,CAACyJ,2BAAJ,GAAkC9J,CAA3F;;AACA,WAAKjD,YAAL,CAAkBiJ,IAAlB,CAAuBhI,QAAvB;;AACAqC,MAAAA,GAAG,CAAC4F,KAAJ,CAAU5F,GAAG,CAAC6F,gBAAJ,GAAuB7F,GAAG,CAAC8F,gBAArC;;AAEAnI,MAAAA,QAAQ,CAACyJ,UAAT,CAAoBM,kBAAkB,CAAC2B,MAAD,CAAtC,EAAgDC,MAAhD,EAAwDrG,UAAxD;AACH;;AAED,SAAKvG,YAAL,CAAkB8K,MAAlB,CAAyB7J,QAAzB;AACH,GAvfF;AAyfCqF,EAAAA,iBAAiB,EAAE,2BAAUnD,KAAV,EAAiB;AAChC,QAAI6J,cAAc,GAAG,KAAKxM,eAAL,CAAqB2C,KAAK,CAAC8J,OAA3B,CAArB;AACA,QAAIC,YAAY,GAAG/J,KAAK,CAACoB,IAAN,KAAe,aAAlC;;AACA,QAAI,CAACyI,cAAL,EAAqB;AACjB,UAAIG,YAAY,GAAGD,YAAY,GAAG,mBAAH,GAAyB,gBAAxD;AACAF,MAAAA,cAAc,GAAG,IAAIlP,QAAJ,CAAa;AAC1BgC,QAAAA,SAAS,EAAE,KAAKA,SADU;AAE1BsN,QAAAA,MAAM,EAAE,IAAIvP,MAAJ,CAAWA,MAAM,CAAC+C,MAAP,CAAcuM,YAAY,GAAG,QAA7B,CAAX,EAAmDtP,MAAM,CAAC+C,MAAP,CAAcuM,YAAY,GAAG,UAA7B,CAAnD;AAFkB,OAAb,CAAjB;AAKA,WAAK3M,eAAL,CAAqB2C,KAAK,CAAC8J,OAA3B,IAAsCD,cAAtC;AACH;;AACD,QAAI7J,KAAK,CAACkK,gBAAN,IAA0B,IAA9B,EAAoC;AAChCL,MAAAA,cAAc,CAAClM,UAAf,CAA0B,YAA1B,EAAwCqC,KAAK,CAACkK,gBAA9C;AACH;;AACD,QAAIlK,KAAK,CAACmK,UAAN,IAAoB,IAAxB,EAA8B;AAC1BN,MAAAA,cAAc,CAAClM,UAAf,CAA0B,MAA1B,EAAkCqC,KAAK,CAACmK,UAAxC;AACH;;AACD,QAAI,KAAK9N,UAAL,KAAoBF,aAAa,CAAC0C,GAAtC,EAA2C;AACvCgL,MAAAA,cAAc,CAAC/K,MAAf,CAAsB,UAAtB,EAAkC,SAAlC;AACH,KAFD,MAGK;AACD+K,MAAAA,cAAc,CAAC9K,QAAf,CAAwB,UAAxB,EAAoC,SAApC;AACH;;AAED,QAAIgL,YAAJ,EAAkB;AACdF,MAAAA,cAAc,CAACrK,GAAf,CAAmB,eAAnB,EAAoCQ,KAAK,CAACsI,gBAAN,GAAyBxD,KAA7D;AACA+E,MAAAA,cAAc,CAACrK,GAAf,CAAmB,OAAnB,EAA4BQ,KAAK,CAACwI,KAAlC;AACH;;AAED,WAAOqB,cAAP;AACH,GAxhBF;AA0hBCpC,EAAAA,eAAe,EAAE,yBAAU3J,QAAV,EAAoBmB,OAApB,EAA6BX,IAA7B,EAAmC;AAChD,QAAI8L,SAAS,GAAG;AACZzL,MAAAA,KAAK,EAAEL,IADK;AAEZM,MAAAA,MAAM,EAAEN,IAFI;AAGZ8C,MAAAA,IAAI,EAAEvG,OAAO,CAACwP;AAHF,KAAhB;;AAKA,QAAIC,UAAU,GAAG,KAAKhN,YAAL,CAAkB1B,GAAlB,CAAsBwO,SAAtB,CAAjB;;AAEA,SAAKvN,YAAL,CAAkBgJ,MAAlB,CAAyByE,UAAzB;;AACA,SAAKzN,YAAL,CAAkBiJ,IAAlB,CAAuBhI,QAAvB;;AACA,SAAKP,cAAL,CAAoBI,UAApB,CAA+B,SAA/B,EAA0CsB,OAA1C;;AACA,SAAK1B,cAAL,CAAoBI,UAApB,CAA+B,cAA/B,EAA+CW,IAA/C;;AACA,SAAKf,cAAL,CAAoBM,MAApB,CAA2BC,QAA3B;;AAEA,SAAKjB,YAAL,CAAkBgJ,MAAlB,CAAyB5G,OAAzB;;AACA,SAAKvB,cAAL,CAAoBC,UAApB,CAA+B,SAA/B,EAA0C2M,UAA1C;;AACA,SAAK5M,cAAL,CAAoBC,UAApB,CAA+B,eAA/B,EAAgDW,IAAhD;;AACA,SAAKZ,cAAL,CAAoBG,MAApB,CAA2BC,QAA3B;;AACA,SAAKjB,YAAL,CAAkB8K,MAAlB,CAAyB7J,QAAzB;;AAEA,SAAKR,YAAL,CAAkBiN,GAAlB,CAAsBD,UAAtB;AACH,GA/iBF;AAijBC1E,EAAAA,WAAW,EAAE,qBAAU5F,KAAV,EAAiBwK,OAAjB,EAA0B;AACnC,QAAI3I,GAAG,GAAG7B,KAAK,CAAC8J,OAAhB;AACA,QAAI7K,OAAO,GAAG,KAAKnC,SAAL,CAAe+E,GAAf,CAAd;AACA,QAAI4I,UAAU,GAAGzK,KAAK,CAACoH,gBAAN,IAA0B,GAA3C;AACAoD,IAAAA,OAAO,GAAGA,OAAO,IAAI,CAArB;;AACA,QAAI,CAACvL,OAAL,EAAc;AACV,UAAIe,KAAK,CAACoB,IAAN,KAAe,aAAnB,EAAkC;AAC9BnC,QAAAA,OAAO,GAAG,IAAIlE,WAAJ,EAAV;AACH,OAFD,MAGK;AACDkE,QAAAA,OAAO,GAAG,IAAInE,SAAJ,EAAV;AACH,OANS,CAOV;AACA;;;AACAmE,MAAAA,OAAO,CAACN,KAAR,GAAgB8L,UAAU,GAAGD,OAA7B;AACAvL,MAAAA,OAAO,CAACL,MAAR,GAAiB6L,UAAjB;;AACA,UAAI,KAAKpO,UAAL,KAAoBF,aAAa,CAAC0C,GAAtC,EAA2C;AACvCI,QAAAA,OAAO,CAACmC,IAAR,GAAevG,OAAO,CAACwP,KAAvB;AACApL,QAAAA,OAAO,CAACyL,WAAR,GAAsB,CAAtB;AACH,OAHD,MAIK;AACDzL,QAAAA,OAAO,CAAC0L,SAAR,GAAoBvQ,MAAM,CAACwQ,OAA3B;AACA3L,QAAAA,OAAO,CAAC4L,SAAR,GAAoBzQ,MAAM,CAACwQ,OAA3B;AACA3L,QAAAA,OAAO,CAAC6L,SAAR,GAAoB,KAApB;AACH;;AACD,WAAKhO,SAAL,CAAe+E,GAAf,IAAsB5C,OAAtB;AACH;;AAED,WAAOA,OAAP;AACH,GA9kBF;AAglBCyK,EAAAA,oBAAoB,EAAE,8BAAU1J,KAAV,EAAiBwJ,MAAjB,EAAyB;AAC3C,QAAI,CAAC,KAAKpM,aAAL,CAAmB2N,KAAxB,EAA+B;AAC3B,WAAK3N,aAAL,CAAmB2N,KAAnB,GAA2B;AACvBjD,QAAAA,EAAE,EAAE,IAAI9M,iBAAJ,EADmB;AAEvBiN,QAAAA,EAAE,EAAE,IAAIjN,iBAAJ,EAFmB;AAGvB+M,QAAAA,EAAE,EAAE,IAAI/M,iBAAJ,EAHmB;AAIvBkN,QAAAA,EAAE,EAAE,IAAIlN,iBAAJ,EAJmB;AAKvBgN,QAAAA,EAAE,EAAE,IAAIhN,iBAAJ,EALmB;AAMvBmN,QAAAA,EAAE,EAAE,IAAInN,iBAAJ;AANmB,OAA3B;AAQH;;AACD,QAAIyO,MAAM,GAAG,KAAKrM,aAAL,CAAmB2N,KAAnB,CAAyBvB,MAAzB,CAAb;AAEAC,IAAAA,MAAM,CAAClF,GAAP,GAAavE,KAAK,CAACwI,KAAnB;AACAiB,IAAAA,MAAM,CAACpD,GAAP,GAAa,EAAb;AACAoD,IAAAA,MAAM,CAACuB,QAAP,CAAgBxL,GAAhB,CAAoB,CAApB,EAAuB,CAAvB,EAA0B,CAA1B;;AACA,YAAQgK,MAAR;AACI,WAAK,IAAL;AACIC,QAAAA,MAAM,CAACwB,MAAP,CAAc5Q,OAAO,CAAC6Q,UAAtB,EAAkC7Q,OAAO,CAAC8Q,UAA1C;AACA;;AACJ,WAAK,IAAL;AACI1B,QAAAA,MAAM,CAACwB,MAAP,CAAc5Q,OAAO,CAAC+Q,UAAtB,EAAkC/Q,OAAO,CAAC8Q,UAA1C;AACA;;AACJ,WAAK,IAAL;AACI1B,QAAAA,MAAM,CAACwB,MAAP,CAAc5Q,OAAO,CAACgR,UAAtB,EAAkChR,OAAO,CAACiR,UAA1C;AACA;;AACJ,WAAK,IAAL;AACI7B,QAAAA,MAAM,CAACwB,MAAP,CAAc5Q,OAAO,CAAC8Q,UAAtB,EAAkC9Q,OAAO,CAACkR,UAA1C;AACA;;AACJ,WAAK,IAAL;AACI9B,QAAAA,MAAM,CAACwB,MAAP,CAAc5Q,OAAO,CAACiR,UAAtB,EAAkCjR,OAAO,CAAC8Q,UAA1C;AACA;;AACJ,WAAK,IAAL;AACI1B,QAAAA,MAAM,CAACwB,MAAP,CAAc5Q,OAAO,CAACkR,UAAtB,EAAkClR,OAAO,CAAC8Q,UAA1C;AACA;AAlBR;;AAoBAnL,IAAAA,KAAK,CAACsI,gBAAN,CAAuBmB,MAAM,CAACuB,QAA9B;AACAvB,IAAAA,MAAM,CAACpJ,MAAP;AAEA,WAAOoJ,MAAP;AACH,GAxnBF;AA0nBC7E,EAAAA,0BAA0B,EAAG,YAAY;AACrC,QAAI7B,eAAe,GAAG,IAAIvI,OAAJ,EAAtB;AACA,QAAIgR,oBAAoB,GAAG,IAAIlR,WAAJ,EAA3B;AACA,QAAImR,aAAa,GAAG,IAAInR,WAAJ,EAApB,CAHqC,CAIrC;AACA;;AACA,WAAO,UAAU0F,KAAV,EAAiBjC,KAAjB,EAAwBC,WAAxB,EAAqC;AACxC,UAAI,CAAC,KAAKZ,aAAL,CAAmBsO,WAAxB,EAAqC;AACjC,aAAKtO,aAAL,CAAmBsO,WAAnB,GAAiC,IAAIzQ,WAAJ,EAAjC;AACH;;AACD,UAAIwO,MAAM,GAAG,KAAKrM,aAAL,CAAmBsO,WAAhC;AAEAF,MAAAA,oBAAoB,CAACxH,IAArB,CAA0BjG,KAAK,CAAC6F,wBAAhC;AACA4H,MAAAA,oBAAoB,CAACG,YAArB,CAAkC3N,WAAW,CAAC4N,OAAZ,CAAoB9H,WAAtD,EAPwC,CAQxC;;AACA2F,MAAAA,MAAM,CAACuB,QAAP,CACKhH,IADL,CACUwH,oBAAoB,CAACnH,GAD/B,EAEKsE,GAFL,CAES6C,oBAAoB,CAAC/G,GAF9B,EAGKoH,KAHL,CAGW,GAHX,EAIKC,aAJL,CAImB9N,WAAW,CAACiH,cAJ/B;AAKAwE,MAAAA,MAAM,CAACsC,QAAP,CAAgB/H,IAAhB,CAAqBhE,KAAK,CAAC+L,QAA3B;AACAtC,MAAAA,MAAM,CAACoC,KAAP,CAAa7H,IAAb,CAAkBhE,KAAK,CAAC6L,KAAxB;AACApC,MAAAA,MAAM,CAACuC,oBAAP,GAhBwC,CAkBxC;;AACAxR,MAAAA,OAAO,CAACwK,MAAR,CAAejC,eAAf,EAAgC0G,MAAM,CAACxE,cAAvC;AACAzK,MAAAA,OAAO,CAAC0K,QAAR,CAAiBnC,eAAjB,EAAkCA,eAAlC,EAAmD/E,WAAW,CAACiH,cAA/D;AAEAwG,MAAAA,aAAa,CAACzH,IAAd,CAAmBwH,oBAAnB,EAAyCvH,cAAzC,CAAwDlB,eAAxD;AAEA,UAAIsB,GAAG,GAAGoH,aAAa,CAACpH,GAAd,CAAkBS,KAA5B;AACA,UAAIL,GAAG,GAAGgH,aAAa,CAAChH,GAAd,CAAkBK,KAA5B,CAzBwC,CA2BxC;;AACA2E,MAAAA,MAAM,CAACuB,QAAP,CAAgBxL,GAAhB,CAAoB,CAAC6E,GAAG,CAAC,CAAD,CAAH,GAASI,GAAG,CAAC,CAAD,CAAb,IAAoB,CAAxC,EAA2C,CAACJ,GAAG,CAAC,CAAD,CAAH,GAASI,GAAG,CAAC,CAAD,CAAb,IAAoB,CAA/D,EAAkEA,GAAG,CAAC,CAAD,CAArE,EACKqH,aADL,CACmBrC,MAAM,CAACxE,cAD1B;AAEAwE,MAAAA,MAAM,CAAC/E,IAAP,GAAc,CAAd;AACA+E,MAAAA,MAAM,CAAClF,GAAP,GAAa,CAACF,GAAG,CAAC,CAAD,CAAJ,GAAUI,GAAG,CAAC,CAAD,CAA1B,CA/BwC,CAgCxC;;AACA,UAAIwH,KAAK,CAAC,KAAKzP,gBAAN,CAAT,EAAkC;AAC9BiN,QAAAA,MAAM,CAAClF,GAAP,IAAc,CAAd;AACH,OAFD,MAGK;AACDkF,QAAAA,MAAM,CAAClF,GAAP,IAAc,KAAK/H,gBAAnB;AACH;;AACDiN,MAAAA,MAAM,CAAChD,IAAP,GAAcpC,GAAG,CAAC,CAAD,CAAjB;AACAoF,MAAAA,MAAM,CAAC/C,KAAP,GAAejC,GAAG,CAAC,CAAD,CAAlB;AACAgF,MAAAA,MAAM,CAAC7C,GAAP,GAAanC,GAAG,CAAC,CAAD,CAAhB;AACAgF,MAAAA,MAAM,CAAC9C,MAAP,GAAgBtC,GAAG,CAAC,CAAD,CAAnB;AACAoF,MAAAA,MAAM,CAACpJ,MAAP,CAAc,IAAd;AAEA,aAAOoJ,MAAP;AACH,KA9CD;AA+CH,GArD2B,EA1nB7B;AAirBC7B,EAAAA,mBAAmB,EAAE,6BAAU5H,KAAV,EAAiB;AAClC,QAAI,CAAC,KAAK5C,aAAL,CAAmB8O,IAAxB,EAA8B;AAC1B,WAAK9O,aAAL,CAAmB8O,IAAnB,GAA0B,IAAIlR,iBAAJ,EAA1B;AACH;;AACD,QAAIyO,MAAM,GAAG,KAAKrM,aAAL,CAAmB8O,IAAhC,CAJkC,CAKlC;;AACAzC,IAAAA,MAAM,CAACpD,GAAP,GAAarG,KAAK,CAACmM,aAAN,GAAsB,CAAnC;AACA1C,IAAAA,MAAM,CAAClF,GAAP,GAAavE,KAAK,CAACwI,KAAnB;AACAiB,IAAAA,MAAM,CAACxE,cAAP,CAAsBjB,IAAtB,CAA2BhE,KAAK,CAACiF,cAAjC;AACAwE,IAAAA,MAAM,CAAC2C,sBAAP;AACAhR,IAAAA,IAAI,CAAC4J,MAAL,CAAYyE,MAAM,CAACvF,UAAP,CAAkBY,KAA9B,EAAqC2E,MAAM,CAACxE,cAAP,CAAsBH,KAA3D;AAEA,WAAO2E,MAAP;AACH,GA9rBF;;AAgsBC;AACJ;AACA;AACA;AACI;AACA4C,EAAAA,OAAO,EAAE,iBAAUvO,QAAV,EAAoB;AACzB,QAAIqC,GAAG,GAAGrC,QAAQ,CAACsC,EAAT,IAAetC,QAAzB;;AAEA,QAAI,KAAKjB,YAAT,EAAuB;AACnB,WAAKA,YAAL,CAAkBwP,OAAlB,CAA0BlM,GAA1B;AACH;;AAED,SAAK,IAAInB,IAAT,IAAiB,KAAKlC,SAAtB,EAAiC;AAC7B,WAAKA,SAAL,CAAekC,IAAf,EAAqBqN,OAArB,CAA6BlM,GAA7B;AACH;;AAED,SAAK7C,YAAL,CAAkByI,KAAlB,CAAwBjI,QAAQ,CAACsC,EAAjC;;AAEA,SAAKpD,eAAL,GAAuB,EAAvB;AACA,SAAKC,kBAAL,GAA0B,EAA1B;AACA,SAAKH,SAAL,GAAiB,EAAjB;AACA,SAAKM,aAAL,GAAqB,EAArB;AACA,SAAKL,gBAAL,GAAwB;AACpB,qBAAe,CADK;AAEpB,2BAAqB,CAFD;AAGpB,oBAAc;AAHM,KAAxB;AAKA,SAAKuP,cAAL,GAAsB,EAAtB;;AAEA,SAAK,IAAIxM,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAK5C,UAAL,CAAgBuC,MAApC,EAA4CK,CAAC,EAA7C,EAAiD;AAC7C,UAAIT,IAAI,GAAG,KAAKnC,UAAL,CAAgB4C,CAAhB,CAAX,CAD6C,CAE7C;;AACA,UAAIT,IAAI,CAAC1D,QAAT,EAAmB;AACf,YAAIA,QAAQ,GAAG0D,IAAI,CAAC1D,QAApB;AACAA,QAAAA,QAAQ,CAACoD,QAAT,CAAkB,UAAlB,EAA8B,0BAA9B;AACApD,QAAAA,QAAQ,CAACoD,QAAT,CAAkB,UAAlB,EAA8B,gCAA9B;AACApD,QAAAA,QAAQ,CAACoD,QAAT,CAAkB,UAAlB,EAA8B,4BAA9B;AACApD,QAAAA,QAAQ,CAAC6D,GAAT,CAAa,eAAb,EAA8B,CAA9B;AACH;AACJ;;AAED,SAAKtC,UAAL,GAAkB,EAAlB;AACA,SAAKC,iBAAL,GAAyB,EAAzB;AACH;AA3uBF,CApEiB,CAApB;AAkzBA;AACA;AACA;AACA;;AACAhB,aAAa,CAAC0C,GAAd,GAAoB,CAApB;AAEA;AACA;AACA;AACA;;AACA1C,aAAa,CAACG,GAAd,GAAoB,CAApB;AAEA,eAAeH,aAAf","sourcesContent":["import Base from '../core/Base';\nimport glenum from '../core/glenum';\nimport Vector3 from '../math/Vector3';\nimport BoundingBox from '../math/BoundingBox';\nimport Frustum from '../math/Frustum';\nimport Matrix4 from '../math/Matrix4';\nimport Renderer from '../Renderer';\nimport Shader from '../Shader';\nimport Material from '../Material';\nimport FrameBuffer from '../FrameBuffer';\nimport Texture from '../Texture';\nimport Texture2D from '../Texture2D';\nimport TextureCube from '../TextureCube';\nimport PerspectiveCamera from '../camera/Perspective';\nimport OrthoCamera from '../camera/Orthographic';\n\nimport Pass from '../compositor/Pass';\nimport TexturePool from '../compositor/TexturePool';\n\nimport mat4 from '../glmatrix/mat4';\n\nvar targets = ['px', 'nx', 'py', 'ny', 'pz', 'nz'];\n\nimport shadowmapEssl from '../shader/source/shadowmap.glsl.js';\nShader['import'](shadowmapEssl);\n\nfunction getDepthMaterialUniform(renderable, depthMaterial, symbol) {\n    if (symbol === 'alphaMap') {\n        return renderable.material.get('diffuseMap');\n    }\n    else if (symbol === 'alphaCutoff') {\n        if (renderable.material.isDefined('fragment', 'ALPHA_TEST')\n            && renderable.material.get('diffuseMap')\n        ) {\n            var alphaCutoff = renderable.material.get('alphaCutoff');\n            return alphaCutoff || 0;\n        }\n        return 0;\n    }\n    else if (symbol === 'uvRepeat') {\n        return renderable.material.get('uvRepeat');\n    }\n    else if (symbol === 'uvOffset') {\n        return renderable.material.get('uvOffset');\n    }\n    else {\n        return depthMaterial.get(symbol);\n    }\n}\n\nfunction isDepthMaterialChanged(renderable, prevRenderable) {\n    var matA = renderable.material;\n    var matB = prevRenderable.material;\n    return matA.get('diffuseMap') !== matB.get('diffuseMap')\n        || (matA.get('alphaCutoff') || 0) !== (matB.get('alphaCutoff') || 0);\n}\n\n/**\n * Pass rendering shadow map.\n *\n * @constructor clay.prePass.ShadowMap\n * @extends clay.core.Base\n * @example\n *     var shadowMapPass = new clay.prePass.ShadowMap({\n *         softShadow: clay.prePass.ShadowMap.VSM\n *     });\n *     ...\n *     animation.on('frame', function (frameTime) {\n *         shadowMapPass.render(renderer, scene, camera);\n *         renderer.render(scene, camera);\n *     });\n */\nvar ShadowMapPass = Base.extend(function () {\n    return /** @lends clay.prePass.ShadowMap# */ {\n        /**\n         * Soft shadow technique.\n         * Can be {@link clay.prePass.ShadowMap.PCF} or {@link clay.prePass.ShadowMap.VSM}\n         * @type {number}\n         */\n        softShadow: ShadowMapPass.PCF,\n\n        /**\n         * Soft shadow blur size\n         * @type {number}\n         */\n        shadowBlur: 1.0,\n\n        lightFrustumBias: 'auto',\n\n        kernelPCF: new Float32Array([\n            1, 0,\n            1, 1,\n            -1, 1,\n            0, 1,\n            -1, 0,\n            -1, -1,\n            1, -1,\n            0, -1\n        ]),\n\n        precision: 'highp',\n\n        _lastRenderNotCastShadow: false,\n\n        _frameBuffer: new FrameBuffer(),\n\n        _textures: {},\n        _shadowMapNumber: {\n            'POINT_LIGHT': 0,\n            'DIRECTIONAL_LIGHT': 0,\n            'SPOT_LIGHT': 0\n        },\n\n        _depthMaterials: {},\n        _distanceMaterials: {},\n\n        _receivers: [],\n        _lightsCastShadow: [],\n\n        _lightCameras: {},\n        _lightMaterials: {},\n\n        _texturePool: new TexturePool()\n    };\n}, function () {\n    // Gaussian filter pass for VSM\n    this._gaussianPassH = new Pass({\n        fragment: Shader.source('clay.compositor.gaussian_blur')\n    });\n    this._gaussianPassV = new Pass({\n        fragment: Shader.source('clay.compositor.gaussian_blur')\n    });\n    this._gaussianPassH.setUniform('blurSize', this.shadowBlur);\n    this._gaussianPassH.setUniform('blurDir', 0.0);\n    this._gaussianPassV.setUniform('blurSize', this.shadowBlur);\n    this._gaussianPassV.setUniform('blurDir', 1.0);\n\n    this._outputDepthPass = new Pass({\n        fragment: Shader.source('clay.sm.debug_depth')\n    });\n}, {\n    /**\n     * Render scene to shadow textures\n     * @param  {clay.Renderer} renderer\n     * @param  {clay.Scene} scene\n     * @param  {clay.Camera} sceneCamera\n     * @param  {boolean} [notUpdateScene=false]\n     * @memberOf clay.prePass.ShadowMap.prototype\n     */\n    render: function (renderer, scene, sceneCamera, notUpdateScene) {\n        if (!sceneCamera) {\n            sceneCamera = scene.getMainCamera();\n        }\n        this.trigger('beforerender', this, renderer, scene, sceneCamera);\n        this._renderShadowPass(renderer, scene, sceneCamera, notUpdateScene);\n        this.trigger('afterrender', this, renderer, scene, sceneCamera);\n    },\n\n    /**\n     * Debug rendering of shadow textures\n     * @param  {clay.Renderer} renderer\n     * @param  {number} size\n     * @memberOf clay.prePass.ShadowMap.prototype\n     */\n    renderDebug: function (renderer, size) {\n        renderer.saveClear();\n        var viewport = renderer.viewport;\n        var x = 0, y = 0;\n        var width = size || viewport.width / 4;\n        var height = width;\n        if (this.softShadow === ShadowMapPass.VSM) {\n            this._outputDepthPass.material.define('fragment', 'USE_VSM');\n        }\n        else {\n            this._outputDepthPass.material.undefine('fragment', 'USE_VSM');\n        }\n        for (var name in this._textures) {\n            var texture = this._textures[name];\n            renderer.setViewport(x, y, width * texture.width / texture.height, height);\n            this._outputDepthPass.setUniform('depthMap', texture);\n            this._outputDepthPass.render(renderer);\n            x += width * texture.width / texture.height;\n        }\n        renderer.setViewport(viewport);\n        renderer.restoreClear();\n    },\n\n    _updateReceivers: function (renderer, mesh) {\n        if (mesh.receiveShadow) {\n            this._receivers.push(mesh);\n            mesh.material.set('shadowEnabled', 1);\n\n            mesh.material.set('pcfKernel', this.kernelPCF);\n        }\n        else {\n            mesh.material.set('shadowEnabled', 0);\n        }\n\n        if (this.softShadow === ShadowMapPass.VSM) {\n            mesh.material.define('fragment', 'USE_VSM');\n            mesh.material.undefine('fragment', 'PCF_KERNEL_SIZE');\n        }\n        else {\n            mesh.material.undefine('fragment', 'USE_VSM');\n            var kernelPCF = this.kernelPCF;\n            if (kernelPCF && kernelPCF.length) {\n                mesh.material.define('fragment', 'PCF_KERNEL_SIZE', kernelPCF.length / 2);\n            }\n            else {\n                mesh.material.undefine('fragment', 'PCF_KERNEL_SIZE');\n            }\n        }\n    },\n\n    _update: function (renderer, scene) {\n        var self = this;\n        scene.traverse(function (renderable) {\n            if (renderable.isRenderable()) {\n                self._updateReceivers(renderer, renderable);\n            }\n        });\n\n        for (var i = 0; i < scene.lights.length; i++) {\n            var light = scene.lights[i];\n            if (light.castShadow && !light.invisible) {\n                this._lightsCastShadow.push(light);\n            }\n        }\n    },\n\n    _renderShadowPass: function (renderer, scene, sceneCamera, notUpdateScene) {\n        // reset\n        for (var name in this._shadowMapNumber) {\n            this._shadowMapNumber[name] = 0;\n        }\n        this._lightsCastShadow.length = 0;\n        this._receivers.length = 0;\n\n        var _gl = renderer.gl;\n\n        if (!notUpdateScene) {\n            scene.update();\n        }\n        if (sceneCamera) {\n            sceneCamera.update();\n        }\n\n        scene.updateLights();\n        this._update(renderer, scene);\n\n        // Needs to update the receivers again if shadows come from 1 to 0.\n        if (!this._lightsCastShadow.length && this._lastRenderNotCastShadow) {\n            return;\n        }\n\n        this._lastRenderNotCastShadow = this._lightsCastShadow === 0;\n\n        _gl.enable(_gl.DEPTH_TEST);\n        _gl.depthMask(true);\n        _gl.disable(_gl.BLEND);\n\n        // Clear with high-z, so the part not rendered will not been shadowed\n        // TODO\n        // TODO restore\n        _gl.clearColor(1.0, 1.0, 1.0, 1.0);\n\n        // Shadow uniforms\n        var spotLightShadowMaps = [];\n        var spotLightMatrices = [];\n        var directionalLightShadowMaps = [];\n        var directionalLightMatrices = [];\n        var shadowCascadeClips = [];\n        var pointLightShadowMaps = [];\n\n        var dirLightHasCascade;\n        // Create textures for shadow map\n        for (var i = 0; i < this._lightsCastShadow.length; i++) {\n            var light = this._lightsCastShadow[i];\n            if (light.type === 'DIRECTIONAL_LIGHT') {\n\n                if (dirLightHasCascade) {\n                    console.warn('Only one direectional light supported with shadow cascade');\n                    continue;\n                }\n                if (light.shadowCascade > 4) {\n                    console.warn('Support at most 4 cascade');\n                    continue;\n                }\n                if (light.shadowCascade > 1) {\n                    dirLightHasCascade = light;\n                }\n\n                this.renderDirectionalLightShadow(\n                    renderer,\n                    scene,\n                    sceneCamera,\n                    light,\n                    shadowCascadeClips,\n                    directionalLightMatrices,\n                    directionalLightShadowMaps\n                );\n            }\n            else if (light.type === 'SPOT_LIGHT') {\n                this.renderSpotLightShadow(\n                    renderer,\n                    scene,\n                    light,\n                    spotLightMatrices,\n                    spotLightShadowMaps\n                );\n            }\n            else if (light.type === 'POINT_LIGHT') {\n                this.renderPointLightShadow(\n                    renderer,\n                    scene,\n                    light,\n                    pointLightShadowMaps\n                );\n            }\n\n            this._shadowMapNumber[light.type]++;\n        }\n\n        for (var lightType in this._shadowMapNumber) {\n            var number = this._shadowMapNumber[lightType];\n            var key = lightType + '_SHADOWMAP_COUNT';\n            for (var i = 0; i < this._receivers.length; i++) {\n                var mesh = this._receivers[i];\n                var material = mesh.material;\n                if (material.fragmentDefines[key] !== number) {\n                    if (number > 0) {\n                        material.define('fragment', key, number);\n                    }\n                    else if (material.isDefined('fragment', key)) {\n                        material.undefine('fragment', key);\n                    }\n                }\n            }\n        }\n        for (var i = 0; i < this._receivers.length; i++) {\n            var mesh = this._receivers[i];\n            var material = mesh.material;\n            if (dirLightHasCascade) {\n                material.define('fragment', 'SHADOW_CASCADE', dirLightHasCascade.shadowCascade);\n            }\n            else {\n                material.undefine('fragment', 'SHADOW_CASCADE');\n            }\n        }\n\n        var shadowUniforms = scene.shadowUniforms;\n\n        function getSize(texture) {\n            return texture.height;\n        }\n        if (directionalLightShadowMaps.length > 0) {\n            var directionalLightShadowMapSizes = directionalLightShadowMaps.map(getSize);\n            shadowUniforms.directionalLightShadowMaps = { value: directionalLightShadowMaps, type: 'tv' };\n            shadowUniforms.directionalLightMatrices = { value: directionalLightMatrices, type: 'm4v' };\n            shadowUniforms.directionalLightShadowMapSizes = { value: directionalLightShadowMapSizes, type: '1fv' };\n            if (dirLightHasCascade) {\n                var shadowCascadeClipsNear = shadowCascadeClips.slice();\n                var shadowCascadeClipsFar = shadowCascadeClips.slice();\n                shadowCascadeClipsNear.pop();\n                shadowCascadeClipsFar.shift();\n\n                // Iterate from far to near\n                shadowCascadeClipsNear.reverse();\n                shadowCascadeClipsFar.reverse();\n                // directionalLightShadowMaps.reverse();\n                directionalLightMatrices.reverse();\n                shadowUniforms.shadowCascadeClipsNear = { value: shadowCascadeClipsNear, type: '1fv' };\n                shadowUniforms.shadowCascadeClipsFar = { value: shadowCascadeClipsFar, type: '1fv' };\n            }\n        }\n\n        if (spotLightShadowMaps.length > 0) {\n            var spotLightShadowMapSizes = spotLightShadowMaps.map(getSize);\n            var shadowUniforms = scene.shadowUniforms;\n            shadowUniforms.spotLightShadowMaps = { value: spotLightShadowMaps, type: 'tv' };\n            shadowUniforms.spotLightMatrices = { value: spotLightMatrices, type: 'm4v' };\n            shadowUniforms.spotLightShadowMapSizes = { value: spotLightShadowMapSizes, type: '1fv' };\n        }\n\n        if (pointLightShadowMaps.length > 0) {\n            shadowUniforms.pointLightShadowMaps = { value: pointLightShadowMaps, type: 'tv' };\n        }\n    },\n\n    renderDirectionalLightShadow: (function () {\n\n        var splitFrustum = new Frustum();\n        var splitProjMatrix = new Matrix4();\n        var cropBBox = new BoundingBox();\n        var cropMatrix = new Matrix4();\n        var lightViewMatrix = new Matrix4();\n        var lightViewProjMatrix = new Matrix4();\n        var lightProjMatrix = new Matrix4();\n\n        return function (renderer, scene, sceneCamera, light, shadowCascadeClips, directionalLightMatrices, directionalLightShadowMaps) {\n\n            var defaultShadowMaterial = this._getDepthMaterial(light);\n            var passConfig = {\n                getMaterial: function (renderable) {\n                    return renderable.shadowDepthMaterial || defaultShadowMaterial;\n                },\n                isMaterialChanged: isDepthMaterialChanged,\n                getUniform: getDepthMaterialUniform,\n                ifRender: function (renderable) {\n                    return renderable.castShadow;\n                },\n                sortCompare: Renderer.opaqueSortCompare\n            };\n\n            // First frame\n            if (!scene.viewBoundingBoxLastFrame.isFinite()) {\n                var boundingBox = scene.getBoundingBox();\n                scene.viewBoundingBoxLastFrame\n                    .copy(boundingBox).applyTransform(sceneCamera.viewMatrix);\n            }\n            // Considering moving speed since the bounding box is from last frame\n            // TODO: add a bias\n            var clippedFar = Math.min(-scene.viewBoundingBoxLastFrame.min.z, sceneCamera.far);\n            var clippedNear = Math.max(-scene.viewBoundingBoxLastFrame.max.z, sceneCamera.near);\n\n            var lightCamera = this._getDirectionalLightCamera(light, scene, sceneCamera);\n\n            var lvpMat4Arr = lightViewProjMatrix.array;\n            lightProjMatrix.copy(lightCamera.projectionMatrix);\n            mat4.invert(lightViewMatrix.array, lightCamera.worldTransform.array);\n            mat4.multiply(lightViewMatrix.array, lightViewMatrix.array, sceneCamera.worldTransform.array);\n            mat4.multiply(lvpMat4Arr, lightProjMatrix.array, lightViewMatrix.array);\n\n            var clipPlanes = [];\n            var isPerspective = sceneCamera instanceof PerspectiveCamera;\n\n            var scaleZ = (sceneCamera.near + sceneCamera.far) / (sceneCamera.near - sceneCamera.far);\n            var offsetZ = 2 * sceneCamera.near * sceneCamera.far / (sceneCamera.near - sceneCamera.far);\n            for (var i = 0; i <= light.shadowCascade; i++) {\n                var clog = clippedNear * Math.pow(clippedFar / clippedNear, i / light.shadowCascade);\n                var cuni = clippedNear + (clippedFar - clippedNear) * i / light.shadowCascade;\n                var c = clog * light.cascadeSplitLogFactor + cuni * (1 - light.cascadeSplitLogFactor);\n                clipPlanes.push(c);\n                shadowCascadeClips.push(-(-c * scaleZ + offsetZ) / -c);\n            }\n            var texture = this._getTexture(light, light.shadowCascade);\n            directionalLightShadowMaps.push(texture);\n\n            var viewport = renderer.viewport;\n\n            var _gl = renderer.gl;\n            this._frameBuffer.attach(texture);\n            this._frameBuffer.bind(renderer);\n            _gl.clear(_gl.COLOR_BUFFER_BIT | _gl.DEPTH_BUFFER_BIT);\n\n            for (var i = 0; i < light.shadowCascade; i++) {\n                // Get the splitted frustum\n                var nearPlane = clipPlanes[i];\n                var farPlane = clipPlanes[i + 1];\n                if (isPerspective) {\n                    mat4.perspective(splitProjMatrix.array, sceneCamera.fov / 180 * Math.PI, sceneCamera.aspect, nearPlane, farPlane);\n                }\n                else {\n                    mat4.ortho(\n                        splitProjMatrix.array,\n                        sceneCamera.left, sceneCamera.right, sceneCamera.bottom, sceneCamera.top,\n                        nearPlane, farPlane\n                    );\n                }\n                splitFrustum.setFromProjection(splitProjMatrix);\n                splitFrustum.getTransformedBoundingBox(cropBBox, lightViewMatrix);\n                cropBBox.applyProjection(lightProjMatrix);\n                var _min = cropBBox.min.array;\n                var _max = cropBBox.max.array;\n                _min[0] = Math.max(_min[0], -1);\n                _min[1] = Math.max(_min[1], -1);\n                _max[0] = Math.min(_max[0], 1);\n                _max[1] = Math.min(_max[1], 1);\n                cropMatrix.ortho(_min[0], _max[0], _min[1], _max[1], 1, -1);\n                lightCamera.projectionMatrix.multiplyLeft(cropMatrix);\n\n                var shadowSize = light.shadowResolution || 512;\n\n                // Reversed, left to right => far to near\n                renderer.setViewport((light.shadowCascade - i - 1) * shadowSize, 0, shadowSize, shadowSize, 1);\n\n                var renderList = scene.updateRenderList(lightCamera);\n                renderer.renderPass(renderList.opaque, lightCamera, passConfig);\n\n                // Filter for VSM\n                if (this.softShadow === ShadowMapPass.VSM) {\n                    this._gaussianFilter(renderer, texture, texture.width);\n                }\n\n                var matrix = new Matrix4();\n                matrix.copy(lightCamera.viewMatrix)\n                    .multiplyLeft(lightCamera.projectionMatrix);\n\n                directionalLightMatrices.push(matrix.array);\n\n                lightCamera.projectionMatrix.copy(lightProjMatrix);\n            }\n\n            this._frameBuffer.unbind(renderer);\n\n            renderer.setViewport(viewport);\n        };\n    })(),\n\n    renderSpotLightShadow: function (renderer, scene, light, spotLightMatrices, spotLightShadowMaps) {\n\n        var texture = this._getTexture(light);\n        var lightCamera = this._getSpotLightCamera(light);\n        var _gl = renderer.gl;\n\n        this._frameBuffer.attach(texture);\n        this._frameBuffer.bind(renderer);\n\n        _gl.clear(_gl.COLOR_BUFFER_BIT | _gl.DEPTH_BUFFER_BIT);\n\n        var defaultShadowMaterial = this._getDepthMaterial(light);\n        var passConfig = {\n            getMaterial: function (renderable) {\n                return renderable.shadowDepthMaterial || defaultShadowMaterial;\n            },\n            isMaterialChanged: isDepthMaterialChanged,\n            getUniform: getDepthMaterialUniform,\n            ifRender: function (renderable) {\n                return renderable.castShadow;\n            },\n            sortCompare: Renderer.opaqueSortCompare\n        };\n\n        var renderList = scene.updateRenderList(lightCamera);\n        renderer.renderPass(renderList.opaque, lightCamera, passConfig);\n\n        this._frameBuffer.unbind(renderer);\n\n        // Filter for VSM\n        if (this.softShadow === ShadowMapPass.VSM) {\n            this._gaussianFilter(renderer, texture, texture.width);\n        }\n\n        var matrix = new Matrix4();\n        matrix.copy(lightCamera.worldTransform)\n            .invert()\n            .multiplyLeft(lightCamera.projectionMatrix);\n\n        spotLightShadowMaps.push(texture);\n        spotLightMatrices.push(matrix.array);\n    },\n\n    renderPointLightShadow: function (renderer, scene, light, pointLightShadowMaps) {\n        var texture = this._getTexture(light);\n        var _gl = renderer.gl;\n        pointLightShadowMaps.push(texture);\n\n        var defaultShadowMaterial = this._getDepthMaterial(light);\n        var passConfig = {\n            getMaterial: function (renderable) {\n                return renderable.shadowDepthMaterial || defaultShadowMaterial;\n            },\n            getUniform: getDepthMaterialUniform,\n            sortCompare: Renderer.opaqueSortCompare\n        };\n\n        var renderListEachSide = {\n            px: [], py: [], pz: [], nx: [], ny: [], nz: []\n        };\n        var bbox = new BoundingBox();\n        var lightWorldPosition = light.getWorldPosition().array;\n        var lightBBox = new BoundingBox();\n        var range = light.range;\n        lightBBox.min.setArray(lightWorldPosition);\n        lightBBox.max.setArray(lightWorldPosition);\n        var extent = new Vector3(range, range, range);\n        lightBBox.max.add(extent);\n        lightBBox.min.sub(extent);\n\n        var targetsNeedRender = { px: false, py: false, pz: false, nx: false, ny: false, nz: false };\n        scene.traverse(function (renderable) {\n            if (renderable.isRenderable() && renderable.castShadow) {\n                var geometry = renderable.geometry;\n                if (!geometry.boundingBox) {\n                    for (var i = 0; i < targets.length; i++) {\n                        renderListEachSide[targets[i]].push(renderable);\n                    }\n                    return;\n                }\n                bbox.transformFrom(geometry.boundingBox, renderable.worldTransform);\n                if (!bbox.intersectBoundingBox(lightBBox)) {\n                    return;\n                }\n\n                bbox.updateVertices();\n                for (var i = 0; i < targets.length; i++) {\n                    targetsNeedRender[targets[i]] = false;\n                }\n                for (var i = 0; i < 8; i++) {\n                    var vtx = bbox.vertices[i];\n                    var x = vtx[0] - lightWorldPosition[0];\n                    var y = vtx[1] - lightWorldPosition[1];\n                    var z = vtx[2] - lightWorldPosition[2];\n                    var absx = Math.abs(x);\n                    var absy = Math.abs(y);\n                    var absz = Math.abs(z);\n                    if (absx > absy) {\n                        if (absx > absz) {\n                            targetsNeedRender[x > 0 ? 'px' : 'nx'] = true;\n                        }\n                        else {\n                            targetsNeedRender[z > 0 ? 'pz' : 'nz'] = true;\n                        }\n                    }\n                    else {\n                        if (absy > absz) {\n                            targetsNeedRender[y > 0 ? 'py' : 'ny'] = true;\n                        }\n                        else {\n                            targetsNeedRender[z > 0 ? 'pz' : 'nz'] = true;\n                        }\n                    }\n                }\n                for (var i = 0; i < targets.length; i++) {\n                    if (targetsNeedRender[targets[i]]) {\n                        renderListEachSide[targets[i]].push(renderable);\n                    }\n                }\n            }\n        });\n\n        for (var i = 0; i < 6; i++) {\n            var target = targets[i];\n            var camera = this._getPointLightCamera(light, target);\n\n            this._frameBuffer.attach(texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i);\n            this._frameBuffer.bind(renderer);\n            _gl.clear(_gl.COLOR_BUFFER_BIT | _gl.DEPTH_BUFFER_BIT);\n\n            renderer.renderPass(renderListEachSide[target], camera, passConfig);\n        }\n\n        this._frameBuffer.unbind(renderer);\n    },\n\n    _getDepthMaterial: function (light) {\n        var shadowMaterial = this._lightMaterials[light.__uid__];\n        var isPointLight = light.type === 'POINT_LIGHT';\n        if (!shadowMaterial) {\n            var shaderPrefix = isPointLight ? 'clay.sm.distance.' : 'clay.sm.depth.';\n            shadowMaterial = new Material({\n                precision: this.precision,\n                shader: new Shader(Shader.source(shaderPrefix + 'vertex'), Shader.source(shaderPrefix + 'fragment'))\n            });\n\n            this._lightMaterials[light.__uid__] = shadowMaterial;\n        }\n        if (light.shadowSlopeScale != null) {\n            shadowMaterial.setUniform('slopeScale', light.shadowSlopeScale);\n        }\n        if (light.shadowBias != null) {\n            shadowMaterial.setUniform('bias', light.shadowBias);\n        }\n        if (this.softShadow === ShadowMapPass.VSM) {\n            shadowMaterial.define('fragment', 'USE_VSM');\n        }\n        else {\n            shadowMaterial.undefine('fragment', 'USE_VSM');\n        }\n\n        if (isPointLight) {\n            shadowMaterial.set('lightPosition', light.getWorldPosition().array);\n            shadowMaterial.set('range', light.range);\n        }\n\n        return shadowMaterial;\n    },\n\n    _gaussianFilter: function (renderer, texture, size) {\n        var parameter = {\n            width: size,\n            height: size,\n            type: Texture.FLOAT\n        };\n        var tmpTexture = this._texturePool.get(parameter);\n\n        this._frameBuffer.attach(tmpTexture);\n        this._frameBuffer.bind(renderer);\n        this._gaussianPassH.setUniform('texture', texture);\n        this._gaussianPassH.setUniform('textureWidth', size);\n        this._gaussianPassH.render(renderer);\n\n        this._frameBuffer.attach(texture);\n        this._gaussianPassV.setUniform('texture', tmpTexture);\n        this._gaussianPassV.setUniform('textureHeight', size);\n        this._gaussianPassV.render(renderer);\n        this._frameBuffer.unbind(renderer);\n\n        this._texturePool.put(tmpTexture);\n    },\n\n    _getTexture: function (light, cascade) {\n        var key = light.__uid__;\n        var texture = this._textures[key];\n        var resolution = light.shadowResolution || 512;\n        cascade = cascade || 1;\n        if (!texture) {\n            if (light.type === 'POINT_LIGHT') {\n                texture = new TextureCube();\n            }\n            else {\n                texture = new Texture2D();\n            }\n            // At most 4 cascade\n            // TODO share with height ?\n            texture.width = resolution * cascade;\n            texture.height = resolution;\n            if (this.softShadow === ShadowMapPass.VSM) {\n                texture.type = Texture.FLOAT;\n                texture.anisotropic = 4;\n            }\n            else {\n                texture.minFilter = glenum.NEAREST;\n                texture.magFilter = glenum.NEAREST;\n                texture.useMipmap = false;\n            }\n            this._textures[key] = texture;\n        }\n\n        return texture;\n    },\n\n    _getPointLightCamera: function (light, target) {\n        if (!this._lightCameras.point) {\n            this._lightCameras.point = {\n                px: new PerspectiveCamera(),\n                nx: new PerspectiveCamera(),\n                py: new PerspectiveCamera(),\n                ny: new PerspectiveCamera(),\n                pz: new PerspectiveCamera(),\n                nz: new PerspectiveCamera()\n            };\n        }\n        var camera = this._lightCameras.point[target];\n\n        camera.far = light.range;\n        camera.fov = 90;\n        camera.position.set(0, 0, 0);\n        switch (target) {\n            case 'px':\n                camera.lookAt(Vector3.POSITIVE_X, Vector3.NEGATIVE_Y);\n                break;\n            case 'nx':\n                camera.lookAt(Vector3.NEGATIVE_X, Vector3.NEGATIVE_Y);\n                break;\n            case 'py':\n                camera.lookAt(Vector3.POSITIVE_Y, Vector3.POSITIVE_Z);\n                break;\n            case 'ny':\n                camera.lookAt(Vector3.NEGATIVE_Y, Vector3.NEGATIVE_Z);\n                break;\n            case 'pz':\n                camera.lookAt(Vector3.POSITIVE_Z, Vector3.NEGATIVE_Y);\n                break;\n            case 'nz':\n                camera.lookAt(Vector3.NEGATIVE_Z, Vector3.NEGATIVE_Y);\n                break;\n        }\n        light.getWorldPosition(camera.position);\n        camera.update();\n\n        return camera;\n    },\n\n    _getDirectionalLightCamera: (function () {\n        var lightViewMatrix = new Matrix4();\n        var sceneViewBoundingBox = new BoundingBox();\n        var lightViewBBox = new BoundingBox();\n        // Camera of directional light will be adjusted\n        // to contain the view frustum and scene bounding box as tightly as possible\n        return function (light, scene, sceneCamera) {\n            if (!this._lightCameras.directional) {\n                this._lightCameras.directional = new OrthoCamera();\n            }\n            var camera = this._lightCameras.directional;\n\n            sceneViewBoundingBox.copy(scene.viewBoundingBoxLastFrame);\n            sceneViewBoundingBox.intersection(sceneCamera.frustum.boundingBox);\n            // Move to the center of frustum(in world space)\n            camera.position\n                .copy(sceneViewBoundingBox.min)\n                .add(sceneViewBoundingBox.max)\n                .scale(0.5)\n                .transformMat4(sceneCamera.worldTransform);\n            camera.rotation.copy(light.rotation);\n            camera.scale.copy(light.scale);\n            camera.updateWorldTransform();\n\n            // Transform to light view space\n            Matrix4.invert(lightViewMatrix, camera.worldTransform);\n            Matrix4.multiply(lightViewMatrix, lightViewMatrix, sceneCamera.worldTransform);\n\n            lightViewBBox.copy(sceneViewBoundingBox).applyTransform(lightViewMatrix);\n\n            var min = lightViewBBox.min.array;\n            var max = lightViewBBox.max.array;\n\n            // Move camera to adjust the near to 0\n            camera.position.set((min[0] + max[0]) / 2, (min[1] + max[1]) / 2, max[2])\n                .transformMat4(camera.worldTransform);\n            camera.near = 0;\n            camera.far = -min[2] + max[2];\n            // Make sure receivers not in the frustum will stil receive the shadow.\n            if (isNaN(this.lightFrustumBias)) {\n                camera.far *= 4;\n            }\n            else {\n                camera.far += this.lightFrustumBias;\n            }\n            camera.left = min[0];\n            camera.right = max[0];\n            camera.top = max[1];\n            camera.bottom = min[1];\n            camera.update(true);\n\n            return camera;\n        };\n    })(),\n\n    _getSpotLightCamera: function (light) {\n        if (!this._lightCameras.spot) {\n            this._lightCameras.spot = new PerspectiveCamera();\n        }\n        var camera = this._lightCameras.spot;\n        // Update properties\n        camera.fov = light.penumbraAngle * 2;\n        camera.far = light.range;\n        camera.worldTransform.copy(light.worldTransform);\n        camera.updateProjectionMatrix();\n        mat4.invert(camera.viewMatrix.array, camera.worldTransform.array);\n\n        return camera;\n    },\n\n    /**\n     * @param  {clay.Renderer|WebGLRenderingContext} [renderer]\n     * @memberOf clay.prePass.ShadowMap.prototype\n     */\n    // PENDING Renderer or WebGLRenderingContext\n    dispose: function (renderer) {\n        var _gl = renderer.gl || renderer;\n\n        if (this._frameBuffer) {\n            this._frameBuffer.dispose(_gl);\n        }\n\n        for (var name in this._textures) {\n            this._textures[name].dispose(_gl);\n        }\n\n        this._texturePool.clear(renderer.gl);\n\n        this._depthMaterials = {};\n        this._distanceMaterials = {};\n        this._textures = {};\n        this._lightCameras = {};\n        this._shadowMapNumber = {\n            'POINT_LIGHT': 0,\n            'DIRECTIONAL_LIGHT': 0,\n            'SPOT_LIGHT': 0\n        };\n        this._meshMaterials = {};\n\n        for (var i = 0; i < this._receivers.length; i++) {\n            var mesh = this._receivers[i];\n            // Mesh may be disposed\n            if (mesh.material) {\n                var material = mesh.material;\n                material.undefine('fragment', 'POINT_LIGHT_SHADOW_COUNT');\n                material.undefine('fragment', 'DIRECTIONAL_LIGHT_SHADOW_COUNT');\n                material.undefine('fragment', 'AMBIENT_LIGHT_SHADOW_COUNT');\n                material.set('shadowEnabled', 0);\n            }\n        }\n\n        this._receivers = [];\n        this._lightsCastShadow = [];\n    }\n});\n\n/**\n * @name clay.prePass.ShadowMap.VSM\n * @type {number}\n */\nShadowMapPass.VSM = 1;\n\n/**\n * @name clay.prePass.ShadowMap.PCF\n * @type {number}\n */\nShadowMapPass.PCF = 2;\n\nexport default ShadowMapPass;\n"]},"metadata":{},"sourceType":"module"}