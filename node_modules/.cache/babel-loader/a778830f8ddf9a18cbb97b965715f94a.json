{"ast":null,"code":"import \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.split.js\";\nimport Base from './core/Base';\nimport Vector3 from './math/Vector3';\nimport Quaternion from './math/Quaternion';\nimport Matrix4 from './math/Matrix4';\nimport mat4 from './glmatrix/mat4';\nimport BoundingBox from './math/BoundingBox';\nvar nameId = 0;\n/**\n * @constructor clay.Node\n * @extends clay.core.Base\n */\n\nvar Node = Base.extend(\n/** @lends clay.Node# */\n{\n  /**\n   * Scene node name\n   * @type {string}\n   */\n  name: '',\n\n  /**\n   * Position relative to its parent node. aka translation.\n   * @type {clay.Vector3}\n   */\n  position: null,\n\n  /**\n   * Rotation relative to its parent node. Represented by a quaternion\n   * @type {clay.Quaternion}\n   */\n  rotation: null,\n\n  /**\n   * Scale relative to its parent node\n   * @type {clay.Vector3}\n   */\n  scale: null,\n\n  /**\n   * Affine transform matrix relative to its root scene.\n   * @type {clay.Matrix4}\n   */\n  worldTransform: null,\n\n  /**\n   * Affine transform matrix relative to its parent node.\n   * Composited with position, rotation and scale.\n   * @type {clay.Matrix4}\n   */\n  localTransform: null,\n\n  /**\n   * If the local transform is update from SRT(scale, rotation, translation, which is position here) each frame\n   * @type {boolean}\n   */\n  autoUpdateLocalTransform: true,\n\n  /**\n   * Parent of current scene node\n   * @type {?clay.Node}\n   * @private\n   */\n  _parent: null,\n\n  /**\n   * The root scene mounted. Null if it is a isolated node\n   * @type {?clay.Scene}\n   * @private\n   */\n  _scene: null,\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  _needsUpdateWorldTransform: true,\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  _inIterating: false,\n  // Depth for transparent list sorting\n  __depth: 0\n}, function () {\n  if (!this.name) {\n    this.name = (this.type || 'NODE') + '_' + nameId++;\n  }\n\n  if (!this.position) {\n    this.position = new Vector3();\n  }\n\n  if (!this.rotation) {\n    this.rotation = new Quaternion();\n  }\n\n  if (!this.scale) {\n    this.scale = new Vector3(1, 1, 1);\n  }\n\n  this.worldTransform = new Matrix4();\n  this.localTransform = new Matrix4();\n  this._children = [];\n},\n/**@lends clay.Node.prototype. */\n{\n  /**\n   * @type {?clay.Vector3}\n   * @instance\n   */\n  target: null,\n\n  /**\n   * If node and its chilren invisible\n   * @type {boolean}\n   * @instance\n   */\n  invisible: false,\n\n  /**\n   * If Node is a skinned mesh\n   * @return {boolean}\n   */\n  isSkinnedMesh: function isSkinnedMesh() {\n    return false;\n  },\n\n  /**\n   * Return true if it is a renderable scene node, like Mesh and ParticleSystem\n   * @return {boolean}\n   */\n  isRenderable: function isRenderable() {\n    return false;\n  },\n\n  /**\n   * Set the name of the scene node\n   * @param {string} name\n   */\n  setName: function setName(name) {\n    var scene = this._scene;\n\n    if (scene) {\n      var nodeRepository = scene._nodeRepository;\n      delete nodeRepository[this.name];\n      nodeRepository[name] = this;\n    }\n\n    this.name = name;\n  },\n\n  /**\n   * Add a child node\n   * @param {clay.Node} node\n   */\n  add: function add(node) {\n    var originalParent = node._parent;\n\n    if (originalParent === this) {\n      return;\n    }\n\n    if (originalParent) {\n      originalParent.remove(node);\n    }\n\n    node._parent = this;\n\n    this._children.push(node);\n\n    var scene = this._scene;\n\n    if (scene && scene !== node.scene) {\n      node.traverse(this._addSelfToScene, this);\n    } // Mark children needs update transform\n    // In case child are remove and added again after parent moved\n\n\n    node._needsUpdateWorldTransform = true;\n  },\n\n  /**\n   * Remove the given child scene node\n   * @param {clay.Node} node\n   */\n  remove: function remove(node) {\n    var children = this._children;\n    var idx = children.indexOf(node);\n\n    if (idx < 0) {\n      return;\n    }\n\n    children.splice(idx, 1);\n    node._parent = null;\n\n    if (this._scene) {\n      node.traverse(this._removeSelfFromScene, this);\n    }\n  },\n\n  /**\n   * Remove all children\n   */\n  removeAll: function removeAll() {\n    var children = this._children;\n\n    for (var idx = 0; idx < children.length; idx++) {\n      children[idx]._parent = null;\n\n      if (this._scene) {\n        children[idx].traverse(this._removeSelfFromScene, this);\n      }\n    }\n\n    this._children = [];\n  },\n\n  /**\n   * Get the scene mounted\n   * @return {clay.Scene}\n   */\n  getScene: function getScene() {\n    return this._scene;\n  },\n\n  /**\n   * Get parent node\n   * @return {clay.Scene}\n   */\n  getParent: function getParent() {\n    return this._parent;\n  },\n  _removeSelfFromScene: function _removeSelfFromScene(descendant) {\n    descendant._scene.removeFromScene(descendant);\n\n    descendant._scene = null;\n  },\n  _addSelfToScene: function _addSelfToScene(descendant) {\n    this._scene.addToScene(descendant);\n\n    descendant._scene = this._scene;\n  },\n\n  /**\n   * Return true if it is ancestor of the given scene node\n   * @param {clay.Node} node\n   */\n  isAncestor: function isAncestor(node) {\n    var parent = node._parent;\n\n    while (parent) {\n      if (parent === this) {\n        return true;\n      }\n\n      parent = parent._parent;\n    }\n\n    return false;\n  },\n\n  /**\n   * Get a new created array of all children nodes\n   * @return {clay.Node[]}\n   */\n  children: function children() {\n    return this._children.slice();\n  },\n\n  /**\n   * Get child scene node at given index.\n   * @param {number} idx\n   * @return {clay.Node}\n   */\n  childAt: function childAt(idx) {\n    return this._children[idx];\n  },\n\n  /**\n   * Get first child with the given name\n   * @param {string} name\n   * @return {clay.Node}\n   */\n  getChildByName: function getChildByName(name) {\n    var children = this._children;\n\n    for (var i = 0; i < children.length; i++) {\n      if (children[i].name === name) {\n        return children[i];\n      }\n    }\n  },\n\n  /**\n   * Get first descendant have the given name\n   * @param {string} name\n   * @return {clay.Node}\n   */\n  getDescendantByName: function getDescendantByName(name) {\n    var children = this._children;\n\n    for (var i = 0; i < children.length; i++) {\n      var child = children[i];\n\n      if (child.name === name) {\n        return child;\n      } else {\n        var res = child.getDescendantByName(name);\n\n        if (res) {\n          return res;\n        }\n      }\n    }\n  },\n\n  /**\n   * Query descendant node by path\n   * @param {string} path\n   * @return {clay.Node}\n   * @example\n   *  node.queryNode('root/parent/child');\n   */\n  queryNode: function queryNode(path) {\n    if (!path) {\n      return;\n    } // TODO Name have slash ?\n\n\n    var pathArr = path.split('/');\n    var current = this;\n\n    for (var i = 0; i < pathArr.length; i++) {\n      var name = pathArr[i]; // Skip empty\n\n      if (!name) {\n        continue;\n      }\n\n      var found = false;\n      var children = current._children;\n\n      for (var j = 0; j < children.length; j++) {\n        var child = children[j];\n\n        if (child.name === name) {\n          current = child;\n          found = true;\n          break;\n        }\n      } // Early return if not found\n\n\n      if (!found) {\n        return;\n      }\n    }\n\n    return current;\n  },\n\n  /**\n   * Get query path, relative to rootNode(default is scene)\n   * @param {clay.Node} [rootNode]\n   * @return {string}\n   */\n  getPath: function getPath(rootNode) {\n    if (!this._parent) {\n      return '/';\n    }\n\n    var current = this._parent;\n    var path = this.name;\n\n    while (current._parent) {\n      path = current.name + '/' + path;\n\n      if (current._parent == rootNode) {\n        break;\n      }\n\n      current = current._parent;\n    }\n\n    if (!current._parent && rootNode) {\n      return null;\n    }\n\n    return path;\n  },\n\n  /**\n   * Depth first traverse all its descendant scene nodes.\n   *\n   * **WARN** Don't do `add`, `remove` operation in the callback during traverse.\n   * @param {Function} callback\n   * @param {Node} [context]\n   */\n  traverse: function traverse(callback, context) {\n    callback.call(context, this);\n    var _children = this._children;\n\n    for (var i = 0, len = _children.length; i < len; i++) {\n      _children[i].traverse(callback, context);\n    }\n  },\n\n  /**\n   * Traverse all children nodes.\n   *\n   * **WARN** DON'T do `add`, `remove` operation in the callback during iteration.\n   *\n   * @param {Function} callback\n   * @param {Node} [context]\n   */\n  eachChild: function eachChild(callback, context) {\n    var _children = this._children;\n\n    for (var i = 0, len = _children.length; i < len; i++) {\n      var child = _children[i];\n      callback.call(context, child, i);\n    }\n  },\n\n  /**\n   * Set the local transform and decompose to SRT\n   * @param {clay.Matrix4} matrix\n   */\n  setLocalTransform: function setLocalTransform(matrix) {\n    mat4.copy(this.localTransform.array, matrix.array);\n    this.decomposeLocalTransform();\n  },\n\n  /**\n   * Decompose the local transform to SRT\n   */\n  decomposeLocalTransform: function decomposeLocalTransform(keepScale) {\n    var scale = !keepScale ? this.scale : null;\n    this.localTransform.decomposeMatrix(scale, this.rotation, this.position);\n  },\n\n  /**\n   * Set the world transform and decompose to SRT\n   * @param {clay.Matrix4} matrix\n   */\n  setWorldTransform: function setWorldTransform(matrix) {\n    mat4.copy(this.worldTransform.array, matrix.array);\n    this.decomposeWorldTransform();\n  },\n\n  /**\n   * Decompose the world transform to SRT\n   * @function\n   */\n  decomposeWorldTransform: function () {\n    var tmp = mat4.create();\n    return function (keepScale) {\n      var localTransform = this.localTransform;\n      var worldTransform = this.worldTransform; // Assume world transform is updated\n\n      if (this._parent) {\n        mat4.invert(tmp, this._parent.worldTransform.array);\n        mat4.multiply(localTransform.array, tmp, worldTransform.array);\n      } else {\n        mat4.copy(localTransform.array, worldTransform.array);\n      }\n\n      var scale = !keepScale ? this.scale : null;\n      localTransform.decomposeMatrix(scale, this.rotation, this.position);\n    };\n  }(),\n  transformNeedsUpdate: function transformNeedsUpdate() {\n    return this.position._dirty || this.rotation._dirty || this.scale._dirty;\n  },\n\n  /**\n   * Update local transform from SRT\n   * Notice that local transform will not be updated if _dirty mark of position, rotation, scale is all false\n   */\n  updateLocalTransform: function updateLocalTransform() {\n    var position = this.position;\n    var rotation = this.rotation;\n    var scale = this.scale;\n\n    if (this.transformNeedsUpdate()) {\n      var m = this.localTransform.array; // Transform order, scale->rotation->position\n\n      mat4.fromRotationTranslation(m, rotation.array, position.array);\n      mat4.scale(m, m, scale.array);\n      rotation._dirty = false;\n      scale._dirty = false;\n      position._dirty = false;\n      this._needsUpdateWorldTransform = true;\n    }\n  },\n\n  /**\n   * Update world transform, assume its parent world transform have been updated\n   * @private\n   */\n  _updateWorldTransformTopDown: function _updateWorldTransformTopDown() {\n    var localTransform = this.localTransform.array;\n    var worldTransform = this.worldTransform.array;\n\n    if (this._parent) {\n      mat4.multiplyAffine(worldTransform, this._parent.worldTransform.array, localTransform);\n    } else {\n      mat4.copy(worldTransform, localTransform);\n    }\n  },\n\n  /**\n   * Update world transform before whole scene is updated.\n   */\n  updateWorldTransform: function updateWorldTransform() {\n    // Find the root node which transform needs update;\n    var rootNodeIsDirty = this;\n\n    while (rootNodeIsDirty && rootNodeIsDirty.getParent() && rootNodeIsDirty.getParent().transformNeedsUpdate()) {\n      rootNodeIsDirty = rootNodeIsDirty.getParent();\n    }\n\n    rootNodeIsDirty.update();\n  },\n\n  /**\n   * Update local transform and world transform recursively\n   * @param {boolean} forceUpdateWorld\n   */\n  update: function update(forceUpdateWorld) {\n    if (this.autoUpdateLocalTransform) {\n      this.updateLocalTransform();\n    } else {\n      // Transform is manually setted\n      forceUpdateWorld = true;\n    }\n\n    if (forceUpdateWorld || this._needsUpdateWorldTransform) {\n      this._updateWorldTransformTopDown();\n\n      forceUpdateWorld = true;\n      this._needsUpdateWorldTransform = false;\n    }\n\n    var children = this._children;\n\n    for (var i = 0, len = children.length; i < len; i++) {\n      children[i].update(forceUpdateWorld);\n    }\n  },\n\n  /**\n   * Get bounding box of node\n   * @param  {Function} [filter]\n   * @param  {clay.BoundingBox} [out]\n   * @return {clay.BoundingBox}\n   */\n  // TODO Skinning\n  getBoundingBox: function () {\n    function defaultFilter(el) {\n      return !el.invisible && el.geometry;\n    }\n\n    var tmpBBox = new BoundingBox();\n    var tmpMat4 = new Matrix4();\n    var invWorldTransform = new Matrix4();\n    return function (filter, out) {\n      out = out || new BoundingBox();\n      filter = filter || defaultFilter;\n\n      if (this._parent) {\n        Matrix4.invert(invWorldTransform, this._parent.worldTransform);\n      } else {\n        Matrix4.identity(invWorldTransform);\n      }\n\n      this.traverse(function (mesh) {\n        if (mesh.geometry && mesh.geometry.boundingBox) {\n          tmpBBox.copy(mesh.geometry.boundingBox);\n          Matrix4.multiply(tmpMat4, invWorldTransform, mesh.worldTransform);\n          tmpBBox.applyTransform(tmpMat4);\n          out.union(tmpBBox);\n        }\n      }, this, defaultFilter);\n      return out;\n    };\n  }(),\n\n  /**\n   * Get world position, extracted from world transform\n   * @param  {clay.Vector3} [out]\n   * @return {clay.Vector3}\n   */\n  getWorldPosition: function getWorldPosition(out) {\n    // PENDING\n    if (this.transformNeedsUpdate()) {\n      this.updateWorldTransform();\n    }\n\n    var m = this.worldTransform.array;\n\n    if (out) {\n      var arr = out.array;\n      arr[0] = m[12];\n      arr[1] = m[13];\n      arr[2] = m[14];\n      return out;\n    } else {\n      return new Vector3(m[12], m[13], m[14]);\n    }\n  },\n\n  /**\n   * Clone a new node\n   * @return {Node}\n   */\n  clone: function clone() {\n    var node = new this.constructor();\n    var children = this._children;\n    node.setName(this.name);\n    node.position.copy(this.position);\n    node.rotation.copy(this.rotation);\n    node.scale.copy(this.scale);\n\n    for (var i = 0; i < children.length; i++) {\n      node.add(children[i].clone());\n    }\n\n    return node;\n  },\n\n  /**\n   * Rotate the node around a axis by angle degrees, axis passes through point\n   * @param {clay.Vector3} point Center point\n   * @param {clay.Vector3} axis  Center axis\n   * @param {number}       angle Rotation angle\n   * @see http://docs.unity3d.com/Documentation/ScriptReference/Transform.RotateAround.html\n   * @function\n   */\n  rotateAround: function () {\n    var v = new Vector3();\n    var RTMatrix = new Matrix4(); // TODO improve performance\n\n    return function (point, axis, angle) {\n      v.copy(this.position).subtract(point);\n      var localTransform = this.localTransform;\n      localTransform.identity(); // parent node\n\n      localTransform.translate(point);\n      localTransform.rotate(angle, axis);\n      RTMatrix.fromRotationTranslation(this.rotation, v);\n      localTransform.multiply(RTMatrix);\n      localTransform.scale(this.scale);\n      this.decomposeLocalTransform();\n      this._needsUpdateWorldTransform = true;\n    };\n  }(),\n\n  /**\n   * @param {clay.Vector3} target\n   * @param {clay.Vector3} [up]\n   * @see http://www.opengl.org/sdk/docs/man2/xhtml/gluLookAt.xml\n   * @function\n   */\n  lookAt: function () {\n    var m = new Matrix4();\n    return function (target, up) {\n      m.lookAt(this.position, target, up || this.localTransform.y).invert();\n      this.setLocalTransform(m);\n      this.target = target;\n    };\n  }()\n});\nexport default Node;","map":{"version":3,"sources":["C:/Users/Administrator/Desktop/data_view/my_project/vue2_app/myapp/node_modules/_claygl@1.3.0@claygl/src/Node.js"],"names":["Base","Vector3","Quaternion","Matrix4","mat4","BoundingBox","nameId","Node","extend","name","position","rotation","scale","worldTransform","localTransform","autoUpdateLocalTransform","_parent","_scene","_needsUpdateWorldTransform","_inIterating","__depth","type","_children","target","invisible","isSkinnedMesh","isRenderable","setName","scene","nodeRepository","_nodeRepository","add","node","originalParent","remove","push","traverse","_addSelfToScene","children","idx","indexOf","splice","_removeSelfFromScene","removeAll","length","getScene","getParent","descendant","removeFromScene","addToScene","isAncestor","parent","slice","childAt","getChildByName","i","getDescendantByName","child","res","queryNode","path","pathArr","split","current","found","j","getPath","rootNode","callback","context","call","len","eachChild","setLocalTransform","matrix","copy","array","decomposeLocalTransform","keepScale","decomposeMatrix","setWorldTransform","decomposeWorldTransform","tmp","create","invert","multiply","transformNeedsUpdate","_dirty","updateLocalTransform","m","fromRotationTranslation","_updateWorldTransformTopDown","multiplyAffine","updateWorldTransform","rootNodeIsDirty","update","forceUpdateWorld","getBoundingBox","defaultFilter","el","geometry","tmpBBox","tmpMat4","invWorldTransform","filter","out","identity","mesh","boundingBox","applyTransform","union","getWorldPosition","arr","clone","constructor","rotateAround","v","RTMatrix","point","axis","angle","subtract","translate","rotate","lookAt","up","y"],"mappings":"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","sourcesContent":["import Base from './core/Base';\nimport Vector3 from './math/Vector3';\nimport Quaternion from './math/Quaternion';\nimport Matrix4 from './math/Matrix4';\nimport mat4 from './glmatrix/mat4';\nimport BoundingBox from './math/BoundingBox';\n\nvar nameId = 0;\n\n/**\n * @constructor clay.Node\n * @extends clay.core.Base\n */\nvar Node = Base.extend(/** @lends clay.Node# */{\n    /**\n     * Scene node name\n     * @type {string}\n     */\n    name: '',\n\n    /**\n     * Position relative to its parent node. aka translation.\n     * @type {clay.Vector3}\n     */\n    position: null,\n\n    /**\n     * Rotation relative to its parent node. Represented by a quaternion\n     * @type {clay.Quaternion}\n     */\n    rotation: null,\n\n    /**\n     * Scale relative to its parent node\n     * @type {clay.Vector3}\n     */\n    scale: null,\n\n    /**\n     * Affine transform matrix relative to its root scene.\n     * @type {clay.Matrix4}\n     */\n    worldTransform: null,\n\n    /**\n     * Affine transform matrix relative to its parent node.\n     * Composited with position, rotation and scale.\n     * @type {clay.Matrix4}\n     */\n    localTransform: null,\n\n    /**\n     * If the local transform is update from SRT(scale, rotation, translation, which is position here) each frame\n     * @type {boolean}\n     */\n    autoUpdateLocalTransform: true,\n\n    /**\n     * Parent of current scene node\n     * @type {?clay.Node}\n     * @private\n     */\n    _parent: null,\n    /**\n     * The root scene mounted. Null if it is a isolated node\n     * @type {?clay.Scene}\n     * @private\n     */\n    _scene: null,\n    /**\n     * @type {boolean}\n     * @private\n     */\n    _needsUpdateWorldTransform: true,\n    /**\n     * @type {boolean}\n     * @private\n     */\n    _inIterating: false,\n\n    // Depth for transparent list sorting\n    __depth: 0\n\n}, function () {\n\n    if (!this.name) {\n        this.name = (this.type || 'NODE') + '_' + (nameId++);\n    }\n\n    if (!this.position) {\n        this.position = new Vector3();\n    }\n    if (!this.rotation) {\n        this.rotation = new Quaternion();\n    }\n    if (!this.scale) {\n        this.scale = new Vector3(1, 1, 1);\n    }\n\n    this.worldTransform = new Matrix4();\n    this.localTransform = new Matrix4();\n\n    this._children = [];\n\n},\n/**@lends clay.Node.prototype. */\n{\n\n    /**\n     * @type {?clay.Vector3}\n     * @instance\n     */\n    target: null,\n    /**\n     * If node and its chilren invisible\n     * @type {boolean}\n     * @instance\n     */\n    invisible: false,\n\n    /**\n     * If Node is a skinned mesh\n     * @return {boolean}\n     */\n    isSkinnedMesh: function () {\n        return false;\n    },\n    /**\n     * Return true if it is a renderable scene node, like Mesh and ParticleSystem\n     * @return {boolean}\n     */\n    isRenderable: function () {\n        return false;\n    },\n\n    /**\n     * Set the name of the scene node\n     * @param {string} name\n     */\n    setName: function (name) {\n        var scene = this._scene;\n        if (scene) {\n            var nodeRepository = scene._nodeRepository;\n            delete nodeRepository[this.name];\n            nodeRepository[name] = this;\n        }\n        this.name = name;\n    },\n\n    /**\n     * Add a child node\n     * @param {clay.Node} node\n     */\n    add: function (node) {\n        var originalParent = node._parent;\n        if (originalParent === this) {\n            return;\n        }\n        if (originalParent) {\n            originalParent.remove(node);\n        }\n        node._parent = this;\n        this._children.push(node);\n\n        var scene = this._scene;\n        if (scene && scene !== node.scene) {\n            node.traverse(this._addSelfToScene, this);\n        }\n        // Mark children needs update transform\n        // In case child are remove and added again after parent moved\n        node._needsUpdateWorldTransform = true;\n    },\n\n    /**\n     * Remove the given child scene node\n     * @param {clay.Node} node\n     */\n    remove: function (node) {\n        var children = this._children;\n        var idx = children.indexOf(node);\n        if (idx < 0) {\n            return;\n        }\n\n        children.splice(idx, 1);\n        node._parent = null;\n\n        if (this._scene) {\n            node.traverse(this._removeSelfFromScene, this);\n        }\n    },\n\n    /**\n     * Remove all children\n     */\n    removeAll: function () {\n        var children = this._children;\n\n        for (var idx = 0; idx < children.length; idx++) {\n            children[idx]._parent = null;\n\n            if (this._scene) {\n                children[idx].traverse(this._removeSelfFromScene, this);\n            }\n        }\n\n        this._children = [];\n    },\n\n    /**\n     * Get the scene mounted\n     * @return {clay.Scene}\n     */\n    getScene: function () {\n        return this._scene;\n    },\n\n    /**\n     * Get parent node\n     * @return {clay.Scene}\n     */\n    getParent: function () {\n        return this._parent;\n    },\n\n    _removeSelfFromScene: function (descendant) {\n        descendant._scene.removeFromScene(descendant);\n        descendant._scene = null;\n    },\n\n    _addSelfToScene: function (descendant) {\n        this._scene.addToScene(descendant);\n        descendant._scene = this._scene;\n    },\n\n    /**\n     * Return true if it is ancestor of the given scene node\n     * @param {clay.Node} node\n     */\n    isAncestor: function (node) {\n        var parent = node._parent;\n        while(parent) {\n            if (parent === this) {\n                return true;\n            }\n            parent = parent._parent;\n        }\n        return false;\n    },\n\n    /**\n     * Get a new created array of all children nodes\n     * @return {clay.Node[]}\n     */\n    children: function () {\n        return this._children.slice();\n    },\n\n    /**\n     * Get child scene node at given index.\n     * @param {number} idx\n     * @return {clay.Node}\n     */\n    childAt: function (idx) {\n        return this._children[idx];\n    },\n\n    /**\n     * Get first child with the given name\n     * @param {string} name\n     * @return {clay.Node}\n     */\n    getChildByName: function (name) {\n        var children = this._children;\n        for (var i = 0; i < children.length; i++) {\n            if (children[i].name === name) {\n                return children[i];\n            }\n        }\n    },\n\n    /**\n     * Get first descendant have the given name\n     * @param {string} name\n     * @return {clay.Node}\n     */\n    getDescendantByName: function (name) {\n        var children = this._children;\n        for (var i = 0; i < children.length; i++) {\n            var child = children[i];\n            if (child.name === name) {\n                return child;\n            } else {\n                var res = child.getDescendantByName(name);\n                if (res) {\n                    return res;\n                }\n            }\n        }\n    },\n\n    /**\n     * Query descendant node by path\n     * @param {string} path\n     * @return {clay.Node}\n     * @example\n     *  node.queryNode('root/parent/child');\n     */\n    queryNode: function (path) {\n        if (!path) {\n            return;\n        }\n        // TODO Name have slash ?\n        var pathArr = path.split('/');\n        var current = this;\n        for (var i = 0; i < pathArr.length; i++) {\n            var name = pathArr[i];\n            // Skip empty\n            if (!name) {\n                continue;\n            }\n            var found = false;\n            var children = current._children;\n            for (var j = 0; j < children.length; j++) {\n                var child = children[j];\n                if (child.name === name) {\n                    current = child;\n                    found = true;\n                    break;\n                }\n            }\n            // Early return if not found\n            if (!found) {\n                return;\n            }\n        }\n\n        return current;\n    },\n\n    /**\n     * Get query path, relative to rootNode(default is scene)\n     * @param {clay.Node} [rootNode]\n     * @return {string}\n     */\n    getPath: function (rootNode) {\n        if (!this._parent) {\n            return '/';\n        }\n\n        var current = this._parent;\n        var path = this.name;\n        while (current._parent) {\n            path = current.name + '/' + path;\n            if (current._parent == rootNode) {\n                break;\n            }\n            current = current._parent;\n        }\n        if (!current._parent && rootNode) {\n            return null;\n        }\n        return path;\n    },\n\n    /**\n     * Depth first traverse all its descendant scene nodes.\n     *\n     * **WARN** Don't do `add`, `remove` operation in the callback during traverse.\n     * @param {Function} callback\n     * @param {Node} [context]\n     */\n    traverse: function (callback, context) {\n        callback.call(context, this);\n        var _children = this._children;\n        for(var i = 0, len = _children.length; i < len; i++) {\n            _children[i].traverse(callback, context);\n        }\n    },\n\n    /**\n     * Traverse all children nodes.\n     *\n     * **WARN** DON'T do `add`, `remove` operation in the callback during iteration.\n     *\n     * @param {Function} callback\n     * @param {Node} [context]\n     */\n    eachChild: function (callback, context) {\n        var _children = this._children;\n        for(var i = 0, len = _children.length; i < len; i++) {\n            var child = _children[i];\n            callback.call(context, child, i);\n        }\n    },\n\n    /**\n     * Set the local transform and decompose to SRT\n     * @param {clay.Matrix4} matrix\n     */\n    setLocalTransform: function (matrix) {\n        mat4.copy(this.localTransform.array, matrix.array);\n        this.decomposeLocalTransform();\n    },\n\n    /**\n     * Decompose the local transform to SRT\n     */\n    decomposeLocalTransform: function (keepScale) {\n        var scale = !keepScale ? this.scale: null;\n        this.localTransform.decomposeMatrix(scale, this.rotation, this.position);\n    },\n\n    /**\n     * Set the world transform and decompose to SRT\n     * @param {clay.Matrix4} matrix\n     */\n    setWorldTransform: function (matrix) {\n        mat4.copy(this.worldTransform.array, matrix.array);\n        this.decomposeWorldTransform();\n    },\n\n    /**\n     * Decompose the world transform to SRT\n     * @function\n     */\n    decomposeWorldTransform: (function () {\n\n        var tmp = mat4.create();\n\n        return function (keepScale) {\n            var localTransform = this.localTransform;\n            var worldTransform = this.worldTransform;\n            // Assume world transform is updated\n            if (this._parent) {\n                mat4.invert(tmp, this._parent.worldTransform.array);\n                mat4.multiply(localTransform.array, tmp, worldTransform.array);\n            } else {\n                mat4.copy(localTransform.array, worldTransform.array);\n            }\n            var scale = !keepScale ? this.scale: null;\n            localTransform.decomposeMatrix(scale, this.rotation, this.position);\n        };\n    })(),\n\n    transformNeedsUpdate: function () {\n        return this.position._dirty\n            || this.rotation._dirty\n            || this.scale._dirty;\n    },\n\n    /**\n     * Update local transform from SRT\n     * Notice that local transform will not be updated if _dirty mark of position, rotation, scale is all false\n     */\n    updateLocalTransform: function () {\n        var position = this.position;\n        var rotation = this.rotation;\n        var scale = this.scale;\n\n        if (this.transformNeedsUpdate()) {\n            var m = this.localTransform.array;\n\n            // Transform order, scale->rotation->position\n            mat4.fromRotationTranslation(m, rotation.array, position.array);\n\n            mat4.scale(m, m, scale.array);\n\n            rotation._dirty = false;\n            scale._dirty = false;\n            position._dirty = false;\n\n            this._needsUpdateWorldTransform = true;\n        }\n    },\n\n    /**\n     * Update world transform, assume its parent world transform have been updated\n     * @private\n     */\n    _updateWorldTransformTopDown: function () {\n        var localTransform = this.localTransform.array;\n        var worldTransform = this.worldTransform.array;\n        if (this._parent) {\n            mat4.multiplyAffine(\n                worldTransform,\n                this._parent.worldTransform.array,\n                localTransform\n            );\n        }\n        else {\n            mat4.copy(worldTransform, localTransform);\n        }\n    },\n\n    /**\n     * Update world transform before whole scene is updated.\n     */\n    updateWorldTransform: function () {\n        // Find the root node which transform needs update;\n        var rootNodeIsDirty = this;\n        while (rootNodeIsDirty && rootNodeIsDirty.getParent()\n            && rootNodeIsDirty.getParent().transformNeedsUpdate()\n        ) {\n            rootNodeIsDirty = rootNodeIsDirty.getParent();\n        }\n        rootNodeIsDirty.update();\n    },\n\n    /**\n     * Update local transform and world transform recursively\n     * @param {boolean} forceUpdateWorld\n     */\n    update: function (forceUpdateWorld) {\n        if (this.autoUpdateLocalTransform) {\n            this.updateLocalTransform();\n        }\n        else {\n            // Transform is manually setted\n            forceUpdateWorld = true;\n        }\n\n        if (forceUpdateWorld || this._needsUpdateWorldTransform) {\n            this._updateWorldTransformTopDown();\n            forceUpdateWorld = true;\n            this._needsUpdateWorldTransform = false;\n        }\n\n        var children = this._children;\n        for(var i = 0, len = children.length; i < len; i++) {\n            children[i].update(forceUpdateWorld);\n        }\n    },\n\n    /**\n     * Get bounding box of node\n     * @param  {Function} [filter]\n     * @param  {clay.BoundingBox} [out]\n     * @return {clay.BoundingBox}\n     */\n    // TODO Skinning\n    getBoundingBox: (function () {\n        function defaultFilter (el) {\n            return !el.invisible && el.geometry;\n        }\n        var tmpBBox = new BoundingBox();\n        var tmpMat4 = new Matrix4();\n        var invWorldTransform = new Matrix4();\n        return function (filter, out) {\n            out = out || new BoundingBox();\n            filter = filter || defaultFilter;\n\n            if (this._parent) {\n                Matrix4.invert(invWorldTransform, this._parent.worldTransform);\n            }\n            else {\n                Matrix4.identity(invWorldTransform);\n            }\n\n            this.traverse(function (mesh) {\n                if (mesh.geometry && mesh.geometry.boundingBox) {\n                    tmpBBox.copy(mesh.geometry.boundingBox);\n                    Matrix4.multiply(tmpMat4, invWorldTransform, mesh.worldTransform);\n                    tmpBBox.applyTransform(tmpMat4);\n                    out.union(tmpBBox);\n                }\n            }, this, defaultFilter);\n\n            return out;\n        };\n    })(),\n\n    /**\n     * Get world position, extracted from world transform\n     * @param  {clay.Vector3} [out]\n     * @return {clay.Vector3}\n     */\n    getWorldPosition: function (out) {\n        // PENDING\n        if (this.transformNeedsUpdate()) {\n            this.updateWorldTransform();\n        }\n        var m = this.worldTransform.array;\n        if (out) {\n            var arr = out.array;\n            arr[0] = m[12];\n            arr[1] = m[13];\n            arr[2] = m[14];\n            return out;\n        }\n        else {\n            return new Vector3(m[12], m[13], m[14]);\n        }\n    },\n\n    /**\n     * Clone a new node\n     * @return {Node}\n     */\n    clone: function () {\n        var node = new this.constructor();\n\n        var children = this._children;\n\n        node.setName(this.name);\n        node.position.copy(this.position);\n        node.rotation.copy(this.rotation);\n        node.scale.copy(this.scale);\n\n        for (var i = 0; i < children.length; i++) {\n            node.add(children[i].clone());\n        }\n\n        return node;\n    },\n\n    /**\n     * Rotate the node around a axis by angle degrees, axis passes through point\n     * @param {clay.Vector3} point Center point\n     * @param {clay.Vector3} axis  Center axis\n     * @param {number}       angle Rotation angle\n     * @see http://docs.unity3d.com/Documentation/ScriptReference/Transform.RotateAround.html\n     * @function\n     */\n    rotateAround: (function () {\n        var v = new Vector3();\n        var RTMatrix = new Matrix4();\n\n        // TODO improve performance\n        return function (point, axis, angle) {\n\n            v.copy(this.position).subtract(point);\n\n            var localTransform = this.localTransform;\n            localTransform.identity();\n            // parent node\n            localTransform.translate(point);\n            localTransform.rotate(angle, axis);\n\n            RTMatrix.fromRotationTranslation(this.rotation, v);\n            localTransform.multiply(RTMatrix);\n            localTransform.scale(this.scale);\n\n            this.decomposeLocalTransform();\n            this._needsUpdateWorldTransform = true;\n        };\n    })(),\n\n    /**\n     * @param {clay.Vector3} target\n     * @param {clay.Vector3} [up]\n     * @see http://www.opengl.org/sdk/docs/man2/xhtml/gluLookAt.xml\n     * @function\n     */\n    lookAt: (function () {\n        var m = new Matrix4();\n        return function (target, up) {\n            m.lookAt(this.position, target, up || this.localTransform.y).invert();\n            this.setLocalTransform(m);\n\n            this.target = target;\n        };\n    })()\n});\n\nexport default Node;\n"]},"metadata":{},"sourceType":"module"}