{"ast":null,"code":"import * as echarts from 'echarts/lib/echarts';\nimport graphicGL from '../../util/graphicGL';\nimport ViewGL from '../../core/ViewGL';\nimport Lines2DGeometry from '../../util/geometry/Lines2D';\nimport GLViewHelper from '../common/GLViewHelper';\nimport { getItemVisualColor, getItemVisualOpacity } from '../../util/visual';\nimport retrieve from '../../util/retrieve';\nexport default echarts.ChartView.extend({\n  type: 'linesGL',\n  __ecgl__: true,\n  init: function init(ecModel, api) {\n    this.groupGL = new graphicGL.Node();\n    this.viewGL = new ViewGL('orthographic');\n    this.viewGL.add(this.groupGL);\n    this._glViewHelper = new GLViewHelper(this.viewGL);\n    this._nativeLinesShader = graphicGL.createShader('ecgl.lines3D');\n    this._meshLinesShader = graphicGL.createShader('ecgl.meshLines3D');\n    this._linesMeshes = [];\n    this._currentStep = 0;\n  },\n  render: function render(seriesModel, ecModel, api) {\n    this.groupGL.removeAll();\n\n    this._glViewHelper.reset(seriesModel, api);\n\n    var linesMesh = this._linesMeshes[0];\n\n    if (!linesMesh) {\n      linesMesh = this._linesMeshes[0] = this._createLinesMesh(seriesModel);\n    }\n\n    this._linesMeshes.length = 1;\n    this.groupGL.add(linesMesh);\n\n    this._updateLinesMesh(seriesModel, linesMesh, 0, seriesModel.getData().count());\n\n    this.viewGL.setPostEffect(seriesModel.getModel('postEffect'), api);\n  },\n  incrementalPrepareRender: function incrementalPrepareRender(seriesModel, ecModel, api) {\n    this.groupGL.removeAll();\n\n    this._glViewHelper.reset(seriesModel, api);\n\n    this._currentStep = 0;\n    this.viewGL.setPostEffect(seriesModel.getModel('postEffect'), api);\n  },\n  incrementalRender: function incrementalRender(params, seriesModel, ecModel, api) {\n    var linesMesh = this._linesMeshes[this._currentStep];\n\n    if (!linesMesh) {\n      linesMesh = this._createLinesMesh(seriesModel);\n      this._linesMeshes[this._currentStep] = linesMesh;\n    }\n\n    this._updateLinesMesh(seriesModel, linesMesh, params.start, params.end);\n\n    this.groupGL.add(linesMesh);\n    api.getZr().refresh();\n    this._currentStep++;\n  },\n  updateTransform: function updateTransform(seriesModel, ecModel, api) {\n    if (seriesModel.coordinateSystem.getRoamTransform) {\n      this._glViewHelper.updateTransform(seriesModel, api);\n    }\n  },\n  _createLinesMesh: function _createLinesMesh(seriesModel) {\n    var linesMesh = new graphicGL.Mesh({\n      $ignorePicking: true,\n      material: new graphicGL.Material({\n        shader: graphicGL.createShader('ecgl.lines3D'),\n        transparent: true,\n        depthMask: false,\n        depthTest: false\n      }),\n      geometry: new Lines2DGeometry({\n        segmentScale: 10,\n        useNativeLine: true,\n        dynamic: false\n      }),\n      mode: graphicGL.Mesh.LINES,\n      culling: false\n    });\n    return linesMesh;\n  },\n  _updateLinesMesh: function _updateLinesMesh(seriesModel, linesMesh, start, end) {\n    var data = seriesModel.getData();\n    linesMesh.material.blend = seriesModel.get('blendMode') === 'lighter' ? graphicGL.additiveBlend : null;\n    var curveness = seriesModel.get('lineStyle.curveness') || 0;\n    var isPolyline = seriesModel.get('polyline');\n    var geometry = linesMesh.geometry;\n    var coordSys = seriesModel.coordinateSystem;\n    var lineWidth = retrieve.firstNotNull(seriesModel.get('lineStyle.width'), 1);\n\n    if (lineWidth > 1) {\n      if (linesMesh.material.shader !== this._meshLinesShader) {\n        linesMesh.material.attachShader(this._meshLinesShader);\n      }\n\n      linesMesh.mode = graphicGL.Mesh.TRIANGLES;\n    } else {\n      if (linesMesh.material.shader !== this._nativeLinesShader) {\n        linesMesh.material.attachShader(this._nativeLinesShader);\n      }\n\n      linesMesh.mode = graphicGL.Mesh.LINES;\n    }\n\n    start = start || 0;\n    end = end || data.count();\n    geometry.resetOffset();\n    var vertexCount = 0;\n    var triangleCount = 0;\n    var p0 = [];\n    var p1 = [];\n    var p2 = [];\n    var p3 = [];\n    var lineCoords = [];\n    var t = 0.3;\n    var t2 = 0.7;\n\n    function updateBezierControlPoints() {\n      p1[0] = p0[0] * t2 + p3[0] * t - (p0[1] - p3[1]) * curveness;\n      p1[1] = p0[1] * t2 + p3[1] * t - (p3[0] - p0[0]) * curveness;\n      p2[0] = p0[0] * t + p3[0] * t2 - (p0[1] - p3[1]) * curveness;\n      p2[1] = p0[1] * t + p3[1] * t2 - (p3[0] - p0[0]) * curveness;\n    }\n\n    if (isPolyline || curveness !== 0) {\n      for (var idx = start; idx < end; idx++) {\n        if (isPolyline) {\n          var count = seriesModel.getLineCoordsCount(idx);\n          vertexCount += geometry.getPolylineVertexCount(count);\n          triangleCount += geometry.getPolylineTriangleCount(count);\n        } else {\n          seriesModel.getLineCoords(idx, lineCoords);\n\n          this._glViewHelper.dataToPoint(coordSys, lineCoords[0], p0);\n\n          this._glViewHelper.dataToPoint(coordSys, lineCoords[1], p3);\n\n          updateBezierControlPoints();\n          vertexCount += geometry.getCubicCurveVertexCount(p0, p1, p2, p3);\n          triangleCount += geometry.getCubicCurveTriangleCount(p0, p1, p2, p3);\n        }\n      }\n    } else {\n      var lineCount = end - start;\n      vertexCount += lineCount * geometry.getLineVertexCount();\n      triangleCount += lineCount * geometry.getLineVertexCount();\n    }\n\n    geometry.setVertexCount(vertexCount);\n    geometry.setTriangleCount(triangleCount);\n    var dataIndex = start;\n    var colorArr = [];\n\n    for (var idx = start; idx < end; idx++) {\n      graphicGL.parseColor(getItemVisualColor(data, dataIndex), colorArr);\n      var opacity = retrieve.firstNotNull(getItemVisualOpacity(data, dataIndex), 1);\n      colorArr[3] *= opacity;\n      var count = seriesModel.getLineCoords(idx, lineCoords);\n\n      for (var k = 0; k < count; k++) {\n        this._glViewHelper.dataToPoint(coordSys, lineCoords[k], lineCoords[k]);\n      }\n\n      if (isPolyline) {\n        geometry.addPolyline(lineCoords, colorArr, lineWidth, 0, count);\n      } else if (curveness !== 0) {\n        p0 = lineCoords[0];\n        p3 = lineCoords[1];\n        updateBezierControlPoints();\n        geometry.addCubicCurve(p0, p1, p2, p3, colorArr, lineWidth);\n      } else {\n        geometry.addPolyline(lineCoords, colorArr, lineWidth, 0, 2);\n      }\n\n      dataIndex++;\n    }\n  },\n  dispose: function dispose() {\n    this.groupGL.removeAll();\n  },\n  remove: function remove() {\n    this.groupGL.removeAll();\n  }\n});","map":{"version":3,"sources":["C:/Users/Administrator/Desktop/data_view/my_project/vue2_app/myapp/node_modules/_echarts-gl@2.0.9@echarts-gl/lib/chart/linesGL/LinesGLView.js"],"names":["echarts","graphicGL","ViewGL","Lines2DGeometry","GLViewHelper","getItemVisualColor","getItemVisualOpacity","retrieve","ChartView","extend","type","__ecgl__","init","ecModel","api","groupGL","Node","viewGL","add","_glViewHelper","_nativeLinesShader","createShader","_meshLinesShader","_linesMeshes","_currentStep","render","seriesModel","removeAll","reset","linesMesh","_createLinesMesh","length","_updateLinesMesh","getData","count","setPostEffect","getModel","incrementalPrepareRender","incrementalRender","params","start","end","getZr","refresh","updateTransform","coordinateSystem","getRoamTransform","Mesh","$ignorePicking","material","Material","shader","transparent","depthMask","depthTest","geometry","segmentScale","useNativeLine","dynamic","mode","LINES","culling","data","blend","get","additiveBlend","curveness","isPolyline","coordSys","lineWidth","firstNotNull","attachShader","TRIANGLES","resetOffset","vertexCount","triangleCount","p0","p1","p2","p3","lineCoords","t","t2","updateBezierControlPoints","idx","getLineCoordsCount","getPolylineVertexCount","getPolylineTriangleCount","getLineCoords","dataToPoint","getCubicCurveVertexCount","getCubicCurveTriangleCount","lineCount","getLineVertexCount","setVertexCount","setTriangleCount","dataIndex","colorArr","parseColor","opacity","k","addPolyline","addCubicCurve","dispose","remove"],"mappings":"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","sourcesContent":["import * as echarts from 'echarts/lib/echarts';\nimport graphicGL from '../../util/graphicGL';\nimport ViewGL from '../../core/ViewGL';\nimport Lines2DGeometry from '../../util/geometry/Lines2D';\nimport GLViewHelper from '../common/GLViewHelper';\nimport { getItemVisualColor, getItemVisualOpacity } from '../../util/visual';\nimport retrieve from '../../util/retrieve';\nexport default echarts.ChartView.extend({\n  type: 'linesGL',\n  __ecgl__: true,\n  init: function (ecModel, api) {\n    this.groupGL = new graphicGL.Node();\n    this.viewGL = new ViewGL('orthographic');\n    this.viewGL.add(this.groupGL);\n    this._glViewHelper = new GLViewHelper(this.viewGL);\n    this._nativeLinesShader = graphicGL.createShader('ecgl.lines3D');\n    this._meshLinesShader = graphicGL.createShader('ecgl.meshLines3D');\n    this._linesMeshes = [];\n    this._currentStep = 0;\n  },\n  render: function (seriesModel, ecModel, api) {\n    this.groupGL.removeAll();\n\n    this._glViewHelper.reset(seriesModel, api);\n\n    var linesMesh = this._linesMeshes[0];\n\n    if (!linesMesh) {\n      linesMesh = this._linesMeshes[0] = this._createLinesMesh(seriesModel);\n    }\n\n    this._linesMeshes.length = 1;\n    this.groupGL.add(linesMesh);\n\n    this._updateLinesMesh(seriesModel, linesMesh, 0, seriesModel.getData().count());\n\n    this.viewGL.setPostEffect(seriesModel.getModel('postEffect'), api);\n  },\n  incrementalPrepareRender: function (seriesModel, ecModel, api) {\n    this.groupGL.removeAll();\n\n    this._glViewHelper.reset(seriesModel, api);\n\n    this._currentStep = 0;\n    this.viewGL.setPostEffect(seriesModel.getModel('postEffect'), api);\n  },\n  incrementalRender: function (params, seriesModel, ecModel, api) {\n    var linesMesh = this._linesMeshes[this._currentStep];\n\n    if (!linesMesh) {\n      linesMesh = this._createLinesMesh(seriesModel);\n      this._linesMeshes[this._currentStep] = linesMesh;\n    }\n\n    this._updateLinesMesh(seriesModel, linesMesh, params.start, params.end);\n\n    this.groupGL.add(linesMesh);\n    api.getZr().refresh();\n    this._currentStep++;\n  },\n  updateTransform: function (seriesModel, ecModel, api) {\n    if (seriesModel.coordinateSystem.getRoamTransform) {\n      this._glViewHelper.updateTransform(seriesModel, api);\n    }\n  },\n  _createLinesMesh: function (seriesModel) {\n    var linesMesh = new graphicGL.Mesh({\n      $ignorePicking: true,\n      material: new graphicGL.Material({\n        shader: graphicGL.createShader('ecgl.lines3D'),\n        transparent: true,\n        depthMask: false,\n        depthTest: false\n      }),\n      geometry: new Lines2DGeometry({\n        segmentScale: 10,\n        useNativeLine: true,\n        dynamic: false\n      }),\n      mode: graphicGL.Mesh.LINES,\n      culling: false\n    });\n    return linesMesh;\n  },\n  _updateLinesMesh: function (seriesModel, linesMesh, start, end) {\n    var data = seriesModel.getData();\n    linesMesh.material.blend = seriesModel.get('blendMode') === 'lighter' ? graphicGL.additiveBlend : null;\n    var curveness = seriesModel.get('lineStyle.curveness') || 0;\n    var isPolyline = seriesModel.get('polyline');\n    var geometry = linesMesh.geometry;\n    var coordSys = seriesModel.coordinateSystem;\n    var lineWidth = retrieve.firstNotNull(seriesModel.get('lineStyle.width'), 1);\n\n    if (lineWidth > 1) {\n      if (linesMesh.material.shader !== this._meshLinesShader) {\n        linesMesh.material.attachShader(this._meshLinesShader);\n      }\n\n      linesMesh.mode = graphicGL.Mesh.TRIANGLES;\n    } else {\n      if (linesMesh.material.shader !== this._nativeLinesShader) {\n        linesMesh.material.attachShader(this._nativeLinesShader);\n      }\n\n      linesMesh.mode = graphicGL.Mesh.LINES;\n    }\n\n    start = start || 0;\n    end = end || data.count();\n    geometry.resetOffset();\n    var vertexCount = 0;\n    var triangleCount = 0;\n    var p0 = [];\n    var p1 = [];\n    var p2 = [];\n    var p3 = [];\n    var lineCoords = [];\n    var t = 0.3;\n    var t2 = 0.7;\n\n    function updateBezierControlPoints() {\n      p1[0] = p0[0] * t2 + p3[0] * t - (p0[1] - p3[1]) * curveness;\n      p1[1] = p0[1] * t2 + p3[1] * t - (p3[0] - p0[0]) * curveness;\n      p2[0] = p0[0] * t + p3[0] * t2 - (p0[1] - p3[1]) * curveness;\n      p2[1] = p0[1] * t + p3[1] * t2 - (p3[0] - p0[0]) * curveness;\n    }\n\n    if (isPolyline || curveness !== 0) {\n      for (var idx = start; idx < end; idx++) {\n        if (isPolyline) {\n          var count = seriesModel.getLineCoordsCount(idx);\n          vertexCount += geometry.getPolylineVertexCount(count);\n          triangleCount += geometry.getPolylineTriangleCount(count);\n        } else {\n          seriesModel.getLineCoords(idx, lineCoords);\n\n          this._glViewHelper.dataToPoint(coordSys, lineCoords[0], p0);\n\n          this._glViewHelper.dataToPoint(coordSys, lineCoords[1], p3);\n\n          updateBezierControlPoints();\n          vertexCount += geometry.getCubicCurveVertexCount(p0, p1, p2, p3);\n          triangleCount += geometry.getCubicCurveTriangleCount(p0, p1, p2, p3);\n        }\n      }\n    } else {\n      var lineCount = end - start;\n      vertexCount += lineCount * geometry.getLineVertexCount();\n      triangleCount += lineCount * geometry.getLineVertexCount();\n    }\n\n    geometry.setVertexCount(vertexCount);\n    geometry.setTriangleCount(triangleCount);\n    var dataIndex = start;\n    var colorArr = [];\n\n    for (var idx = start; idx < end; idx++) {\n      graphicGL.parseColor(getItemVisualColor(data, dataIndex), colorArr);\n      var opacity = retrieve.firstNotNull(getItemVisualOpacity(data, dataIndex), 1);\n      colorArr[3] *= opacity;\n      var count = seriesModel.getLineCoords(idx, lineCoords);\n\n      for (var k = 0; k < count; k++) {\n        this._glViewHelper.dataToPoint(coordSys, lineCoords[k], lineCoords[k]);\n      }\n\n      if (isPolyline) {\n        geometry.addPolyline(lineCoords, colorArr, lineWidth, 0, count);\n      } else if (curveness !== 0) {\n        p0 = lineCoords[0];\n        p3 = lineCoords[1];\n        updateBezierControlPoints();\n        geometry.addCubicCurve(p0, p1, p2, p3, colorArr, lineWidth);\n      } else {\n        geometry.addPolyline(lineCoords, colorArr, lineWidth, 0, 2);\n      }\n\n      dataIndex++;\n    }\n  },\n  dispose: function () {\n    this.groupGL.removeAll();\n  },\n  remove: function () {\n    this.groupGL.removeAll();\n  }\n});"]},"metadata":{},"sourceType":"module"}