{"ast":null,"code":"import _typeof from \"C:/Users/Administrator/Desktop/data_view/my_project/vue2_app/myapp/node_modules/@babel/runtime/helpers/esm/typeof.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.typed-array.uint32-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/es.function.name.js\";\n// TODO Resources like shader, texture, geometry reference management\n// Trace and find out which shader, texture, geometry can be destroyed\nimport Base from './core/Base';\nimport GLInfo from './core/GLInfo';\nimport glenum from './core/glenum';\nimport vendor from './core/vendor';\nimport Material from './Material';\nimport Vector2 from './math/Vector2';\nimport ProgramManager from './gpu/ProgramManager'; // Light header\n\nimport Shader from './Shader';\nimport prezEssl from './shader/source/prez.glsl.js';\nShader['import'](prezEssl);\nimport mat4 from './glmatrix/mat4';\nimport vec3 from './glmatrix/vec3';\nvar mat4Create = mat4.create;\nvar errorShader = {};\n\nfunction defaultGetMaterial(renderable) {\n  return renderable.material;\n}\n\nfunction defaultGetUniform(renderable, material, symbol) {\n  return material.uniforms[symbol].value;\n}\n\nfunction defaultIsMaterialChanged(renderabled, prevRenderable, material, prevMaterial) {\n  return material !== prevMaterial;\n}\n\nfunction defaultIfRender(renderable) {\n  return true;\n}\n\nfunction noop() {}\n\nvar attributeBufferTypeMap = {\n  float: glenum.FLOAT,\n  byte: glenum.BYTE,\n  ubyte: glenum.UNSIGNED_BYTE,\n  short: glenum.SHORT,\n  ushort: glenum.UNSIGNED_SHORT\n};\n\nfunction VertexArrayObject(availableAttributes, availableAttributeSymbols, indicesBuffer) {\n  this.availableAttributes = availableAttributes;\n  this.availableAttributeSymbols = availableAttributeSymbols;\n  this.indicesBuffer = indicesBuffer;\n  this.vao = null;\n}\n\nfunction PlaceHolderTexture(renderer) {\n  var blankCanvas;\n  var webglTexture;\n\n  this.bind = function (renderer) {\n    if (!blankCanvas) {\n      // TODO Environment not support createCanvas.\n      blankCanvas = vendor.createCanvas();\n      blankCanvas.width = blankCanvas.height = 1;\n      blankCanvas.getContext('2d');\n    }\n\n    var gl = renderer.gl;\n    var firstBind = !webglTexture;\n\n    if (firstBind) {\n      webglTexture = gl.createTexture();\n    }\n\n    gl.bindTexture(gl.TEXTURE_2D, webglTexture);\n\n    if (firstBind) {\n      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, blankCanvas);\n    }\n  };\n\n  this.unbind = function (renderer) {\n    renderer.gl.bindTexture(renderer.gl.TEXTURE_2D, null);\n  };\n\n  this.isRenderable = function () {\n    return true;\n  };\n}\n/**\n * @constructor clay.Renderer\n * @extends clay.core.Base\n */\n\n\nvar Renderer = Base.extend(function () {\n  return (\n    /** @lends clay.Renderer# */\n    {\n      /**\n       * @type {HTMLCanvasElement}\n       * @readonly\n       */\n      canvas: null,\n\n      /**\n       * Canvas width, set by resize method\n       * @type {number}\n       * @private\n       */\n      _width: 100,\n\n      /**\n       * Canvas width, set by resize method\n       * @type {number}\n       * @private\n       */\n      _height: 100,\n\n      /**\n       * Device pixel ratio, set by setDevicePixelRatio method\n       * Specially for high defination display\n       * @see http://www.khronos.org/webgl/wiki/HandlingHighDPI\n       * @type {number}\n       * @private\n       */\n      devicePixelRatio: typeof window !== 'undefined' && window.devicePixelRatio || 1.0,\n\n      /**\n       * Clear color\n       * @type {number[]}\n       */\n      clearColor: [0.0, 0.0, 0.0, 0.0],\n\n      /**\n       * Default:\n       *     _gl.COLOR_BUFFER_BIT | _gl.DEPTH_BUFFER_BIT | _gl.STENCIL_BUFFER_BIT\n       * @type {number}\n       */\n      clearBit: 17664,\n      // Settings when getting context\n      // http://www.khronos.org/registry/webgl/specs/latest/#2.4\n\n      /**\n       * If enable alpha, default true\n       * @type {boolean}\n       */\n      alpha: true,\n\n      /**\n       * If enable depth buffer, default true\n       * @type {boolean}\n       */\n      depth: true,\n\n      /**\n       * If enable stencil buffer, default false\n       * @type {boolean}\n       */\n      stencil: false,\n\n      /**\n       * If enable antialias, default true\n       * @type {boolean}\n       */\n      antialias: true,\n\n      /**\n       * If enable premultiplied alpha, default true\n       * @type {boolean}\n       */\n      premultipliedAlpha: true,\n\n      /**\n       * If preserve drawing buffer, default false\n       * @type {boolean}\n       */\n      preserveDrawingBuffer: false,\n\n      /**\n       * If throw context error, usually turned on in debug mode\n       * @type {boolean}\n       */\n      throwError: true,\n\n      /**\n       * WebGL Context created from given canvas\n       * @type {WebGLRenderingContext}\n       */\n      gl: null,\n\n      /**\n       * Renderer viewport, read-only, can be set by setViewport method\n       * @type {Object}\n       */\n      viewport: {},\n\n      /**\n       * Max joint number\n       * @type {number}\n       */\n      maxJointNumber: 20,\n      // Set by FrameBuffer#bind\n      __currentFrameBuffer: null,\n      _viewportStack: [],\n      _clearStack: [],\n      _sceneRendering: null\n    }\n  );\n}, function () {\n  if (!this.canvas) {\n    this.canvas = vendor.createCanvas();\n  }\n\n  var canvas = this.canvas;\n\n  try {\n    var opts = {\n      alpha: this.alpha,\n      depth: this.depth,\n      stencil: this.stencil,\n      antialias: this.antialias,\n      premultipliedAlpha: this.premultipliedAlpha,\n      preserveDrawingBuffer: this.preserveDrawingBuffer\n    };\n    this.gl = canvas.getContext('webgl', opts) || canvas.getContext('experimental-webgl', opts);\n\n    if (!this.gl) {\n      throw new Error();\n    }\n\n    this._glinfo = new GLInfo(this.gl);\n\n    if (this.gl.targetRenderer) {\n      console.error('Already created a renderer');\n    }\n\n    this.gl.targetRenderer = this;\n    this.resize();\n  } catch (e) {\n    throw 'Error creating WebGL Context ' + e;\n  } // Init managers\n\n\n  this._programMgr = new ProgramManager(this);\n  this._placeholderTexture = new PlaceHolderTexture(this);\n},\n/** @lends clay.Renderer.prototype. **/\n{\n  /**\n   * Resize the canvas\n   * @param {number} width\n   * @param {number} height\n   */\n  resize: function resize(width, height) {\n    var canvas = this.canvas; // http://www.khronos.org/webgl/wiki/HandlingHighDPI\n    // set the display size of the canvas.\n\n    var dpr = this.devicePixelRatio;\n\n    if (width != null) {\n      if (canvas.style) {\n        canvas.style.width = width + 'px';\n        canvas.style.height = height + 'px';\n      } // set the size of the drawingBuffer\n\n\n      canvas.width = width * dpr;\n      canvas.height = height * dpr;\n      this._width = width;\n      this._height = height;\n    } else {\n      this._width = canvas.width / dpr;\n      this._height = canvas.height / dpr;\n    }\n\n    this.setViewport(0, 0, this._width, this._height);\n  },\n\n  /**\n   * Get renderer width\n   * @return {number}\n   */\n  getWidth: function getWidth() {\n    return this._width;\n  },\n\n  /**\n   * Get renderer height\n   * @return {number}\n   */\n  getHeight: function getHeight() {\n    return this._height;\n  },\n\n  /**\n   * Get viewport aspect,\n   * @return {number}\n   */\n  getViewportAspect: function getViewportAspect() {\n    var viewport = this.viewport;\n    return viewport.width / viewport.height;\n  },\n\n  /**\n   * Set devicePixelRatio\n   * @param {number} devicePixelRatio\n   */\n  setDevicePixelRatio: function setDevicePixelRatio(devicePixelRatio) {\n    this.devicePixelRatio = devicePixelRatio;\n    this.resize(this._width, this._height);\n  },\n\n  /**\n   * Get devicePixelRatio\n   * @param {number} devicePixelRatio\n   */\n  getDevicePixelRatio: function getDevicePixelRatio() {\n    return this.devicePixelRatio;\n  },\n\n  /**\n   * Get WebGL extension\n   * @param {string} name\n   * @return {object}\n   */\n  getGLExtension: function getGLExtension(name) {\n    return this._glinfo.getExtension(name);\n  },\n\n  /**\n   * Get WebGL parameter\n   * @param {string} name\n   * @return {*}\n   */\n  getGLParameter: function getGLParameter(name) {\n    return this._glinfo.getParameter(name);\n  },\n\n  /**\n   * Set rendering viewport\n   * @param {number|Object} x\n   * @param {number} [y]\n   * @param {number} [width]\n   * @param {number} [height]\n   * @param {number} [devicePixelRatio]\n   *        Defaultly use the renderere devicePixelRatio\n   *        It needs to be 1 when setViewport is called by frameBuffer\n   *\n   * @example\n   *  setViewport(0,0,width,height,1)\n   *  setViewport({\n   *      x: 0,\n   *      y: 0,\n   *      width: width,\n   *      height: height,\n   *      devicePixelRatio: 1\n   *  })\n   */\n  setViewport: function setViewport(x, y, width, height, dpr) {\n    if (_typeof(x) === 'object') {\n      var obj = x;\n      x = obj.x;\n      y = obj.y;\n      width = obj.width;\n      height = obj.height;\n      dpr = obj.devicePixelRatio;\n    }\n\n    dpr = dpr || this.devicePixelRatio;\n    this.gl.viewport(x * dpr, y * dpr, width * dpr, height * dpr); // Use a fresh new object, not write property.\n\n    this.viewport = {\n      x: x,\n      y: y,\n      width: width,\n      height: height,\n      devicePixelRatio: dpr\n    };\n  },\n\n  /**\n   * Push current viewport into a stack\n   */\n  saveViewport: function saveViewport() {\n    this._viewportStack.push(this.viewport);\n  },\n\n  /**\n   * Pop viewport from stack, restore in the renderer\n   */\n  restoreViewport: function restoreViewport() {\n    if (this._viewportStack.length > 0) {\n      this.setViewport(this._viewportStack.pop());\n    }\n  },\n\n  /**\n   * Push current clear into a stack\n   */\n  saveClear: function saveClear() {\n    this._clearStack.push({\n      clearBit: this.clearBit,\n      clearColor: this.clearColor\n    });\n  },\n\n  /**\n   * Pop clear from stack, restore in the renderer\n   */\n  restoreClear: function restoreClear() {\n    if (this._clearStack.length > 0) {\n      var opt = this._clearStack.pop();\n\n      this.clearColor = opt.clearColor;\n      this.clearBit = opt.clearBit;\n    }\n  },\n  bindSceneRendering: function bindSceneRendering(scene) {\n    this._sceneRendering = scene;\n  },\n\n  /**\n   * Render the scene in camera to the screen or binded offline framebuffer\n   * @param  {clay.Scene}       scene\n   * @param  {clay.Camera}      camera\n   * @param  {boolean}     [notUpdateScene] If not call the scene.update methods in the rendering, default true\n   * @param  {boolean}     [preZ]           If use preZ optimization, default false\n   * @return {IRenderInfo}\n   */\n  render: function render(scene, camera, notUpdateScene, preZ) {\n    var _gl = this.gl;\n    var clearColor = this.clearColor;\n\n    if (this.clearBit) {\n      // Must set depth and color mask true before clear\n      _gl.colorMask(true, true, true, true);\n\n      _gl.depthMask(true);\n\n      var viewport = this.viewport;\n      var needsScissor = false;\n      var viewportDpr = viewport.devicePixelRatio;\n\n      if (viewport.width !== this._width || viewport.height !== this._height || viewportDpr && viewportDpr !== this.devicePixelRatio || viewport.x || viewport.y) {\n        needsScissor = true; // http://stackoverflow.com/questions/11544608/how-to-clear-a-rectangle-area-in-webgl\n        // Only clear the viewport\n\n        _gl.enable(_gl.SCISSOR_TEST);\n\n        _gl.scissor(viewport.x * viewportDpr, viewport.y * viewportDpr, viewport.width * viewportDpr, viewport.height * viewportDpr);\n      }\n\n      _gl.clearColor(clearColor[0], clearColor[1], clearColor[2], clearColor[3]);\n\n      _gl.clear(this.clearBit);\n\n      if (needsScissor) {\n        _gl.disable(_gl.SCISSOR_TEST);\n      }\n    } // If the scene have been updated in the prepass like shadow map\n    // There is no need to update it again\n\n\n    if (!notUpdateScene) {\n      scene.update(false);\n    }\n\n    scene.updateLights();\n    camera = camera || scene.getMainCamera();\n\n    if (!camera) {\n      console.error('Can\\'t find camera in the scene.');\n      return;\n    }\n\n    camera.update();\n    var renderList = scene.updateRenderList(camera, true);\n    this._sceneRendering = scene;\n    var opaqueList = renderList.opaque;\n    var transparentList = renderList.transparent;\n    var sceneMaterial = scene.material;\n    scene.trigger('beforerender', this, scene, camera, renderList); // Render pre z\n\n    if (preZ) {\n      this.renderPreZ(opaqueList, scene, camera);\n\n      _gl.depthFunc(_gl.LEQUAL);\n    } else {\n      _gl.depthFunc(_gl.LESS);\n    } // Update the depth of transparent list.\n\n\n    var worldViewMat = mat4Create();\n    var posViewSpace = vec3.create();\n\n    for (var i = 0; i < transparentList.length; i++) {\n      var renderable = transparentList[i];\n      mat4.multiplyAffine(worldViewMat, camera.viewMatrix.array, renderable.worldTransform.array);\n      vec3.transformMat4(posViewSpace, renderable.position.array, worldViewMat);\n      renderable.__depth = posViewSpace[2];\n    } // Render opaque list\n\n\n    this.renderPass(opaqueList, camera, {\n      getMaterial: function getMaterial(renderable) {\n        return sceneMaterial || renderable.material;\n      },\n      sortCompare: this.opaqueSortCompare\n    });\n    this.renderPass(transparentList, camera, {\n      getMaterial: function getMaterial(renderable) {\n        return sceneMaterial || renderable.material;\n      },\n      sortCompare: this.transparentSortCompare\n    });\n    scene.trigger('afterrender', this, scene, camera, renderList); // Cleanup\n\n    this._sceneRendering = null;\n  },\n  getProgram: function getProgram(renderable, renderMaterial, scene) {\n    renderMaterial = renderMaterial || renderable.material;\n    return this._programMgr.getProgram(renderable, renderMaterial, scene);\n  },\n  validateProgram: function validateProgram(program) {\n    if (program.__error) {\n      var errorMsg = program.__error;\n\n      if (errorShader[program.__uid__]) {\n        return;\n      }\n\n      errorShader[program.__uid__] = true;\n\n      if (this.throwError) {\n        throw new Error(errorMsg);\n      } else {\n        this.trigger('error', errorMsg);\n      }\n    }\n  },\n  updatePrograms: function updatePrograms(list, scene, passConfig) {\n    var getMaterial = passConfig && passConfig.getMaterial || defaultGetMaterial;\n    scene = scene || null;\n\n    for (var i = 0; i < list.length; i++) {\n      var renderable = list[i];\n      var renderMaterial = getMaterial.call(this, renderable);\n\n      if (i > 0) {\n        var prevRenderable = list[i - 1];\n        var prevJointsLen = prevRenderable.joints ? prevRenderable.joints.length : 0;\n        var jointsLen = renderable.joints ? renderable.joints.length : 0; // Keep program not change if joints, material, lightGroup are same of two renderables.\n\n        if (jointsLen === prevJointsLen && renderable.material === prevRenderable.material && renderable.lightGroup === prevRenderable.lightGroup) {\n          renderable.__program = prevRenderable.__program;\n          continue;\n        }\n      }\n\n      var program = this._programMgr.getProgram(renderable, renderMaterial, scene);\n\n      this.validateProgram(program);\n      renderable.__program = program;\n    }\n  },\n\n  /**\n   * Render a single renderable list in camera in sequence\n   * @param {clay.Renderable[]} list List of all renderables.\n   * @param {clay.Camera} [camera] Camera provide view matrix and porjection matrix. It can be null.\n   * @param {Object} [passConfig]\n   * @param {Function} [passConfig.getMaterial] Get renderable material.\n   * @param {Function} [passConfig.getUniform] Get material uniform value.\n   * @param {Function} [passConfig.isMaterialChanged] If material changed.\n   * @param {Function} [passConfig.beforeRender] Before render each renderable.\n   * @param {Function} [passConfig.afterRender] After render each renderable\n   * @param {Function} [passConfig.ifRender] If render the renderable.\n   * @param {Function} [passConfig.sortCompare] Sort compare function.\n   * @return {IRenderInfo}\n   */\n  renderPass: function renderPass(list, camera, passConfig) {\n    this.trigger('beforerenderpass', this, list, camera, passConfig);\n    passConfig = passConfig || {};\n    passConfig.getMaterial = passConfig.getMaterial || defaultGetMaterial;\n    passConfig.getUniform = passConfig.getUniform || defaultGetUniform; // PENDING Better solution?\n\n    passConfig.isMaterialChanged = passConfig.isMaterialChanged || defaultIsMaterialChanged;\n    passConfig.beforeRender = passConfig.beforeRender || noop;\n    passConfig.afterRender = passConfig.afterRender || noop;\n    var ifRenderObject = passConfig.ifRender || defaultIfRender;\n    this.updatePrograms(list, this._sceneRendering, passConfig);\n\n    if (passConfig.sortCompare) {\n      list.sort(passConfig.sortCompare);\n    } // Some common builtin uniforms\n\n\n    var viewport = this.viewport;\n    var vDpr = viewport.devicePixelRatio;\n    var viewportUniform = [viewport.x * vDpr, viewport.y * vDpr, viewport.width * vDpr, viewport.height * vDpr];\n    var windowDpr = this.devicePixelRatio;\n    var windowSizeUniform = this.__currentFrameBuffer ? [this.__currentFrameBuffer.getTextureWidth(), this.__currentFrameBuffer.getTextureHeight()] : [this._width * windowDpr, this._height * windowDpr]; // DEPRECATED\n\n    var viewportSizeUniform = [viewportUniform[2], viewportUniform[3]];\n    var time = Date.now(); // Calculate view and projection matrix\n\n    if (camera) {\n      mat4.copy(matrices.VIEW, camera.viewMatrix.array);\n      mat4.copy(matrices.PROJECTION, camera.projectionMatrix.array);\n      mat4.copy(matrices.VIEWINVERSE, camera.worldTransform.array);\n    } else {\n      mat4.identity(matrices.VIEW);\n      mat4.identity(matrices.PROJECTION);\n      mat4.identity(matrices.VIEWINVERSE);\n    }\n\n    mat4.multiply(matrices.VIEWPROJECTION, matrices.PROJECTION, matrices.VIEW);\n    mat4.invert(matrices.PROJECTIONINVERSE, matrices.PROJECTION);\n    mat4.invert(matrices.VIEWPROJECTIONINVERSE, matrices.VIEWPROJECTION);\n    var _gl = this.gl;\n    var scene = this._sceneRendering;\n    var prevMaterial;\n    var prevProgram;\n    var prevRenderable; // Status\n\n    var depthTest, depthMask;\n    var culling, cullFace, frontFace;\n    var transparent;\n    var drawID;\n    var currentVAO;\n    var materialTakesTextureSlot; // var vaoExt = this.getGLExtension('OES_vertex_array_object');\n    // not use vaoExt, some platforms may mess it up.\n\n    var vaoExt = null;\n\n    for (var i = 0; i < list.length; i++) {\n      var renderable = list[i];\n      var isSceneNode = renderable.worldTransform != null;\n      var worldM;\n\n      if (!ifRenderObject(renderable)) {\n        continue;\n      } // Skinned mesh will transformed to joint space. Ignore the mesh transform\n\n\n      if (isSceneNode) {\n        worldM = renderable.isSkinnedMesh && renderable.isSkinnedMesh() // TODO\n        ? renderable.offsetMatrix ? renderable.offsetMatrix.array : matrices.IDENTITY : renderable.worldTransform.array;\n      }\n\n      var geometry = renderable.geometry;\n      var material = passConfig.getMaterial.call(this, renderable);\n      var program = renderable.__program;\n      var shader = material.shader;\n      var currentDrawID = geometry.__uid__ + '-' + program.__uid__;\n      var drawIDChanged = currentDrawID !== drawID;\n      drawID = currentDrawID;\n\n      if (drawIDChanged && vaoExt) {\n        // TODO Seems need to be bound to null immediately (or before bind another program?) if vao is changed\n        vaoExt.bindVertexArrayOES(null);\n      }\n\n      if (isSceneNode) {\n        mat4.copy(matrices.WORLD, worldM);\n        mat4.multiply(matrices.WORLDVIEWPROJECTION, matrices.VIEWPROJECTION, worldM);\n        mat4.multiplyAffine(matrices.WORLDVIEW, matrices.VIEW, worldM);\n\n        if (shader.matrixSemantics.WORLDINVERSE || shader.matrixSemantics.WORLDINVERSETRANSPOSE) {\n          mat4.invert(matrices.WORLDINVERSE, worldM);\n        }\n\n        if (shader.matrixSemantics.WORLDVIEWINVERSE || shader.matrixSemantics.WORLDVIEWINVERSETRANSPOSE) {\n          mat4.invert(matrices.WORLDVIEWINVERSE, matrices.WORLDVIEW);\n        }\n\n        if (shader.matrixSemantics.WORLDVIEWPROJECTIONINVERSE || shader.matrixSemantics.WORLDVIEWPROJECTIONINVERSETRANSPOSE) {\n          mat4.invert(matrices.WORLDVIEWPROJECTIONINVERSE, matrices.WORLDVIEWPROJECTION);\n        }\n      } // Before render hook\n\n\n      renderable.beforeRender && renderable.beforeRender(this);\n      passConfig.beforeRender.call(this, renderable, material, prevMaterial);\n      var programChanged = program !== prevProgram;\n\n      if (programChanged) {\n        // Set lights number\n        program.bind(this); // Set some common uniforms\n\n        program.setUniformOfSemantic(_gl, 'VIEWPORT', viewportUniform);\n        program.setUniformOfSemantic(_gl, 'WINDOW_SIZE', windowSizeUniform);\n\n        if (camera) {\n          program.setUniformOfSemantic(_gl, 'NEAR', camera.near);\n          program.setUniformOfSemantic(_gl, 'FAR', camera.far);\n        }\n\n        program.setUniformOfSemantic(_gl, 'DEVICEPIXELRATIO', vDpr);\n        program.setUniformOfSemantic(_gl, 'TIME', time); // DEPRECATED\n\n        program.setUniformOfSemantic(_gl, 'VIEWPORT_SIZE', viewportSizeUniform); // Set lights uniforms\n        // TODO needs optimized\n\n        if (scene) {\n          scene.setLightUniforms(program, renderable.lightGroup, this);\n        }\n      } else {\n        program = prevProgram;\n      } // Program changes also needs reset the materials.\n\n\n      if (programChanged || passConfig.isMaterialChanged(renderable, prevRenderable, material, prevMaterial)) {\n        if (material.depthTest !== depthTest) {\n          material.depthTest ? _gl.enable(_gl.DEPTH_TEST) : _gl.disable(_gl.DEPTH_TEST);\n          depthTest = material.depthTest;\n        }\n\n        if (material.depthMask !== depthMask) {\n          _gl.depthMask(material.depthMask);\n\n          depthMask = material.depthMask;\n        }\n\n        if (material.transparent !== transparent) {\n          material.transparent ? _gl.enable(_gl.BLEND) : _gl.disable(_gl.BLEND);\n          transparent = material.transparent;\n        } // TODO cache blending\n\n\n        if (material.transparent) {\n          if (material.blend) {\n            material.blend(_gl);\n          } else {\n            // Default blend function\n            _gl.blendEquationSeparate(_gl.FUNC_ADD, _gl.FUNC_ADD);\n\n            _gl.blendFuncSeparate(_gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA, _gl.ONE, _gl.ONE_MINUS_SRC_ALPHA);\n          }\n        }\n\n        materialTakesTextureSlot = this._bindMaterial(renderable, material, program, prevRenderable || null, prevMaterial || null, prevProgram || null, passConfig.getUniform);\n        prevMaterial = material;\n      }\n\n      var matrixSemanticKeys = shader.matrixSemanticKeys;\n\n      if (isSceneNode) {\n        for (var k = 0; k < matrixSemanticKeys.length; k++) {\n          var semantic = matrixSemanticKeys[k];\n          var semanticInfo = shader.matrixSemantics[semantic];\n          var matrix = matrices[semantic];\n\n          if (semanticInfo.isTranspose) {\n            var matrixNoTranspose = matrices[semanticInfo.semanticNoTranspose];\n            mat4.transpose(matrix, matrixNoTranspose);\n          }\n\n          program.setUniform(_gl, semanticInfo.type, semanticInfo.symbol, matrix);\n        }\n      }\n\n      if (renderable.cullFace !== cullFace) {\n        cullFace = renderable.cullFace;\n\n        _gl.cullFace(cullFace);\n      }\n\n      if (renderable.frontFace !== frontFace) {\n        frontFace = renderable.frontFace;\n\n        _gl.frontFace(frontFace);\n      }\n\n      if (renderable.culling !== culling) {\n        culling = renderable.culling;\n        culling ? _gl.enable(_gl.CULL_FACE) : _gl.disable(_gl.CULL_FACE);\n      } // TODO Not update skeleton in each renderable.\n\n\n      this._updateSkeleton(renderable, program, materialTakesTextureSlot);\n\n      if (drawIDChanged) {\n        currentVAO = this._bindVAO(vaoExt, shader, geometry, program);\n      }\n\n      this._renderObject(renderable, currentVAO, program); // After render hook\n\n\n      passConfig.afterRender(this, renderable);\n      renderable.afterRender && renderable.afterRender(this);\n      prevProgram = program;\n      prevRenderable = renderable;\n    } // TODO Seems need to be bound to null immediately if vao is changed?\n\n\n    if (vaoExt) {\n      vaoExt.bindVertexArrayOES(null);\n    }\n\n    this.trigger('afterrenderpass', this, list, camera, passConfig);\n  },\n  getMaxJointNumber: function getMaxJointNumber() {\n    return this.maxJointNumber;\n  },\n  _updateSkeleton: function _updateSkeleton(object, program, slot) {\n    var _gl = this.gl;\n    var skeleton = object.skeleton; // Set pose matrices of skinned mesh\n\n    if (skeleton) {\n      // TODO Update before culling.\n      skeleton.update();\n\n      if (object.joints.length > this.getMaxJointNumber()) {\n        var skinMatricesTexture = skeleton.getSubSkinMatricesTexture(object.__uid__, object.joints);\n        program.useTextureSlot(this, skinMatricesTexture, slot);\n        program.setUniform(_gl, '1i', 'skinMatricesTexture', slot);\n        program.setUniform(_gl, '1f', 'skinMatricesTextureSize', skinMatricesTexture.width);\n      } else {\n        var skinMatricesArray = skeleton.getSubSkinMatrices(object.__uid__, object.joints);\n        program.setUniformOfSemantic(_gl, 'SKIN_MATRIX', skinMatricesArray);\n      }\n    }\n  },\n  _renderObject: function _renderObject(renderable, vao, program) {\n    var _gl = this.gl;\n    var geometry = renderable.geometry;\n    var glDrawMode = renderable.mode;\n\n    if (glDrawMode == null) {\n      glDrawMode = 0x0004;\n    }\n\n    var ext = null;\n    var isInstanced = renderable.isInstancedMesh && renderable.isInstancedMesh();\n\n    if (isInstanced) {\n      ext = this.getGLExtension('ANGLE_instanced_arrays');\n\n      if (!ext) {\n        console.warn('Device not support ANGLE_instanced_arrays extension');\n        return;\n      }\n    }\n\n    var instancedAttrLocations;\n\n    if (isInstanced) {\n      instancedAttrLocations = this._bindInstancedAttributes(renderable, program, ext);\n    }\n\n    if (vao.indicesBuffer) {\n      var uintExt = this.getGLExtension('OES_element_index_uint');\n      var useUintExt = uintExt && geometry.indices instanceof Uint32Array;\n      var indicesType = useUintExt ? _gl.UNSIGNED_INT : _gl.UNSIGNED_SHORT;\n\n      if (isInstanced) {\n        ext.drawElementsInstancedANGLE(glDrawMode, vao.indicesBuffer.count, indicesType, 0, renderable.getInstanceCount());\n      } else {\n        _gl.drawElements(glDrawMode, vao.indicesBuffer.count, indicesType, 0);\n      }\n    } else {\n      if (isInstanced) {\n        ext.drawArraysInstancedANGLE(glDrawMode, 0, geometry.vertexCount, renderable.getInstanceCount());\n      } else {\n        // FIXME Use vertex number in buffer\n        // vertexCount may get the wrong value when geometry forget to mark dirty after update\n        _gl.drawArrays(glDrawMode, 0, geometry.vertexCount);\n      }\n    }\n\n    if (isInstanced) {\n      for (var i = 0; i < instancedAttrLocations.length; i++) {\n        _gl.disableVertexAttribArray(instancedAttrLocations[i]);\n      }\n    }\n  },\n  _bindInstancedAttributes: function _bindInstancedAttributes(renderable, program, ext) {\n    var _gl = this.gl;\n    var instancedBuffers = renderable.getInstancedAttributesBuffers(this);\n    var locations = [];\n\n    for (var i = 0; i < instancedBuffers.length; i++) {\n      var bufferObj = instancedBuffers[i];\n      var location = program.getAttribLocation(_gl, bufferObj.symbol);\n\n      if (location < 0) {\n        continue;\n      }\n\n      var glType = attributeBufferTypeMap[bufferObj.type] || _gl.FLOAT;\n      ;\n\n      _gl.enableVertexAttribArray(location); // TODO\n\n\n      _gl.bindBuffer(_gl.ARRAY_BUFFER, bufferObj.buffer);\n\n      _gl.vertexAttribPointer(location, bufferObj.size, glType, false, 0, 0);\n\n      ext.vertexAttribDivisorANGLE(location, bufferObj.divisor);\n      locations.push(location);\n    }\n\n    return locations;\n  },\n  _bindMaterial: function _bindMaterial(renderable, material, program, prevRenderable, prevMaterial, prevProgram, getUniformValue) {\n    var _gl = this.gl; // PENDING Same texture in different material take different slot?\n    // May use shader of other material if shader code are same\n\n    var sameProgram = prevProgram === program;\n    var currentTextureSlot = program.currentTextureSlot();\n    var enabledUniforms = material.getEnabledUniforms();\n    var textureUniforms = material.getTextureUniforms();\n    var placeholderTexture = this._placeholderTexture;\n\n    for (var u = 0; u < textureUniforms.length; u++) {\n      var symbol = textureUniforms[u];\n      var uniformValue = getUniformValue(renderable, material, symbol);\n      var uniformType = material.uniforms[symbol].type; // Not use `instanceof` to determine if a value is texture in Material#bind.\n      // Use type instead, in some case texture may be in different namespaces.\n      // TODO Duck type validate.\n\n      if (uniformType === 't' && uniformValue) {\n        // Reset slot\n        uniformValue.__slot = -1;\n      } else if (uniformType === 'tv') {\n        for (var i = 0; i < uniformValue.length; i++) {\n          if (uniformValue[i]) {\n            uniformValue[i].__slot = -1;\n          }\n        }\n      }\n    }\n\n    placeholderTexture.__slot = -1; // Set uniforms\n\n    for (var u = 0; u < enabledUniforms.length; u++) {\n      var symbol = enabledUniforms[u];\n      var uniform = material.uniforms[symbol];\n      var uniformValue = getUniformValue(renderable, material, symbol);\n      var uniformType = uniform.type;\n      var isTexture = uniformType === 't';\n\n      if (isTexture) {\n        if (!uniformValue || !uniformValue.isRenderable()) {\n          uniformValue = placeholderTexture;\n        }\n      } // PENDING\n      // When binding two materials with the same shader\n      // Many uniforms will be be set twice even if they have the same value\n      // So add a evaluation to see if the uniform is really needed to be set\n\n\n      if (prevMaterial && sameProgram) {\n        var prevUniformValue = getUniformValue(prevRenderable, prevMaterial, symbol);\n\n        if (isTexture) {\n          if (!prevUniformValue || !prevUniformValue.isRenderable()) {\n            prevUniformValue = placeholderTexture;\n          }\n        }\n\n        if (prevUniformValue === uniformValue) {\n          if (isTexture) {\n            // Still take the slot to make sure same texture in different materials have same slot.\n            program.takeCurrentTextureSlot(this, null);\n          } else if (uniformType === 'tv' && uniformValue) {\n            for (var i = 0; i < uniformValue.length; i++) {\n              program.takeCurrentTextureSlot(this, null);\n            }\n          }\n\n          continue;\n        }\n      }\n\n      if (uniformValue == null) {\n        continue;\n      } else if (isTexture) {\n        if (uniformValue.__slot < 0) {\n          var slot = program.currentTextureSlot();\n          var res = program.setUniform(_gl, '1i', symbol, slot);\n\n          if (res) {\n            // Texture uniform is enabled\n            program.takeCurrentTextureSlot(this, uniformValue);\n            uniformValue.__slot = slot;\n          }\n        } // Multiple uniform use same texture..\n        else {\n          program.setUniform(_gl, '1i', symbol, uniformValue.__slot);\n        }\n      } else if (Array.isArray(uniformValue)) {\n        if (uniformValue.length === 0) {\n          continue;\n        } // Texture Array\n\n\n        if (uniformType === 'tv') {\n          if (!program.hasUniform(symbol)) {\n            continue;\n          }\n\n          var arr = [];\n\n          for (var i = 0; i < uniformValue.length; i++) {\n            var texture = uniformValue[i];\n\n            if (texture.__slot < 0) {\n              var slot = program.currentTextureSlot();\n              arr.push(slot);\n              program.takeCurrentTextureSlot(this, texture);\n              texture.__slot = slot;\n            } else {\n              arr.push(texture.__slot);\n            }\n          }\n\n          program.setUniform(_gl, '1iv', symbol, arr);\n        } else {\n          program.setUniform(_gl, uniform.type, symbol, uniformValue);\n        }\n      } else {\n        program.setUniform(_gl, uniform.type, symbol, uniformValue);\n      }\n    }\n\n    var newSlot = program.currentTextureSlot(); // Texture slot maybe used out of material.\n\n    program.resetTextureSlot(currentTextureSlot);\n    return newSlot;\n  },\n  _bindVAO: function _bindVAO(vaoExt, shader, geometry, program) {\n    var isStatic = !geometry.dynamic;\n    var _gl = this.gl;\n    var vaoId = this.__uid__ + '-' + program.__uid__;\n    var vao = geometry.__vaoCache[vaoId];\n\n    if (!vao) {\n      var chunks = geometry.getBufferChunks(this);\n\n      if (!chunks || !chunks.length) {\n        // Empty mesh\n        return;\n      }\n\n      var chunk = chunks[0];\n      var attributeBuffers = chunk.attributeBuffers;\n      var indicesBuffer = chunk.indicesBuffer;\n      var availableAttributes = [];\n      var availableAttributeSymbols = [];\n\n      for (var a = 0; a < attributeBuffers.length; a++) {\n        var attributeBufferInfo = attributeBuffers[a];\n        var name = attributeBufferInfo.name;\n        var semantic = attributeBufferInfo.semantic;\n        var symbol;\n\n        if (semantic) {\n          var semanticInfo = shader.attributeSemantics[semantic];\n          symbol = semanticInfo && semanticInfo.symbol;\n        } else {\n          symbol = name;\n        }\n\n        if (symbol && program.attributes[symbol]) {\n          availableAttributes.push(attributeBufferInfo);\n          availableAttributeSymbols.push(symbol);\n        }\n      }\n\n      vao = new VertexArrayObject(availableAttributes, availableAttributeSymbols, indicesBuffer);\n\n      if (isStatic) {\n        geometry.__vaoCache[vaoId] = vao;\n      }\n    }\n\n    var needsBindAttributes = true; // Create vertex object array cost a lot\n    // So we don't use it on the dynamic object\n\n    if (vaoExt && isStatic) {\n      // Use vertex array object\n      // http://blog.tojicode.com/2012/10/oesvertexarrayobject-extension.html\n      if (vao.vao == null) {\n        vao.vao = vaoExt.createVertexArrayOES();\n      } else {\n        needsBindAttributes = false;\n      }\n\n      vaoExt.bindVertexArrayOES(vao.vao);\n    }\n\n    var availableAttributes = vao.availableAttributes;\n    var indicesBuffer = vao.indicesBuffer;\n\n    if (needsBindAttributes) {\n      var locationList = program.enableAttributes(this, vao.availableAttributeSymbols, vaoExt && isStatic && vao); // Setting attributes;\n\n      for (var a = 0; a < availableAttributes.length; a++) {\n        var location = locationList[a];\n\n        if (location === -1) {\n          continue;\n        }\n\n        var attributeBufferInfo = availableAttributes[a];\n        var buffer = attributeBufferInfo.buffer;\n        var size = attributeBufferInfo.size;\n        var glType = attributeBufferTypeMap[attributeBufferInfo.type] || _gl.FLOAT;\n\n        _gl.bindBuffer(_gl.ARRAY_BUFFER, buffer);\n\n        _gl.vertexAttribPointer(location, size, glType, false, 0, 0);\n      }\n\n      if (geometry.isUseIndices()) {\n        _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, indicesBuffer.buffer);\n      }\n    }\n\n    return vao;\n  },\n  renderPreZ: function renderPreZ(list, scene, camera) {\n    var _gl = this.gl;\n    var preZPassMaterial = this._prezMaterial || new Material({\n      shader: new Shader(Shader.source('clay.prez.vertex'), Shader.source('clay.prez.fragment'))\n    });\n    this._prezMaterial = preZPassMaterial;\n\n    _gl.colorMask(false, false, false, false);\n\n    _gl.depthMask(true); // Status\n\n\n    this.renderPass(list, camera, {\n      ifRender: function ifRender(renderable) {\n        return !renderable.ignorePreZ;\n      },\n      isMaterialChanged: function isMaterialChanged(renderable, prevRenderable) {\n        var matA = renderable.material;\n        var matB = prevRenderable.material;\n        return matA.get('diffuseMap') !== matB.get('diffuseMap') || (matA.get('alphaCutoff') || 0) !== (matB.get('alphaCutoff') || 0);\n      },\n      getUniform: function getUniform(renderable, depthMaterial, symbol) {\n        if (symbol === 'alphaMap') {\n          return renderable.material.get('diffuseMap');\n        } else if (symbol === 'alphaCutoff') {\n          if (renderable.material.isDefined('fragment', 'ALPHA_TEST') && renderable.material.get('diffuseMap')) {\n            var alphaCutoff = renderable.material.get('alphaCutoff');\n            return alphaCutoff || 0;\n          }\n\n          return 0;\n        } else if (symbol === 'uvRepeat') {\n          return renderable.material.get('uvRepeat');\n        } else if (symbol === 'uvOffset') {\n          return renderable.material.get('uvOffset');\n        } else {\n          return depthMaterial.get(symbol);\n        }\n      },\n      getMaterial: function getMaterial() {\n        return preZPassMaterial;\n      },\n      sort: this.opaqueSortCompare\n    });\n\n    _gl.colorMask(true, true, true, true);\n\n    _gl.depthMask(true);\n  },\n\n  /**\n   * Dispose given scene, including all geometris, textures and shaders in the scene\n   * @param {clay.Scene} scene\n   */\n  disposeScene: function disposeScene(scene) {\n    this.disposeNode(scene, true, true);\n    scene.dispose();\n  },\n\n  /**\n   * Dispose given node, including all geometries, textures and shaders attached on it or its descendant\n   * @param {clay.Node} node\n   * @param {boolean} [disposeGeometry=false] If dispose the geometries used in the descendant mesh\n   * @param {boolean} [disposeTexture=false] If dispose the textures used in the descendant mesh\n   */\n  disposeNode: function disposeNode(root, disposeGeometry, disposeTexture) {\n    // Dettached from parent\n    if (root.getParent()) {\n      root.getParent().remove(root);\n    }\n\n    var disposedMap = {};\n    root.traverse(function (node) {\n      var material = node.material;\n\n      if (node.geometry && disposeGeometry) {\n        node.geometry.dispose(this);\n      }\n\n      if (disposeTexture && material && !disposedMap[material.__uid__]) {\n        var textureUniforms = material.getTextureUniforms();\n\n        for (var u = 0; u < textureUniforms.length; u++) {\n          var uniformName = textureUniforms[u];\n          var val = material.uniforms[uniformName].value;\n          var uniformType = material.uniforms[uniformName].type;\n\n          if (!val) {\n            continue;\n          }\n\n          if (uniformType === 't') {\n            val.dispose && val.dispose(this);\n          } else if (uniformType === 'tv') {\n            for (var k = 0; k < val.length; k++) {\n              if (val[k]) {\n                val[k].dispose && val[k].dispose(this);\n              }\n            }\n          }\n        }\n\n        disposedMap[material.__uid__] = true;\n      } // Particle system and AmbientCubemap light need to dispose\n\n\n      if (node.dispose) {\n        node.dispose(this);\n      }\n    }, this);\n  },\n\n  /**\n   * Dispose given geometry\n   * @param {clay.Geometry} geometry\n   */\n  disposeGeometry: function disposeGeometry(geometry) {\n    geometry.dispose(this);\n  },\n\n  /**\n   * Dispose given texture\n   * @param {clay.Texture} texture\n   */\n  disposeTexture: function disposeTexture(texture) {\n    texture.dispose(this);\n  },\n\n  /**\n   * Dispose given frame buffer\n   * @param {clay.FrameBuffer} frameBuffer\n   */\n  disposeFrameBuffer: function disposeFrameBuffer(frameBuffer) {\n    frameBuffer.dispose(this);\n  },\n\n  /**\n   * Dispose renderer\n   */\n  dispose: function dispose() {},\n\n  /**\n   * Convert screen coords to normalized device coordinates(NDC)\n   * Screen coords can get from mouse event, it is positioned relative to canvas element\n   * NDC can be used in ray casting with Camera.prototype.castRay methods\n   *\n   * @param  {number}       x\n   * @param  {number}       y\n   * @param  {clay.Vector2} [out]\n   * @return {clay.Vector2}\n   */\n  screenToNDC: function screenToNDC(x, y, out) {\n    if (!out) {\n      out = new Vector2();\n    } // Invert y;\n\n\n    y = this._height - y;\n    var viewport = this.viewport;\n    var arr = out.array;\n    arr[0] = (x - viewport.x) / viewport.width;\n    arr[0] = arr[0] * 2 - 1;\n    arr[1] = (y - viewport.y) / viewport.height;\n    arr[1] = arr[1] * 2 - 1;\n    return out;\n  }\n});\n/**\n * Opaque renderables compare function\n * @param  {clay.Renderable} x\n * @param  {clay.Renderable} y\n * @return {boolean}\n * @static\n */\n\nRenderer.opaqueSortCompare = Renderer.prototype.opaqueSortCompare = function (x, y) {\n  // Priority renderOrder -> program -> material -> geometry\n  if (x.renderOrder === y.renderOrder) {\n    if (x.__program === y.__program) {\n      if (x.material === y.material) {\n        return x.geometry.__uid__ - y.geometry.__uid__;\n      }\n\n      return x.material.__uid__ - y.material.__uid__;\n    }\n\n    if (x.__program && y.__program) {\n      return x.__program.__uid__ - y.__program.__uid__;\n    }\n\n    return 0;\n  }\n\n  return x.renderOrder - y.renderOrder;\n};\n/**\n * Transparent renderables compare function\n * @param  {clay.Renderable} a\n * @param  {clay.Renderable} b\n * @return {boolean}\n * @static\n */\n\n\nRenderer.transparentSortCompare = Renderer.prototype.transparentSortCompare = function (x, y) {\n  // Priority renderOrder -> depth -> program -> material -> geometry\n  if (x.renderOrder === y.renderOrder) {\n    if (x.__depth === y.__depth) {\n      if (x.__program === y.__program) {\n        if (x.material === y.material) {\n          return x.geometry.__uid__ - y.geometry.__uid__;\n        }\n\n        return x.material.__uid__ - y.material.__uid__;\n      }\n\n      if (x.__program && y.__program) {\n        return x.__program.__uid__ - y.__program.__uid__;\n      }\n\n      return 0;\n    } // Depth is negative\n    // So farther object has smaller depth value\n\n\n    return x.__depth - y.__depth;\n  }\n\n  return x.renderOrder - y.renderOrder;\n}; // Temporary variables\n\n\nvar matrices = {\n  IDENTITY: mat4Create(),\n  WORLD: mat4Create(),\n  VIEW: mat4Create(),\n  PROJECTION: mat4Create(),\n  WORLDVIEW: mat4Create(),\n  VIEWPROJECTION: mat4Create(),\n  WORLDVIEWPROJECTION: mat4Create(),\n  WORLDINVERSE: mat4Create(),\n  VIEWINVERSE: mat4Create(),\n  PROJECTIONINVERSE: mat4Create(),\n  WORLDVIEWINVERSE: mat4Create(),\n  VIEWPROJECTIONINVERSE: mat4Create(),\n  WORLDVIEWPROJECTIONINVERSE: mat4Create(),\n  WORLDTRANSPOSE: mat4Create(),\n  VIEWTRANSPOSE: mat4Create(),\n  PROJECTIONTRANSPOSE: mat4Create(),\n  WORLDVIEWTRANSPOSE: mat4Create(),\n  VIEWPROJECTIONTRANSPOSE: mat4Create(),\n  WORLDVIEWPROJECTIONTRANSPOSE: mat4Create(),\n  WORLDINVERSETRANSPOSE: mat4Create(),\n  VIEWINVERSETRANSPOSE: mat4Create(),\n  PROJECTIONINVERSETRANSPOSE: mat4Create(),\n  WORLDVIEWINVERSETRANSPOSE: mat4Create(),\n  VIEWPROJECTIONINVERSETRANSPOSE: mat4Create(),\n  WORLDVIEWPROJECTIONINVERSETRANSPOSE: mat4Create()\n};\n/**\n * @name clay.Renderer.COLOR_BUFFER_BIT\n * @type {number}\n */\n\nRenderer.COLOR_BUFFER_BIT = glenum.COLOR_BUFFER_BIT;\n/**\n * @name clay.Renderer.DEPTH_BUFFER_BIT\n * @type {number}\n */\n\nRenderer.DEPTH_BUFFER_BIT = glenum.DEPTH_BUFFER_BIT;\n/**\n * @name clay.Renderer.STENCIL_BUFFER_BIT\n * @type {number}\n */\n\nRenderer.STENCIL_BUFFER_BIT = glenum.STENCIL_BUFFER_BIT;\nexport default Renderer;","map":{"version":3,"sources":["C:/Users/Administrator/Desktop/data_view/my_project/vue2_app/myapp/node_modules/claygl/src/Renderer.js"],"names":["Base","GLInfo","glenum","vendor","Material","Vector2","ProgramManager","Shader","prezEssl","mat4","vec3","mat4Create","create","errorShader","defaultGetMaterial","renderable","material","defaultGetUniform","symbol","uniforms","value","defaultIsMaterialChanged","renderabled","prevRenderable","prevMaterial","defaultIfRender","noop","attributeBufferTypeMap","float","FLOAT","byte","BYTE","ubyte","UNSIGNED_BYTE","short","SHORT","ushort","UNSIGNED_SHORT","VertexArrayObject","availableAttributes","availableAttributeSymbols","indicesBuffer","vao","PlaceHolderTexture","renderer","blankCanvas","webglTexture","bind","createCanvas","width","height","getContext","gl","firstBind","createTexture","bindTexture","TEXTURE_2D","texImage2D","RGBA","unbind","isRenderable","Renderer","extend","canvas","_width","_height","devicePixelRatio","window","clearColor","clearBit","alpha","depth","stencil","antialias","premultipliedAlpha","preserveDrawingBuffer","throwError","viewport","maxJointNumber","__currentFrameBuffer","_viewportStack","_clearStack","_sceneRendering","opts","Error","_glinfo","targetRenderer","console","error","resize","e","_programMgr","_placeholderTexture","dpr","style","setViewport","getWidth","getHeight","getViewportAspect","setDevicePixelRatio","getDevicePixelRatio","getGLExtension","name","getExtension","getGLParameter","getParameter","x","y","obj","saveViewport","push","restoreViewport","length","pop","saveClear","restoreClear","opt","bindSceneRendering","scene","render","camera","notUpdateScene","preZ","_gl","colorMask","depthMask","needsScissor","viewportDpr","enable","SCISSOR_TEST","scissor","clear","disable","update","updateLights","getMainCamera","renderList","updateRenderList","opaqueList","opaque","transparentList","transparent","sceneMaterial","trigger","renderPreZ","depthFunc","LEQUAL","LESS","worldViewMat","posViewSpace","i","multiplyAffine","viewMatrix","array","worldTransform","transformMat4","position","__depth","renderPass","getMaterial","sortCompare","opaqueSortCompare","transparentSortCompare","getProgram","renderMaterial","validateProgram","program","__error","errorMsg","__uid__","updatePrograms","list","passConfig","call","prevJointsLen","joints","jointsLen","lightGroup","__program","getUniform","isMaterialChanged","beforeRender","afterRender","ifRenderObject","ifRender","sort","vDpr","viewportUniform","windowDpr","windowSizeUniform","getTextureWidth","getTextureHeight","viewportSizeUniform","time","Date","now","copy","matrices","VIEW","PROJECTION","projectionMatrix","VIEWINVERSE","identity","multiply","VIEWPROJECTION","invert","PROJECTIONINVERSE","VIEWPROJECTIONINVERSE","prevProgram","depthTest","culling","cullFace","frontFace","drawID","currentVAO","materialTakesTextureSlot","vaoExt","isSceneNode","worldM","isSkinnedMesh","offsetMatrix","IDENTITY","geometry","shader","currentDrawID","drawIDChanged","bindVertexArrayOES","WORLD","WORLDVIEWPROJECTION","WORLDVIEW","matrixSemantics","WORLDINVERSE","WORLDINVERSETRANSPOSE","WORLDVIEWINVERSE","WORLDVIEWINVERSETRANSPOSE","WORLDVIEWPROJECTIONINVERSE","WORLDVIEWPROJECTIONINVERSETRANSPOSE","programChanged","setUniformOfSemantic","near","far","setLightUniforms","DEPTH_TEST","BLEND","blend","blendEquationSeparate","FUNC_ADD","blendFuncSeparate","SRC_ALPHA","ONE_MINUS_SRC_ALPHA","ONE","_bindMaterial","matrixSemanticKeys","k","semantic","semanticInfo","matrix","isTranspose","matrixNoTranspose","semanticNoTranspose","transpose","setUniform","type","CULL_FACE","_updateSkeleton","_bindVAO","_renderObject","getMaxJointNumber","object","slot","skeleton","skinMatricesTexture","getSubSkinMatricesTexture","useTextureSlot","skinMatricesArray","getSubSkinMatrices","glDrawMode","mode","ext","isInstanced","isInstancedMesh","warn","instancedAttrLocations","_bindInstancedAttributes","uintExt","useUintExt","indices","Uint32Array","indicesType","UNSIGNED_INT","drawElementsInstancedANGLE","count","getInstanceCount","drawElements","drawArraysInstancedANGLE","vertexCount","drawArrays","disableVertexAttribArray","instancedBuffers","getInstancedAttributesBuffers","locations","bufferObj","location","getAttribLocation","glType","enableVertexAttribArray","bindBuffer","ARRAY_BUFFER","buffer","vertexAttribPointer","size","vertexAttribDivisorANGLE","divisor","getUniformValue","sameProgram","currentTextureSlot","enabledUniforms","getEnabledUniforms","textureUniforms","getTextureUniforms","placeholderTexture","u","uniformValue","uniformType","__slot","uniform","isTexture","prevUniformValue","takeCurrentTextureSlot","res","Array","isArray","hasUniform","arr","texture","newSlot","resetTextureSlot","isStatic","dynamic","vaoId","__vaoCache","chunks","getBufferChunks","chunk","attributeBuffers","a","attributeBufferInfo","attributeSemantics","attributes","needsBindAttributes","createVertexArrayOES","locationList","enableAttributes","isUseIndices","ELEMENT_ARRAY_BUFFER","preZPassMaterial","_prezMaterial","source","ignorePreZ","matA","matB","get","depthMaterial","isDefined","alphaCutoff","disposeScene","disposeNode","dispose","root","disposeGeometry","disposeTexture","getParent","remove","disposedMap","traverse","node","uniformName","val","disposeFrameBuffer","frameBuffer","screenToNDC","out","prototype","renderOrder","WORLDTRANSPOSE","VIEWTRANSPOSE","PROJECTIONTRANSPOSE","WORLDVIEWTRANSPOSE","VIEWPROJECTIONTRANSPOSE","WORLDVIEWPROJECTIONTRANSPOSE","VIEWINVERSETRANSPOSE","PROJECTIONINVERSETRANSPOSE","VIEWPROJECTIONINVERSETRANSPOSE","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","STENCIL_BUFFER_BIT"],"mappings":"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","sourcesContent":["// TODO Resources like shader, texture, geometry reference management\n// Trace and find out which shader, texture, geometry can be destroyed\nimport Base from './core/Base';\nimport GLInfo from './core/GLInfo';\nimport glenum from './core/glenum';\nimport vendor from './core/vendor';\n\nimport Material from './Material';\nimport Vector2 from './math/Vector2';\nimport ProgramManager from './gpu/ProgramManager';\n\n// Light header\nimport Shader from './Shader';\n\nimport prezEssl from './shader/source/prez.glsl.js';\nShader['import'](prezEssl);\n\nimport mat4 from './glmatrix/mat4';\nimport vec3 from './glmatrix/vec3';\n\nvar mat4Create = mat4.create;\n\nvar errorShader = {};\n\nfunction defaultGetMaterial(renderable) {\n    return renderable.material;\n}\nfunction defaultGetUniform(renderable, material, symbol) {\n    return material.uniforms[symbol].value;\n}\nfunction defaultIsMaterialChanged(renderabled, prevRenderable, material, prevMaterial) {\n    return material !== prevMaterial;\n}\nfunction defaultIfRender(renderable) {\n    return true;\n}\n\nfunction noop() {}\n\nvar attributeBufferTypeMap = {\n    float: glenum.FLOAT,\n    byte: glenum.BYTE,\n    ubyte: glenum.UNSIGNED_BYTE,\n    short: glenum.SHORT,\n    ushort: glenum.UNSIGNED_SHORT\n};\n\nfunction VertexArrayObject(availableAttributes, availableAttributeSymbols, indicesBuffer) {\n    this.availableAttributes = availableAttributes;\n    this.availableAttributeSymbols = availableAttributeSymbols;\n    this.indicesBuffer = indicesBuffer;\n\n    this.vao = null;\n}\n\nfunction PlaceHolderTexture(renderer) {\n    var blankCanvas;\n    var webglTexture;\n    this.bind = function (renderer) {\n        if (!blankCanvas) {\n            // TODO Environment not support createCanvas.\n            blankCanvas = vendor.createCanvas();\n            blankCanvas.width = blankCanvas.height = 1;\n            blankCanvas.getContext('2d');\n        }\n\n        var gl = renderer.gl;\n        var firstBind = !webglTexture;\n        if (firstBind) {\n            webglTexture = gl.createTexture();\n        }\n        gl.bindTexture(gl.TEXTURE_2D, webglTexture);\n        if (firstBind) {\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, blankCanvas);\n        }\n    };\n    this.unbind = function (renderer) {\n        renderer.gl.bindTexture(renderer.gl.TEXTURE_2D, null);\n    };\n    this.isRenderable = function () {\n        return true;\n    };\n}\n/**\n * @constructor clay.Renderer\n * @extends clay.core.Base\n */\nvar Renderer = Base.extend(function () {\n    return /** @lends clay.Renderer# */ {\n\n        /**\n         * @type {HTMLCanvasElement}\n         * @readonly\n         */\n        canvas: null,\n\n        /**\n         * Canvas width, set by resize method\n         * @type {number}\n         * @private\n         */\n        _width: 100,\n\n        /**\n         * Canvas width, set by resize method\n         * @type {number}\n         * @private\n         */\n        _height: 100,\n\n        /**\n         * Device pixel ratio, set by setDevicePixelRatio method\n         * Specially for high defination display\n         * @see http://www.khronos.org/webgl/wiki/HandlingHighDPI\n         * @type {number}\n         * @private\n         */\n        devicePixelRatio: (typeof window !== 'undefined' && window.devicePixelRatio) || 1.0,\n\n        /**\n         * Clear color\n         * @type {number[]}\n         */\n        clearColor: [0.0, 0.0, 0.0, 0.0],\n\n        /**\n         * Default:\n         *     _gl.COLOR_BUFFER_BIT | _gl.DEPTH_BUFFER_BIT | _gl.STENCIL_BUFFER_BIT\n         * @type {number}\n         */\n        clearBit: 17664,\n\n        // Settings when getting context\n        // http://www.khronos.org/registry/webgl/specs/latest/#2.4\n\n        /**\n         * If enable alpha, default true\n         * @type {boolean}\n         */\n        alpha: true,\n        /**\n         * If enable depth buffer, default true\n         * @type {boolean}\n         */\n        depth: true,\n        /**\n         * If enable stencil buffer, default false\n         * @type {boolean}\n         */\n        stencil: false,\n        /**\n         * If enable antialias, default true\n         * @type {boolean}\n         */\n        antialias: true,\n        /**\n         * If enable premultiplied alpha, default true\n         * @type {boolean}\n         */\n        premultipliedAlpha: true,\n        /**\n         * If preserve drawing buffer, default false\n         * @type {boolean}\n         */\n        preserveDrawingBuffer: false,\n        /**\n         * If throw context error, usually turned on in debug mode\n         * @type {boolean}\n         */\n        throwError: true,\n        /**\n         * WebGL Context created from given canvas\n         * @type {WebGLRenderingContext}\n         */\n        gl: null,\n        /**\n         * Renderer viewport, read-only, can be set by setViewport method\n         * @type {Object}\n         */\n        viewport: {},\n\n        /**\n         * Max joint number\n         * @type {number}\n         */\n        maxJointNumber: 20,\n\n        // Set by FrameBuffer#bind\n        __currentFrameBuffer: null,\n\n        _viewportStack: [],\n        _clearStack: [],\n\n        _sceneRendering: null\n    };\n}, function () {\n\n    if (!this.canvas) {\n        this.canvas = vendor.createCanvas();\n    }\n    var canvas = this.canvas;\n    try {\n        var opts = {\n            alpha: this.alpha,\n            depth: this.depth,\n            stencil: this.stencil,\n            antialias: this.antialias,\n            premultipliedAlpha: this.premultipliedAlpha,\n            preserveDrawingBuffer: this.preserveDrawingBuffer\n        };\n\n        this.gl = canvas.getContext('webgl', opts)\n            || canvas.getContext('experimental-webgl', opts);\n\n        if (!this.gl) {\n            throw new Error();\n        }\n\n        this._glinfo = new GLInfo(this.gl);\n\n        if (this.gl.targetRenderer) {\n            console.error('Already created a renderer');\n        }\n        this.gl.targetRenderer = this;\n\n        this.resize();\n    }\n    catch (e) {\n        throw 'Error creating WebGL Context ' + e;\n    }\n\n    // Init managers\n    this._programMgr = new ProgramManager(this);\n\n    this._placeholderTexture = new PlaceHolderTexture(this);\n},\n/** @lends clay.Renderer.prototype. **/\n{\n    /**\n     * Resize the canvas\n     * @param {number} width\n     * @param {number} height\n     */\n    resize: function(width, height) {\n        var canvas = this.canvas;\n        // http://www.khronos.org/webgl/wiki/HandlingHighDPI\n        // set the display size of the canvas.\n        var dpr = this.devicePixelRatio;\n        if (width != null) {\n            if (canvas.style) {\n                canvas.style.width = width + 'px';\n                canvas.style.height = height + 'px';\n            }\n            // set the size of the drawingBuffer\n            canvas.width = width * dpr;\n            canvas.height = height * dpr;\n\n            this._width = width;\n            this._height = height;\n        }\n        else {\n            this._width = canvas.width / dpr;\n            this._height = canvas.height / dpr;\n        }\n\n        this.setViewport(0, 0, this._width, this._height);\n    },\n\n    /**\n     * Get renderer width\n     * @return {number}\n     */\n    getWidth: function () {\n        return this._width;\n    },\n\n    /**\n     * Get renderer height\n     * @return {number}\n     */\n    getHeight: function () {\n        return this._height;\n    },\n\n    /**\n     * Get viewport aspect,\n     * @return {number}\n     */\n    getViewportAspect: function () {\n        var viewport = this.viewport;\n        return viewport.width / viewport.height;\n    },\n\n    /**\n     * Set devicePixelRatio\n     * @param {number} devicePixelRatio\n     */\n    setDevicePixelRatio: function(devicePixelRatio) {\n        this.devicePixelRatio = devicePixelRatio;\n        this.resize(this._width, this._height);\n    },\n\n    /**\n     * Get devicePixelRatio\n     * @param {number} devicePixelRatio\n     */\n    getDevicePixelRatio: function () {\n        return this.devicePixelRatio;\n    },\n\n    /**\n     * Get WebGL extension\n     * @param {string} name\n     * @return {object}\n     */\n    getGLExtension: function (name) {\n        return this._glinfo.getExtension(name);\n    },\n\n    /**\n     * Get WebGL parameter\n     * @param {string} name\n     * @return {*}\n     */\n    getGLParameter: function (name) {\n        return this._glinfo.getParameter(name);\n    },\n\n    /**\n     * Set rendering viewport\n     * @param {number|Object} x\n     * @param {number} [y]\n     * @param {number} [width]\n     * @param {number} [height]\n     * @param {number} [devicePixelRatio]\n     *        Defaultly use the renderere devicePixelRatio\n     *        It needs to be 1 when setViewport is called by frameBuffer\n     *\n     * @example\n     *  setViewport(0,0,width,height,1)\n     *  setViewport({\n     *      x: 0,\n     *      y: 0,\n     *      width: width,\n     *      height: height,\n     *      devicePixelRatio: 1\n     *  })\n     */\n    setViewport: function (x, y, width, height, dpr) {\n\n        if (typeof x === 'object') {\n            var obj = x;\n\n            x = obj.x;\n            y = obj.y;\n            width = obj.width;\n            height = obj.height;\n            dpr = obj.devicePixelRatio;\n        }\n        dpr = dpr || this.devicePixelRatio;\n\n        this.gl.viewport(\n            x * dpr, y * dpr, width * dpr, height * dpr\n        );\n        // Use a fresh new object, not write property.\n        this.viewport = {\n            x: x,\n            y: y,\n            width: width,\n            height: height,\n            devicePixelRatio: dpr\n        };\n    },\n\n    /**\n     * Push current viewport into a stack\n     */\n    saveViewport: function () {\n        this._viewportStack.push(this.viewport);\n    },\n\n    /**\n     * Pop viewport from stack, restore in the renderer\n     */\n    restoreViewport: function () {\n        if (this._viewportStack.length > 0) {\n            this.setViewport(this._viewportStack.pop());\n        }\n    },\n\n    /**\n     * Push current clear into a stack\n     */\n    saveClear: function () {\n        this._clearStack.push({\n            clearBit: this.clearBit,\n            clearColor: this.clearColor\n        });\n    },\n\n    /**\n     * Pop clear from stack, restore in the renderer\n     */\n    restoreClear: function () {\n        if (this._clearStack.length > 0) {\n            var opt = this._clearStack.pop();\n            this.clearColor = opt.clearColor;\n            this.clearBit = opt.clearBit;\n        }\n    },\n\n    bindSceneRendering: function (scene) {\n        this._sceneRendering = scene;\n    },\n\n    /**\n     * Render the scene in camera to the screen or binded offline framebuffer\n     * @param  {clay.Scene}       scene\n     * @param  {clay.Camera}      camera\n     * @param  {boolean}     [notUpdateScene] If not call the scene.update methods in the rendering, default true\n     * @param  {boolean}     [preZ]           If use preZ optimization, default false\n     * @return {IRenderInfo}\n     */\n    render: function(scene, camera, notUpdateScene, preZ) {\n        var _gl = this.gl;\n\n        var clearColor = this.clearColor;\n\n        if (this.clearBit) {\n\n            // Must set depth and color mask true before clear\n            _gl.colorMask(true, true, true, true);\n            _gl.depthMask(true);\n            var viewport = this.viewport;\n            var needsScissor = false;\n            var viewportDpr = viewport.devicePixelRatio;\n            if (viewport.width !== this._width || viewport.height !== this._height\n                || (viewportDpr && viewportDpr !== this.devicePixelRatio)\n                || viewport.x || viewport.y\n            ) {\n                needsScissor = true;\n                // http://stackoverflow.com/questions/11544608/how-to-clear-a-rectangle-area-in-webgl\n                // Only clear the viewport\n                _gl.enable(_gl.SCISSOR_TEST);\n                _gl.scissor(viewport.x * viewportDpr, viewport.y * viewportDpr, viewport.width * viewportDpr, viewport.height * viewportDpr);\n            }\n            _gl.clearColor(clearColor[0], clearColor[1], clearColor[2], clearColor[3]);\n            _gl.clear(this.clearBit);\n            if (needsScissor) {\n                _gl.disable(_gl.SCISSOR_TEST);\n            }\n        }\n\n        // If the scene have been updated in the prepass like shadow map\n        // There is no need to update it again\n        if (!notUpdateScene) {\n            scene.update(false);\n        }\n        scene.updateLights();\n\n        camera = camera || scene.getMainCamera();\n        if (!camera) {\n            console.error('Can\\'t find camera in the scene.');\n            return;\n        }\n        camera.update();\n        var renderList = scene.updateRenderList(camera, true);\n\n        this._sceneRendering = scene;\n\n        var opaqueList = renderList.opaque;\n        var transparentList = renderList.transparent;\n        var sceneMaterial = scene.material;\n\n        scene.trigger('beforerender', this, scene, camera, renderList);\n\n        // Render pre z\n        if (preZ) {\n            this.renderPreZ(opaqueList, scene, camera);\n            _gl.depthFunc(_gl.LEQUAL);\n        }\n        else {\n            _gl.depthFunc(_gl.LESS);\n        }\n\n        // Update the depth of transparent list.\n        var worldViewMat = mat4Create();\n        var posViewSpace = vec3.create();\n        for (var i = 0; i < transparentList.length; i++) {\n            var renderable = transparentList[i];\n            mat4.multiplyAffine(worldViewMat, camera.viewMatrix.array, renderable.worldTransform.array);\n            vec3.transformMat4(posViewSpace, renderable.position.array, worldViewMat);\n            renderable.__depth = posViewSpace[2];\n        }\n\n        // Render opaque list\n        this.renderPass(opaqueList, camera, {\n            getMaterial: function (renderable) {\n                return sceneMaterial || renderable.material;\n            },\n            sortCompare: this.opaqueSortCompare\n        });\n\n        this.renderPass(transparentList, camera, {\n            getMaterial: function (renderable) {\n                return sceneMaterial || renderable.material;\n            },\n            sortCompare: this.transparentSortCompare\n        });\n\n        scene.trigger('afterrender', this, scene, camera, renderList);\n\n        // Cleanup\n        this._sceneRendering = null;\n    },\n\n    getProgram: function (renderable, renderMaterial, scene) {\n        renderMaterial = renderMaterial || renderable.material;\n        return this._programMgr.getProgram(renderable, renderMaterial, scene);\n    },\n\n    validateProgram: function (program) {\n        if (program.__error) {\n            var errorMsg = program.__error;\n            if (errorShader[program.__uid__]) {\n                return;\n            }\n            errorShader[program.__uid__] = true;\n\n            if (this.throwError) {\n                throw new Error(errorMsg);\n            }\n            else {\n                this.trigger('error', errorMsg);\n            }\n\n        }\n\n    },\n\n    updatePrograms: function (list, scene, passConfig) {\n        var getMaterial = (passConfig && passConfig.getMaterial) || defaultGetMaterial;\n        scene = scene || null;\n        for (var i = 0; i < list.length; i++) {\n            var renderable = list[i];\n            var renderMaterial = getMaterial.call(this, renderable);\n            if (i > 0) {\n                var prevRenderable = list[i - 1];\n                var prevJointsLen = prevRenderable.joints ? prevRenderable.joints.length : 0;\n                var jointsLen = renderable.joints ? renderable.joints.length : 0;\n                // Keep program not change if joints, material, lightGroup are same of two renderables.\n                if (jointsLen === prevJointsLen\n                    && renderable.material === prevRenderable.material\n                    && renderable.lightGroup === prevRenderable.lightGroup\n                ) {\n                    renderable.__program = prevRenderable.__program;\n                    continue;\n                }\n            }\n\n            var program = this._programMgr.getProgram(renderable, renderMaterial, scene);\n\n            this.validateProgram(program);\n\n            renderable.__program = program;\n        }\n    },\n\n    /**\n     * Render a single renderable list in camera in sequence\n     * @param {clay.Renderable[]} list List of all renderables.\n     * @param {clay.Camera} [camera] Camera provide view matrix and porjection matrix. It can be null.\n     * @param {Object} [passConfig]\n     * @param {Function} [passConfig.getMaterial] Get renderable material.\n     * @param {Function} [passConfig.getUniform] Get material uniform value.\n     * @param {Function} [passConfig.isMaterialChanged] If material changed.\n     * @param {Function} [passConfig.beforeRender] Before render each renderable.\n     * @param {Function} [passConfig.afterRender] After render each renderable\n     * @param {Function} [passConfig.ifRender] If render the renderable.\n     * @param {Function} [passConfig.sortCompare] Sort compare function.\n     * @return {IRenderInfo}\n     */\n    renderPass: function(list, camera, passConfig) {\n        this.trigger('beforerenderpass', this, list, camera, passConfig);\n\n        passConfig = passConfig || {};\n        passConfig.getMaterial = passConfig.getMaterial || defaultGetMaterial;\n        passConfig.getUniform = passConfig.getUniform || defaultGetUniform;\n        // PENDING Better solution?\n        passConfig.isMaterialChanged = passConfig.isMaterialChanged || defaultIsMaterialChanged;\n        passConfig.beforeRender = passConfig.beforeRender || noop;\n        passConfig.afterRender = passConfig.afterRender || noop;\n\n        var ifRenderObject = passConfig.ifRender || defaultIfRender;\n\n        this.updatePrograms(list, this._sceneRendering, passConfig);\n        if (passConfig.sortCompare) {\n            list.sort(passConfig.sortCompare);\n        }\n\n        // Some common builtin uniforms\n        var viewport = this.viewport;\n        var vDpr = viewport.devicePixelRatio;\n        var viewportUniform = [\n            viewport.x * vDpr, viewport.y * vDpr,\n            viewport.width * vDpr, viewport.height * vDpr\n        ];\n        var windowDpr = this.devicePixelRatio;\n        var windowSizeUniform = this.__currentFrameBuffer\n            ? [this.__currentFrameBuffer.getTextureWidth(), this.__currentFrameBuffer.getTextureHeight()]\n            : [this._width * windowDpr, this._height * windowDpr];\n        // DEPRECATED\n        var viewportSizeUniform = [\n            viewportUniform[2], viewportUniform[3]\n        ];\n        var time = Date.now();\n\n        // Calculate view and projection matrix\n        if (camera) {\n            mat4.copy(matrices.VIEW, camera.viewMatrix.array);\n            mat4.copy(matrices.PROJECTION, camera.projectionMatrix.array);\n            mat4.copy(matrices.VIEWINVERSE, camera.worldTransform.array);\n        }\n        else {\n            mat4.identity(matrices.VIEW);\n            mat4.identity(matrices.PROJECTION);\n            mat4.identity(matrices.VIEWINVERSE);\n        }\n        mat4.multiply(matrices.VIEWPROJECTION, matrices.PROJECTION, matrices.VIEW);\n        mat4.invert(matrices.PROJECTIONINVERSE, matrices.PROJECTION);\n        mat4.invert(matrices.VIEWPROJECTIONINVERSE, matrices.VIEWPROJECTION);\n\n        var _gl = this.gl;\n        var scene = this._sceneRendering;\n\n        var prevMaterial;\n        var prevProgram;\n        var prevRenderable;\n\n        // Status\n        var depthTest, depthMask;\n        var culling, cullFace, frontFace;\n        var transparent;\n        var drawID;\n        var currentVAO;\n        var materialTakesTextureSlot;\n\n        // var vaoExt = this.getGLExtension('OES_vertex_array_object');\n        // not use vaoExt, some platforms may mess it up.\n        var vaoExt = null;\n\n        for (var i = 0; i < list.length; i++) {\n            var renderable = list[i];\n            var isSceneNode = renderable.worldTransform != null;\n            var worldM;\n\n            if (!ifRenderObject(renderable)) {\n                continue;\n            }\n\n            // Skinned mesh will transformed to joint space. Ignore the mesh transform\n            if (isSceneNode) {\n                worldM = (renderable.isSkinnedMesh && renderable.isSkinnedMesh())\n                    // TODO\n                    ? (renderable.offsetMatrix ? renderable.offsetMatrix.array :matrices.IDENTITY)\n                    : renderable.worldTransform.array;\n            }\n            var geometry = renderable.geometry;\n            var material = passConfig.getMaterial.call(this, renderable);\n\n            var program = renderable.__program;\n            var shader = material.shader;\n\n            var currentDrawID = geometry.__uid__ + '-' + program.__uid__;\n            var drawIDChanged = currentDrawID !== drawID;\n            drawID = currentDrawID;\n            if (drawIDChanged && vaoExt) {\n                // TODO Seems need to be bound to null immediately (or before bind another program?) if vao is changed\n                vaoExt.bindVertexArrayOES(null);\n            }\n            if (isSceneNode) {\n                mat4.copy(matrices.WORLD, worldM);\n                mat4.multiply(matrices.WORLDVIEWPROJECTION, matrices.VIEWPROJECTION, worldM);\n                mat4.multiplyAffine(matrices.WORLDVIEW, matrices.VIEW, worldM);\n                if (shader.matrixSemantics.WORLDINVERSE ||\n                    shader.matrixSemantics.WORLDINVERSETRANSPOSE) {\n                    mat4.invert(matrices.WORLDINVERSE, worldM);\n                }\n                if (shader.matrixSemantics.WORLDVIEWINVERSE ||\n                    shader.matrixSemantics.WORLDVIEWINVERSETRANSPOSE) {\n                    mat4.invert(matrices.WORLDVIEWINVERSE, matrices.WORLDVIEW);\n                }\n                if (shader.matrixSemantics.WORLDVIEWPROJECTIONINVERSE ||\n                    shader.matrixSemantics.WORLDVIEWPROJECTIONINVERSETRANSPOSE) {\n                    mat4.invert(matrices.WORLDVIEWPROJECTIONINVERSE, matrices.WORLDVIEWPROJECTION);\n                }\n            }\n\n            // Before render hook\n            renderable.beforeRender && renderable.beforeRender(this);\n            passConfig.beforeRender.call(this, renderable, material, prevMaterial);\n\n            var programChanged = program !== prevProgram;\n            if (programChanged) {\n                // Set lights number\n                program.bind(this);\n                // Set some common uniforms\n                program.setUniformOfSemantic(_gl, 'VIEWPORT', viewportUniform);\n                program.setUniformOfSemantic(_gl, 'WINDOW_SIZE', windowSizeUniform);\n                if (camera) {\n                    program.setUniformOfSemantic(_gl, 'NEAR', camera.near);\n                    program.setUniformOfSemantic(_gl, 'FAR', camera.far);\n                }\n                program.setUniformOfSemantic(_gl, 'DEVICEPIXELRATIO', vDpr);\n                program.setUniformOfSemantic(_gl, 'TIME', time);\n                // DEPRECATED\n                program.setUniformOfSemantic(_gl, 'VIEWPORT_SIZE', viewportSizeUniform);\n\n                // Set lights uniforms\n                // TODO needs optimized\n                if (scene) {\n                    scene.setLightUniforms(program, renderable.lightGroup, this);\n                }\n            }\n            else {\n                program = prevProgram;\n            }\n\n            // Program changes also needs reset the materials.\n            if (programChanged || passConfig.isMaterialChanged(\n                renderable, prevRenderable, material, prevMaterial\n            )) {\n                if (material.depthTest !== depthTest) {\n                    material.depthTest ? _gl.enable(_gl.DEPTH_TEST) : _gl.disable(_gl.DEPTH_TEST);\n                    depthTest = material.depthTest;\n                }\n                if (material.depthMask !== depthMask) {\n                    _gl.depthMask(material.depthMask);\n                    depthMask = material.depthMask;\n                }\n                if (material.transparent !== transparent) {\n                    material.transparent ? _gl.enable(_gl.BLEND) : _gl.disable(_gl.BLEND);\n                    transparent = material.transparent;\n                }\n                // TODO cache blending\n                if (material.transparent) {\n                    if (material.blend) {\n                        material.blend(_gl);\n                    }\n                    else {\n                        // Default blend function\n                        _gl.blendEquationSeparate(_gl.FUNC_ADD, _gl.FUNC_ADD);\n                        _gl.blendFuncSeparate(_gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA, _gl.ONE, _gl.ONE_MINUS_SRC_ALPHA);\n                    }\n                }\n\n                materialTakesTextureSlot = this._bindMaterial(\n                    renderable, material, program,\n                    prevRenderable || null, prevMaterial || null, prevProgram || null,\n                    passConfig.getUniform\n                );\n                prevMaterial = material;\n            }\n\n            var matrixSemanticKeys = shader.matrixSemanticKeys;\n\n            if (isSceneNode) {\n                for (var k = 0; k < matrixSemanticKeys.length; k++) {\n                    var semantic = matrixSemanticKeys[k];\n                    var semanticInfo = shader.matrixSemantics[semantic];\n                    var matrix = matrices[semantic];\n                    if (semanticInfo.isTranspose) {\n                        var matrixNoTranspose = matrices[semanticInfo.semanticNoTranspose];\n                        mat4.transpose(matrix, matrixNoTranspose);\n                    }\n                    program.setUniform(_gl, semanticInfo.type, semanticInfo.symbol, matrix);\n                }\n            }\n\n            if (renderable.cullFace !== cullFace) {\n                cullFace = renderable.cullFace;\n                _gl.cullFace(cullFace);\n            }\n            if (renderable.frontFace !== frontFace) {\n                frontFace = renderable.frontFace;\n                _gl.frontFace(frontFace);\n            }\n            if (renderable.culling !== culling) {\n                culling = renderable.culling;\n                culling ? _gl.enable(_gl.CULL_FACE) : _gl.disable(_gl.CULL_FACE);\n            }\n            // TODO Not update skeleton in each renderable.\n            this._updateSkeleton(renderable, program, materialTakesTextureSlot);\n            if (drawIDChanged) {\n                currentVAO = this._bindVAO(vaoExt, shader, geometry, program);\n            }\n            this._renderObject(renderable, currentVAO, program);\n\n            // After render hook\n            passConfig.afterRender(this, renderable);\n            renderable.afterRender && renderable.afterRender(this);\n\n            prevProgram = program;\n            prevRenderable = renderable;\n        }\n\n        // TODO Seems need to be bound to null immediately if vao is changed?\n        if (vaoExt) {\n            vaoExt.bindVertexArrayOES(null);\n        }\n\n        this.trigger('afterrenderpass', this, list, camera, passConfig);\n    },\n\n    getMaxJointNumber: function () {\n        return this.maxJointNumber;\n    },\n\n    _updateSkeleton: function (object, program, slot) {\n        var _gl = this.gl;\n        var skeleton = object.skeleton;\n        // Set pose matrices of skinned mesh\n        if (skeleton) {\n            // TODO Update before culling.\n            skeleton.update();\n            if (object.joints.length > this.getMaxJointNumber()) {\n                var skinMatricesTexture = skeleton.getSubSkinMatricesTexture(object.__uid__, object.joints);\n                program.useTextureSlot(this, skinMatricesTexture, slot);\n                program.setUniform(_gl, '1i', 'skinMatricesTexture', slot);\n                program.setUniform(_gl, '1f', 'skinMatricesTextureSize', skinMatricesTexture.width);\n            }\n            else {\n                var skinMatricesArray = skeleton.getSubSkinMatrices(object.__uid__, object.joints);\n                program.setUniformOfSemantic(_gl, 'SKIN_MATRIX', skinMatricesArray);\n            }\n        }\n    },\n\n    _renderObject: function (renderable, vao, program) {\n        var _gl = this.gl;\n        var geometry = renderable.geometry;\n\n        var glDrawMode = renderable.mode;\n        if (glDrawMode == null) {\n            glDrawMode = 0x0004;\n        }\n\n        var ext = null;\n        var isInstanced = renderable.isInstancedMesh && renderable.isInstancedMesh();\n        if (isInstanced) {\n            ext = this.getGLExtension('ANGLE_instanced_arrays');\n            if (!ext) {\n                console.warn('Device not support ANGLE_instanced_arrays extension');\n                return;\n            }\n        }\n\n        var instancedAttrLocations;\n        if (isInstanced) {\n            instancedAttrLocations = this._bindInstancedAttributes(renderable, program, ext);\n        }\n\n        if (vao.indicesBuffer) {\n            var uintExt = this.getGLExtension('OES_element_index_uint');\n            var useUintExt = uintExt && (geometry.indices instanceof Uint32Array);\n            var indicesType = useUintExt ? _gl.UNSIGNED_INT : _gl.UNSIGNED_SHORT;\n\n            if (isInstanced) {\n                ext.drawElementsInstancedANGLE(\n                    glDrawMode, vao.indicesBuffer.count, indicesType, 0, renderable.getInstanceCount()\n                );\n            }\n            else {\n                _gl.drawElements(glDrawMode, vao.indicesBuffer.count, indicesType, 0);\n            }\n        }\n        else {\n            if (isInstanced) {\n                ext.drawArraysInstancedANGLE(glDrawMode, 0, geometry.vertexCount, renderable.getInstanceCount());\n            }\n            else {\n                // FIXME Use vertex number in buffer\n                // vertexCount may get the wrong value when geometry forget to mark dirty after update\n                _gl.drawArrays(glDrawMode, 0, geometry.vertexCount);\n            }\n        }\n\n        if (isInstanced) {\n            for (var i = 0; i < instancedAttrLocations.length; i++) {\n                _gl.disableVertexAttribArray(instancedAttrLocations[i]);\n            }\n        }\n    },\n\n    _bindInstancedAttributes: function (renderable, program, ext) {\n        var _gl = this.gl;\n        var instancedBuffers = renderable.getInstancedAttributesBuffers(this);\n        var locations = [];\n\n        for (var i = 0; i < instancedBuffers.length; i++) {\n            var bufferObj = instancedBuffers[i];\n            var location = program.getAttribLocation(_gl, bufferObj.symbol);\n            if (location < 0) {\n                continue;\n            }\n\n            var glType = attributeBufferTypeMap[bufferObj.type] || _gl.FLOAT;;\n            _gl.enableVertexAttribArray(location);  // TODO\n            _gl.bindBuffer(_gl.ARRAY_BUFFER, bufferObj.buffer);\n            _gl.vertexAttribPointer(location, bufferObj.size, glType, false, 0, 0);\n            ext.vertexAttribDivisorANGLE(location, bufferObj.divisor);\n\n            locations.push(location);\n        }\n\n        return locations;\n    },\n\n    _bindMaterial: function (renderable, material, program, prevRenderable, prevMaterial, prevProgram, getUniformValue) {\n        var _gl = this.gl;\n        // PENDING Same texture in different material take different slot?\n\n        // May use shader of other material if shader code are same\n        var sameProgram = prevProgram === program;\n\n        var currentTextureSlot = program.currentTextureSlot();\n        var enabledUniforms = material.getEnabledUniforms();\n        var textureUniforms = material.getTextureUniforms();\n        var placeholderTexture = this._placeholderTexture;\n\n        for (var u = 0; u < textureUniforms.length; u++) {\n            var symbol = textureUniforms[u];\n            var uniformValue = getUniformValue(renderable, material, symbol);\n            var uniformType = material.uniforms[symbol].type;\n            // Not use `instanceof` to determine if a value is texture in Material#bind.\n            // Use type instead, in some case texture may be in different namespaces.\n            // TODO Duck type validate.\n            if (uniformType === 't' && uniformValue) {\n                // Reset slot\n                uniformValue.__slot = -1;\n            }\n            else if (uniformType === 'tv') {\n                for (var i = 0; i < uniformValue.length; i++) {\n                    if (uniformValue[i]) {\n                        uniformValue[i].__slot = -1;\n                    }\n                }\n            }\n        }\n\n        placeholderTexture.__slot = -1;\n\n        // Set uniforms\n        for (var u = 0; u < enabledUniforms.length; u++) {\n            var symbol = enabledUniforms[u];\n            var uniform = material.uniforms[symbol];\n            var uniformValue = getUniformValue(renderable, material, symbol);\n            var uniformType = uniform.type;\n            var isTexture = uniformType === 't';\n\n            if (isTexture) {\n                if (!uniformValue || !uniformValue.isRenderable()) {\n                    uniformValue = placeholderTexture;\n                }\n            }\n            // PENDING\n            // When binding two materials with the same shader\n            // Many uniforms will be be set twice even if they have the same value\n            // So add a evaluation to see if the uniform is really needed to be set\n            if (prevMaterial && sameProgram) {\n                var prevUniformValue = getUniformValue(prevRenderable, prevMaterial, symbol);\n                if (isTexture) {\n                    if (!prevUniformValue || !prevUniformValue.isRenderable()) {\n                        prevUniformValue = placeholderTexture;\n                    }\n                }\n\n                if (prevUniformValue === uniformValue) {\n                    if (isTexture) {\n                        // Still take the slot to make sure same texture in different materials have same slot.\n                        program.takeCurrentTextureSlot(this, null);\n                    }\n                    else if (uniformType === 'tv' && uniformValue) {\n                        for (var i = 0; i < uniformValue.length; i++) {\n                            program.takeCurrentTextureSlot(this, null);\n                        }\n                    }\n                    continue;\n                }\n            }\n\n            if (uniformValue == null) {\n                continue;\n            }\n            else if (isTexture) {\n                if (uniformValue.__slot < 0) {\n                    var slot = program.currentTextureSlot();\n                    var res = program.setUniform(_gl, '1i', symbol, slot);\n                    if (res) { // Texture uniform is enabled\n                        program.takeCurrentTextureSlot(this, uniformValue);\n                        uniformValue.__slot = slot;\n                    }\n                }\n                // Multiple uniform use same texture..\n                else {\n                    program.setUniform(_gl, '1i', symbol, uniformValue.__slot);\n                }\n            }\n            else if (Array.isArray(uniformValue)) {\n                if (uniformValue.length === 0) {\n                    continue;\n                }\n                // Texture Array\n                if (uniformType === 'tv') {\n                    if (!program.hasUniform(symbol)) {\n                        continue;\n                    }\n\n                    var arr = [];\n                    for (var i = 0; i < uniformValue.length; i++) {\n                        var texture = uniformValue[i];\n\n                        if (texture.__slot < 0) {\n                            var slot = program.currentTextureSlot();\n                            arr.push(slot);\n                            program.takeCurrentTextureSlot(this, texture);\n                            texture.__slot = slot;\n                        }\n                        else {\n                            arr.push(texture.__slot);\n                        }\n                    }\n\n                    program.setUniform(_gl, '1iv', symbol, arr);\n                }\n                else {\n                    program.setUniform(_gl, uniform.type, symbol, uniformValue);\n                }\n            }\n            else{\n                program.setUniform(_gl, uniform.type, symbol, uniformValue);\n            }\n        }\n        var newSlot = program.currentTextureSlot();\n        // Texture slot maybe used out of material.\n        program.resetTextureSlot(currentTextureSlot);\n        return newSlot;\n    },\n\n    _bindVAO: function (vaoExt, shader, geometry, program) {\n        var isStatic = !geometry.dynamic;\n        var _gl = this.gl;\n\n        var vaoId = this.__uid__ + '-' + program.__uid__;\n        var vao = geometry.__vaoCache[vaoId];\n        if (!vao) {\n            var chunks = geometry.getBufferChunks(this);\n            if (!chunks || !chunks.length) {  // Empty mesh\n                return;\n            }\n            var chunk = chunks[0];\n            var attributeBuffers = chunk.attributeBuffers;\n            var indicesBuffer = chunk.indicesBuffer;\n\n            var availableAttributes = [];\n            var availableAttributeSymbols = [];\n            for (var a = 0; a < attributeBuffers.length; a++) {\n                var attributeBufferInfo = attributeBuffers[a];\n                var name = attributeBufferInfo.name;\n                var semantic = attributeBufferInfo.semantic;\n                var symbol;\n                if (semantic) {\n                    var semanticInfo = shader.attributeSemantics[semantic];\n                    symbol = semanticInfo && semanticInfo.symbol;\n                }\n                else {\n                    symbol = name;\n                }\n                if (symbol && program.attributes[symbol]) {\n                    availableAttributes.push(attributeBufferInfo);\n                    availableAttributeSymbols.push(symbol);\n                }\n            }\n\n            vao = new VertexArrayObject(\n                availableAttributes,\n                availableAttributeSymbols,\n                indicesBuffer\n            );\n\n            if (isStatic) {\n                geometry.__vaoCache[vaoId] = vao;\n            }\n        }\n\n        var needsBindAttributes = true;\n\n        // Create vertex object array cost a lot\n        // So we don't use it on the dynamic object\n        if (vaoExt && isStatic) {\n            // Use vertex array object\n            // http://blog.tojicode.com/2012/10/oesvertexarrayobject-extension.html\n            if (vao.vao == null) {\n                vao.vao = vaoExt.createVertexArrayOES();\n            }\n            else {\n                needsBindAttributes = false;\n            }\n            vaoExt.bindVertexArrayOES(vao.vao);\n        }\n\n        var availableAttributes = vao.availableAttributes;\n        var indicesBuffer = vao.indicesBuffer;\n\n        if (needsBindAttributes) {\n            var locationList = program.enableAttributes(this, vao.availableAttributeSymbols, (vaoExt && isStatic && vao));\n            // Setting attributes;\n            for (var a = 0; a < availableAttributes.length; a++) {\n                var location = locationList[a];\n                if (location === -1) {\n                    continue;\n                }\n                var attributeBufferInfo = availableAttributes[a];\n                var buffer = attributeBufferInfo.buffer;\n                var size = attributeBufferInfo.size;\n                var glType = attributeBufferTypeMap[attributeBufferInfo.type] || _gl.FLOAT;\n\n                _gl.bindBuffer(_gl.ARRAY_BUFFER, buffer);\n                _gl.vertexAttribPointer(location, size, glType, false, 0, 0);\n            }\n\n            if (geometry.isUseIndices()) {\n                _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, indicesBuffer.buffer);\n            }\n        }\n\n        return vao;\n    },\n\n    renderPreZ: function (list, scene, camera) {\n        var _gl = this.gl;\n        var preZPassMaterial = this._prezMaterial || new Material({\n            shader: new Shader(Shader.source('clay.prez.vertex'), Shader.source('clay.prez.fragment'))\n        });\n        this._prezMaterial = preZPassMaterial;\n\n        _gl.colorMask(false, false, false, false);\n        _gl.depthMask(true);\n\n        // Status\n        this.renderPass(list, camera, {\n            ifRender: function (renderable) {\n                return !renderable.ignorePreZ;\n            },\n            isMaterialChanged: function (renderable, prevRenderable) {\n                var matA = renderable.material;\n                var matB = prevRenderable.material;\n                return matA.get('diffuseMap') !== matB.get('diffuseMap')\n                    || (matA.get('alphaCutoff') || 0) !== (matB.get('alphaCutoff') || 0);\n            },\n            getUniform: function (renderable, depthMaterial, symbol) {\n                if (symbol === 'alphaMap') {\n                    return renderable.material.get('diffuseMap');\n                }\n                else if (symbol === 'alphaCutoff') {\n                    if (renderable.material.isDefined('fragment', 'ALPHA_TEST')\n                        && renderable.material.get('diffuseMap')\n                    ) {\n                        var alphaCutoff = renderable.material.get('alphaCutoff');\n                        return alphaCutoff || 0;\n                    }\n                    return 0;\n                }\n                else if (symbol === 'uvRepeat') {\n                    return renderable.material.get('uvRepeat');\n                }\n                else if (symbol === 'uvOffset') {\n                    return renderable.material.get('uvOffset');\n                }\n                else {\n                    return depthMaterial.get(symbol);\n                }\n            },\n            getMaterial: function () {\n                return preZPassMaterial;\n            },\n            sort: this.opaqueSortCompare\n        });\n\n        _gl.colorMask(true, true, true, true);\n        _gl.depthMask(true);\n    },\n\n    /**\n     * Dispose given scene, including all geometris, textures and shaders in the scene\n     * @param {clay.Scene} scene\n     */\n    disposeScene: function(scene) {\n        this.disposeNode(scene, true, true);\n        scene.dispose();\n    },\n\n    /**\n     * Dispose given node, including all geometries, textures and shaders attached on it or its descendant\n     * @param {clay.Node} node\n     * @param {boolean} [disposeGeometry=false] If dispose the geometries used in the descendant mesh\n     * @param {boolean} [disposeTexture=false] If dispose the textures used in the descendant mesh\n     */\n    disposeNode: function(root, disposeGeometry, disposeTexture) {\n        // Dettached from parent\n        if (root.getParent()) {\n            root.getParent().remove(root);\n        }\n        var disposedMap = {};\n        root.traverse(function(node) {\n            var material = node.material;\n            if (node.geometry && disposeGeometry) {\n                node.geometry.dispose(this);\n            }\n            if (disposeTexture && material && !disposedMap[material.__uid__]) {\n                var textureUniforms = material.getTextureUniforms();\n                for (var u = 0; u < textureUniforms.length; u++) {\n                    var uniformName = textureUniforms[u];\n                    var val = material.uniforms[uniformName].value;\n                    var uniformType = material.uniforms[uniformName].type;\n                    if (!val) {\n                        continue;\n                    }\n                    if (uniformType === 't') {\n                        val.dispose && val.dispose(this);\n                    }\n                    else if (uniformType === 'tv') {\n                        for (var k = 0; k < val.length; k++) {\n                            if (val[k]) {\n                                val[k].dispose && val[k].dispose(this);\n                            }\n                        }\n                    }\n                }\n                disposedMap[material.__uid__] = true;\n            }\n            // Particle system and AmbientCubemap light need to dispose\n            if (node.dispose) {\n                node.dispose(this);\n            }\n        }, this);\n    },\n\n    /**\n     * Dispose given geometry\n     * @param {clay.Geometry} geometry\n     */\n    disposeGeometry: function(geometry) {\n        geometry.dispose(this);\n    },\n\n    /**\n     * Dispose given texture\n     * @param {clay.Texture} texture\n     */\n    disposeTexture: function(texture) {\n        texture.dispose(this);\n    },\n\n    /**\n     * Dispose given frame buffer\n     * @param {clay.FrameBuffer} frameBuffer\n     */\n    disposeFrameBuffer: function(frameBuffer) {\n        frameBuffer.dispose(this);\n    },\n\n    /**\n     * Dispose renderer\n     */\n    dispose: function () {},\n\n    /**\n     * Convert screen coords to normalized device coordinates(NDC)\n     * Screen coords can get from mouse event, it is positioned relative to canvas element\n     * NDC can be used in ray casting with Camera.prototype.castRay methods\n     *\n     * @param  {number}       x\n     * @param  {number}       y\n     * @param  {clay.Vector2} [out]\n     * @return {clay.Vector2}\n     */\n    screenToNDC: function(x, y, out) {\n        if (!out) {\n            out = new Vector2();\n        }\n        // Invert y;\n        y = this._height - y;\n\n        var viewport = this.viewport;\n        var arr = out.array;\n        arr[0] = (x - viewport.x) / viewport.width;\n        arr[0] = arr[0] * 2 - 1;\n        arr[1] = (y - viewport.y) / viewport.height;\n        arr[1] = arr[1] * 2 - 1;\n\n        return out;\n    }\n});\n\n/**\n * Opaque renderables compare function\n * @param  {clay.Renderable} x\n * @param  {clay.Renderable} y\n * @return {boolean}\n * @static\n */\nRenderer.opaqueSortCompare = Renderer.prototype.opaqueSortCompare = function(x, y) {\n    // Priority renderOrder -> program -> material -> geometry\n    if (x.renderOrder === y.renderOrder) {\n        if (x.__program === y.__program) {\n            if (x.material === y.material) {\n                return x.geometry.__uid__ - y.geometry.__uid__;\n            }\n            return x.material.__uid__ - y.material.__uid__;\n        }\n        if (x.__program && y.__program) {\n            return x.__program.__uid__ - y.__program.__uid__;\n        }\n        return 0;\n    }\n    return x.renderOrder - y.renderOrder;\n};\n\n/**\n * Transparent renderables compare function\n * @param  {clay.Renderable} a\n * @param  {clay.Renderable} b\n * @return {boolean}\n * @static\n */\nRenderer.transparentSortCompare = Renderer.prototype.transparentSortCompare = function(x, y) {\n    // Priority renderOrder -> depth -> program -> material -> geometry\n\n    if (x.renderOrder === y.renderOrder) {\n        if (x.__depth === y.__depth) {\n            if (x.__program === y.__program) {\n                if (x.material === y.material) {\n                    return x.geometry.__uid__ - y.geometry.__uid__;\n                }\n                return x.material.__uid__ - y.material.__uid__;\n            }\n            if (x.__program  && y.__program) {\n                return x.__program.__uid__ - y.__program.__uid__;\n            }\n            return 0;\n        }\n        // Depth is negative\n        // So farther object has smaller depth value\n        return x.__depth - y.__depth;\n    }\n    return x.renderOrder - y.renderOrder;\n};\n\n// Temporary variables\nvar matrices = {\n    IDENTITY: mat4Create(),\n\n    WORLD: mat4Create(),\n    VIEW: mat4Create(),\n    PROJECTION: mat4Create(),\n    WORLDVIEW: mat4Create(),\n    VIEWPROJECTION: mat4Create(),\n    WORLDVIEWPROJECTION: mat4Create(),\n\n    WORLDINVERSE: mat4Create(),\n    VIEWINVERSE: mat4Create(),\n    PROJECTIONINVERSE: mat4Create(),\n    WORLDVIEWINVERSE: mat4Create(),\n    VIEWPROJECTIONINVERSE: mat4Create(),\n    WORLDVIEWPROJECTIONINVERSE: mat4Create(),\n\n    WORLDTRANSPOSE: mat4Create(),\n    VIEWTRANSPOSE: mat4Create(),\n    PROJECTIONTRANSPOSE: mat4Create(),\n    WORLDVIEWTRANSPOSE: mat4Create(),\n    VIEWPROJECTIONTRANSPOSE: mat4Create(),\n    WORLDVIEWPROJECTIONTRANSPOSE: mat4Create(),\n    WORLDINVERSETRANSPOSE: mat4Create(),\n    VIEWINVERSETRANSPOSE: mat4Create(),\n    PROJECTIONINVERSETRANSPOSE: mat4Create(),\n    WORLDVIEWINVERSETRANSPOSE: mat4Create(),\n    VIEWPROJECTIONINVERSETRANSPOSE: mat4Create(),\n    WORLDVIEWPROJECTIONINVERSETRANSPOSE: mat4Create()\n};\n\n/**\n * @name clay.Renderer.COLOR_BUFFER_BIT\n * @type {number}\n */\nRenderer.COLOR_BUFFER_BIT = glenum.COLOR_BUFFER_BIT;\n/**\n * @name clay.Renderer.DEPTH_BUFFER_BIT\n * @type {number}\n */\nRenderer.DEPTH_BUFFER_BIT = glenum.DEPTH_BUFFER_BIT;\n/**\n * @name clay.Renderer.STENCIL_BUFFER_BIT\n * @type {number}\n */\nRenderer.STENCIL_BUFFER_BIT = glenum.STENCIL_BUFFER_BIT;\n\nexport default Renderer;\n"]},"metadata":{},"sourceType":"module"}