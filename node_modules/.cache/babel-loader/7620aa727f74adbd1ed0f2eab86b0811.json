{"ast":null,"code":"import \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport graphicGL from '../../util/graphicGL';\nimport verticesSortMixin from '../../util/geometry/verticesSortMixin';\nimport * as echarts from 'echarts/lib/echarts';\nimport glmatrix from 'claygl/src/dep/glmatrix';\nvar vec4 = glmatrix.vec4;\nimport sdfSpriteGLSL from './sdfSprite.glsl.js';\ngraphicGL.Shader.import(sdfSpriteGLSL);\nvar PointsMesh = graphicGL.Mesh.extend(function () {\n  var geometry = new graphicGL.Geometry({\n    dynamic: true,\n    attributes: {\n      color: new graphicGL.Geometry.Attribute('color', 'float', 4, 'COLOR'),\n      position: new graphicGL.Geometry.Attribute('position', 'float', 3, 'POSITION'),\n      size: new graphicGL.Geometry.Attribute('size', 'float', 1),\n      prevPosition: new graphicGL.Geometry.Attribute('prevPosition', 'float', 3),\n      prevSize: new graphicGL.Geometry.Attribute('prevSize', 'float', 1)\n    }\n  });\n  Object.assign(geometry, verticesSortMixin);\n  var material = new graphicGL.Material({\n    shader: graphicGL.createShader('ecgl.sdfSprite'),\n    transparent: true,\n    depthMask: false\n  });\n  material.enableTexture('sprite');\n  material.define('both', 'VERTEX_COLOR');\n  material.define('both', 'VERTEX_SIZE');\n  var sdfTexture = new graphicGL.Texture2D({\n    image: document.createElement('canvas'),\n    flipY: false\n  });\n  material.set('sprite', sdfTexture); // Custom pick methods.\n\n  geometry.pick = this._pick.bind(this);\n  return {\n    geometry: geometry,\n    material: material,\n    mode: graphicGL.Mesh.POINTS,\n    sizeScale: 1\n  };\n}, {\n  _pick: function (x, y, renderer, camera, renderable, out) {\n    var positionNDC = this._positionNDC;\n\n    if (!positionNDC) {\n      return;\n    }\n\n    var viewport = renderer.viewport;\n    var ndcScaleX = 2 / viewport.width;\n    var ndcScaleY = 2 / viewport.height; // From near to far. indices have been sorted.\n\n    for (var i = this.geometry.vertexCount - 1; i >= 0; i--) {\n      var idx;\n\n      if (!this.geometry.indices) {\n        idx = i;\n      } else {\n        idx = this.geometry.indices[i];\n      }\n\n      var cx = positionNDC[idx * 2];\n      var cy = positionNDC[idx * 2 + 1];\n      var size = this.geometry.attributes.size.get(idx) / this.sizeScale;\n      var halfSize = size / 2;\n\n      if (x > cx - halfSize * ndcScaleX && x < cx + halfSize * ndcScaleX && y > cy - halfSize * ndcScaleY && y < cy + halfSize * ndcScaleY) {\n        var point = new graphicGL.Vector3();\n        var pointWorld = new graphicGL.Vector3();\n        this.geometry.attributes.position.get(idx, point.array);\n        graphicGL.Vector3.transformMat4(pointWorld, point, this.worldTransform);\n        out.push({\n          vertexIndex: idx,\n          point: point,\n          pointWorld: pointWorld,\n          target: this,\n          distance: pointWorld.distance(camera.getWorldPosition())\n        });\n      }\n    }\n  },\n  updateNDCPosition: function (worldViewProjection, is2D, api) {\n    var positionNDC = this._positionNDC;\n    var geometry = this.geometry;\n\n    if (!positionNDC || positionNDC.length / 2 !== geometry.vertexCount) {\n      positionNDC = this._positionNDC = new Float32Array(geometry.vertexCount * 2);\n    }\n\n    var pos = vec4.create();\n\n    for (var i = 0; i < geometry.vertexCount; i++) {\n      geometry.attributes.position.get(i, pos);\n      pos[3] = 1;\n      vec4.transformMat4(pos, pos, worldViewProjection.array);\n      vec4.scale(pos, pos, 1 / pos[3]);\n      positionNDC[i * 2] = pos[0];\n      positionNDC[i * 2 + 1] = pos[1];\n    }\n  }\n});\nexport default PointsMesh;","map":{"version":3,"sources":["C:/Users/Administrator/Desktop/data_view/my_project/vue2_app/myapp/node_modules/echarts-gl/lib/chart/common/PointsMesh.js"],"names":["graphicGL","verticesSortMixin","echarts","glmatrix","vec4","sdfSpriteGLSL","Shader","import","PointsMesh","Mesh","extend","geometry","Geometry","dynamic","attributes","color","Attribute","position","size","prevPosition","prevSize","Object","assign","material","Material","shader","createShader","transparent","depthMask","enableTexture","define","sdfTexture","Texture2D","image","document","createElement","flipY","set","pick","_pick","bind","mode","POINTS","sizeScale","x","y","renderer","camera","renderable","out","positionNDC","_positionNDC","viewport","ndcScaleX","width","ndcScaleY","height","i","vertexCount","idx","indices","cx","cy","get","halfSize","point","Vector3","pointWorld","array","transformMat4","worldTransform","push","vertexIndex","target","distance","getWorldPosition","updateNDCPosition","worldViewProjection","is2D","api","length","Float32Array","pos","create","scale"],"mappings":"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","sourcesContent":["import graphicGL from '../../util/graphicGL';\nimport verticesSortMixin from '../../util/geometry/verticesSortMixin';\nimport * as echarts from 'echarts/lib/echarts';\nimport glmatrix from 'claygl/src/dep/glmatrix';\nvar vec4 = glmatrix.vec4;\nimport sdfSpriteGLSL from './sdfSprite.glsl.js';\ngraphicGL.Shader.import(sdfSpriteGLSL);\nvar PointsMesh = graphicGL.Mesh.extend(function () {\n  var geometry = new graphicGL.Geometry({\n    dynamic: true,\n    attributes: {\n      color: new graphicGL.Geometry.Attribute('color', 'float', 4, 'COLOR'),\n      position: new graphicGL.Geometry.Attribute('position', 'float', 3, 'POSITION'),\n      size: new graphicGL.Geometry.Attribute('size', 'float', 1),\n      prevPosition: new graphicGL.Geometry.Attribute('prevPosition', 'float', 3),\n      prevSize: new graphicGL.Geometry.Attribute('prevSize', 'float', 1)\n    }\n  });\n  Object.assign(geometry, verticesSortMixin);\n  var material = new graphicGL.Material({\n    shader: graphicGL.createShader('ecgl.sdfSprite'),\n    transparent: true,\n    depthMask: false\n  });\n  material.enableTexture('sprite');\n  material.define('both', 'VERTEX_COLOR');\n  material.define('both', 'VERTEX_SIZE');\n  var sdfTexture = new graphicGL.Texture2D({\n    image: document.createElement('canvas'),\n    flipY: false\n  });\n  material.set('sprite', sdfTexture); // Custom pick methods.\n\n  geometry.pick = this._pick.bind(this);\n  return {\n    geometry: geometry,\n    material: material,\n    mode: graphicGL.Mesh.POINTS,\n    sizeScale: 1\n  };\n}, {\n  _pick: function (x, y, renderer, camera, renderable, out) {\n    var positionNDC = this._positionNDC;\n\n    if (!positionNDC) {\n      return;\n    }\n\n    var viewport = renderer.viewport;\n    var ndcScaleX = 2 / viewport.width;\n    var ndcScaleY = 2 / viewport.height; // From near to far. indices have been sorted.\n\n    for (var i = this.geometry.vertexCount - 1; i >= 0; i--) {\n      var idx;\n\n      if (!this.geometry.indices) {\n        idx = i;\n      } else {\n        idx = this.geometry.indices[i];\n      }\n\n      var cx = positionNDC[idx * 2];\n      var cy = positionNDC[idx * 2 + 1];\n      var size = this.geometry.attributes.size.get(idx) / this.sizeScale;\n      var halfSize = size / 2;\n\n      if (x > cx - halfSize * ndcScaleX && x < cx + halfSize * ndcScaleX && y > cy - halfSize * ndcScaleY && y < cy + halfSize * ndcScaleY) {\n        var point = new graphicGL.Vector3();\n        var pointWorld = new graphicGL.Vector3();\n        this.geometry.attributes.position.get(idx, point.array);\n        graphicGL.Vector3.transformMat4(pointWorld, point, this.worldTransform);\n        out.push({\n          vertexIndex: idx,\n          point: point,\n          pointWorld: pointWorld,\n          target: this,\n          distance: pointWorld.distance(camera.getWorldPosition())\n        });\n      }\n    }\n  },\n  updateNDCPosition: function (worldViewProjection, is2D, api) {\n    var positionNDC = this._positionNDC;\n    var geometry = this.geometry;\n\n    if (!positionNDC || positionNDC.length / 2 !== geometry.vertexCount) {\n      positionNDC = this._positionNDC = new Float32Array(geometry.vertexCount * 2);\n    }\n\n    var pos = vec4.create();\n\n    for (var i = 0; i < geometry.vertexCount; i++) {\n      geometry.attributes.position.get(i, pos);\n      pos[3] = 1;\n      vec4.transformMat4(pos, pos, worldViewProjection.array);\n      vec4.scale(pos, pos, 1 / pos[3]);\n      positionNDC[i * 2] = pos[0];\n      positionNDC[i * 2 + 1] = pos[1];\n    }\n  }\n});\nexport default PointsMesh;"]},"metadata":{},"sourceType":"module"}