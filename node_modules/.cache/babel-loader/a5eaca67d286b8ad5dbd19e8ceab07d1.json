{"ast":null,"code":"import \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.typed-array.float32-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport * as echarts from 'echarts/lib/echarts';\nimport graphicGL from '../../util/graphicGL';\nimport retrieve from '../../util/retrieve';\nimport ViewGL from '../../core/ViewGL';\nimport VectorFieldParticleSurface from './VectorFieldParticleSurface'; // TODO 百度地图不是 linear 的\n\nexport default echarts.ChartView.extend({\n  type: 'flowGL',\n  __ecgl__: true,\n  init: function init(ecModel, api) {\n    this.viewGL = new ViewGL('orthographic');\n    this.groupGL = new graphicGL.Node();\n    this.viewGL.add(this.groupGL);\n    this._particleSurface = new VectorFieldParticleSurface();\n    var planeMesh = new graphicGL.Mesh({\n      geometry: new graphicGL.PlaneGeometry(),\n      material: new graphicGL.Material({\n        shader: new graphicGL.Shader({\n          vertex: graphicGL.Shader.source('ecgl.color.vertex'),\n          fragment: graphicGL.Shader.source('ecgl.color.fragment')\n        }),\n        // Must enable blending and multiply alpha.\n        // Or premultipliedAlpha will let the alpha useless.\n        transparent: true\n      })\n    });\n    planeMesh.material.enableTexture('diffuseMap');\n    this.groupGL.add(planeMesh);\n    this._planeMesh = planeMesh;\n  },\n  render: function render(seriesModel, ecModel, api) {\n    var particleSurface = this._particleSurface; // Set particleType before set others.\n\n    particleSurface.setParticleType(seriesModel.get('particleType'));\n    particleSurface.setSupersampling(seriesModel.get('supersampling'));\n\n    this._updateData(seriesModel, api);\n\n    this._updateCamera(api.getWidth(), api.getHeight(), api.getDevicePixelRatio());\n\n    var particleDensity = retrieve.firstNotNull(seriesModel.get('particleDensity'), 128);\n    particleSurface.setParticleDensity(particleDensity, particleDensity);\n    var planeMesh = this._planeMesh;\n    var time = +new Date();\n    var self = this;\n    var firstFrame = true;\n    planeMesh.__percent = 0;\n    planeMesh.stopAnimation();\n    planeMesh.animate('', {\n      loop: true\n    }).when(100000, {\n      __percent: 1\n    }).during(function () {\n      var timeNow = +new Date();\n      var dTime = Math.min(timeNow - time, 20);\n      time = time + dTime;\n\n      if (self._renderer) {\n        particleSurface.update(self._renderer, api, dTime / 1000, firstFrame);\n        planeMesh.material.set('diffuseMap', particleSurface.getSurfaceTexture()); // planeMesh.material.set('diffuseMap', self._particleSurface.vectorFieldTexture);\n      }\n\n      firstFrame = false;\n    }).start();\n    var itemStyleModel = seriesModel.getModel('itemStyle');\n    var color = graphicGL.parseColor(itemStyleModel.get('color'));\n    color[3] *= retrieve.firstNotNull(itemStyleModel.get('opacity'), 1);\n    planeMesh.material.set('color', color);\n    particleSurface.setColorTextureImage(seriesModel.get('colorTexture'), api);\n    particleSurface.setParticleSize(seriesModel.get('particleSize'));\n    particleSurface.particleSpeedScaling = seriesModel.get('particleSpeed');\n    particleSurface.motionBlurFactor = 1.0 - Math.pow(0.1, seriesModel.get('particleTrail'));\n  },\n  updateTransform: function updateTransform(seriesModel, ecModel, api) {\n    this._updateData(seriesModel, api);\n  },\n  afterRender: function afterRender(globeModel, ecModel, api, layerGL) {\n    var renderer = layerGL.renderer;\n    this._renderer = renderer;\n  },\n  _updateData: function _updateData(seriesModel, api) {\n    var coordSys = seriesModel.coordinateSystem;\n    var dims = coordSys.dimensions.map(function (coordDim) {\n      return seriesModel.coordDimToDataDim(coordDim)[0];\n    });\n    var data = seriesModel.getData();\n    var xExtent = data.getDataExtent(dims[0]);\n    var yExtent = data.getDataExtent(dims[1]);\n    var gridWidth = seriesModel.get('gridWidth');\n    var gridHeight = seriesModel.get('gridHeight');\n\n    if (gridWidth == null || gridWidth === 'auto') {\n      // TODO not accurate.\n      var aspect = (xExtent[1] - xExtent[0]) / (yExtent[1] - yExtent[0]);\n      gridWidth = Math.round(Math.sqrt(aspect * data.count()));\n    }\n\n    if (gridHeight == null || gridHeight === 'auto') {\n      gridHeight = Math.ceil(data.count() / gridWidth);\n    }\n\n    var vectorFieldTexture = this._particleSurface.vectorFieldTexture; // Half Float needs Uint16Array\n\n    var pixels = vectorFieldTexture.pixels;\n\n    if (!pixels || pixels.length !== gridHeight * gridWidth * 4) {\n      pixels = vectorFieldTexture.pixels = new Float32Array(gridWidth * gridHeight * 4);\n    } else {\n      for (var i = 0; i < pixels.length; i++) {\n        pixels[i] = 0;\n      }\n    }\n\n    var maxMag = 0;\n    var minMag = Infinity;\n    var points = new Float32Array(data.count() * 2);\n    var offset = 0;\n    var bbox = [[Infinity, Infinity], [-Infinity, -Infinity]];\n    data.each([dims[0], dims[1], 'vx', 'vy'], function (x, y, vx, vy) {\n      var pt = coordSys.dataToPoint([x, y]);\n      points[offset++] = pt[0];\n      points[offset++] = pt[1];\n      bbox[0][0] = Math.min(pt[0], bbox[0][0]);\n      bbox[0][1] = Math.min(pt[1], bbox[0][1]);\n      bbox[1][0] = Math.max(pt[0], bbox[1][0]);\n      bbox[1][1] = Math.max(pt[1], bbox[1][1]);\n      var mag = Math.sqrt(vx * vx + vy * vy);\n      maxMag = Math.max(maxMag, mag);\n      minMag = Math.min(minMag, mag);\n    });\n    data.each(['vx', 'vy'], function (vx, vy, i) {\n      var xPix = Math.round((points[i * 2] - bbox[0][0]) / (bbox[1][0] - bbox[0][0]) * (gridWidth - 1));\n      var yPix = gridHeight - 1 - Math.round((points[i * 2 + 1] - bbox[0][1]) / (bbox[1][1] - bbox[0][1]) * (gridHeight - 1));\n      var idx = (yPix * gridWidth + xPix) * 4;\n      pixels[idx] = vx / maxMag * 0.5 + 0.5;\n      pixels[idx + 1] = vy / maxMag * 0.5 + 0.5;\n      pixels[idx + 3] = 1;\n    });\n    vectorFieldTexture.width = gridWidth;\n    vectorFieldTexture.height = gridHeight;\n\n    if (seriesModel.get('coordinateSystem') === 'bmap') {\n      this._fillEmptyPixels(vectorFieldTexture);\n    }\n\n    vectorFieldTexture.dirty();\n\n    this._updatePlanePosition(bbox[0], bbox[1], seriesModel, api);\n\n    this._updateGradientTexture(data.getVisual('visualMeta'), [minMag, maxMag]);\n  },\n  // PENDING Use grid mesh ? or delaunay triangulation?\n  _fillEmptyPixels: function _fillEmptyPixels(texture) {\n    var pixels = texture.pixels;\n    var width = texture.width;\n    var height = texture.height;\n\n    function fetchPixel(x, y, rg) {\n      x = Math.max(Math.min(x, width - 1), 0);\n      y = Math.max(Math.min(y, height - 1), 0);\n      var idx = (y * (width - 1) + x) * 4;\n\n      if (pixels[idx + 3] === 0) {\n        return false;\n      }\n\n      rg[0] = pixels[idx];\n      rg[1] = pixels[idx + 1];\n      return true;\n    }\n\n    function addPixel(a, b, out) {\n      out[0] = a[0] + b[0];\n      out[1] = a[1] + b[1];\n    }\n\n    var center = [],\n        left = [],\n        right = [],\n        top = [],\n        bottom = [];\n    var weight = 0;\n\n    for (var y = 0; y < height; y++) {\n      for (var x = 0; x < width; x++) {\n        var idx = (y * (width - 1) + x) * 4;\n\n        if (pixels[idx + 3] === 0) {\n          weight = center[0] = center[1] = 0;\n\n          if (fetchPixel(x - 1, y, left)) {\n            weight++;\n            addPixel(left, center, center);\n          }\n\n          if (fetchPixel(x + 1, y, right)) {\n            weight++;\n            addPixel(right, center, center);\n          }\n\n          if (fetchPixel(x, y - 1, top)) {\n            weight++;\n            addPixel(top, center, center);\n          }\n\n          if (fetchPixel(x, y + 1, bottom)) {\n            weight++;\n            addPixel(bottom, center, center);\n          }\n\n          center[0] /= weight;\n          center[1] /= weight; // PENDING If overwrite. bilinear interpolation.\n\n          pixels[idx] = center[0];\n          pixels[idx + 1] = center[1];\n        }\n\n        pixels[idx + 3] = 1;\n      }\n    }\n  },\n  _updateGradientTexture: function _updateGradientTexture(visualMeta, magExtent) {\n    if (!visualMeta || !visualMeta.length) {\n      this._particleSurface.setGradientTexture(null);\n\n      return;\n    } // TODO Different dimensions\n\n\n    this._gradientTexture = this._gradientTexture || new graphicGL.Texture2D({\n      image: document.createElement('canvas')\n    });\n    var gradientTexture = this._gradientTexture;\n    var canvas = gradientTexture.image;\n    canvas.width = 200;\n    canvas.height = 1;\n    var ctx = canvas.getContext('2d');\n    var gradient = ctx.createLinearGradient(0, 0.5, canvas.width, 0.5);\n    visualMeta[0].stops.forEach(function (stop) {\n      var offset;\n\n      if (magExtent[1] === magExtent[0]) {\n        offset = 0;\n      } else {\n        offset = stop.value / magExtent[1];\n        offset = Math.min(Math.max(offset, 0), 1);\n      }\n\n      gradient.addColorStop(offset, stop.color);\n    });\n    ctx.fillStyle = gradient;\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n    gradientTexture.dirty();\n\n    this._particleSurface.setGradientTexture(this._gradientTexture);\n  },\n  _updatePlanePosition: function _updatePlanePosition(leftTop, rightBottom, seriesModel, api) {\n    var limitedResult = this._limitInViewportAndFullFill(leftTop, rightBottom, seriesModel, api);\n\n    leftTop = limitedResult.leftTop;\n    rightBottom = limitedResult.rightBottom;\n\n    this._particleSurface.setRegion(limitedResult.region);\n\n    this._planeMesh.position.set((leftTop[0] + rightBottom[0]) / 2, api.getHeight() - (leftTop[1] + rightBottom[1]) / 2, 0);\n\n    var width = rightBottom[0] - leftTop[0];\n    var height = rightBottom[1] - leftTop[1];\n\n    this._planeMesh.scale.set(width / 2, height / 2, 1);\n\n    this._particleSurface.resize(Math.max(Math.min(width, 2048), 1), Math.max(Math.min(height, 2048), 1));\n\n    if (this._renderer) {\n      this._particleSurface.clearFrame(this._renderer);\n    }\n  },\n  _limitInViewportAndFullFill: function _limitInViewportAndFullFill(leftTop, rightBottom, seriesModel, api) {\n    var newLeftTop = [Math.max(leftTop[0], 0), Math.max(leftTop[1], 0)];\n    var newRightBottom = [Math.min(rightBottom[0], api.getWidth()), Math.min(rightBottom[1], api.getHeight())]; // Tiliing in lng orientation.\n\n    if (seriesModel.get('coordinateSystem') === 'bmap') {\n      var lngRange = seriesModel.getData().getDataExtent(seriesModel.coordDimToDataDim('lng')[0]); // PENDING, consider grid density\n\n      var isContinuous = Math.floor(lngRange[1] - lngRange[0]) >= 359;\n\n      if (isContinuous) {\n        if (newLeftTop[0] > 0) {\n          newLeftTop[0] = 0;\n        }\n\n        if (newRightBottom[0] < api.getWidth()) {\n          newRightBottom[0] = api.getWidth();\n        }\n      }\n    }\n\n    var width = rightBottom[0] - leftTop[0];\n    var height = rightBottom[1] - leftTop[1];\n    var newWidth = newRightBottom[0] - newLeftTop[0];\n    var newHeight = newRightBottom[1] - newLeftTop[1];\n    var region = [(newLeftTop[0] - leftTop[0]) / width, 1.0 - newHeight / height - (newLeftTop[1] - leftTop[1]) / height, newWidth / width, newHeight / height];\n    return {\n      leftTop: newLeftTop,\n      rightBottom: newRightBottom,\n      region: region\n    };\n  },\n  _updateCamera: function _updateCamera(width, height, dpr) {\n    this.viewGL.setViewport(0, 0, width, height, dpr);\n    var camera = this.viewGL.camera; // FIXME  bottom can't be larger than top\n\n    camera.left = camera.bottom = 0;\n    camera.top = height;\n    camera.right = width;\n    camera.near = 0;\n    camera.far = 100;\n    camera.position.z = 10;\n  },\n  remove: function remove() {\n    this._planeMesh.stopAnimation();\n\n    this.groupGL.removeAll();\n  },\n  dispose: function dispose() {\n    if (this._renderer) {\n      this._particleSurface.dispose(this._renderer);\n    }\n\n    this.groupGL.removeAll();\n  }\n});","map":{"version":3,"sources":["C:/Users/Administrator/Desktop/data_view/my_project/vue2_app/myapp/node_modules/echarts-gl/lib/chart/flowGL/FlowGLView.js"],"names":["echarts","graphicGL","retrieve","ViewGL","VectorFieldParticleSurface","ChartView","extend","type","__ecgl__","init","ecModel","api","viewGL","groupGL","Node","add","_particleSurface","planeMesh","Mesh","geometry","PlaneGeometry","material","Material","shader","Shader","vertex","source","fragment","transparent","enableTexture","_planeMesh","render","seriesModel","particleSurface","setParticleType","get","setSupersampling","_updateData","_updateCamera","getWidth","getHeight","getDevicePixelRatio","particleDensity","firstNotNull","setParticleDensity","time","Date","self","firstFrame","__percent","stopAnimation","animate","loop","when","during","timeNow","dTime","Math","min","_renderer","update","set","getSurfaceTexture","start","itemStyleModel","getModel","color","parseColor","setColorTextureImage","setParticleSize","particleSpeedScaling","motionBlurFactor","pow","updateTransform","afterRender","globeModel","layerGL","renderer","coordSys","coordinateSystem","dims","dimensions","map","coordDim","coordDimToDataDim","data","getData","xExtent","getDataExtent","yExtent","gridWidth","gridHeight","aspect","round","sqrt","count","ceil","vectorFieldTexture","pixels","length","Float32Array","i","maxMag","minMag","Infinity","points","offset","bbox","each","x","y","vx","vy","pt","dataToPoint","max","mag","xPix","yPix","idx","width","height","_fillEmptyPixels","dirty","_updatePlanePosition","_updateGradientTexture","getVisual","texture","fetchPixel","rg","addPixel","a","b","out","center","left","right","top","bottom","weight","visualMeta","magExtent","setGradientTexture","_gradientTexture","Texture2D","image","document","createElement","gradientTexture","canvas","ctx","getContext","gradient","createLinearGradient","stops","forEach","stop","value","addColorStop","fillStyle","fillRect","leftTop","rightBottom","limitedResult","_limitInViewportAndFullFill","setRegion","region","position","scale","resize","clearFrame","newLeftTop","newRightBottom","lngRange","isContinuous","floor","newWidth","newHeight","dpr","setViewport","camera","near","far","z","remove","removeAll","dispose"],"mappings":"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","sourcesContent":["import * as echarts from 'echarts/lib/echarts';\nimport graphicGL from '../../util/graphicGL';\nimport retrieve from '../../util/retrieve';\nimport ViewGL from '../../core/ViewGL';\nimport VectorFieldParticleSurface from './VectorFieldParticleSurface'; // TODO 百度地图不是 linear 的\n\nexport default echarts.ChartView.extend({\n  type: 'flowGL',\n  __ecgl__: true,\n  init: function (ecModel, api) {\n    this.viewGL = new ViewGL('orthographic');\n    this.groupGL = new graphicGL.Node();\n    this.viewGL.add(this.groupGL);\n    this._particleSurface = new VectorFieldParticleSurface();\n    var planeMesh = new graphicGL.Mesh({\n      geometry: new graphicGL.PlaneGeometry(),\n      material: new graphicGL.Material({\n        shader: new graphicGL.Shader({\n          vertex: graphicGL.Shader.source('ecgl.color.vertex'),\n          fragment: graphicGL.Shader.source('ecgl.color.fragment')\n        }),\n        // Must enable blending and multiply alpha.\n        // Or premultipliedAlpha will let the alpha useless.\n        transparent: true\n      })\n    });\n    planeMesh.material.enableTexture('diffuseMap');\n    this.groupGL.add(planeMesh);\n    this._planeMesh = planeMesh;\n  },\n  render: function (seriesModel, ecModel, api) {\n    var particleSurface = this._particleSurface; // Set particleType before set others.\n\n    particleSurface.setParticleType(seriesModel.get('particleType'));\n    particleSurface.setSupersampling(seriesModel.get('supersampling'));\n\n    this._updateData(seriesModel, api);\n\n    this._updateCamera(api.getWidth(), api.getHeight(), api.getDevicePixelRatio());\n\n    var particleDensity = retrieve.firstNotNull(seriesModel.get('particleDensity'), 128);\n    particleSurface.setParticleDensity(particleDensity, particleDensity);\n    var planeMesh = this._planeMesh;\n    var time = +new Date();\n    var self = this;\n    var firstFrame = true;\n    planeMesh.__percent = 0;\n    planeMesh.stopAnimation();\n    planeMesh.animate('', {\n      loop: true\n    }).when(100000, {\n      __percent: 1\n    }).during(function () {\n      var timeNow = +new Date();\n      var dTime = Math.min(timeNow - time, 20);\n      time = time + dTime;\n\n      if (self._renderer) {\n        particleSurface.update(self._renderer, api, dTime / 1000, firstFrame);\n        planeMesh.material.set('diffuseMap', particleSurface.getSurfaceTexture()); // planeMesh.material.set('diffuseMap', self._particleSurface.vectorFieldTexture);\n      }\n\n      firstFrame = false;\n    }).start();\n    var itemStyleModel = seriesModel.getModel('itemStyle');\n    var color = graphicGL.parseColor(itemStyleModel.get('color'));\n    color[3] *= retrieve.firstNotNull(itemStyleModel.get('opacity'), 1);\n    planeMesh.material.set('color', color);\n    particleSurface.setColorTextureImage(seriesModel.get('colorTexture'), api);\n    particleSurface.setParticleSize(seriesModel.get('particleSize'));\n    particleSurface.particleSpeedScaling = seriesModel.get('particleSpeed');\n    particleSurface.motionBlurFactor = 1.0 - Math.pow(0.1, seriesModel.get('particleTrail'));\n  },\n  updateTransform: function (seriesModel, ecModel, api) {\n    this._updateData(seriesModel, api);\n  },\n  afterRender: function (globeModel, ecModel, api, layerGL) {\n    var renderer = layerGL.renderer;\n    this._renderer = renderer;\n  },\n  _updateData: function (seriesModel, api) {\n    var coordSys = seriesModel.coordinateSystem;\n    var dims = coordSys.dimensions.map(function (coordDim) {\n      return seriesModel.coordDimToDataDim(coordDim)[0];\n    });\n    var data = seriesModel.getData();\n    var xExtent = data.getDataExtent(dims[0]);\n    var yExtent = data.getDataExtent(dims[1]);\n    var gridWidth = seriesModel.get('gridWidth');\n    var gridHeight = seriesModel.get('gridHeight');\n\n    if (gridWidth == null || gridWidth === 'auto') {\n      // TODO not accurate.\n      var aspect = (xExtent[1] - xExtent[0]) / (yExtent[1] - yExtent[0]);\n      gridWidth = Math.round(Math.sqrt(aspect * data.count()));\n    }\n\n    if (gridHeight == null || gridHeight === 'auto') {\n      gridHeight = Math.ceil(data.count() / gridWidth);\n    }\n\n    var vectorFieldTexture = this._particleSurface.vectorFieldTexture; // Half Float needs Uint16Array\n\n    var pixels = vectorFieldTexture.pixels;\n\n    if (!pixels || pixels.length !== gridHeight * gridWidth * 4) {\n      pixels = vectorFieldTexture.pixels = new Float32Array(gridWidth * gridHeight * 4);\n    } else {\n      for (var i = 0; i < pixels.length; i++) {\n        pixels[i] = 0;\n      }\n    }\n\n    var maxMag = 0;\n    var minMag = Infinity;\n    var points = new Float32Array(data.count() * 2);\n    var offset = 0;\n    var bbox = [[Infinity, Infinity], [-Infinity, -Infinity]];\n    data.each([dims[0], dims[1], 'vx', 'vy'], function (x, y, vx, vy) {\n      var pt = coordSys.dataToPoint([x, y]);\n      points[offset++] = pt[0];\n      points[offset++] = pt[1];\n      bbox[0][0] = Math.min(pt[0], bbox[0][0]);\n      bbox[0][1] = Math.min(pt[1], bbox[0][1]);\n      bbox[1][0] = Math.max(pt[0], bbox[1][0]);\n      bbox[1][1] = Math.max(pt[1], bbox[1][1]);\n      var mag = Math.sqrt(vx * vx + vy * vy);\n      maxMag = Math.max(maxMag, mag);\n      minMag = Math.min(minMag, mag);\n    });\n    data.each(['vx', 'vy'], function (vx, vy, i) {\n      var xPix = Math.round((points[i * 2] - bbox[0][0]) / (bbox[1][0] - bbox[0][0]) * (gridWidth - 1));\n      var yPix = gridHeight - 1 - Math.round((points[i * 2 + 1] - bbox[0][1]) / (bbox[1][1] - bbox[0][1]) * (gridHeight - 1));\n      var idx = (yPix * gridWidth + xPix) * 4;\n      pixels[idx] = vx / maxMag * 0.5 + 0.5;\n      pixels[idx + 1] = vy / maxMag * 0.5 + 0.5;\n      pixels[idx + 3] = 1;\n    });\n    vectorFieldTexture.width = gridWidth;\n    vectorFieldTexture.height = gridHeight;\n\n    if (seriesModel.get('coordinateSystem') === 'bmap') {\n      this._fillEmptyPixels(vectorFieldTexture);\n    }\n\n    vectorFieldTexture.dirty();\n\n    this._updatePlanePosition(bbox[0], bbox[1], seriesModel, api);\n\n    this._updateGradientTexture(data.getVisual('visualMeta'), [minMag, maxMag]);\n  },\n  // PENDING Use grid mesh ? or delaunay triangulation?\n  _fillEmptyPixels: function (texture) {\n    var pixels = texture.pixels;\n    var width = texture.width;\n    var height = texture.height;\n\n    function fetchPixel(x, y, rg) {\n      x = Math.max(Math.min(x, width - 1), 0);\n      y = Math.max(Math.min(y, height - 1), 0);\n      var idx = (y * (width - 1) + x) * 4;\n\n      if (pixels[idx + 3] === 0) {\n        return false;\n      }\n\n      rg[0] = pixels[idx];\n      rg[1] = pixels[idx + 1];\n      return true;\n    }\n\n    function addPixel(a, b, out) {\n      out[0] = a[0] + b[0];\n      out[1] = a[1] + b[1];\n    }\n\n    var center = [],\n        left = [],\n        right = [],\n        top = [],\n        bottom = [];\n    var weight = 0;\n\n    for (var y = 0; y < height; y++) {\n      for (var x = 0; x < width; x++) {\n        var idx = (y * (width - 1) + x) * 4;\n\n        if (pixels[idx + 3] === 0) {\n          weight = center[0] = center[1] = 0;\n\n          if (fetchPixel(x - 1, y, left)) {\n            weight++;\n            addPixel(left, center, center);\n          }\n\n          if (fetchPixel(x + 1, y, right)) {\n            weight++;\n            addPixel(right, center, center);\n          }\n\n          if (fetchPixel(x, y - 1, top)) {\n            weight++;\n            addPixel(top, center, center);\n          }\n\n          if (fetchPixel(x, y + 1, bottom)) {\n            weight++;\n            addPixel(bottom, center, center);\n          }\n\n          center[0] /= weight;\n          center[1] /= weight; // PENDING If overwrite. bilinear interpolation.\n\n          pixels[idx] = center[0];\n          pixels[idx + 1] = center[1];\n        }\n\n        pixels[idx + 3] = 1;\n      }\n    }\n  },\n  _updateGradientTexture: function (visualMeta, magExtent) {\n    if (!visualMeta || !visualMeta.length) {\n      this._particleSurface.setGradientTexture(null);\n\n      return;\n    } // TODO Different dimensions\n\n\n    this._gradientTexture = this._gradientTexture || new graphicGL.Texture2D({\n      image: document.createElement('canvas')\n    });\n    var gradientTexture = this._gradientTexture;\n    var canvas = gradientTexture.image;\n    canvas.width = 200;\n    canvas.height = 1;\n    var ctx = canvas.getContext('2d');\n    var gradient = ctx.createLinearGradient(0, 0.5, canvas.width, 0.5);\n    visualMeta[0].stops.forEach(function (stop) {\n      var offset;\n\n      if (magExtent[1] === magExtent[0]) {\n        offset = 0;\n      } else {\n        offset = stop.value / magExtent[1];\n        offset = Math.min(Math.max(offset, 0), 1);\n      }\n\n      gradient.addColorStop(offset, stop.color);\n    });\n    ctx.fillStyle = gradient;\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n    gradientTexture.dirty();\n\n    this._particleSurface.setGradientTexture(this._gradientTexture);\n  },\n  _updatePlanePosition: function (leftTop, rightBottom, seriesModel, api) {\n    var limitedResult = this._limitInViewportAndFullFill(leftTop, rightBottom, seriesModel, api);\n\n    leftTop = limitedResult.leftTop;\n    rightBottom = limitedResult.rightBottom;\n\n    this._particleSurface.setRegion(limitedResult.region);\n\n    this._planeMesh.position.set((leftTop[0] + rightBottom[0]) / 2, api.getHeight() - (leftTop[1] + rightBottom[1]) / 2, 0);\n\n    var width = rightBottom[0] - leftTop[0];\n    var height = rightBottom[1] - leftTop[1];\n\n    this._planeMesh.scale.set(width / 2, height / 2, 1);\n\n    this._particleSurface.resize(Math.max(Math.min(width, 2048), 1), Math.max(Math.min(height, 2048), 1));\n\n    if (this._renderer) {\n      this._particleSurface.clearFrame(this._renderer);\n    }\n  },\n  _limitInViewportAndFullFill: function (leftTop, rightBottom, seriesModel, api) {\n    var newLeftTop = [Math.max(leftTop[0], 0), Math.max(leftTop[1], 0)];\n    var newRightBottom = [Math.min(rightBottom[0], api.getWidth()), Math.min(rightBottom[1], api.getHeight())]; // Tiliing in lng orientation.\n\n    if (seriesModel.get('coordinateSystem') === 'bmap') {\n      var lngRange = seriesModel.getData().getDataExtent(seriesModel.coordDimToDataDim('lng')[0]); // PENDING, consider grid density\n\n      var isContinuous = Math.floor(lngRange[1] - lngRange[0]) >= 359;\n\n      if (isContinuous) {\n        if (newLeftTop[0] > 0) {\n          newLeftTop[0] = 0;\n        }\n\n        if (newRightBottom[0] < api.getWidth()) {\n          newRightBottom[0] = api.getWidth();\n        }\n      }\n    }\n\n    var width = rightBottom[0] - leftTop[0];\n    var height = rightBottom[1] - leftTop[1];\n    var newWidth = newRightBottom[0] - newLeftTop[0];\n    var newHeight = newRightBottom[1] - newLeftTop[1];\n    var region = [(newLeftTop[0] - leftTop[0]) / width, 1.0 - newHeight / height - (newLeftTop[1] - leftTop[1]) / height, newWidth / width, newHeight / height];\n    return {\n      leftTop: newLeftTop,\n      rightBottom: newRightBottom,\n      region: region\n    };\n  },\n  _updateCamera: function (width, height, dpr) {\n    this.viewGL.setViewport(0, 0, width, height, dpr);\n    var camera = this.viewGL.camera; // FIXME  bottom can't be larger than top\n\n    camera.left = camera.bottom = 0;\n    camera.top = height;\n    camera.right = width;\n    camera.near = 0;\n    camera.far = 100;\n    camera.position.z = 10;\n  },\n  remove: function () {\n    this._planeMesh.stopAnimation();\n\n    this.groupGL.removeAll();\n  },\n  dispose: function () {\n    if (this._renderer) {\n      this._particleSurface.dispose(this._renderer);\n    }\n\n    this.groupGL.removeAll();\n  }\n});"]},"metadata":{},"sourceType":"module"}