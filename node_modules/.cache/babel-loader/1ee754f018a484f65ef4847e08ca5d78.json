{"ast":null,"code":"'use strict';\n\nrequire(\"core-js/modules/es.error.cause.js\");\n\nrequire(\"core-js/modules/es.array.map.js\");\n\nrequire(\"core-js/modules/es.object.to-string.js\");\n\nrequire(\"core-js/modules/es.symbol.iterator.js\");\n\nrequire(\"core-js/modules/es.string.iterator.js\");\n\nrequire(\"core-js/modules/web.dom-collections.iterator.js\");\n\nrequire(\"core-js/modules/es.symbol.js\");\n\nrequire(\"core-js/modules/es.symbol.description.js\");\n\nrequire(\"core-js/modules/es.regexp.to-string.js\");\n\nrequire(\"core-js/modules/es.regexp.exec.js\");\n\nrequire(\"core-js/modules/es.regexp.test.js\");\n\nrequire(\"core-js/modules/es.string.replace.js\");\n\nrequire(\"core-js/modules/es.string.match.js\");\n\nexports.__esModule = true;\n\nvar _jsBase = require('js-base64');\n\nvar _sourceMap = require('source-map');\n\nvar _sourceMap2 = _interopRequireDefault(_sourceMap);\n\nvar _path = require('path');\n\nvar _path2 = _interopRequireDefault(_path);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar MapGenerator = function () {\n  function MapGenerator(stringify, root, opts) {\n    _classCallCheck(this, MapGenerator);\n\n    this.stringify = stringify;\n    this.mapOpts = opts.map || {};\n    this.root = root;\n    this.opts = opts;\n  }\n\n  MapGenerator.prototype.isMap = function isMap() {\n    if (typeof this.opts.map !== 'undefined') {\n      return !!this.opts.map;\n    } else {\n      return this.previous().length > 0;\n    }\n  };\n\n  MapGenerator.prototype.previous = function previous() {\n    var _this = this;\n\n    if (!this.previousMaps) {\n      this.previousMaps = [];\n      this.root.walk(function (node) {\n        if (node.source && node.source.input.map) {\n          var map = node.source.input.map;\n\n          if (_this.previousMaps.indexOf(map) === -1) {\n            _this.previousMaps.push(map);\n          }\n        }\n      });\n    }\n\n    return this.previousMaps;\n  };\n\n  MapGenerator.prototype.isInline = function isInline() {\n    if (typeof this.mapOpts.inline !== 'undefined') {\n      return this.mapOpts.inline;\n    }\n\n    var annotation = this.mapOpts.annotation;\n\n    if (typeof annotation !== 'undefined' && annotation !== true) {\n      return false;\n    }\n\n    if (this.previous().length) {\n      return this.previous().some(function (i) {\n        return i.inline;\n      });\n    } else {\n      return true;\n    }\n  };\n\n  MapGenerator.prototype.isSourcesContent = function isSourcesContent() {\n    if (typeof this.mapOpts.sourcesContent !== 'undefined') {\n      return this.mapOpts.sourcesContent;\n    }\n\n    if (this.previous().length) {\n      return this.previous().some(function (i) {\n        return i.withContent();\n      });\n    } else {\n      return true;\n    }\n  };\n\n  MapGenerator.prototype.clearAnnotation = function clearAnnotation() {\n    if (this.mapOpts.annotation === false) return;\n    var node = void 0;\n\n    for (var i = this.root.nodes.length - 1; i >= 0; i--) {\n      node = this.root.nodes[i];\n      if (node.type !== 'comment') continue;\n\n      if (node.text.indexOf('# sourceMappingURL=') === 0) {\n        this.root.removeChild(i);\n      }\n    }\n  };\n\n  MapGenerator.prototype.setSourcesContent = function setSourcesContent() {\n    var _this2 = this;\n\n    var already = {};\n    this.root.walk(function (node) {\n      if (node.source) {\n        var from = node.source.input.from;\n\n        if (from && !already[from]) {\n          already[from] = true;\n\n          var relative = _this2.relative(from);\n\n          _this2.map.setSourceContent(relative, node.source.input.css);\n        }\n      }\n    });\n  };\n\n  MapGenerator.prototype.applyPrevMaps = function applyPrevMaps() {\n    for (var _iterator = this.previous(), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var prev = _ref;\n      var from = this.relative(prev.file);\n\n      var root = prev.root || _path2.default.dirname(prev.file);\n\n      var map = void 0;\n\n      if (this.mapOpts.sourcesContent === false) {\n        map = new _sourceMap2.default.SourceMapConsumer(prev.text);\n\n        if (map.sourcesContent) {\n          map.sourcesContent = map.sourcesContent.map(function () {\n            return null;\n          });\n        }\n      } else {\n        map = prev.consumer();\n      }\n\n      this.map.applySourceMap(map, from, this.relative(root));\n    }\n  };\n\n  MapGenerator.prototype.isAnnotation = function isAnnotation() {\n    if (this.isInline()) {\n      return true;\n    } else if (typeof this.mapOpts.annotation !== 'undefined') {\n      return this.mapOpts.annotation;\n    } else if (this.previous().length) {\n      return this.previous().some(function (i) {\n        return i.annotation;\n      });\n    } else {\n      return true;\n    }\n  };\n\n  MapGenerator.prototype.addAnnotation = function addAnnotation() {\n    var content = void 0;\n\n    if (this.isInline()) {\n      content = 'data:application/json;base64,' + _jsBase.Base64.encode(this.map.toString());\n    } else if (typeof this.mapOpts.annotation === 'string') {\n      content = this.mapOpts.annotation;\n    } else {\n      content = this.outputFile() + '.map';\n    }\n\n    var eol = '\\n';\n    if (this.css.indexOf('\\r\\n') !== -1) eol = '\\r\\n';\n    this.css += eol + '/*# sourceMappingURL=' + content + ' */';\n  };\n\n  MapGenerator.prototype.outputFile = function outputFile() {\n    if (this.opts.to) {\n      return this.relative(this.opts.to);\n    } else if (this.opts.from) {\n      return this.relative(this.opts.from);\n    } else {\n      return 'to.css';\n    }\n  };\n\n  MapGenerator.prototype.generateMap = function generateMap() {\n    this.generateString();\n    if (this.isSourcesContent()) this.setSourcesContent();\n    if (this.previous().length > 0) this.applyPrevMaps();\n    if (this.isAnnotation()) this.addAnnotation();\n\n    if (this.isInline()) {\n      return [this.css];\n    } else {\n      return [this.css, this.map];\n    }\n  };\n\n  MapGenerator.prototype.relative = function relative(file) {\n    if (file.indexOf('<') === 0) return file;\n    if (/^\\w+:\\/\\//.test(file)) return file;\n    var from = this.opts.to ? _path2.default.dirname(this.opts.to) : '.';\n\n    if (typeof this.mapOpts.annotation === 'string') {\n      from = _path2.default.dirname(_path2.default.resolve(from, this.mapOpts.annotation));\n    }\n\n    file = _path2.default.relative(from, file);\n\n    if (_path2.default.sep === '\\\\') {\n      return file.replace(/\\\\/g, '/');\n    } else {\n      return file;\n    }\n  };\n\n  MapGenerator.prototype.sourcePath = function sourcePath(node) {\n    if (this.mapOpts.from) {\n      return this.mapOpts.from;\n    } else {\n      return this.relative(node.source.input.from);\n    }\n  };\n\n  MapGenerator.prototype.generateString = function generateString() {\n    var _this3 = this;\n\n    this.css = '';\n    this.map = new _sourceMap2.default.SourceMapGenerator({\n      file: this.outputFile()\n    });\n    var line = 1;\n    var column = 1;\n    var lines = void 0,\n        last = void 0;\n    this.stringify(this.root, function (str, node, type) {\n      _this3.css += str;\n\n      if (node && type !== 'end') {\n        if (node.source && node.source.start) {\n          _this3.map.addMapping({\n            source: _this3.sourcePath(node),\n            generated: {\n              line: line,\n              column: column - 1\n            },\n            original: {\n              line: node.source.start.line,\n              column: node.source.start.column - 1\n            }\n          });\n        } else {\n          _this3.map.addMapping({\n            source: '<no source>',\n            original: {\n              line: 1,\n              column: 0\n            },\n            generated: {\n              line: line,\n              column: column - 1\n            }\n          });\n        }\n      }\n\n      lines = str.match(/\\n/g);\n\n      if (lines) {\n        line += lines.length;\n        last = str.lastIndexOf('\\n');\n        column = str.length - last;\n      } else {\n        column += str.length;\n      }\n\n      if (node && type !== 'start') {\n        if (node.source && node.source.end) {\n          _this3.map.addMapping({\n            source: _this3.sourcePath(node),\n            generated: {\n              line: line,\n              column: column - 1\n            },\n            original: {\n              line: node.source.end.line,\n              column: node.source.end.column\n            }\n          });\n        } else {\n          _this3.map.addMapping({\n            source: '<no source>',\n            original: {\n              line: 1,\n              column: 0\n            },\n            generated: {\n              line: line,\n              column: column - 1\n            }\n          });\n        }\n      }\n    });\n  };\n\n  MapGenerator.prototype.generate = function generate() {\n    this.clearAnnotation();\n\n    if (this.isMap()) {\n      return this.generateMap();\n    } else {\n      var result = '';\n      this.stringify(this.root, function (i) {\n        result += i;\n      });\n      return [result];\n    }\n  };\n\n  return MapGenerator;\n}();\n\nexports.default = MapGenerator;\nmodule.exports = exports['default'];","map":{"version":3,"mappings":"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","names":["MapGenerator","stringify","root","opts","_classCallCheck","mapOpts","map","isMap","previous","length","previousMaps","walk","node","source","input","_this","indexOf","push","isInline","inline","annotation","some","i","isSourcesContent","sourcesContent","withContent","clearAnnotation","nodes","type","text","removeChild","setSourcesContent","already","from","relative","_this2","setSourceContent","css","applyPrevMaps","_ref","_i","prev","file","_path2","dirname","_sourceMap2","SourceMapConsumer","consumer","applySourceMap","isAnnotation","addAnnotation","content","_jsBase","encode","toString","outputFile","eol","to","generateMap","generateString","test","resolve","sep","replace","sourcePath","SourceMapGenerator","line","column","lines","last","str","_this3","start","addMapping","generated","original","match","lastIndexOf","end","generate","result"],"sources":["map-generator.es6"],"sourcesContent":["import { Base64 } from 'js-base64';\nimport   mozilla  from 'source-map';\nimport   path     from 'path';\n\nexport default class MapGenerator {\n\n    constructor(stringify, root, opts) {\n        this.stringify = stringify;\n        this.mapOpts   = opts.map || { };\n        this.root      = root;\n        this.opts      = opts;\n    }\n\n    isMap() {\n        if ( typeof this.opts.map !== 'undefined' ) {\n            return !!this.opts.map;\n        } else {\n            return this.previous().length > 0;\n        }\n    }\n\n    previous() {\n        if ( !this.previousMaps ) {\n            this.previousMaps = [];\n            this.root.walk( node => {\n                if ( node.source && node.source.input.map ) {\n                    let map = node.source.input.map;\n                    if ( this.previousMaps.indexOf(map) === -1 ) {\n                        this.previousMaps.push(map);\n                    }\n                }\n            });\n        }\n\n        return this.previousMaps;\n    }\n\n    isInline() {\n        if ( typeof this.mapOpts.inline !== 'undefined' ) {\n            return this.mapOpts.inline;\n        }\n\n        let annotation = this.mapOpts.annotation;\n        if ( typeof annotation !== 'undefined' && annotation !== true ) {\n            return false;\n        }\n\n        if ( this.previous().length ) {\n            return this.previous().some( i => i.inline );\n        } else {\n            return true;\n        }\n    }\n\n    isSourcesContent() {\n        if ( typeof this.mapOpts.sourcesContent !== 'undefined' ) {\n            return this.mapOpts.sourcesContent;\n        }\n        if ( this.previous().length ) {\n            return this.previous().some( i => i.withContent() );\n        } else {\n            return true;\n        }\n    }\n\n    clearAnnotation() {\n        if ( this.mapOpts.annotation === false ) return;\n\n        let node;\n        for ( let i = this.root.nodes.length - 1; i >= 0; i-- ) {\n            node = this.root.nodes[i];\n            if ( node.type !== 'comment' ) continue;\n            if ( node.text.indexOf('# sourceMappingURL=') === 0 ) {\n                this.root.removeChild(i);\n            }\n        }\n    }\n\n    setSourcesContent() {\n        let already = { };\n        this.root.walk( node => {\n            if ( node.source ) {\n                let from = node.source.input.from;\n                if ( from && !already[from] ) {\n                    already[from] = true;\n                    let relative = this.relative(from);\n                    this.map.setSourceContent(relative, node.source.input.css);\n                }\n            }\n        });\n    }\n\n    applyPrevMaps() {\n        for ( let prev of this.previous() ) {\n            let from = this.relative(prev.file);\n            let root = prev.root || path.dirname(prev.file);\n            let map;\n\n            if ( this.mapOpts.sourcesContent === false ) {\n                map = new mozilla.SourceMapConsumer(prev.text);\n                if ( map.sourcesContent ) {\n                    map.sourcesContent = map.sourcesContent.map( () => null );\n                }\n            } else {\n                map = prev.consumer();\n            }\n\n            this.map.applySourceMap(map, from, this.relative(root));\n        }\n    }\n\n    isAnnotation() {\n        if ( this.isInline() ) {\n            return true;\n        } else if ( typeof this.mapOpts.annotation !== 'undefined' ) {\n            return this.mapOpts.annotation;\n        } else if ( this.previous().length ) {\n            return this.previous().some( i => i.annotation );\n        } else {\n            return true;\n        }\n    }\n\n    addAnnotation() {\n        let content;\n\n        if ( this.isInline() ) {\n            content = 'data:application/json;base64,' +\n                       Base64.encode( this.map.toString() );\n\n        } else if ( typeof this.mapOpts.annotation === 'string' ) {\n            content = this.mapOpts.annotation;\n\n        } else {\n            content = this.outputFile() + '.map';\n        }\n\n        let eol   = '\\n';\n        if ( this.css.indexOf('\\r\\n') !== -1 ) eol = '\\r\\n';\n\n        this.css += eol + '/*# sourceMappingURL=' + content + ' */';\n    }\n\n    outputFile() {\n        if ( this.opts.to ) {\n            return this.relative(this.opts.to);\n        } else if ( this.opts.from ) {\n            return this.relative(this.opts.from);\n        } else {\n            return 'to.css';\n        }\n    }\n\n    generateMap() {\n        this.generateString();\n        if ( this.isSourcesContent() )    this.setSourcesContent();\n        if ( this.previous().length > 0 ) this.applyPrevMaps();\n        if ( this.isAnnotation() )        this.addAnnotation();\n\n        if ( this.isInline() ) {\n            return [this.css];\n        } else {\n            return [this.css, this.map];\n        }\n    }\n\n    relative(file) {\n        if ( file.indexOf('<') === 0 ) return file;\n        if ( /^\\w+:\\/\\//.test(file) ) return file;\n\n        let from = this.opts.to ? path.dirname(this.opts.to) : '.';\n\n        if ( typeof this.mapOpts.annotation === 'string' ) {\n            from = path.dirname( path.resolve(from, this.mapOpts.annotation) );\n        }\n\n        file = path.relative(from, file);\n        if ( path.sep === '\\\\' ) {\n            return file.replace(/\\\\/g, '/');\n        } else {\n            return file;\n        }\n    }\n\n    sourcePath(node) {\n        if ( this.mapOpts.from ) {\n            return this.mapOpts.from;\n        } else {\n            return this.relative(node.source.input.from);\n        }\n    }\n\n    generateString() {\n        this.css = '';\n        this.map = new mozilla.SourceMapGenerator({ file: this.outputFile() });\n\n        let line   = 1;\n        let column = 1;\n\n        let lines, last;\n        this.stringify(this.root, (str, node, type) => {\n            this.css += str;\n\n            if ( node && type !== 'end' ) {\n                if ( node.source && node.source.start ) {\n                    this.map.addMapping({\n                        source:    this.sourcePath(node),\n                        generated: { line, column: column - 1 },\n                        original:  {\n                            line:   node.source.start.line,\n                            column: node.source.start.column - 1\n                        }\n                    });\n                } else {\n                    this.map.addMapping({\n                        source:    '<no source>',\n                        original:  { line: 1, column: 0 },\n                        generated: { line, column: column - 1 }\n                    });\n                }\n            }\n\n            lines = str.match(/\\n/g);\n            if ( lines ) {\n                line  += lines.length;\n                last   = str.lastIndexOf('\\n');\n                column = str.length - last;\n            } else {\n                column += str.length;\n            }\n\n            if ( node && type !== 'start' ) {\n                if ( node.source && node.source.end ) {\n                    this.map.addMapping({\n                        source:    this.sourcePath(node),\n                        generated: { line, column: column - 1 },\n                        original:  {\n                            line:   node.source.end.line,\n                            column: node.source.end.column\n                        }\n                    });\n                } else {\n                    this.map.addMapping({\n                        source:    '<no source>',\n                        original:  { line: 1, column: 0 },\n                        generated: { line, column: column - 1 }\n                    });\n                }\n            }\n        });\n    }\n\n    generate() {\n        this.clearAnnotation();\n\n        if ( this.isMap() ) {\n            return this.generateMap();\n        } else {\n            let result = '';\n            this.stringify(this.root, i => {\n                result += i;\n            });\n            return [result];\n        }\n    }\n\n}\n"]},"metadata":{},"sourceType":"script"}