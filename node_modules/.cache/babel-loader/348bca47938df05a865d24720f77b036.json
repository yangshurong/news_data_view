{"ast":null,"code":"import Geo3DBuilder from '../common/Geo3DBuilder';\nimport * as echarts from 'echarts/lib/echarts';\nimport graphicGL from '../../util/graphicGL';\nimport OrbitControl from '../../util/OrbitControl';\nimport SceneHelper from '../common/SceneHelper';\nexport default echarts.ComponentView.extend({\n  type: 'geo3D',\n  __ecgl__: true,\n  init: function (ecModel, api) {\n    this._geo3DBuilder = new Geo3DBuilder(api);\n    this.groupGL = new graphicGL.Node();\n    this._lightRoot = new graphicGL.Node();\n    this._sceneHelper = new SceneHelper(this._lightRoot);\n\n    this._sceneHelper.initLight(this._lightRoot);\n\n    this._control = new OrbitControl({\n      zr: api.getZr()\n    });\n\n    this._control.init();\n  },\n  render: function (geo3DModel, ecModel, api) {\n    this.groupGL.add(this._geo3DBuilder.rootNode);\n    var geo3D = geo3DModel.coordinateSystem;\n\n    if (!geo3D || !geo3D.viewGL) {\n      return;\n    } // Always have light.\n\n\n    geo3D.viewGL.add(this._lightRoot);\n\n    if (geo3DModel.get('show')) {\n      geo3D.viewGL.add(this.groupGL);\n    } else {\n      geo3D.viewGL.remove(this.groupGL);\n    }\n\n    var control = this._control;\n    control.setViewGL(geo3D.viewGL);\n    var viewControlModel = geo3DModel.getModel('viewControl');\n    control.setFromViewControlModel(viewControlModel, 0);\n\n    this._sceneHelper.setScene(geo3D.viewGL.scene);\n\n    this._sceneHelper.updateLight(geo3DModel); // Set post effect\n\n\n    geo3D.viewGL.setPostEffect(geo3DModel.getModel('postEffect'), api);\n    geo3D.viewGL.setTemporalSuperSampling(geo3DModel.getModel('temporalSuperSampling')); // Must update after geo3D.viewGL.setPostEffect\n\n    this._geo3DBuilder.update(geo3DModel, ecModel, api, 0, geo3DModel.getData().count());\n\n    var srgbDefineMethod = geo3D.viewGL.isLinearSpace() ? 'define' : 'undefine';\n\n    this._geo3DBuilder.rootNode.traverse(function (mesh) {\n      if (mesh.material) {\n        mesh.material[srgbDefineMethod]('fragment', 'SRGB_DECODE');\n      }\n    });\n\n    control.off('update');\n    control.on('update', function () {\n      api.dispatchAction({\n        type: 'geo3DChangeCamera',\n        alpha: control.getAlpha(),\n        beta: control.getBeta(),\n        distance: control.getDistance(),\n        center: control.getCenter(),\n        from: this.uid,\n        geo3DId: geo3DModel.id\n      });\n    });\n    control.update();\n  },\n  afterRender: function (geo3DModel, ecModel, api, layerGL) {\n    var renderer = layerGL.renderer;\n\n    this._sceneHelper.updateAmbientCubemap(renderer, geo3DModel, api);\n\n    this._sceneHelper.updateSkybox(renderer, geo3DModel, api);\n  },\n  dispose: function () {\n    this._control.dispose();\n\n    this._geo3DBuilder.dispose();\n  }\n});","map":{"version":3,"sources":["C:/Users/Administrator/Desktop/data_view/my_project/vue2_app/myapp/node_modules/echarts-gl/lib/component/geo3D/Geo3DView.js"],"names":["Geo3DBuilder","echarts","graphicGL","OrbitControl","SceneHelper","ComponentView","extend","type","__ecgl__","init","ecModel","api","_geo3DBuilder","groupGL","Node","_lightRoot","_sceneHelper","initLight","_control","zr","getZr","render","geo3DModel","add","rootNode","geo3D","coordinateSystem","viewGL","get","remove","control","setViewGL","viewControlModel","getModel","setFromViewControlModel","setScene","scene","updateLight","setPostEffect","setTemporalSuperSampling","update","getData","count","srgbDefineMethod","isLinearSpace","traverse","mesh","material","off","on","dispatchAction","alpha","getAlpha","beta","getBeta","distance","getDistance","center","getCenter","from","uid","geo3DId","id","afterRender","layerGL","renderer","updateAmbientCubemap","updateSkybox","dispose"],"mappings":"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","sourcesContent":["import Geo3DBuilder from '../common/Geo3DBuilder';\nimport * as echarts from 'echarts/lib/echarts';\nimport graphicGL from '../../util/graphicGL';\nimport OrbitControl from '../../util/OrbitControl';\nimport SceneHelper from '../common/SceneHelper';\nexport default echarts.ComponentView.extend({\n  type: 'geo3D',\n  __ecgl__: true,\n  init: function (ecModel, api) {\n    this._geo3DBuilder = new Geo3DBuilder(api);\n    this.groupGL = new graphicGL.Node();\n    this._lightRoot = new graphicGL.Node();\n    this._sceneHelper = new SceneHelper(this._lightRoot);\n\n    this._sceneHelper.initLight(this._lightRoot);\n\n    this._control = new OrbitControl({\n      zr: api.getZr()\n    });\n\n    this._control.init();\n  },\n  render: function (geo3DModel, ecModel, api) {\n    this.groupGL.add(this._geo3DBuilder.rootNode);\n    var geo3D = geo3DModel.coordinateSystem;\n\n    if (!geo3D || !geo3D.viewGL) {\n      return;\n    } // Always have light.\n\n\n    geo3D.viewGL.add(this._lightRoot);\n\n    if (geo3DModel.get('show')) {\n      geo3D.viewGL.add(this.groupGL);\n    } else {\n      geo3D.viewGL.remove(this.groupGL);\n    }\n\n    var control = this._control;\n    control.setViewGL(geo3D.viewGL);\n    var viewControlModel = geo3DModel.getModel('viewControl');\n    control.setFromViewControlModel(viewControlModel, 0);\n\n    this._sceneHelper.setScene(geo3D.viewGL.scene);\n\n    this._sceneHelper.updateLight(geo3DModel); // Set post effect\n\n\n    geo3D.viewGL.setPostEffect(geo3DModel.getModel('postEffect'), api);\n    geo3D.viewGL.setTemporalSuperSampling(geo3DModel.getModel('temporalSuperSampling')); // Must update after geo3D.viewGL.setPostEffect\n\n    this._geo3DBuilder.update(geo3DModel, ecModel, api, 0, geo3DModel.getData().count());\n\n    var srgbDefineMethod = geo3D.viewGL.isLinearSpace() ? 'define' : 'undefine';\n\n    this._geo3DBuilder.rootNode.traverse(function (mesh) {\n      if (mesh.material) {\n        mesh.material[srgbDefineMethod]('fragment', 'SRGB_DECODE');\n      }\n    });\n\n    control.off('update');\n    control.on('update', function () {\n      api.dispatchAction({\n        type: 'geo3DChangeCamera',\n        alpha: control.getAlpha(),\n        beta: control.getBeta(),\n        distance: control.getDistance(),\n        center: control.getCenter(),\n        from: this.uid,\n        geo3DId: geo3DModel.id\n      });\n    });\n    control.update();\n  },\n  afterRender: function (geo3DModel, ecModel, api, layerGL) {\n    var renderer = layerGL.renderer;\n\n    this._sceneHelper.updateAmbientCubemap(renderer, geo3DModel, api);\n\n    this._sceneHelper.updateSkybox(renderer, geo3DModel, api);\n  },\n  dispose: function () {\n    this._control.dispose();\n\n    this._geo3DBuilder.dispose();\n  }\n});"]},"metadata":{},"sourceType":"module"}