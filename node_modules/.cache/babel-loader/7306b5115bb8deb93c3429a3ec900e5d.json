{"ast":null,"code":"import Base from './core/Base';\nimport util from './core/util';\nimport colorUtil from './core/color';\nvar parseColor = colorUtil.parseToFloat;\nvar programKeyCache = {};\n\nfunction getDefineCode(defines) {\n  var defineKeys = Object.keys(defines);\n  defineKeys.sort();\n  var defineStr = []; // Custom Defines\n\n  for (var i = 0; i < defineKeys.length; i++) {\n    var key = defineKeys[i];\n    var value = defines[key];\n\n    if (value === null) {\n      defineStr.push(key);\n    } else {\n      defineStr.push(key + ' ' + value.toString());\n    }\n  }\n\n  return defineStr.join('\\n');\n}\n\nfunction getProgramKey(vertexDefines, fragmentDefines, enabledTextures) {\n  enabledTextures.sort();\n  var defineStr = [];\n\n  for (var i = 0; i < enabledTextures.length; i++) {\n    var symbol = enabledTextures[i];\n    defineStr.push(symbol);\n  }\n\n  var key = getDefineCode(vertexDefines) + '\\n' + getDefineCode(fragmentDefines) + '\\n' + defineStr.join('\\n');\n\n  if (programKeyCache[key]) {\n    return programKeyCache[key];\n  }\n\n  var id = util.genGUID();\n  programKeyCache[key] = id;\n  return id;\n}\n/**\n * Material defines the appearance of mesh surface, like `color`, `roughness`, `metalness`, etc.\n * It contains a {@link clay.Shader} and corresponding uniforms.\n *\n * Here is a basic example to create a standard material\n```js\nvar material = new clay.Material({\n    shader: new clay.Shader(\n        clay.Shader.source('clay.vertex'),\n        clay.Shader.source('clay.fragment')\n    )\n});\n```\n * @constructor clay.Material\n * @extends clay.core.Base\n */\n\n\nvar Material = Base.extend(function () {\n  return (\n    /** @lends clay.Material# */\n    {\n      /**\n       * @type {string}\n       */\n      name: '',\n\n      /**\n       * @type {Object}\n       */\n      // uniforms: null,\n\n      /**\n       * @type {clay.Shader}\n       */\n      // shader: null,\n\n      /**\n       * @type {boolean}\n       */\n      depthTest: true,\n\n      /**\n       * @type {boolean}\n       */\n      depthMask: true,\n\n      /**\n       * @type {boolean}\n       */\n      transparent: false,\n\n      /**\n       * Blend func is a callback function when the material\n       * have custom blending\n       * The gl context will be the only argument passed in tho the\n       * blend function\n       * Detail of blend function in WebGL:\n       * http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf\n       *\n       * Example :\n       * function(_gl) {\n       *  _gl.blendEquation(_gl.FUNC_ADD);\n       *  _gl.blendFunc(_gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA);\n       * }\n       */\n      blend: null,\n\n      /**\n       * If update texture status automatically.\n       */\n      autoUpdateTextureStatus: true,\n      uniforms: {},\n      vertexDefines: {},\n      fragmentDefines: {},\n      _textureStatus: {},\n      // shadowTransparentMap : null\n      // PENDING enable the uniform that only used in shader.\n      _enabledUniforms: null\n    }\n  );\n}, function () {\n  if (!this.name) {\n    this.name = 'MATERIAL_' + this.__uid__;\n  }\n\n  if (this.shader) {\n    // Keep status, mainly preset uniforms, vertexDefines and fragmentDefines\n    this.attachShader(this.shader, true);\n  }\n},\n/** @lends clay.Material.prototype */\n{\n  precision: 'highp',\n\n  /**\n   * Set material uniform\n   * @example\n   *  mat.setUniform('color', [1, 1, 1, 1]);\n   * @param {string} symbol\n   * @param {number|array|clay.Texture|ArrayBufferView} value\n   */\n  setUniform: function (symbol, value) {\n    if (value === undefined) {\n      console.warn('Uniform value \"' + symbol + '\" is undefined');\n    }\n\n    var uniform = this.uniforms[symbol];\n\n    if (uniform) {\n      if (typeof value === 'string') {\n        // Try to parse as a color. Invalid color string will return null.\n        value = parseColor(value) || value;\n      }\n\n      uniform.value = value;\n\n      if (this.autoUpdateTextureStatus && uniform.type === 't') {\n        if (value) {\n          this.enableTexture(symbol);\n        } else {\n          this.disableTexture(symbol);\n        }\n      }\n    }\n  },\n\n  /**\n   * @param {Object} obj\n   */\n  setUniforms: function (obj) {\n    for (var key in obj) {\n      var val = obj[key];\n      this.setUniform(key, val);\n    }\n  },\n\n  /**\n   * @param  {string}  symbol\n   * @return {boolean}\n   */\n  isUniformEnabled: function (symbol) {\n    return this._enabledUniforms.indexOf(symbol) >= 0;\n  },\n  getEnabledUniforms: function () {\n    return this._enabledUniforms;\n  },\n  getTextureUniforms: function () {\n    return this._textureUniforms;\n  },\n\n  /**\n   * Alias of setUniform and setUniforms\n   * @param {object|string} symbol\n   * @param {number|array|clay.Texture|ArrayBufferView} [value]\n   */\n  set: function (symbol, value) {\n    if (typeof symbol === 'object') {\n      for (var key in symbol) {\n        var val = symbol[key];\n        this.setUniform(key, val);\n      }\n    } else {\n      this.setUniform(symbol, value);\n    }\n  },\n\n  /**\n   * Get uniform value\n   * @param  {string} symbol\n   * @return {number|array|clay.Texture|ArrayBufferView}\n   */\n  get: function (symbol) {\n    var uniform = this.uniforms[symbol];\n\n    if (uniform) {\n      return uniform.value;\n    }\n  },\n\n  /**\n   * Attach a shader instance\n   * @param  {clay.Shader} shader\n   * @param  {boolean} keepStatus If try to keep uniform and texture\n   */\n  attachShader: function (shader, keepStatus) {\n    var originalUniforms = this.uniforms; // Ignore if uniform can use in shader.\n\n    this.uniforms = shader.createUniforms();\n    this.shader = shader;\n    var uniforms = this.uniforms;\n    this._enabledUniforms = Object.keys(uniforms); // Make sure uniforms are set in same order to avoid texture slot wrong\n\n    this._enabledUniforms.sort();\n\n    this._textureUniforms = this._enabledUniforms.filter(function (uniformName) {\n      var type = this.uniforms[uniformName].type;\n      return type === 't' || type === 'tv';\n    }, this);\n    var originalVertexDefines = this.vertexDefines;\n    var originalFragmentDefines = this.fragmentDefines;\n    this.vertexDefines = util.clone(shader.vertexDefines);\n    this.fragmentDefines = util.clone(shader.fragmentDefines);\n\n    if (keepStatus) {\n      for (var symbol in originalUniforms) {\n        if (uniforms[symbol]) {\n          uniforms[symbol].value = originalUniforms[symbol].value;\n        }\n      }\n\n      util.defaults(this.vertexDefines, originalVertexDefines);\n      util.defaults(this.fragmentDefines, originalFragmentDefines);\n    }\n\n    var textureStatus = {};\n\n    for (var key in shader.textures) {\n      textureStatus[key] = {\n        shaderType: shader.textures[key].shaderType,\n        type: shader.textures[key].type,\n        enabled: keepStatus && this._textureStatus[key] ? this._textureStatus[key].enabled : false\n      };\n    }\n\n    this._textureStatus = textureStatus;\n    this._programKey = '';\n  },\n\n  /**\n   * Clone a new material and keep uniforms, shader will not be cloned\n   * @return {clay.Material}\n   */\n  clone: function () {\n    var material = new this.constructor({\n      name: this.name,\n      shader: this.shader\n    });\n\n    for (var symbol in this.uniforms) {\n      material.uniforms[symbol].value = this.uniforms[symbol].value;\n    }\n\n    material.depthTest = this.depthTest;\n    material.depthMask = this.depthMask;\n    material.transparent = this.transparent;\n    material.blend = this.blend;\n    material.vertexDefines = util.clone(this.vertexDefines);\n    material.fragmentDefines = util.clone(this.fragmentDefines);\n    material.enableTexture(this.getEnabledTextures());\n    material.precision = this.precision;\n    return material;\n  },\n\n  /**\n   * Add a #define macro in shader code\n   * @param  {string} shaderType Can be vertex, fragment or both\n   * @param  {string} symbol\n   * @param  {number} [val]\n   */\n  define: function (shaderType, symbol, val) {\n    var vertexDefines = this.vertexDefines;\n    var fragmentDefines = this.fragmentDefines;\n\n    if (shaderType !== 'vertex' && shaderType !== 'fragment' && shaderType !== 'both' && arguments.length < 3) {\n      // shaderType default to be 'both'\n      val = symbol;\n      symbol = shaderType;\n      shaderType = 'both';\n    }\n\n    val = val != null ? val : null;\n\n    if (shaderType === 'vertex' || shaderType === 'both') {\n      if (vertexDefines[symbol] !== val) {\n        vertexDefines[symbol] = val; // Mark as dirty\n\n        this._programKey = '';\n      }\n    }\n\n    if (shaderType === 'fragment' || shaderType === 'both') {\n      if (fragmentDefines[symbol] !== val) {\n        fragmentDefines[symbol] = val;\n\n        if (shaderType !== 'both') {\n          this._programKey = '';\n        }\n      }\n    }\n  },\n\n  /**\n   * Remove a #define macro in shader code\n   * @param  {string} shaderType Can be vertex, fragment or both\n   * @param  {string} symbol\n   */\n  undefine: function (shaderType, symbol) {\n    if (shaderType !== 'vertex' && shaderType !== 'fragment' && shaderType !== 'both' && arguments.length < 2) {\n      // shaderType default to be 'both'\n      symbol = shaderType;\n      shaderType = 'both';\n    }\n\n    if (shaderType === 'vertex' || shaderType === 'both') {\n      if (this.isDefined('vertex', symbol)) {\n        delete this.vertexDefines[symbol]; // Mark as dirty\n\n        this._programKey = '';\n      }\n    }\n\n    if (shaderType === 'fragment' || shaderType === 'both') {\n      if (this.isDefined('fragment', symbol)) {\n        delete this.fragmentDefines[symbol];\n\n        if (shaderType !== 'both') {\n          this._programKey = '';\n        }\n      }\n    }\n  },\n\n  /**\n   * If macro is defined in shader.\n   * @param  {string} shaderType Can be vertex, fragment or both\n   * @param  {string} symbol\n   */\n  isDefined: function (shaderType, symbol) {\n    // PENDING hasOwnProperty ?\n    switch (shaderType) {\n      case 'vertex':\n        return this.vertexDefines[symbol] !== undefined;\n\n      case 'fragment':\n        return this.fragmentDefines[symbol] !== undefined;\n    }\n  },\n\n  /**\n   * Get macro value defined in shader.\n   * @param  {string} shaderType Can be vertex, fragment or both\n   * @param  {string} symbol\n   */\n  getDefine: function (shaderType, symbol) {\n    switch (shaderType) {\n      case 'vertex':\n        return this.vertexDefines[symbol];\n\n      case 'fragment':\n        return this.fragmentDefines[symbol];\n    }\n  },\n\n  /**\n   * Enable a texture, actually it will add a #define macro in the shader code\n   * For example, if texture symbol is diffuseMap, it will add a line `#define DIFFUSEMAP_ENABLED` in the shader code\n   * @param  {string} symbol\n   */\n  enableTexture: function (symbol) {\n    if (Array.isArray(symbol)) {\n      for (var i = 0; i < symbol.length; i++) {\n        this.enableTexture(symbol[i]);\n      }\n\n      return;\n    }\n\n    var status = this._textureStatus[symbol];\n\n    if (status) {\n      var isEnabled = status.enabled;\n\n      if (!isEnabled) {\n        status.enabled = true;\n        this._programKey = '';\n      }\n    }\n  },\n\n  /**\n   * Enable all textures used in the shader\n   */\n  enableTexturesAll: function () {\n    var textureStatus = this._textureStatus;\n\n    for (var symbol in textureStatus) {\n      textureStatus[symbol].enabled = true;\n    }\n\n    this._programKey = '';\n  },\n\n  /**\n   * Disable a texture, it remove a #define macro in the shader\n   * @param  {string} symbol\n   */\n  disableTexture: function (symbol) {\n    if (Array.isArray(symbol)) {\n      for (var i = 0; i < symbol.length; i++) {\n        this.disableTexture(symbol[i]);\n      }\n\n      return;\n    }\n\n    var status = this._textureStatus[symbol];\n\n    if (status) {\n      var isDisabled = !status.enabled;\n\n      if (!isDisabled) {\n        status.enabled = false;\n        this._programKey = '';\n      }\n    }\n  },\n\n  /**\n   * Disable all textures used in the shader\n   */\n  disableTexturesAll: function () {\n    var textureStatus = this._textureStatus;\n\n    for (var symbol in textureStatus) {\n      textureStatus[symbol].enabled = false;\n    }\n\n    this._programKey = '';\n  },\n\n  /**\n   * If texture of given type is enabled.\n   * @param  {string}  symbol\n   * @return {boolean}\n   */\n  isTextureEnabled: function (symbol) {\n    var textureStatus = this._textureStatus;\n    return !!textureStatus[symbol] && textureStatus[symbol].enabled;\n  },\n\n  /**\n   * Get all enabled textures\n   * @return {string[]}\n   */\n  getEnabledTextures: function () {\n    var enabledTextures = [];\n    var textureStatus = this._textureStatus;\n\n    for (var symbol in textureStatus) {\n      if (textureStatus[symbol].enabled) {\n        enabledTextures.push(symbol);\n      }\n    }\n\n    return enabledTextures;\n  },\n\n  /**\n   * Mark defines are updated.\n   */\n  dirtyDefines: function () {\n    this._programKey = '';\n  },\n  getProgramKey: function () {\n    if (!this._programKey) {\n      this._programKey = getProgramKey(this.vertexDefines, this.fragmentDefines, this.getEnabledTextures());\n    }\n\n    return this._programKey;\n  }\n});\nexport default Material;","map":{"version":3,"sources":["C:/Users/Administrator/Desktop/data_view/my_project/vue2_app/myapp/node_modules/claygl/src/Material.js"],"names":["Base","util","colorUtil","parseColor","parseToFloat","programKeyCache","getDefineCode","defines","defineKeys","Object","keys","sort","defineStr","i","length","key","value","push","toString","join","getProgramKey","vertexDefines","fragmentDefines","enabledTextures","symbol","id","genGUID","Material","extend","name","depthTest","depthMask","transparent","blend","autoUpdateTextureStatus","uniforms","_textureStatus","_enabledUniforms","__uid__","shader","attachShader","precision","setUniform","undefined","console","warn","uniform","type","enableTexture","disableTexture","setUniforms","obj","val","isUniformEnabled","indexOf","getEnabledUniforms","getTextureUniforms","_textureUniforms","set","get","keepStatus","originalUniforms","createUniforms","filter","uniformName","originalVertexDefines","originalFragmentDefines","clone","defaults","textureStatus","textures","shaderType","enabled","_programKey","material","constructor","getEnabledTextures","define","arguments","undefine","isDefined","getDefine","Array","isArray","status","isEnabled","enableTexturesAll","isDisabled","disableTexturesAll","isTextureEnabled","dirtyDefines"],"mappings":"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","sourcesContent":["import Base from './core/Base';\nimport util from './core/util';\nimport colorUtil from './core/color';\nvar parseColor = colorUtil.parseToFloat;\n\nvar programKeyCache = {};\n\nfunction getDefineCode(defines) {\n    var defineKeys = Object.keys(defines);\n    defineKeys.sort();\n    var defineStr = [];\n    // Custom Defines\n    for (var i = 0; i < defineKeys.length; i++) {\n        var key = defineKeys[i];\n        var value = defines[key];\n        if (value === null) {\n            defineStr.push(key);\n        }\n        else{\n            defineStr.push(key + ' ' + value.toString());\n        }\n    }\n    return defineStr.join('\\n');\n}\n\nfunction getProgramKey(vertexDefines, fragmentDefines, enabledTextures) {\n    enabledTextures.sort();\n    var defineStr = [];\n    for (var i = 0; i < enabledTextures.length; i++) {\n        var symbol = enabledTextures[i];\n        defineStr.push(symbol);\n    }\n    var key = getDefineCode(vertexDefines) + '\\n'\n        + getDefineCode(fragmentDefines) + '\\n'\n        + defineStr.join('\\n');\n\n    if (programKeyCache[key]) {\n        return programKeyCache[key];\n    }\n\n    var id = util.genGUID();\n    programKeyCache[key] = id;\n    return id;\n}\n\n/**\n * Material defines the appearance of mesh surface, like `color`, `roughness`, `metalness`, etc.\n * It contains a {@link clay.Shader} and corresponding uniforms.\n *\n * Here is a basic example to create a standard material\n```js\nvar material = new clay.Material({\n    shader: new clay.Shader(\n        clay.Shader.source('clay.vertex'),\n        clay.Shader.source('clay.fragment')\n    )\n});\n```\n * @constructor clay.Material\n * @extends clay.core.Base\n */\nvar Material = Base.extend(function () {\n    return /** @lends clay.Material# */ {\n        /**\n         * @type {string}\n         */\n        name: '',\n\n        /**\n         * @type {Object}\n         */\n        // uniforms: null,\n\n        /**\n         * @type {clay.Shader}\n         */\n        // shader: null,\n\n        /**\n         * @type {boolean}\n         */\n        depthTest: true,\n\n        /**\n         * @type {boolean}\n         */\n        depthMask: true,\n\n        /**\n         * @type {boolean}\n         */\n        transparent: false,\n        /**\n         * Blend func is a callback function when the material\n         * have custom blending\n         * The gl context will be the only argument passed in tho the\n         * blend function\n         * Detail of blend function in WebGL:\n         * http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf\n         *\n         * Example :\n         * function(_gl) {\n         *  _gl.blendEquation(_gl.FUNC_ADD);\n         *  _gl.blendFunc(_gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA);\n         * }\n         */\n        blend: null,\n\n        /**\n         * If update texture status automatically.\n         */\n        autoUpdateTextureStatus: true,\n\n        uniforms: {},\n        vertexDefines: {},\n        fragmentDefines: {},\n        _textureStatus: {},\n\n        // shadowTransparentMap : null\n\n        // PENDING enable the uniform that only used in shader.\n        _enabledUniforms: null,\n    };\n}, function () {\n    if (!this.name) {\n        this.name = 'MATERIAL_' + this.__uid__;\n    }\n\n    if (this.shader) {\n        // Keep status, mainly preset uniforms, vertexDefines and fragmentDefines\n        this.attachShader(this.shader, true);\n    }\n},\n/** @lends clay.Material.prototype */\n{\n    precision: 'highp',\n\n    /**\n     * Set material uniform\n     * @example\n     *  mat.setUniform('color', [1, 1, 1, 1]);\n     * @param {string} symbol\n     * @param {number|array|clay.Texture|ArrayBufferView} value\n     */\n    setUniform: function (symbol, value) {\n        if (value === undefined) {\n            console.warn('Uniform value \"' + symbol + '\" is undefined');\n        }\n        var uniform = this.uniforms[symbol];\n        if (uniform) {\n\n            if (typeof value === 'string') {\n                // Try to parse as a color. Invalid color string will return null.\n                value = parseColor(value) || value;\n            }\n\n            uniform.value = value;\n\n            if (this.autoUpdateTextureStatus && uniform.type === 't') {\n                if (value) {\n                    this.enableTexture(symbol);\n                }\n                else {\n                    this.disableTexture(symbol);\n                }\n            }\n        }\n    },\n\n    /**\n     * @param {Object} obj\n     */\n    setUniforms: function(obj) {\n        for (var key in obj) {\n            var val = obj[key];\n            this.setUniform(key, val);\n        }\n    },\n\n    /**\n     * @param  {string}  symbol\n     * @return {boolean}\n     */\n    isUniformEnabled: function (symbol) {\n        return this._enabledUniforms.indexOf(symbol) >= 0;\n    },\n\n    getEnabledUniforms: function () {\n        return this._enabledUniforms;\n    },\n    getTextureUniforms: function () {\n        return this._textureUniforms;\n    },\n\n    /**\n     * Alias of setUniform and setUniforms\n     * @param {object|string} symbol\n     * @param {number|array|clay.Texture|ArrayBufferView} [value]\n     */\n    set: function (symbol, value) {\n        if (typeof(symbol) === 'object') {\n            for (var key in symbol) {\n                var val = symbol[key];\n                this.setUniform(key, val);\n            }\n        }\n        else {\n            this.setUniform(symbol, value);\n        }\n    },\n    /**\n     * Get uniform value\n     * @param  {string} symbol\n     * @return {number|array|clay.Texture|ArrayBufferView}\n     */\n    get: function (symbol) {\n        var uniform = this.uniforms[symbol];\n        if (uniform) {\n            return uniform.value;\n        }\n    },\n    /**\n     * Attach a shader instance\n     * @param  {clay.Shader} shader\n     * @param  {boolean} keepStatus If try to keep uniform and texture\n     */\n    attachShader: function(shader, keepStatus) {\n        var originalUniforms = this.uniforms;\n\n        // Ignore if uniform can use in shader.\n        this.uniforms = shader.createUniforms();\n        this.shader = shader;\n\n        var uniforms = this.uniforms;\n        this._enabledUniforms = Object.keys(uniforms);\n        // Make sure uniforms are set in same order to avoid texture slot wrong\n        this._enabledUniforms.sort();\n        this._textureUniforms = this._enabledUniforms.filter(function (uniformName) {\n            var type = this.uniforms[uniformName].type;\n            return type === 't' || type === 'tv';\n        }, this);\n\n        var originalVertexDefines = this.vertexDefines;\n        var originalFragmentDefines = this.fragmentDefines;\n\n        this.vertexDefines = util.clone(shader.vertexDefines);\n        this.fragmentDefines = util.clone(shader.fragmentDefines);\n\n        if (keepStatus) {\n            for (var symbol in originalUniforms) {\n                if (uniforms[symbol]) {\n                    uniforms[symbol].value = originalUniforms[symbol].value;\n                }\n            }\n\n            util.defaults(this.vertexDefines, originalVertexDefines);\n            util.defaults(this.fragmentDefines, originalFragmentDefines);\n        }\n\n        var textureStatus = {};\n        for (var key in shader.textures) {\n            textureStatus[key] = {\n                shaderType: shader.textures[key].shaderType,\n                type: shader.textures[key].type,\n                enabled: (keepStatus && this._textureStatus[key]) ? this._textureStatus[key].enabled : false\n            };\n        }\n\n        this._textureStatus = textureStatus;\n\n        this._programKey = '';\n    },\n\n    /**\n     * Clone a new material and keep uniforms, shader will not be cloned\n     * @return {clay.Material}\n     */\n    clone: function () {\n        var material = new this.constructor({\n            name: this.name,\n            shader: this.shader\n        });\n        for (var symbol in this.uniforms) {\n            material.uniforms[symbol].value = this.uniforms[symbol].value;\n        }\n        material.depthTest = this.depthTest;\n        material.depthMask = this.depthMask;\n        material.transparent = this.transparent;\n        material.blend = this.blend;\n\n        material.vertexDefines = util.clone(this.vertexDefines);\n        material.fragmentDefines = util.clone(this.fragmentDefines);\n        material.enableTexture(this.getEnabledTextures());\n        material.precision = this.precision;\n\n        return material;\n    },\n\n    /**\n     * Add a #define macro in shader code\n     * @param  {string} shaderType Can be vertex, fragment or both\n     * @param  {string} symbol\n     * @param  {number} [val]\n     */\n    define: function (shaderType, symbol, val) {\n        var vertexDefines = this.vertexDefines;\n        var fragmentDefines = this.fragmentDefines;\n        if (shaderType !== 'vertex' && shaderType !== 'fragment' && shaderType !== 'both'\n            && arguments.length < 3\n        ) {\n            // shaderType default to be 'both'\n            val = symbol;\n            symbol = shaderType;\n            shaderType = 'both';\n        }\n        val = val != null ? val : null;\n        if (shaderType === 'vertex' || shaderType === 'both') {\n            if (vertexDefines[symbol] !== val) {\n                vertexDefines[symbol] = val;\n                // Mark as dirty\n                this._programKey = '';\n            }\n        }\n        if (shaderType === 'fragment' || shaderType === 'both') {\n            if (fragmentDefines[symbol] !== val) {\n                fragmentDefines[symbol] = val;\n                if (shaderType !== 'both') {\n                    this._programKey = '';\n                }\n            }\n        }\n    },\n\n    /**\n     * Remove a #define macro in shader code\n     * @param  {string} shaderType Can be vertex, fragment or both\n     * @param  {string} symbol\n     */\n    undefine: function (shaderType, symbol) {\n        if (shaderType !== 'vertex' && shaderType !== 'fragment' && shaderType !== 'both'\n            && arguments.length < 2\n        ) {\n            // shaderType default to be 'both'\n            symbol = shaderType;\n            shaderType = 'both';\n        }\n        if (shaderType === 'vertex' || shaderType === 'both') {\n            if (this.isDefined('vertex', symbol)) {\n                delete this.vertexDefines[symbol];\n                // Mark as dirty\n                this._programKey = '';\n            }\n        }\n        if (shaderType === 'fragment' || shaderType === 'both') {\n            if (this.isDefined('fragment', symbol)) {\n                delete this.fragmentDefines[symbol];\n                if (shaderType !== 'both') {\n                    this._programKey = '';\n                }\n            }\n        }\n    },\n\n    /**\n     * If macro is defined in shader.\n     * @param  {string} shaderType Can be vertex, fragment or both\n     * @param  {string} symbol\n     */\n    isDefined: function (shaderType, symbol) {\n        // PENDING hasOwnProperty ?\n        switch (shaderType) {\n            case 'vertex':\n                return this.vertexDefines[symbol] !== undefined;\n            case 'fragment':\n                return this.fragmentDefines[symbol] !== undefined;\n        }\n    },\n    /**\n     * Get macro value defined in shader.\n     * @param  {string} shaderType Can be vertex, fragment or both\n     * @param  {string} symbol\n     */\n    getDefine: function (shaderType, symbol) {\n        switch(shaderType) {\n            case 'vertex':\n                return this.vertexDefines[symbol];\n            case 'fragment':\n                return this.fragmentDefines[symbol];\n        }\n    },\n    /**\n     * Enable a texture, actually it will add a #define macro in the shader code\n     * For example, if texture symbol is diffuseMap, it will add a line `#define DIFFUSEMAP_ENABLED` in the shader code\n     * @param  {string} symbol\n     */\n    enableTexture: function (symbol) {\n        if (Array.isArray(symbol)) {\n            for (var i = 0; i < symbol.length; i++) {\n                this.enableTexture(symbol[i]);\n            }\n            return;\n        }\n\n        var status = this._textureStatus[symbol];\n        if (status) {\n            var isEnabled = status.enabled;\n            if (!isEnabled) {\n                status.enabled = true;\n                this._programKey = '';\n            }\n        }\n    },\n    /**\n     * Enable all textures used in the shader\n     */\n    enableTexturesAll: function () {\n        var textureStatus = this._textureStatus;\n        for (var symbol in textureStatus) {\n            textureStatus[symbol].enabled = true;\n        }\n\n        this._programKey = '';\n    },\n    /**\n     * Disable a texture, it remove a #define macro in the shader\n     * @param  {string} symbol\n     */\n    disableTexture: function (symbol) {\n        if (Array.isArray(symbol)) {\n            for (var i = 0; i < symbol.length; i++) {\n                this.disableTexture(symbol[i]);\n            }\n            return;\n        }\n\n        var status = this._textureStatus[symbol];\n        if (status) {\n            var isDisabled = ! status.enabled;\n            if (!isDisabled) {\n                status.enabled = false;\n                this._programKey = '';\n            }\n        }\n    },\n    /**\n     * Disable all textures used in the shader\n     */\n    disableTexturesAll: function () {\n        var textureStatus = this._textureStatus;\n        for (var symbol in textureStatus) {\n            textureStatus[symbol].enabled = false;\n        }\n\n        this._programKey = '';\n    },\n    /**\n     * If texture of given type is enabled.\n     * @param  {string}  symbol\n     * @return {boolean}\n     */\n    isTextureEnabled: function (symbol) {\n        var textureStatus = this._textureStatus;\n        return !!textureStatus[symbol]\n            && textureStatus[symbol].enabled;\n    },\n\n    /**\n     * Get all enabled textures\n     * @return {string[]}\n     */\n    getEnabledTextures: function () {\n        var enabledTextures = [];\n        var textureStatus = this._textureStatus;\n        for (var symbol in textureStatus) {\n            if (textureStatus[symbol].enabled) {\n                enabledTextures.push(symbol);\n            }\n        }\n        return enabledTextures;\n    },\n\n    /**\n     * Mark defines are updated.\n     */\n    dirtyDefines: function () {\n        this._programKey = '';\n    },\n\n    getProgramKey: function () {\n        if (!this._programKey) {\n            this._programKey = getProgramKey(\n                this.vertexDefines, this.fragmentDefines, this.getEnabledTextures()\n            );\n        }\n        return this._programKey;\n    }\n});\n\nexport default Material;\n"]},"metadata":{},"sourceType":"module"}