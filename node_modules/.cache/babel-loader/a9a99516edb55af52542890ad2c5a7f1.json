{"ast":null,"code":"import \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.replace.js\";\nimport \"core-js/modules/es.number.to-fixed.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport GLProgram from './GLProgram';\nvar loopRegex = /for\\s*?\\(int\\s*?_idx_\\s*\\=\\s*([\\w-]+)\\;\\s*_idx_\\s*<\\s*([\\w-]+);\\s*_idx_\\s*\\+\\+\\s*\\)\\s*\\{\\{([\\s\\S]+?)(?=\\}\\})\\}\\}/g;\n\nfunction unrollLoop(shaderStr, defines, lightsNumbers) {\n  // Loop unroll from three.js, https://github.com/mrdoob/three.js/blob/master/src/renderers/webgl/WebGLProgram.js#L175\n  // In some case like shadowMap in loop use 'i' to index value much slower.\n  // Loop use _idx_ and increased with _idx_++ will be unrolled\n  // Use {{ }} to match the pair so the if statement will not be affected\n  // Write like following\n  // for (int _idx_ = 0; _idx_ < 4; _idx_++) {{\n  //     vec3 color = texture2D(textures[_idx_], uv).rgb;\n  // }}\n  function replace(match, start, end, snippet) {\n    var unroll = ''; // Try to treat as define\n\n    if (isNaN(start)) {\n      if (start in defines) {\n        start = defines[start];\n      } else {\n        start = lightNumberDefines[start];\n      }\n    }\n\n    if (isNaN(end)) {\n      if (end in defines) {\n        end = defines[end];\n      } else {\n        end = lightNumberDefines[end];\n      }\n    } // TODO Error checking\n\n\n    for (var idx = parseInt(start); idx < parseInt(end); idx++) {\n      // PENDING Add scope?\n      unroll += '{' + snippet.replace(/float\\s*\\(\\s*_idx_\\s*\\)/g, idx.toFixed(1)).replace(/_idx_/g, idx) + '}';\n    }\n\n    return unroll;\n  }\n\n  var lightNumberDefines = {};\n\n  for (var lightType in lightsNumbers) {\n    lightNumberDefines[lightType + '_COUNT'] = lightsNumbers[lightType];\n  }\n\n  return shaderStr.replace(loopRegex, replace);\n}\n\nfunction getDefineCode(defines, lightsNumbers, enabledTextures) {\n  var defineStr = [];\n\n  if (lightsNumbers) {\n    for (var lightType in lightsNumbers) {\n      var count = lightsNumbers[lightType];\n\n      if (count > 0) {\n        defineStr.push('#define ' + lightType.toUpperCase() + '_COUNT ' + count);\n      }\n    }\n  }\n\n  if (enabledTextures) {\n    for (var i = 0; i < enabledTextures.length; i++) {\n      var symbol = enabledTextures[i];\n      defineStr.push('#define ' + symbol.toUpperCase() + '_ENABLED');\n    }\n  } // Custom Defines\n\n\n  for (var symbol in defines) {\n    var value = defines[symbol];\n\n    if (value === null) {\n      defineStr.push('#define ' + symbol);\n    } else {\n      defineStr.push('#define ' + symbol + ' ' + value.toString());\n    }\n  }\n\n  return defineStr.join('\\n');\n}\n\nfunction getExtensionCode(exts) {\n  // Extension declaration must before all non-preprocessor codes\n  // TODO vertex ? extension enum ?\n  var extensionStr = [];\n\n  for (var i = 0; i < exts.length; i++) {\n    extensionStr.push('#extension GL_' + exts[i] + ' : enable');\n  }\n\n  return extensionStr.join('\\n');\n}\n\nfunction getPrecisionCode(precision) {\n  return ['precision', precision, 'float'].join(' ') + ';\\n' + ['precision', precision, 'int'].join(' ') + ';\\n' // depth texture may have precision problem on iOS device.\n  + ['precision', precision, 'sampler2D'].join(' ') + ';\\n';\n}\n\nfunction ProgramManager(renderer) {\n  this._renderer = renderer;\n  this._cache = {};\n}\n\nProgramManager.prototype.getProgram = function (renderable, material, scene) {\n  var cache = this._cache;\n  var isSkinnedMesh = renderable.isSkinnedMesh && renderable.isSkinnedMesh();\n  var isInstancedMesh = renderable.isInstancedMesh && renderable.isInstancedMesh();\n  var key = 's' + material.shader.shaderID + 'm' + material.getProgramKey();\n\n  if (scene) {\n    key += 'se' + scene.getProgramKey(renderable.lightGroup);\n  }\n\n  if (isSkinnedMesh) {\n    key += ',sk' + renderable.joints.length;\n  }\n\n  if (isInstancedMesh) {\n    key += ',is';\n  }\n\n  var program = cache[key];\n\n  if (program) {\n    return program;\n  }\n\n  var lightsNumbers = scene ? scene.getLightsNumbers(renderable.lightGroup) : {};\n  var renderer = this._renderer;\n  var _gl = renderer.gl;\n  var enabledTextures = material.getEnabledTextures();\n  var extraDefineCode = '';\n\n  if (isSkinnedMesh) {\n    var skinDefines = {\n      SKINNING: null,\n      JOINT_COUNT: renderable.joints.length\n    };\n\n    if (renderable.joints.length > renderer.getMaxJointNumber()) {\n      skinDefines.USE_SKIN_MATRICES_TEXTURE = null;\n    } // TODO Add skinning code?\n\n\n    extraDefineCode += '\\n' + getDefineCode(skinDefines) + '\\n';\n  }\n\n  if (isInstancedMesh) {\n    extraDefineCode += '\\n#define INSTANCING\\n';\n  } // TODO Optimize key generation\n  // VERTEX\n\n\n  var vertexDefineStr = extraDefineCode + getDefineCode(material.vertexDefines, lightsNumbers, enabledTextures); // FRAGMENT\n\n  var fragmentDefineStr = extraDefineCode + getDefineCode(material.fragmentDefines, lightsNumbers, enabledTextures);\n  var vertexCode = vertexDefineStr + '\\n' + material.shader.vertex;\n  var extensions = ['OES_standard_derivatives', 'EXT_shader_texture_lod'].filter(function (ext) {\n    return renderer.getGLExtension(ext) != null;\n  });\n\n  if (extensions.indexOf('EXT_shader_texture_lod') >= 0) {\n    fragmentDefineStr += '\\n#define SUPPORT_TEXTURE_LOD';\n  }\n\n  if (extensions.indexOf('OES_standard_derivatives') >= 0) {\n    fragmentDefineStr += '\\n#define SUPPORT_STANDARD_DERIVATIVES';\n  }\n\n  var fragmentCode = getExtensionCode(extensions) + '\\n' + getPrecisionCode(material.precision) + '\\n' + fragmentDefineStr + '\\n' + material.shader.fragment;\n  var finalVertexCode = unrollLoop(vertexCode, material.vertexDefines, lightsNumbers);\n  var finalFragmentCode = unrollLoop(fragmentCode, material.fragmentDefines, lightsNumbers);\n  var program = new GLProgram();\n  program.uniformSemantics = material.shader.uniformSemantics;\n  program.attributes = material.shader.attributes;\n  var errorMsg = program.buildProgram(_gl, material.shader, finalVertexCode, finalFragmentCode);\n  program.__error = errorMsg;\n  cache[key] = program;\n  return program;\n};\n\nexport default ProgramManager;","map":{"version":3,"sources":["C:/Users/Administrator/Desktop/data_view/my_project/vue2_app/myapp/node_modules/_claygl@1.3.0@claygl/src/gpu/ProgramManager.js"],"names":["GLProgram","loopRegex","unrollLoop","shaderStr","defines","lightsNumbers","replace","match","start","end","snippet","unroll","isNaN","lightNumberDefines","idx","parseInt","toFixed","lightType","getDefineCode","enabledTextures","defineStr","count","push","toUpperCase","i","length","symbol","value","toString","join","getExtensionCode","exts","extensionStr","getPrecisionCode","precision","ProgramManager","renderer","_renderer","_cache","prototype","getProgram","renderable","material","scene","cache","isSkinnedMesh","isInstancedMesh","key","shader","shaderID","getProgramKey","lightGroup","joints","program","getLightsNumbers","_gl","gl","getEnabledTextures","extraDefineCode","skinDefines","SKINNING","JOINT_COUNT","getMaxJointNumber","USE_SKIN_MATRICES_TEXTURE","vertexDefineStr","vertexDefines","fragmentDefineStr","fragmentDefines","vertexCode","vertex","extensions","filter","ext","getGLExtension","indexOf","fragmentCode","fragment","finalVertexCode","finalFragmentCode","uniformSemantics","attributes","errorMsg","buildProgram","__error"],"mappings":"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","sourcesContent":["import GLProgram from './GLProgram';\n\nvar loopRegex = /for\\s*?\\(int\\s*?_idx_\\s*\\=\\s*([\\w-]+)\\;\\s*_idx_\\s*<\\s*([\\w-]+);\\s*_idx_\\s*\\+\\+\\s*\\)\\s*\\{\\{([\\s\\S]+?)(?=\\}\\})\\}\\}/g;\n\nfunction unrollLoop(shaderStr, defines, lightsNumbers) {\n    // Loop unroll from three.js, https://github.com/mrdoob/three.js/blob/master/src/renderers/webgl/WebGLProgram.js#L175\n    // In some case like shadowMap in loop use 'i' to index value much slower.\n\n    // Loop use _idx_ and increased with _idx_++ will be unrolled\n    // Use {{ }} to match the pair so the if statement will not be affected\n    // Write like following\n    // for (int _idx_ = 0; _idx_ < 4; _idx_++) {{\n    //     vec3 color = texture2D(textures[_idx_], uv).rgb;\n    // }}\n    function replace(match, start, end, snippet) {\n        var unroll = '';\n        // Try to treat as define\n        if (isNaN(start)) {\n            if (start in defines) {\n                start = defines[start];\n            }\n            else {\n                start = lightNumberDefines[start];\n            }\n        }\n        if (isNaN(end)) {\n            if (end in defines) {\n                end = defines[end];\n            }\n            else {\n                end = lightNumberDefines[end];\n            }\n        }\n        // TODO Error checking\n\n        for (var idx = parseInt(start); idx < parseInt(end); idx++) {\n            // PENDING Add scope?\n            unroll += '{'\n                + snippet\n                    .replace(/float\\s*\\(\\s*_idx_\\s*\\)/g, idx.toFixed(1))\n                    .replace(/_idx_/g, idx)\n            + '}';\n        }\n\n        return unroll;\n    }\n\n    var lightNumberDefines = {};\n    for (var lightType in lightsNumbers) {\n        lightNumberDefines[lightType + '_COUNT'] = lightsNumbers[lightType];\n    }\n    return shaderStr.replace(loopRegex, replace);\n}\n\nfunction getDefineCode(defines, lightsNumbers, enabledTextures) {\n    var defineStr = [];\n    if (lightsNumbers) {\n        for (var lightType in lightsNumbers) {\n            var count = lightsNumbers[lightType];\n            if (count > 0) {\n                defineStr.push('#define ' + lightType.toUpperCase() + '_COUNT ' + count);\n            }\n        }\n    }\n    if (enabledTextures) {\n        for (var i = 0; i < enabledTextures.length; i++) {\n            var symbol = enabledTextures[i];\n            defineStr.push('#define ' + symbol.toUpperCase() + '_ENABLED');\n        }\n    }\n    // Custom Defines\n    for (var symbol in defines) {\n        var value = defines[symbol];\n        if (value === null) {\n            defineStr.push('#define ' + symbol);\n        }\n        else{\n            defineStr.push('#define ' + symbol + ' ' + value.toString());\n        }\n    }\n    return defineStr.join('\\n');\n}\n\nfunction getExtensionCode(exts) {\n    // Extension declaration must before all non-preprocessor codes\n    // TODO vertex ? extension enum ?\n    var extensionStr = [];\n    for (var i = 0; i < exts.length; i++) {\n        extensionStr.push('#extension GL_' + exts[i] + ' : enable');\n    }\n    return extensionStr.join('\\n');\n}\n\nfunction getPrecisionCode(precision) {\n    return ['precision', precision, 'float'].join(' ') + ';\\n'\n        + ['precision', precision, 'int'].join(' ') + ';\\n'\n        // depth texture may have precision problem on iOS device.\n        + ['precision', precision, 'sampler2D'].join(' ') + ';\\n';\n}\n\nfunction ProgramManager(renderer) {\n    this._renderer = renderer;\n    this._cache = {};\n}\n\nProgramManager.prototype.getProgram = function (renderable, material, scene) {\n    var cache = this._cache;\n\n    var isSkinnedMesh = renderable.isSkinnedMesh && renderable.isSkinnedMesh();\n    var isInstancedMesh = renderable.isInstancedMesh && renderable.isInstancedMesh();\n    var key = 's' + material.shader.shaderID + 'm' + material.getProgramKey();\n    if (scene) {\n        key += 'se' + scene.getProgramKey(renderable.lightGroup);\n    }\n    if (isSkinnedMesh) {\n        key += ',sk' + renderable.joints.length;\n    }\n    if (isInstancedMesh) {\n        key += ',is';\n    }\n    var program = cache[key];\n\n    if (program) {\n        return program;\n    }\n\n    var lightsNumbers = scene ? scene.getLightsNumbers(renderable.lightGroup) : {};\n    var renderer = this._renderer;\n    var _gl = renderer.gl;\n    var enabledTextures = material.getEnabledTextures();\n    var extraDefineCode = '';\n    if (isSkinnedMesh) {\n        var skinDefines = {\n            SKINNING: null,\n            JOINT_COUNT: renderable.joints.length\n        };\n        if (renderable.joints.length > renderer.getMaxJointNumber()) {\n            skinDefines.USE_SKIN_MATRICES_TEXTURE = null;\n        }\n        // TODO Add skinning code?\n        extraDefineCode += '\\n' + getDefineCode(skinDefines) + '\\n';\n    }\n    if (isInstancedMesh) {\n        extraDefineCode += '\\n#define INSTANCING\\n';\n    }\n    // TODO Optimize key generation\n    // VERTEX\n    var vertexDefineStr = extraDefineCode + getDefineCode(material.vertexDefines, lightsNumbers, enabledTextures);\n    // FRAGMENT\n    var fragmentDefineStr = extraDefineCode + getDefineCode(material.fragmentDefines, lightsNumbers, enabledTextures);\n\n    var vertexCode = vertexDefineStr + '\\n' + material.shader.vertex;\n\n    var extensions = [\n        'OES_standard_derivatives',\n        'EXT_shader_texture_lod'\n    ].filter(function (ext) {\n        return renderer.getGLExtension(ext) != null;\n    });\n\n    if (extensions.indexOf('EXT_shader_texture_lod') >= 0) {\n        fragmentDefineStr += '\\n#define SUPPORT_TEXTURE_LOD';\n    }\n    if (extensions.indexOf('OES_standard_derivatives') >= 0) {\n        fragmentDefineStr += '\\n#define SUPPORT_STANDARD_DERIVATIVES';\n    }\n\n    var fragmentCode = getExtensionCode(extensions) + '\\n'\n        + getPrecisionCode(material.precision) + '\\n'\n        + fragmentDefineStr + '\\n'\n        + material.shader.fragment;\n\n    var finalVertexCode = unrollLoop(vertexCode, material.vertexDefines, lightsNumbers);\n    var finalFragmentCode = unrollLoop(fragmentCode, material.fragmentDefines, lightsNumbers);\n\n    var program = new GLProgram();\n    program.uniformSemantics = material.shader.uniformSemantics;\n    program.attributes = material.shader.attributes;\n    var errorMsg = program.buildProgram(_gl, material.shader, finalVertexCode, finalFragmentCode);\n    program.__error = errorMsg;\n\n    cache[key] = program;\n\n    return program;\n};\n\nexport default ProgramManager;"]},"metadata":{},"sourceType":"module"}