{"ast":null,"code":"import glmatrix from 'claygl/src/dep/glmatrix';\nvar mat4 = glmatrix.mat4;\nvar TILE_SIZE = 512;\nvar FOV = 0.6435011087932844;\nvar PI = Math.PI;\nvar WORLD_SCALE = 1 / 10;\n\nfunction MapServiceCoordSys3D() {\n  /**\n   * Width of mapbox viewport\n   */\n  this.width = 0;\n  /**\n   * Height of mapbox viewport\n   */\n\n  this.height = 0;\n  this.altitudeScale = 1; // TODO Change boxHeight won't have animation.\n\n  this.boxHeight = 'auto'; // Set by mapbox creator\n\n  this.altitudeExtent;\n  this.bearing = 0;\n  this.pitch = 0;\n  this.center = [0, 0];\n  this._origin;\n  this.zoom = 0;\n  this._initialZoom; // Some parameters for different map services.\n\n  this.maxPitch = 60;\n  this.zoomOffset = 0;\n}\n\nMapServiceCoordSys3D.prototype = {\n  constructor: MapServiceCoordSys3D,\n  dimensions: ['lng', 'lat', 'alt'],\n  containPoint: function containPoint() {},\n  setCameraOption: function setCameraOption(option) {\n    this.bearing = option.bearing;\n    this.pitch = option.pitch;\n    this.center = option.center;\n    this.zoom = option.zoom;\n\n    if (!this._origin) {\n      this._origin = this.projectOnTileWithScale(this.center, TILE_SIZE);\n    }\n\n    if (this._initialZoom == null) {\n      this._initialZoom = this.zoom;\n    }\n\n    this.updateTransform();\n  },\n  // https://github.com/mapbox/mapbox-gl-js/blob/master/src/geo/transform.js#L479\n  updateTransform: function updateTransform() {\n    if (!this.height) {\n      return;\n    }\n\n    var cameraToCenterDistance = 0.5 / Math.tan(FOV / 2) * this.height * WORLD_SCALE; // Convert to radian.\n\n    var pitch = Math.max(Math.min(this.pitch, this.maxPitch), 0) / 180 * Math.PI; // Find the distance from the center point [width/2, height/2] to the\n    // center top point [width/2, 0] in Z units, using the law of sines.\n    // 1 Z unit is equivalent to 1 horizontal px at the center of the map\n    // (the distance between[width/2, height/2] and [width/2 + 1, height/2])\n\n    var halfFov = FOV / 2;\n    var groundAngle = Math.PI / 2 + pitch;\n    var topHalfSurfaceDistance = Math.sin(halfFov) * cameraToCenterDistance / Math.sin(Math.PI - groundAngle - halfFov); // Calculate z distance of the farthest fragment that should be rendered.\n\n    var furthestDistance = Math.cos(Math.PI / 2 - pitch) * topHalfSurfaceDistance + cameraToCenterDistance; // Add a bit extra to avoid precision problems when a fragment's distance is exactly `furthestDistance`\n\n    var farZ = furthestDistance * 1.1; // Forced to be 1000\n\n    if (this.pitch > 50) {\n      farZ = 1000;\n    } // matrix for conversion from location to GL coordinates (-1 .. 1)\n\n\n    var m = [];\n    mat4.perspective(m, FOV, this.width / this.height, 1, farZ);\n    this.viewGL.camera.projectionMatrix.setArray(m);\n    this.viewGL.camera.decomposeProjectionMatrix();\n    var m = mat4.identity([]);\n    var pt = this.dataToPoint(this.center); // Inverse\n\n    mat4.scale(m, m, [1, -1, 1]); // Translate to altitude\n\n    mat4.translate(m, m, [0, 0, -cameraToCenterDistance]);\n    mat4.rotateX(m, m, pitch);\n    mat4.rotateZ(m, m, -this.bearing / 180 * Math.PI); // Translate to center.\n\n    mat4.translate(m, m, [-pt[0] * this.getScale() * WORLD_SCALE, -pt[1] * this.getScale() * WORLD_SCALE, 0]);\n    this.viewGL.camera.viewMatrix.array = m;\n    var invertM = [];\n    mat4.invert(invertM, m);\n    this.viewGL.camera.worldTransform.array = invertM;\n    this.viewGL.camera.decomposeWorldTransform(); // scale vertically to meters per pixel (inverse of ground resolution):\n    // worldSize / (circumferenceOfEarth * cos(lat * π / 180))\n\n    var worldSize = TILE_SIZE * this.getScale();\n    var verticalScale;\n\n    if (this.altitudeExtent && !isNaN(this.boxHeight)) {\n      var range = this.altitudeExtent[1] - this.altitudeExtent[0];\n      verticalScale = this.boxHeight / range * this.getScale() / Math.pow(2, this._initialZoom - this.zoomOffset);\n    } else {\n      verticalScale = worldSize / (2 * Math.PI * 6378000 * Math.abs(Math.cos(this.center[1] * (Math.PI / 180)))) * this.altitudeScale * WORLD_SCALE;\n    } // Include scale to avoid relayout when zooming\n    // FIXME Camera scale may have problem in shadow\n\n\n    this.viewGL.rootNode.scale.set(this.getScale() * WORLD_SCALE, this.getScale() * WORLD_SCALE, verticalScale);\n  },\n  getScale: function getScale() {\n    return Math.pow(2, this.zoom - this.zoomOffset);\n  },\n  projectOnTile: function projectOnTile(data, out) {\n    return this.projectOnTileWithScale(data, this.getScale() * TILE_SIZE, out);\n  },\n  projectOnTileWithScale: function projectOnTileWithScale(data, scale, out) {\n    var lng = data[0];\n    var lat = data[1];\n    var lambda2 = lng * PI / 180;\n    var phi2 = lat * PI / 180;\n    var x = scale * (lambda2 + PI) / (2 * PI);\n    var y = scale * (PI - Math.log(Math.tan(PI / 4 + phi2 * 0.5))) / (2 * PI);\n    out = out || [];\n    out[0] = x;\n    out[1] = y;\n    return out;\n  },\n  unprojectFromTile: function unprojectFromTile(point, out) {\n    return this.unprojectOnTileWithScale(point, this.getScale() * TILE_SIZE, out);\n  },\n  unprojectOnTileWithScale: function unprojectOnTileWithScale(point, scale, out) {\n    var x = point[0];\n    var y = point[1];\n    var lambda2 = x / scale * (2 * PI) - PI;\n    var phi2 = 2 * (Math.atan(Math.exp(PI - y / scale * (2 * PI))) - PI / 4);\n    out = out || [];\n    out[0] = lambda2 * 180 / PI;\n    out[1] = phi2 * 180 / PI;\n    return out;\n  },\n  dataToPoint: function dataToPoint(data, out) {\n    out = this.projectOnTileWithScale(data, TILE_SIZE, out); // Add a origin to avoid precision issue in WebGL.\n\n    out[0] -= this._origin[0];\n    out[1] -= this._origin[1]; // PENDING\n\n    out[2] = !isNaN(data[2]) ? data[2] : 0;\n\n    if (!isNaN(data[2])) {\n      out[2] = data[2];\n\n      if (this.altitudeExtent) {\n        out[2] -= this.altitudeExtent[0];\n      }\n    }\n\n    return out;\n  }\n};\nexport default MapServiceCoordSys3D;","map":{"version":3,"sources":["C:/Users/Administrator/Desktop/data_view/my_project/vue2_app/myapp/node_modules/echarts-gl/lib/coord/mapServiceCommon/MapService3D.js"],"names":["glmatrix","mat4","TILE_SIZE","FOV","PI","Math","WORLD_SCALE","MapServiceCoordSys3D","width","height","altitudeScale","boxHeight","altitudeExtent","bearing","pitch","center","_origin","zoom","_initialZoom","maxPitch","zoomOffset","prototype","constructor","dimensions","containPoint","setCameraOption","option","projectOnTileWithScale","updateTransform","cameraToCenterDistance","tan","max","min","halfFov","groundAngle","topHalfSurfaceDistance","sin","furthestDistance","cos","farZ","m","perspective","viewGL","camera","projectionMatrix","setArray","decomposeProjectionMatrix","identity","pt","dataToPoint","scale","translate","rotateX","rotateZ","getScale","viewMatrix","array","invertM","invert","worldTransform","decomposeWorldTransform","worldSize","verticalScale","isNaN","range","pow","abs","rootNode","set","projectOnTile","data","out","lng","lat","lambda2","phi2","x","y","log","unprojectFromTile","point","unprojectOnTileWithScale","atan","exp"],"mappings":"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","sourcesContent":["import glmatrix from 'claygl/src/dep/glmatrix';\nvar mat4 = glmatrix.mat4;\nvar TILE_SIZE = 512;\nvar FOV = 0.6435011087932844;\nvar PI = Math.PI;\nvar WORLD_SCALE = 1 / 10;\n\nfunction MapServiceCoordSys3D() {\n  /**\n   * Width of mapbox viewport\n   */\n  this.width = 0;\n  /**\n   * Height of mapbox viewport\n   */\n\n  this.height = 0;\n  this.altitudeScale = 1; // TODO Change boxHeight won't have animation.\n\n  this.boxHeight = 'auto'; // Set by mapbox creator\n\n  this.altitudeExtent;\n  this.bearing = 0;\n  this.pitch = 0;\n  this.center = [0, 0];\n  this._origin;\n  this.zoom = 0;\n  this._initialZoom; // Some parameters for different map services.\n\n  this.maxPitch = 60;\n  this.zoomOffset = 0;\n}\n\nMapServiceCoordSys3D.prototype = {\n  constructor: MapServiceCoordSys3D,\n  dimensions: ['lng', 'lat', 'alt'],\n  containPoint: function () {},\n  setCameraOption: function (option) {\n    this.bearing = option.bearing;\n    this.pitch = option.pitch;\n    this.center = option.center;\n    this.zoom = option.zoom;\n\n    if (!this._origin) {\n      this._origin = this.projectOnTileWithScale(this.center, TILE_SIZE);\n    }\n\n    if (this._initialZoom == null) {\n      this._initialZoom = this.zoom;\n    }\n\n    this.updateTransform();\n  },\n  // https://github.com/mapbox/mapbox-gl-js/blob/master/src/geo/transform.js#L479\n  updateTransform: function () {\n    if (!this.height) {\n      return;\n    }\n\n    var cameraToCenterDistance = 0.5 / Math.tan(FOV / 2) * this.height * WORLD_SCALE; // Convert to radian.\n\n    var pitch = Math.max(Math.min(this.pitch, this.maxPitch), 0) / 180 * Math.PI; // Find the distance from the center point [width/2, height/2] to the\n    // center top point [width/2, 0] in Z units, using the law of sines.\n    // 1 Z unit is equivalent to 1 horizontal px at the center of the map\n    // (the distance between[width/2, height/2] and [width/2 + 1, height/2])\n\n    var halfFov = FOV / 2;\n    var groundAngle = Math.PI / 2 + pitch;\n    var topHalfSurfaceDistance = Math.sin(halfFov) * cameraToCenterDistance / Math.sin(Math.PI - groundAngle - halfFov); // Calculate z distance of the farthest fragment that should be rendered.\n\n    var furthestDistance = Math.cos(Math.PI / 2 - pitch) * topHalfSurfaceDistance + cameraToCenterDistance; // Add a bit extra to avoid precision problems when a fragment's distance is exactly `furthestDistance`\n\n    var farZ = furthestDistance * 1.1; // Forced to be 1000\n\n    if (this.pitch > 50) {\n      farZ = 1000;\n    } // matrix for conversion from location to GL coordinates (-1 .. 1)\n\n\n    var m = [];\n    mat4.perspective(m, FOV, this.width / this.height, 1, farZ);\n    this.viewGL.camera.projectionMatrix.setArray(m);\n    this.viewGL.camera.decomposeProjectionMatrix();\n    var m = mat4.identity([]);\n    var pt = this.dataToPoint(this.center); // Inverse\n\n    mat4.scale(m, m, [1, -1, 1]); // Translate to altitude\n\n    mat4.translate(m, m, [0, 0, -cameraToCenterDistance]);\n    mat4.rotateX(m, m, pitch);\n    mat4.rotateZ(m, m, -this.bearing / 180 * Math.PI); // Translate to center.\n\n    mat4.translate(m, m, [-pt[0] * this.getScale() * WORLD_SCALE, -pt[1] * this.getScale() * WORLD_SCALE, 0]);\n    this.viewGL.camera.viewMatrix.array = m;\n    var invertM = [];\n    mat4.invert(invertM, m);\n    this.viewGL.camera.worldTransform.array = invertM;\n    this.viewGL.camera.decomposeWorldTransform(); // scale vertically to meters per pixel (inverse of ground resolution):\n    // worldSize / (circumferenceOfEarth * cos(lat * π / 180))\n\n    var worldSize = TILE_SIZE * this.getScale();\n    var verticalScale;\n\n    if (this.altitudeExtent && !isNaN(this.boxHeight)) {\n      var range = this.altitudeExtent[1] - this.altitudeExtent[0];\n      verticalScale = this.boxHeight / range * this.getScale() / Math.pow(2, this._initialZoom - this.zoomOffset);\n    } else {\n      verticalScale = worldSize / (2 * Math.PI * 6378000 * Math.abs(Math.cos(this.center[1] * (Math.PI / 180)))) * this.altitudeScale * WORLD_SCALE;\n    } // Include scale to avoid relayout when zooming\n    // FIXME Camera scale may have problem in shadow\n\n\n    this.viewGL.rootNode.scale.set(this.getScale() * WORLD_SCALE, this.getScale() * WORLD_SCALE, verticalScale);\n  },\n  getScale: function () {\n    return Math.pow(2, this.zoom - this.zoomOffset);\n  },\n  projectOnTile: function (data, out) {\n    return this.projectOnTileWithScale(data, this.getScale() * TILE_SIZE, out);\n  },\n  projectOnTileWithScale: function (data, scale, out) {\n    var lng = data[0];\n    var lat = data[1];\n    var lambda2 = lng * PI / 180;\n    var phi2 = lat * PI / 180;\n    var x = scale * (lambda2 + PI) / (2 * PI);\n    var y = scale * (PI - Math.log(Math.tan(PI / 4 + phi2 * 0.5))) / (2 * PI);\n    out = out || [];\n    out[0] = x;\n    out[1] = y;\n    return out;\n  },\n  unprojectFromTile: function (point, out) {\n    return this.unprojectOnTileWithScale(point, this.getScale() * TILE_SIZE, out);\n  },\n  unprojectOnTileWithScale: function (point, scale, out) {\n    var x = point[0];\n    var y = point[1];\n    var lambda2 = x / scale * (2 * PI) - PI;\n    var phi2 = 2 * (Math.atan(Math.exp(PI - y / scale * (2 * PI))) - PI / 4);\n    out = out || [];\n    out[0] = lambda2 * 180 / PI;\n    out[1] = phi2 * 180 / PI;\n    return out;\n  },\n  dataToPoint: function (data, out) {\n    out = this.projectOnTileWithScale(data, TILE_SIZE, out); // Add a origin to avoid precision issue in WebGL.\n\n    out[0] -= this._origin[0];\n    out[1] -= this._origin[1]; // PENDING\n\n    out[2] = !isNaN(data[2]) ? data[2] : 0;\n\n    if (!isNaN(data[2])) {\n      out[2] = data[2];\n\n      if (this.altitudeExtent) {\n        out[2] -= this.altitudeExtent[0];\n      }\n    }\n\n    return out;\n  }\n};\nexport default MapServiceCoordSys3D;"]},"metadata":{},"sourceType":"module"}