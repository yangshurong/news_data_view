{"ast":null,"code":"'use strict';\n\nrequire(\"core-js/modules/es.regexp.exec.js\");\n\nrequire(\"core-js/modules/es.regexp.test.js\");\n\nrequire(\"core-js/modules/es.string.trim.js\");\n\nrequire(\"core-js/modules/es.array.splice.js\");\n\nrequire(\"core-js/modules/es.array.map.js\");\n\nrequire(\"core-js/modules/es.regexp.constructor.js\");\n\nrequire(\"core-js/modules/es.regexp.dot-all.js\");\n\nrequire(\"core-js/modules/es.regexp.sticky.js\");\n\nrequire(\"core-js/modules/es.regexp.to-string.js\");\n\nrequire(\"core-js/modules/es.number.to-fixed.js\");\n\nrequire(\"core-js/modules/es.string.replace.js\");\n\nvar css = require('css');\n\nvar extend = require('extend');\n\nvar defaultConfig = {\n  baseDpr: 2,\n  // base device pixel ratio (default: 2)\n  remUnit: 75,\n  // rem unit value (default: 75)\n  remPrecision: 6,\n  // rem value precision (default: 6)\n  forcePxComment: 'px',\n  // force px comment (default: `px`)\n  keepComment: 'no' // no transform value comment (default: `no`)\n\n};\nvar pxRegExp = /\\b(\\d+(\\.\\d+)?)px\\b/;\n\nfunction Px2rem(options) {\n  this.config = {};\n  extend(this.config, defaultConfig, options);\n} // generate @1x, @2x and @3x version stylesheet\n\n\nPx2rem.prototype.generateThree = function (cssText, dpr) {\n  dpr = dpr || 2;\n  var self = this;\n  var config = self.config;\n  var astObj = css.parse(cssText);\n\n  function processRules(rules) {\n    for (var i = 0; i < rules.length; i++) {\n      var rule = rules[i];\n\n      if (rule.type === 'media') {\n        processRules(rule.rules); // recursive invocation while dealing with media queries\n\n        continue;\n      } else if (rule.type === 'keyframes') {\n        processRules(rule.keyframes); // recursive invocation while dealing with keyframes\n\n        continue;\n      } else if (rule.type !== 'rule' && rule.type !== 'keyframe') {\n        continue;\n      }\n\n      var declarations = rule.declarations;\n\n      for (var j = 0; j < declarations.length; j++) {\n        var declaration = declarations[j]; // need transform: declaration && has 'px'\n\n        if (declaration.type === 'declaration' && pxRegExp.test(declaration.value)) {\n          var nextDeclaration = rule.declarations[j + 1];\n\n          if (nextDeclaration && nextDeclaration.type === 'comment') {\n            // next next declaration is comment\n            if (nextDeclaration.comment.trim() === config.keepComment) {\n              // no transform\n              declarations.splice(j + 1, 1); // delete corresponding comment\n\n              continue;\n            } else if (nextDeclaration.comment.trim() === config.forcePxComment) {\n              // force px\n              declarations.splice(j + 1, 1); // delete corresponding comment\n            }\n          }\n\n          declaration.value = self._getCalcValue('px', declaration.value, dpr); // common transform\n        }\n      }\n    }\n  }\n\n  processRules(astObj.stylesheet.rules);\n  return css.stringify(astObj);\n}; // generate rem version stylesheet\n\n\nPx2rem.prototype.generateRem = function (cssText) {\n  var self = this;\n  var config = self.config;\n  var astObj = css.parse(cssText);\n\n  function processRules(rules, noDealPx) {\n    // FIXME: keyframes do not support `force px` comment\n    for (var i = 0; i < rules.length; i++) {\n      var rule = rules[i];\n\n      if (rule.type === 'media') {\n        processRules(rule.rules); // recursive invocation while dealing with media queries\n\n        continue;\n      } else if (rule.type === 'keyframes') {\n        processRules(rule.keyframes, true); // recursive invocation while dealing with keyframes\n\n        continue;\n      } else if (rule.type !== 'rule' && rule.type !== 'keyframe') {\n        continue;\n      }\n\n      if (!noDealPx) {\n        // generate 3 new rules which has [data-dpr]\n        var newRules = [];\n\n        for (var dpr = 1; dpr <= 3; dpr++) {\n          var newRule = {};\n          newRule.type = rule.type;\n          newRule.selectors = rule.selectors.map(function (sel) {\n            return '[data-dpr=\"' + dpr + '\"] ' + sel;\n          });\n          newRule.declarations = [];\n          newRules.push(newRule);\n        }\n      }\n\n      var declarations = rule.declarations;\n\n      for (var j = 0; j < declarations.length; j++) {\n        var declaration = declarations[j]; // need transform: declaration && has 'px'\n\n        if (declaration.type === 'declaration' && pxRegExp.test(declaration.value)) {\n          var nextDeclaration = rule.declarations[j + 1];\n\n          if (nextDeclaration && nextDeclaration.type === 'comment') {\n            // next next declaration is comment\n            if (nextDeclaration.comment.trim() === config.forcePxComment) {\n              // force px\n              // do not transform `0px`\n              if (declaration.value === '0px') {\n                declaration.value = '0';\n                declarations.splice(j + 1, 1); // delete corresponding comment\n\n                continue;\n              }\n\n              if (!noDealPx) {\n                // generate 3 new declarations and put them in the new rules which has [data-dpr]\n                for (var dpr = 1; dpr <= 3; dpr++) {\n                  var newDeclaration = {};\n                  extend(true, newDeclaration, declaration);\n                  newDeclaration.value = self._getCalcValue('px', newDeclaration.value, dpr);\n                  newRules[dpr - 1].declarations.push(newDeclaration);\n                }\n\n                declarations.splice(j, 2); // delete this rule and corresponding comment\n\n                j--;\n              } else {\n                // FIXME: keyframes do not support `force px` comment\n                declaration.value = self._getCalcValue('rem', declaration.value); // common transform\n\n                declarations.splice(j + 1, 1); // delete corresponding comment\n              }\n            } else if (nextDeclaration.comment.trim() === config.keepComment) {\n              // no transform\n              declarations.splice(j + 1, 1); // delete corresponding comment\n            } else {\n              declaration.value = self._getCalcValue('rem', declaration.value); // common transform\n            }\n          } else {\n            declaration.value = self._getCalcValue('rem', declaration.value); // common transform\n          }\n        }\n      } // if the origin rule has no declarations, delete it\n\n\n      if (!rules[i].declarations.length) {\n        rules.splice(i, 1);\n        i--;\n      }\n\n      if (!noDealPx) {\n        // add the new rules which contain declarations that are forced to use px\n        if (newRules[0].declarations.length) {\n          rules.splice(i + 1, 0, newRules[0], newRules[1], newRules[2]);\n          i += 3; // skip the added new rules\n        }\n      }\n    }\n  }\n\n  processRules(astObj.stylesheet.rules);\n  return css.stringify(astObj);\n}; // get calculated value of px or rem\n\n\nPx2rem.prototype._getCalcValue = function (type, value, dpr) {\n  var config = this.config;\n  var pxGlobalRegExp = new RegExp(pxRegExp.source, 'g');\n\n  function getValue(val) {\n    val = parseFloat(val.toFixed(config.remPrecision)); // control decimal precision of the calculated value\n\n    return val == 0 ? val : val + type;\n  }\n\n  return value.replace(pxGlobalRegExp, function ($0, $1) {\n    return type === 'px' ? getValue($1 * dpr / config.baseDpr) : getValue($1 / config.remUnit);\n  });\n};\n\nmodule.exports = Px2rem;","map":{"version":3,"sources":["C:/Users/Administrator/Desktop/data_view/my_project/vue2_app/myapp/node_modules/px2rem/lib/px2rem.js"],"names":["css","require","extend","defaultConfig","baseDpr","remUnit","remPrecision","forcePxComment","keepComment","pxRegExp","Px2rem","options","config","prototype","generateThree","cssText","dpr","self","astObj","parse","processRules","rules","i","length","rule","type","keyframes","declarations","j","declaration","test","value","nextDeclaration","comment","trim","splice","_getCalcValue","stylesheet","stringify","generateRem","noDealPx","newRules","newRule","selectors","map","sel","push","newDeclaration","pxGlobalRegExp","RegExp","source","getValue","val","parseFloat","toFixed","replace","$0","$1","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar css = require('css');\nvar extend = require('extend');\n\nvar defaultConfig = {\n  baseDpr: 2,             // base device pixel ratio (default: 2)\n  remUnit: 75,            // rem unit value (default: 75)\n  remPrecision: 6,        // rem value precision (default: 6)\n  forcePxComment: 'px',   // force px comment (default: `px`)\n  keepComment: 'no'       // no transform value comment (default: `no`)\n};\n\nvar pxRegExp = /\\b(\\d+(\\.\\d+)?)px\\b/;\n\nfunction Px2rem(options) {\n  this.config = {};\n  extend(this.config, defaultConfig, options);\n}\n\n// generate @1x, @2x and @3x version stylesheet\nPx2rem.prototype.generateThree = function (cssText, dpr) {\n  dpr = dpr || 2;\n  var self = this;\n  var config = self.config;\n  var astObj = css.parse(cssText);\n\n  function processRules(rules) {\n    for (var i = 0; i < rules.length; i++) {\n      var rule = rules[i];\n      if (rule.type === 'media') {\n        processRules(rule.rules); // recursive invocation while dealing with media queries\n        continue;\n      } else if (rule.type === 'keyframes') {\n        processRules(rule.keyframes); // recursive invocation while dealing with keyframes\n        continue;\n      } else if (rule.type !== 'rule' && rule.type !== 'keyframe') {\n        continue;\n      }\n\n      var declarations = rule.declarations;\n      for (var j = 0; j < declarations.length; j++) {\n        var declaration = declarations[j];\n        // need transform: declaration && has 'px'\n        if (declaration.type === 'declaration' && pxRegExp.test(declaration.value)) {\n          var nextDeclaration = rule.declarations[j + 1];\n          if (nextDeclaration && nextDeclaration.type === 'comment') { // next next declaration is comment\n            if (nextDeclaration.comment.trim() === config.keepComment) { // no transform\n              declarations.splice(j + 1, 1); // delete corresponding comment\n              continue;\n            } else if (nextDeclaration.comment.trim() === config.forcePxComment) { // force px\n              declarations.splice(j + 1, 1); // delete corresponding comment\n            }\n          }\n          declaration.value = self._getCalcValue('px', declaration.value, dpr); // common transform\n        }\n      }\n    }\n  }\n\n  processRules(astObj.stylesheet.rules);\n\n  return css.stringify(astObj);\n};\n\n// generate rem version stylesheet\nPx2rem.prototype.generateRem = function (cssText) {\n  var self = this;\n  var config = self.config;\n  var astObj = css.parse(cssText);\n\n  function processRules(rules, noDealPx) { // FIXME: keyframes do not support `force px` comment\n    for (var i = 0; i < rules.length; i++) {\n      var rule = rules[i];\n      if (rule.type === 'media') {\n        processRules(rule.rules); // recursive invocation while dealing with media queries\n        continue;\n      } else if (rule.type === 'keyframes') {\n        processRules(rule.keyframes, true); // recursive invocation while dealing with keyframes\n        continue;\n      } else if (rule.type !== 'rule' && rule.type !== 'keyframe') {\n        continue;\n      }\n\n      if (!noDealPx) {\n        // generate 3 new rules which has [data-dpr]\n        var newRules = [];\n        for (var dpr = 1; dpr <= 3; dpr++) {\n          var newRule = {};\n          newRule.type = rule.type;\n          newRule.selectors = rule.selectors.map(function (sel) {\n            return '[data-dpr=\"' + dpr + '\"] ' + sel;\n          });\n          newRule.declarations = [];\n          newRules.push(newRule);\n        }\n      }\n\n      var declarations = rule.declarations;\n      for (var j = 0; j < declarations.length; j++) {\n        var declaration = declarations[j];\n        // need transform: declaration && has 'px'\n        if (declaration.type === 'declaration' && pxRegExp.test(declaration.value)) {\n          var nextDeclaration = rule.declarations[j + 1];\n          if (nextDeclaration && nextDeclaration.type === 'comment') { // next next declaration is comment\n            if (nextDeclaration.comment.trim() === config.forcePxComment) { // force px\n              // do not transform `0px`\n              if (declaration.value === '0px') {\n                declaration.value = '0';\n                declarations.splice(j + 1, 1); // delete corresponding comment\n                continue;\n              }\n              if (!noDealPx) {\n                // generate 3 new declarations and put them in the new rules which has [data-dpr]\n                for (var dpr = 1; dpr <= 3; dpr++) {\n                  var newDeclaration = {};\n                  extend(true, newDeclaration, declaration);\n                  newDeclaration.value = self._getCalcValue('px', newDeclaration.value, dpr);\n                  newRules[dpr - 1].declarations.push(newDeclaration);\n                }\n                declarations.splice(j, 2); // delete this rule and corresponding comment\n                j--;\n              } else { // FIXME: keyframes do not support `force px` comment\n                declaration.value = self._getCalcValue('rem', declaration.value); // common transform\n                declarations.splice(j + 1, 1); // delete corresponding comment\n              }\n            } else if (nextDeclaration.comment.trim() === config.keepComment) { // no transform\n              declarations.splice(j + 1, 1); // delete corresponding comment\n            } else {\n              declaration.value = self._getCalcValue('rem', declaration.value); // common transform\n            }\n          } else {\n            declaration.value = self._getCalcValue('rem', declaration.value); // common transform\n          }\n        }\n      }\n\n      // if the origin rule has no declarations, delete it\n      if (!rules[i].declarations.length) {\n        rules.splice(i, 1);\n        i--;\n      }\n\n      if (!noDealPx) {\n        // add the new rules which contain declarations that are forced to use px\n        if (newRules[0].declarations.length) {\n          rules.splice(i + 1, 0, newRules[0], newRules[1], newRules[2]);\n          i += 3; // skip the added new rules\n        }\n      }\n    }\n  }\n\n  processRules(astObj.stylesheet.rules);\n\n  return css.stringify(astObj);\n};\n\n// get calculated value of px or rem\nPx2rem.prototype._getCalcValue = function (type, value, dpr) {\n  var config = this.config;\n  var pxGlobalRegExp = new RegExp(pxRegExp.source, 'g');\n\n  function getValue(val) {\n    val = parseFloat(val.toFixed(config.remPrecision)); // control decimal precision of the calculated value\n    return val == 0 ? val : val + type;\n  }\n\n  return value.replace(pxGlobalRegExp, function ($0, $1) {\n    return type === 'px' ? getValue($1 * dpr / config.baseDpr) : getValue($1 / config.remUnit);\n  });\n};\n\nmodule.exports = Px2rem;\n"]},"metadata":{},"sourceType":"script"}