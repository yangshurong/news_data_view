{"ast":null,"code":"import \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.typed-array.float32-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport * as echarts from 'echarts/lib/echarts';\nimport componentShadingMixin from '../../component/common/componentShadingMixin';\nimport _formatTooltip from '../common/formatTooltip';\nimport createList from '../common/createList';\nvar SurfaceSeries = echarts.SeriesModel.extend({\n  type: 'series.surface',\n  dependencies: ['globe', 'grid3D', 'geo3D'],\n  visualStyleAccessPath: 'itemStyle',\n  formatTooltip: function formatTooltip(dataIndex) {\n    return _formatTooltip(this, dataIndex);\n  },\n  getInitialData: function getInitialData(option, ecModel) {\n    var data = option.data;\n\n    function validateDimension(dimOpts) {\n      return !(isNaN(dimOpts.min) || isNaN(dimOpts.max) || isNaN(dimOpts.step));\n    }\n\n    function getPrecision(dimOpts) {\n      var getPrecision = echarts.number.getPrecisionSafe;\n      return Math.max(getPrecision(dimOpts.min), getPrecision(dimOpts.max), getPrecision(dimOpts.step)) + 1;\n    }\n\n    if (!data) {\n      if (!option.parametric) {\n        // From surface equation\n        var equation = option.equation || {};\n        var xOpts = equation.x || {};\n        var yOpts = equation.y || {};\n        ['x', 'y'].forEach(function (dim) {\n          if (!validateDimension(equation[dim])) {\n            if (process.env.NODE_ENV !== 'production') {\n              console.error('Invalid equation.%s', dim);\n            }\n\n            return;\n          }\n        });\n\n        if (typeof equation.z !== 'function') {\n          if (process.env.NODE_ENV !== 'production') {\n            console.error('equation.z needs to be function');\n          }\n\n          return;\n        }\n\n        var xCount = Math.floor((xOpts.max + xOpts.step - xOpts.min) / xOpts.step);\n        var yCount = Math.floor((yOpts.max + yOpts.step - yOpts.min) / yOpts.step);\n        data = new Float32Array(xCount * yCount * 3);\n        var xPrecision = getPrecision(xOpts);\n        var yPrecision = getPrecision(yOpts);\n        var off = 0;\n\n        for (var j = 0; j < yCount; j++) {\n          for (var i = 0; i < xCount; i++) {\n            var x = i * xOpts.step + xOpts.min;\n            var y = j * yOpts.step + yOpts.min;\n            var x2 = echarts.number.round(Math.min(x, xOpts.max), xPrecision);\n            var y2 = echarts.number.round(Math.min(y, yOpts.max), yPrecision);\n            var z = equation.z(x2, y2);\n            data[off++] = x2;\n            data[off++] = y2;\n            data[off++] = z;\n          }\n        }\n      } else {\n        var parametricEquation = option.parametricEquation || {};\n        var uOpts = parametricEquation.u || {};\n        var vOpts = parametricEquation.v || {};\n        ['u', 'v'].forEach(function (dim) {\n          if (!validateDimension(parametricEquation[dim])) {\n            if (process.env.NODE_ENV !== 'production') {\n              console.error('Invalid parametricEquation.%s', dim);\n            }\n\n            return;\n          }\n        });\n        ['x', 'y', 'z'].forEach(function (dim) {\n          if (typeof parametricEquation[dim] !== 'function') {\n            if (process.env.NODE_ENV !== 'production') {\n              console.error('parametricEquation.%s needs to be function', dim);\n            }\n\n            return;\n          }\n        });\n        var uCount = Math.floor((uOpts.max + uOpts.step - uOpts.min) / uOpts.step);\n        var vCount = Math.floor((vOpts.max + vOpts.step - vOpts.min) / vOpts.step);\n        data = new Float32Array(uCount * vCount * 5);\n        var uPrecision = getPrecision(uOpts);\n        var vPrecision = getPrecision(vOpts);\n        var off = 0;\n\n        for (var j = 0; j < vCount; j++) {\n          for (var i = 0; i < uCount; i++) {\n            var u = i * uOpts.step + uOpts.min;\n            var v = j * vOpts.step + vOpts.min;\n            var u2 = echarts.number.round(Math.min(u, uOpts.max), uPrecision);\n            var v2 = echarts.number.round(Math.min(v, vOpts.max), vPrecision);\n            var x = parametricEquation.x(u2, v2);\n            var y = parametricEquation.y(u2, v2);\n            var z = parametricEquation.z(u2, v2);\n            data[off++] = x;\n            data[off++] = y;\n            data[off++] = z;\n            data[off++] = u2;\n            data[off++] = v2;\n          }\n        }\n      }\n    }\n\n    var dims = ['x', 'y', 'z'];\n\n    if (option.parametric) {\n      dims.push('u', 'v');\n    } // PENDING getSource?\n\n\n    var list = createList(this, dims, data);\n    return list;\n  },\n  defaultOption: {\n    coordinateSystem: 'cartesian3D',\n    zlevel: -10,\n    // Cartesian coordinate system\n    grid3DIndex: 0,\n    // Surface needs lambert shading to show the difference\n    shading: 'lambert',\n    // If parametric surface\n    parametric: false,\n    wireframe: {\n      show: true,\n      lineStyle: {\n        color: 'rgba(0,0,0,0.5)',\n        width: 1\n      }\n    },\n\n    /**\n     * Generate surface data from z = f(x, y) equation\n     */\n    equation: {\n      // [min, max, step]\n      x: {\n        min: -1,\n        max: 1,\n        step: 0.1\n      },\n      y: {\n        min: -1,\n        max: 1,\n        step: 0.1\n      },\n      z: null\n    },\n    parametricEquation: {\n      // [min, max, step]\n      u: {\n        min: -1,\n        max: 1,\n        step: 0.1\n      },\n      v: {\n        min: -1,\n        max: 1,\n        step: 0.1\n      },\n      // [x, y, z] = f(x, y)\n      x: null,\n      y: null,\n      z: null\n    },\n    // Shape of give data\n    // It is an array to specify rows and columns.\n    // For example [30, 30]\n    dataShape: null,\n    itemStyle: {// Color\n    },\n    animationDurationUpdate: 500\n  }\n});\necharts.util.merge(SurfaceSeries.prototype, componentShadingMixin);\nexport default SurfaceSeries;","map":{"version":3,"sources":["C:/Users/Administrator/Desktop/data_view/my_project/vue2_app/myapp/node_modules/echarts-gl/lib/chart/surface/SurfaceSeries.js"],"names":["echarts","componentShadingMixin","formatTooltip","createList","SurfaceSeries","SeriesModel","extend","type","dependencies","visualStyleAccessPath","dataIndex","getInitialData","option","ecModel","data","validateDimension","dimOpts","isNaN","min","max","step","getPrecision","number","getPrecisionSafe","Math","parametric","equation","xOpts","x","yOpts","y","forEach","dim","process","env","NODE_ENV","console","error","z","xCount","floor","yCount","Float32Array","xPrecision","yPrecision","off","j","i","x2","round","y2","parametricEquation","uOpts","u","vOpts","v","uCount","vCount","uPrecision","vPrecision","u2","v2","dims","push","list","defaultOption","coordinateSystem","zlevel","grid3DIndex","shading","wireframe","show","lineStyle","color","width","dataShape","itemStyle","animationDurationUpdate","util","merge","prototype"],"mappings":"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","sourcesContent":["import * as echarts from 'echarts/lib/echarts';\nimport componentShadingMixin from '../../component/common/componentShadingMixin';\nimport formatTooltip from '../common/formatTooltip';\nimport createList from '../common/createList';\nvar SurfaceSeries = echarts.SeriesModel.extend({\n  type: 'series.surface',\n  dependencies: ['globe', 'grid3D', 'geo3D'],\n  visualStyleAccessPath: 'itemStyle',\n  formatTooltip: function (dataIndex) {\n    return formatTooltip(this, dataIndex);\n  },\n  getInitialData: function (option, ecModel) {\n    var data = option.data;\n\n    function validateDimension(dimOpts) {\n      return !(isNaN(dimOpts.min) || isNaN(dimOpts.max) || isNaN(dimOpts.step));\n    }\n\n    function getPrecision(dimOpts) {\n      var getPrecision = echarts.number.getPrecisionSafe;\n      return Math.max(getPrecision(dimOpts.min), getPrecision(dimOpts.max), getPrecision(dimOpts.step)) + 1;\n    }\n\n    if (!data) {\n      if (!option.parametric) {\n        // From surface equation\n        var equation = option.equation || {};\n        var xOpts = equation.x || {};\n        var yOpts = equation.y || {};\n        ['x', 'y'].forEach(function (dim) {\n          if (!validateDimension(equation[dim])) {\n            if (process.env.NODE_ENV !== 'production') {\n              console.error('Invalid equation.%s', dim);\n            }\n\n            return;\n          }\n        });\n\n        if (typeof equation.z !== 'function') {\n          if (process.env.NODE_ENV !== 'production') {\n            console.error('equation.z needs to be function');\n          }\n\n          return;\n        }\n\n        var xCount = Math.floor((xOpts.max + xOpts.step - xOpts.min) / xOpts.step);\n        var yCount = Math.floor((yOpts.max + yOpts.step - yOpts.min) / yOpts.step);\n        data = new Float32Array(xCount * yCount * 3);\n        var xPrecision = getPrecision(xOpts);\n        var yPrecision = getPrecision(yOpts);\n        var off = 0;\n\n        for (var j = 0; j < yCount; j++) {\n          for (var i = 0; i < xCount; i++) {\n            var x = i * xOpts.step + xOpts.min;\n            var y = j * yOpts.step + yOpts.min;\n            var x2 = echarts.number.round(Math.min(x, xOpts.max), xPrecision);\n            var y2 = echarts.number.round(Math.min(y, yOpts.max), yPrecision);\n            var z = equation.z(x2, y2);\n            data[off++] = x2;\n            data[off++] = y2;\n            data[off++] = z;\n          }\n        }\n      } else {\n        var parametricEquation = option.parametricEquation || {};\n        var uOpts = parametricEquation.u || {};\n        var vOpts = parametricEquation.v || {};\n        ['u', 'v'].forEach(function (dim) {\n          if (!validateDimension(parametricEquation[dim])) {\n            if (process.env.NODE_ENV !== 'production') {\n              console.error('Invalid parametricEquation.%s', dim);\n            }\n\n            return;\n          }\n        });\n        ['x', 'y', 'z'].forEach(function (dim) {\n          if (typeof parametricEquation[dim] !== 'function') {\n            if (process.env.NODE_ENV !== 'production') {\n              console.error('parametricEquation.%s needs to be function', dim);\n            }\n\n            return;\n          }\n        });\n        var uCount = Math.floor((uOpts.max + uOpts.step - uOpts.min) / uOpts.step);\n        var vCount = Math.floor((vOpts.max + vOpts.step - vOpts.min) / vOpts.step);\n        data = new Float32Array(uCount * vCount * 5);\n        var uPrecision = getPrecision(uOpts);\n        var vPrecision = getPrecision(vOpts);\n        var off = 0;\n\n        for (var j = 0; j < vCount; j++) {\n          for (var i = 0; i < uCount; i++) {\n            var u = i * uOpts.step + uOpts.min;\n            var v = j * vOpts.step + vOpts.min;\n            var u2 = echarts.number.round(Math.min(u, uOpts.max), uPrecision);\n            var v2 = echarts.number.round(Math.min(v, vOpts.max), vPrecision);\n            var x = parametricEquation.x(u2, v2);\n            var y = parametricEquation.y(u2, v2);\n            var z = parametricEquation.z(u2, v2);\n            data[off++] = x;\n            data[off++] = y;\n            data[off++] = z;\n            data[off++] = u2;\n            data[off++] = v2;\n          }\n        }\n      }\n    }\n\n    var dims = ['x', 'y', 'z'];\n\n    if (option.parametric) {\n      dims.push('u', 'v');\n    } // PENDING getSource?\n\n\n    var list = createList(this, dims, data);\n    return list;\n  },\n  defaultOption: {\n    coordinateSystem: 'cartesian3D',\n    zlevel: -10,\n    // Cartesian coordinate system\n    grid3DIndex: 0,\n    // Surface needs lambert shading to show the difference\n    shading: 'lambert',\n    // If parametric surface\n    parametric: false,\n    wireframe: {\n      show: true,\n      lineStyle: {\n        color: 'rgba(0,0,0,0.5)',\n        width: 1\n      }\n    },\n\n    /**\n     * Generate surface data from z = f(x, y) equation\n     */\n    equation: {\n      // [min, max, step]\n      x: {\n        min: -1,\n        max: 1,\n        step: 0.1\n      },\n      y: {\n        min: -1,\n        max: 1,\n        step: 0.1\n      },\n      z: null\n    },\n    parametricEquation: {\n      // [min, max, step]\n      u: {\n        min: -1,\n        max: 1,\n        step: 0.1\n      },\n      v: {\n        min: -1,\n        max: 1,\n        step: 0.1\n      },\n      // [x, y, z] = f(x, y)\n      x: null,\n      y: null,\n      z: null\n    },\n    // Shape of give data\n    // It is an array to specify rows and columns.\n    // For example [30, 30]\n    dataShape: null,\n    itemStyle: {// Color\n    },\n    animationDurationUpdate: 500\n  }\n});\necharts.util.merge(SurfaceSeries.prototype, componentShadingMixin);\nexport default SurfaceSeries;"]},"metadata":{},"sourceType":"module"}