{"ast":null,"code":"import Vector3 from './Vector3';\nimport vec3 from '../glmatrix/vec3';\nvar EPSILON = 1e-5;\n/**\n * @constructor\n * @alias clay.Ray\n * @param {clay.Vector3} [origin]\n * @param {clay.Vector3} [direction]\n */\n\nvar Ray = function (origin, direction) {\n  /**\n   * @type {clay.Vector3}\n   */\n  this.origin = origin || new Vector3();\n  /**\n   * @type {clay.Vector3}\n   */\n\n  this.direction = direction || new Vector3();\n};\n\nRay.prototype = {\n  constructor: Ray,\n  // http://www.siggraph.org/education/materials/HyperGraph/raytrace/rayplane_intersection.htm\n\n  /**\n   * Calculate intersection point between ray and a give plane\n   * @param  {clay.Plane} plane\n   * @param  {clay.Vector3} [out]\n   * @return {clay.Vector3}\n   */\n  intersectPlane: function (plane, out) {\n    var pn = plane.normal.array;\n    var d = plane.distance;\n    var ro = this.origin.array;\n    var rd = this.direction.array;\n    var divider = vec3.dot(pn, rd); // ray is parallel to the plane\n\n    if (divider === 0) {\n      return null;\n    }\n\n    if (!out) {\n      out = new Vector3();\n    }\n\n    var t = (vec3.dot(pn, ro) - d) / divider;\n    vec3.scaleAndAdd(out.array, ro, rd, -t);\n    out._dirty = true;\n    return out;\n  },\n\n  /**\n   * Mirror the ray against plane\n   * @param  {clay.Plane} plane\n   */\n  mirrorAgainstPlane: function (plane) {\n    // Distance to plane\n    var d = vec3.dot(plane.normal.array, this.direction.array);\n    vec3.scaleAndAdd(this.direction.array, this.direction.array, plane.normal.array, -d * 2);\n    this.direction._dirty = true;\n  },\n  distanceToPoint: function () {\n    var v = vec3.create();\n    return function (point) {\n      vec3.sub(v, point, this.origin.array); // Distance from projection point to origin\n\n      var b = vec3.dot(v, this.direction.array);\n\n      if (b < 0) {\n        return vec3.distance(this.origin.array, point);\n      } // Squared distance from center to origin\n\n\n      var c2 = vec3.lenSquared(v); // Squared distance from center to projection point\n\n      return Math.sqrt(c2 - b * b);\n    };\n  }(),\n\n  /**\n   * Calculate intersection point between ray and sphere\n   * @param  {clay.Vector3} center\n   * @param  {number} radius\n   * @param  {clay.Vector3} out\n   * @return {clay.Vector3}\n   */\n  intersectSphere: function () {\n    var v = vec3.create();\n    return function (center, radius, out) {\n      var origin = this.origin.array;\n      var direction = this.direction.array;\n      center = center.array;\n      vec3.sub(v, center, origin); // Distance from projection point to origin\n\n      var b = vec3.dot(v, direction); // Squared distance from center to origin\n\n      var c2 = vec3.squaredLength(v); // Squared distance from center to projection point\n\n      var d2 = c2 - b * b;\n      var r2 = radius * radius; // No intersection\n\n      if (d2 > r2) {\n        return;\n      }\n\n      var a = Math.sqrt(r2 - d2); // First intersect point\n\n      var t0 = b - a; // Second intersect point\n\n      var t1 = b + a;\n\n      if (!out) {\n        out = new Vector3();\n      }\n\n      if (t0 < 0) {\n        if (t1 < 0) {\n          return null;\n        } else {\n          vec3.scaleAndAdd(out.array, origin, direction, t1);\n          return out;\n        }\n      } else {\n        vec3.scaleAndAdd(out.array, origin, direction, t0);\n        return out;\n      }\n    };\n  }(),\n  // http://www.scratchapixel.com/lessons/3d-basic-lessons/lesson-7-intersecting-simple-shapes/ray-box-intersection/\n\n  /**\n   * Calculate intersection point between ray and bounding box\n   * @param {clay.BoundingBox} bbox\n   * @param {clay.Vector3}\n   * @return {clay.Vector3}\n   */\n  intersectBoundingBox: function (bbox, out) {\n    var dir = this.direction.array;\n    var origin = this.origin.array;\n    var min = bbox.min.array;\n    var max = bbox.max.array;\n    var invdirx = 1 / dir[0];\n    var invdiry = 1 / dir[1];\n    var invdirz = 1 / dir[2];\n    var tmin, tmax, tymin, tymax, tzmin, tzmax;\n\n    if (invdirx >= 0) {\n      tmin = (min[0] - origin[0]) * invdirx;\n      tmax = (max[0] - origin[0]) * invdirx;\n    } else {\n      tmax = (min[0] - origin[0]) * invdirx;\n      tmin = (max[0] - origin[0]) * invdirx;\n    }\n\n    if (invdiry >= 0) {\n      tymin = (min[1] - origin[1]) * invdiry;\n      tymax = (max[1] - origin[1]) * invdiry;\n    } else {\n      tymax = (min[1] - origin[1]) * invdiry;\n      tymin = (max[1] - origin[1]) * invdiry;\n    }\n\n    if (tmin > tymax || tymin > tmax) {\n      return null;\n    }\n\n    if (tymin > tmin || tmin !== tmin) {\n      tmin = tymin;\n    }\n\n    if (tymax < tmax || tmax !== tmax) {\n      tmax = tymax;\n    }\n\n    if (invdirz >= 0) {\n      tzmin = (min[2] - origin[2]) * invdirz;\n      tzmax = (max[2] - origin[2]) * invdirz;\n    } else {\n      tzmax = (min[2] - origin[2]) * invdirz;\n      tzmin = (max[2] - origin[2]) * invdirz;\n    }\n\n    if (tmin > tzmax || tzmin > tmax) {\n      return null;\n    }\n\n    if (tzmin > tmin || tmin !== tmin) {\n      tmin = tzmin;\n    }\n\n    if (tzmax < tmax || tmax !== tmax) {\n      tmax = tzmax;\n    }\n\n    if (tmax < 0) {\n      return null;\n    }\n\n    var t = tmin >= 0 ? tmin : tmax;\n\n    if (!out) {\n      out = new Vector3();\n    }\n\n    vec3.scaleAndAdd(out.array, origin, dir, t);\n    return out;\n  },\n  // http://en.wikipedia.org/wiki/M%C3%B6ller%E2%80%93Trumbore_intersection_algorithm\n\n  /**\n   * Calculate intersection point between ray and three triangle vertices\n   * @param {clay.Vector3} a\n   * @param {clay.Vector3} b\n   * @param {clay.Vector3} c\n   * @param {boolean}           singleSided, CW triangle will be ignored\n   * @param {clay.Vector3} [out]\n   * @param {clay.Vector3} [barycenteric] barycentric coords\n   * @return {clay.Vector3}\n   */\n  intersectTriangle: function () {\n    var eBA = vec3.create();\n    var eCA = vec3.create();\n    var AO = vec3.create();\n    var vCross = vec3.create();\n    return function (a, b, c, singleSided, out, barycenteric) {\n      var dir = this.direction.array;\n      var origin = this.origin.array;\n      a = a.array;\n      b = b.array;\n      c = c.array;\n      vec3.sub(eBA, b, a);\n      vec3.sub(eCA, c, a);\n      vec3.cross(vCross, eCA, dir);\n      var det = vec3.dot(eBA, vCross);\n\n      if (singleSided) {\n        if (det > -EPSILON) {\n          return null;\n        }\n      } else {\n        if (det > -EPSILON && det < EPSILON) {\n          return null;\n        }\n      }\n\n      vec3.sub(AO, origin, a);\n      var u = vec3.dot(vCross, AO) / det;\n\n      if (u < 0 || u > 1) {\n        return null;\n      }\n\n      vec3.cross(vCross, eBA, AO);\n      var v = vec3.dot(dir, vCross) / det;\n\n      if (v < 0 || v > 1 || u + v > 1) {\n        return null;\n      }\n\n      vec3.cross(vCross, eBA, eCA);\n      var t = -vec3.dot(AO, vCross) / det;\n\n      if (t < 0) {\n        return null;\n      }\n\n      if (!out) {\n        out = new Vector3();\n      }\n\n      if (barycenteric) {\n        Vector3.set(barycenteric, 1 - u - v, u, v);\n      }\n\n      vec3.scaleAndAdd(out.array, origin, dir, t);\n      return out;\n    };\n  }(),\n\n  /**\n   * Apply an affine transform matrix to the ray\n   * @return {clay.Matrix4} matrix\n   */\n  applyTransform: function (matrix) {\n    Vector3.add(this.direction, this.direction, this.origin);\n    Vector3.transformMat4(this.origin, this.origin, matrix);\n    Vector3.transformMat4(this.direction, this.direction, matrix);\n    Vector3.sub(this.direction, this.direction, this.origin);\n    Vector3.normalize(this.direction, this.direction);\n  },\n\n  /**\n   * Copy values from another ray\n   * @param {clay.Ray} ray\n   */\n  copy: function (ray) {\n    Vector3.copy(this.origin, ray.origin);\n    Vector3.copy(this.direction, ray.direction);\n  },\n\n  /**\n   * Clone a new ray\n   * @return {clay.Ray}\n   */\n  clone: function () {\n    var ray = new Ray();\n    ray.copy(this);\n    return ray;\n  }\n};\nexport default Ray;","map":{"version":3,"sources":["C:/Users/Administrator/Desktop/data_view/my_project/vue2_app/myapp/node_modules/claygl/src/math/Ray.js"],"names":["Vector3","vec3","EPSILON","Ray","origin","direction","prototype","constructor","intersectPlane","plane","out","pn","normal","array","d","distance","ro","rd","divider","dot","t","scaleAndAdd","_dirty","mirrorAgainstPlane","distanceToPoint","v","create","point","sub","b","c2","lenSquared","Math","sqrt","intersectSphere","center","radius","squaredLength","d2","r2","a","t0","t1","intersectBoundingBox","bbox","dir","min","max","invdirx","invdiry","invdirz","tmin","tmax","tymin","tymax","tzmin","tzmax","intersectTriangle","eBA","eCA","AO","vCross","c","singleSided","barycenteric","cross","det","u","set","applyTransform","matrix","add","transformMat4","normalize","copy","ray","clone"],"mappings":"AAAA,OAAOA,OAAP,MAAoB,WAApB;AACA,OAAOC,IAAP,MAAiB,kBAAjB;AAEA,IAAIC,OAAO,GAAG,IAAd;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA,IAAIC,GAAG,GAAG,UAAUC,MAAV,EAAkBC,SAAlB,EAA6B;AACnC;AACJ;AACA;AACI,OAAKD,MAAL,GAAcA,MAAM,IAAI,IAAIJ,OAAJ,EAAxB;AACA;AACJ;AACA;;AACI,OAAKK,SAAL,GAAiBA,SAAS,IAAI,IAAIL,OAAJ,EAA9B;AACH,CATD;;AAWAG,GAAG,CAACG,SAAJ,GAAgB;AAEZC,EAAAA,WAAW,EAAEJ,GAFD;AAIZ;;AACA;AACJ;AACA;AACA;AACA;AACA;AACIK,EAAAA,cAAc,EAAE,UAAUC,KAAV,EAAiBC,GAAjB,EAAsB;AAClC,QAAIC,EAAE,GAAGF,KAAK,CAACG,MAAN,CAAaC,KAAtB;AACA,QAAIC,CAAC,GAAGL,KAAK,CAACM,QAAd;AACA,QAAIC,EAAE,GAAG,KAAKZ,MAAL,CAAYS,KAArB;AACA,QAAII,EAAE,GAAG,KAAKZ,SAAL,CAAeQ,KAAxB;AAEA,QAAIK,OAAO,GAAGjB,IAAI,CAACkB,GAAL,CAASR,EAAT,EAAaM,EAAb,CAAd,CANkC,CAOlC;;AACA,QAAIC,OAAO,KAAK,CAAhB,EAAmB;AACf,aAAO,IAAP;AACH;;AACD,QAAI,CAACR,GAAL,EAAU;AACNA,MAAAA,GAAG,GAAG,IAAIV,OAAJ,EAAN;AACH;;AACD,QAAIoB,CAAC,GAAG,CAACnB,IAAI,CAACkB,GAAL,CAASR,EAAT,EAAaK,EAAb,IAAmBF,CAApB,IAAyBI,OAAjC;AACAjB,IAAAA,IAAI,CAACoB,WAAL,CAAiBX,GAAG,CAACG,KAArB,EAA4BG,EAA5B,EAAgCC,EAAhC,EAAoC,CAACG,CAArC;AACAV,IAAAA,GAAG,CAACY,MAAJ,GAAa,IAAb;AACA,WAAOZ,GAAP;AACH,GA7BW;;AA+BZ;AACJ;AACA;AACA;AACIa,EAAAA,kBAAkB,EAAE,UAAUd,KAAV,EAAiB;AACjC;AACA,QAAIK,CAAC,GAAGb,IAAI,CAACkB,GAAL,CAASV,KAAK,CAACG,MAAN,CAAaC,KAAtB,EAA6B,KAAKR,SAAL,CAAeQ,KAA5C,CAAR;AACAZ,IAAAA,IAAI,CAACoB,WAAL,CAAiB,KAAKhB,SAAL,CAAeQ,KAAhC,EAAuC,KAAKR,SAAL,CAAeQ,KAAtD,EAA6DJ,KAAK,CAACG,MAAN,CAAaC,KAA1E,EAAiF,CAACC,CAAD,GAAK,CAAtF;AACA,SAAKT,SAAL,CAAeiB,MAAf,GAAwB,IAAxB;AACH,GAxCW;AA0CZE,EAAAA,eAAe,EAAG,YAAY;AAC1B,QAAIC,CAAC,GAAGxB,IAAI,CAACyB,MAAL,EAAR;AACA,WAAO,UAAUC,KAAV,EAAiB;AACpB1B,MAAAA,IAAI,CAAC2B,GAAL,CAASH,CAAT,EAAYE,KAAZ,EAAmB,KAAKvB,MAAL,CAAYS,KAA/B,EADoB,CAEpB;;AACA,UAAIgB,CAAC,GAAG5B,IAAI,CAACkB,GAAL,CAASM,CAAT,EAAY,KAAKpB,SAAL,CAAeQ,KAA3B,CAAR;;AACA,UAAIgB,CAAC,GAAG,CAAR,EAAW;AACP,eAAO5B,IAAI,CAACc,QAAL,CAAc,KAAKX,MAAL,CAAYS,KAA1B,EAAiCc,KAAjC,CAAP;AACH,OANmB,CAOpB;;;AACA,UAAIG,EAAE,GAAG7B,IAAI,CAAC8B,UAAL,CAAgBN,CAAhB,CAAT,CARoB,CASpB;;AACA,aAAOO,IAAI,CAACC,IAAL,CAAUH,EAAE,GAAGD,CAAC,GAAGA,CAAnB,CAAP;AACH,KAXD;AAYH,GAdgB,EA1CL;;AA0DZ;AACJ;AACA;AACA;AACA;AACA;AACA;AACIK,EAAAA,eAAe,EAAG,YAAY;AAC1B,QAAIT,CAAC,GAAGxB,IAAI,CAACyB,MAAL,EAAR;AACA,WAAO,UAAUS,MAAV,EAAkBC,MAAlB,EAA0B1B,GAA1B,EAA+B;AAClC,UAAIN,MAAM,GAAG,KAAKA,MAAL,CAAYS,KAAzB;AACA,UAAIR,SAAS,GAAG,KAAKA,SAAL,CAAeQ,KAA/B;AACAsB,MAAAA,MAAM,GAAGA,MAAM,CAACtB,KAAhB;AACAZ,MAAAA,IAAI,CAAC2B,GAAL,CAASH,CAAT,EAAYU,MAAZ,EAAoB/B,MAApB,EAJkC,CAKlC;;AACA,UAAIyB,CAAC,GAAG5B,IAAI,CAACkB,GAAL,CAASM,CAAT,EAAYpB,SAAZ,CAAR,CANkC,CAOlC;;AACA,UAAIyB,EAAE,GAAG7B,IAAI,CAACoC,aAAL,CAAmBZ,CAAnB,CAAT,CARkC,CASlC;;AACA,UAAIa,EAAE,GAAGR,EAAE,GAAGD,CAAC,GAAGA,CAAlB;AAEA,UAAIU,EAAE,GAAGH,MAAM,GAAGA,MAAlB,CAZkC,CAalC;;AACA,UAAIE,EAAE,GAAGC,EAAT,EAAa;AACT;AACH;;AAED,UAAIC,CAAC,GAAGR,IAAI,CAACC,IAAL,CAAUM,EAAE,GAAGD,EAAf,CAAR,CAlBkC,CAmBlC;;AACA,UAAIG,EAAE,GAAGZ,CAAC,GAAGW,CAAb,CApBkC,CAqBlC;;AACA,UAAIE,EAAE,GAAGb,CAAC,GAAGW,CAAb;;AAEA,UAAI,CAAC9B,GAAL,EAAU;AACNA,QAAAA,GAAG,GAAG,IAAIV,OAAJ,EAAN;AACH;;AACD,UAAIyC,EAAE,GAAG,CAAT,EAAY;AACR,YAAIC,EAAE,GAAG,CAAT,EAAY;AACR,iBAAO,IAAP;AACH,SAFD,MAGK;AACDzC,UAAAA,IAAI,CAACoB,WAAL,CAAiBX,GAAG,CAACG,KAArB,EAA4BT,MAA5B,EAAoCC,SAApC,EAA+CqC,EAA/C;AACA,iBAAOhC,GAAP;AACH;AACJ,OARD,MASK;AACDT,QAAAA,IAAI,CAACoB,WAAL,CAAiBX,GAAG,CAACG,KAArB,EAA4BT,MAA5B,EAAoCC,SAApC,EAA+CoC,EAA/C;AACA,eAAO/B,GAAP;AACH;AACJ,KAxCD;AAyCH,GA3CgB,EAjEL;AA8GZ;;AACA;AACJ;AACA;AACA;AACA;AACA;AACIiC,EAAAA,oBAAoB,EAAE,UAAUC,IAAV,EAAgBlC,GAAhB,EAAqB;AACvC,QAAImC,GAAG,GAAG,KAAKxC,SAAL,CAAeQ,KAAzB;AACA,QAAIT,MAAM,GAAG,KAAKA,MAAL,CAAYS,KAAzB;AACA,QAAIiC,GAAG,GAAGF,IAAI,CAACE,GAAL,CAASjC,KAAnB;AACA,QAAIkC,GAAG,GAAGH,IAAI,CAACG,GAAL,CAASlC,KAAnB;AAEA,QAAImC,OAAO,GAAG,IAAIH,GAAG,CAAC,CAAD,CAArB;AACA,QAAII,OAAO,GAAG,IAAIJ,GAAG,CAAC,CAAD,CAArB;AACA,QAAIK,OAAO,GAAG,IAAIL,GAAG,CAAC,CAAD,CAArB;AAEA,QAAIM,IAAJ,EAAUC,IAAV,EAAgBC,KAAhB,EAAuBC,KAAvB,EAA8BC,KAA9B,EAAqCC,KAArC;;AACA,QAAIR,OAAO,IAAI,CAAf,EAAkB;AACdG,MAAAA,IAAI,GAAG,CAACL,GAAG,CAAC,CAAD,CAAH,GAAS1C,MAAM,CAAC,CAAD,CAAhB,IAAuB4C,OAA9B;AACAI,MAAAA,IAAI,GAAG,CAACL,GAAG,CAAC,CAAD,CAAH,GAAS3C,MAAM,CAAC,CAAD,CAAhB,IAAuB4C,OAA9B;AACH,KAHD,MAIK;AACDI,MAAAA,IAAI,GAAG,CAACN,GAAG,CAAC,CAAD,CAAH,GAAS1C,MAAM,CAAC,CAAD,CAAhB,IAAuB4C,OAA9B;AACAG,MAAAA,IAAI,GAAG,CAACJ,GAAG,CAAC,CAAD,CAAH,GAAS3C,MAAM,CAAC,CAAD,CAAhB,IAAuB4C,OAA9B;AACH;;AACD,QAAIC,OAAO,IAAI,CAAf,EAAkB;AACdI,MAAAA,KAAK,GAAG,CAACP,GAAG,CAAC,CAAD,CAAH,GAAS1C,MAAM,CAAC,CAAD,CAAhB,IAAuB6C,OAA/B;AACAK,MAAAA,KAAK,GAAG,CAACP,GAAG,CAAC,CAAD,CAAH,GAAS3C,MAAM,CAAC,CAAD,CAAhB,IAAuB6C,OAA/B;AACH,KAHD,MAIK;AACDK,MAAAA,KAAK,GAAG,CAACR,GAAG,CAAC,CAAD,CAAH,GAAS1C,MAAM,CAAC,CAAD,CAAhB,IAAuB6C,OAA/B;AACAI,MAAAA,KAAK,GAAG,CAACN,GAAG,CAAC,CAAD,CAAH,GAAS3C,MAAM,CAAC,CAAD,CAAhB,IAAuB6C,OAA/B;AACH;;AAED,QAAKE,IAAI,GAAGG,KAAR,IAAmBD,KAAK,GAAGD,IAA/B,EAAsC;AAClC,aAAO,IAAP;AACH;;AAED,QAAIC,KAAK,GAAGF,IAAR,IAAgBA,IAAI,KAAKA,IAA7B,EAAmC;AAC/BA,MAAAA,IAAI,GAAGE,KAAP;AACH;;AACD,QAAIC,KAAK,GAAGF,IAAR,IAAgBA,IAAI,KAAKA,IAA7B,EAAmC;AAC/BA,MAAAA,IAAI,GAAGE,KAAP;AACH;;AAED,QAAIJ,OAAO,IAAI,CAAf,EAAkB;AACdK,MAAAA,KAAK,GAAG,CAACT,GAAG,CAAC,CAAD,CAAH,GAAS1C,MAAM,CAAC,CAAD,CAAhB,IAAuB8C,OAA/B;AACAM,MAAAA,KAAK,GAAG,CAACT,GAAG,CAAC,CAAD,CAAH,GAAS3C,MAAM,CAAC,CAAD,CAAhB,IAAuB8C,OAA/B;AACH,KAHD,MAIK;AACDM,MAAAA,KAAK,GAAG,CAACV,GAAG,CAAC,CAAD,CAAH,GAAS1C,MAAM,CAAC,CAAD,CAAhB,IAAuB8C,OAA/B;AACAK,MAAAA,KAAK,GAAG,CAACR,GAAG,CAAC,CAAD,CAAH,GAAS3C,MAAM,CAAC,CAAD,CAAhB,IAAuB8C,OAA/B;AACH;;AAED,QAAKC,IAAI,GAAGK,KAAR,IAAmBD,KAAK,GAAGH,IAA/B,EAAsC;AAClC,aAAO,IAAP;AACH;;AAED,QAAIG,KAAK,GAAGJ,IAAR,IAAgBA,IAAI,KAAKA,IAA7B,EAAmC;AAC/BA,MAAAA,IAAI,GAAGI,KAAP;AACH;;AACD,QAAIC,KAAK,GAAGJ,IAAR,IAAgBA,IAAI,KAAKA,IAA7B,EAAmC;AAC/BA,MAAAA,IAAI,GAAGI,KAAP;AACH;;AACD,QAAIJ,IAAI,GAAG,CAAX,EAAc;AACV,aAAO,IAAP;AACH;;AAED,QAAIhC,CAAC,GAAG+B,IAAI,IAAI,CAAR,GAAYA,IAAZ,GAAmBC,IAA3B;;AAEA,QAAI,CAAC1C,GAAL,EAAU;AACNA,MAAAA,GAAG,GAAG,IAAIV,OAAJ,EAAN;AACH;;AACDC,IAAAA,IAAI,CAACoB,WAAL,CAAiBX,GAAG,CAACG,KAArB,EAA4BT,MAA5B,EAAoCyC,GAApC,EAAyCzB,CAAzC;AACA,WAAOV,GAAP;AACH,GA1LW;AA4LZ;;AACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACI+C,EAAAA,iBAAiB,EAAG,YAAY;AAE5B,QAAIC,GAAG,GAAGzD,IAAI,CAACyB,MAAL,EAAV;AACA,QAAIiC,GAAG,GAAG1D,IAAI,CAACyB,MAAL,EAAV;AACA,QAAIkC,EAAE,GAAG3D,IAAI,CAACyB,MAAL,EAAT;AACA,QAAImC,MAAM,GAAG5D,IAAI,CAACyB,MAAL,EAAb;AAEA,WAAO,UAAUc,CAAV,EAAaX,CAAb,EAAgBiC,CAAhB,EAAmBC,WAAnB,EAAgCrD,GAAhC,EAAqCsD,YAArC,EAAmD;AACtD,UAAInB,GAAG,GAAG,KAAKxC,SAAL,CAAeQ,KAAzB;AACA,UAAIT,MAAM,GAAG,KAAKA,MAAL,CAAYS,KAAzB;AACA2B,MAAAA,CAAC,GAAGA,CAAC,CAAC3B,KAAN;AACAgB,MAAAA,CAAC,GAAGA,CAAC,CAAChB,KAAN;AACAiD,MAAAA,CAAC,GAAGA,CAAC,CAACjD,KAAN;AAEAZ,MAAAA,IAAI,CAAC2B,GAAL,CAAS8B,GAAT,EAAc7B,CAAd,EAAiBW,CAAjB;AACAvC,MAAAA,IAAI,CAAC2B,GAAL,CAAS+B,GAAT,EAAcG,CAAd,EAAiBtB,CAAjB;AAEAvC,MAAAA,IAAI,CAACgE,KAAL,CAAWJ,MAAX,EAAmBF,GAAnB,EAAwBd,GAAxB;AAEA,UAAIqB,GAAG,GAAGjE,IAAI,CAACkB,GAAL,CAASuC,GAAT,EAAcG,MAAd,CAAV;;AAEA,UAAIE,WAAJ,EAAiB;AACb,YAAIG,GAAG,GAAG,CAAChE,OAAX,EAAoB;AAChB,iBAAO,IAAP;AACH;AACJ,OAJD,MAKK;AACD,YAAIgE,GAAG,GAAG,CAAChE,OAAP,IAAkBgE,GAAG,GAAGhE,OAA5B,EAAqC;AACjC,iBAAO,IAAP;AACH;AACJ;;AAEDD,MAAAA,IAAI,CAAC2B,GAAL,CAASgC,EAAT,EAAaxD,MAAb,EAAqBoC,CAArB;AACA,UAAI2B,CAAC,GAAGlE,IAAI,CAACkB,GAAL,CAAS0C,MAAT,EAAiBD,EAAjB,IAAuBM,GAA/B;;AACA,UAAIC,CAAC,GAAG,CAAJ,IAASA,CAAC,GAAG,CAAjB,EAAoB;AAChB,eAAO,IAAP;AACH;;AAEDlE,MAAAA,IAAI,CAACgE,KAAL,CAAWJ,MAAX,EAAmBH,GAAnB,EAAwBE,EAAxB;AACA,UAAInC,CAAC,GAAGxB,IAAI,CAACkB,GAAL,CAAS0B,GAAT,EAAcgB,MAAd,IAAwBK,GAAhC;;AAEA,UAAIzC,CAAC,GAAG,CAAJ,IAASA,CAAC,GAAG,CAAb,IAAmB0C,CAAC,GAAG1C,CAAJ,GAAQ,CAA/B,EAAmC;AAC/B,eAAO,IAAP;AACH;;AAEDxB,MAAAA,IAAI,CAACgE,KAAL,CAAWJ,MAAX,EAAmBH,GAAnB,EAAwBC,GAAxB;AACA,UAAIvC,CAAC,GAAG,CAACnB,IAAI,CAACkB,GAAL,CAASyC,EAAT,EAAaC,MAAb,CAAD,GAAwBK,GAAhC;;AAEA,UAAI9C,CAAC,GAAG,CAAR,EAAW;AACP,eAAO,IAAP;AACH;;AAED,UAAI,CAACV,GAAL,EAAU;AACNA,QAAAA,GAAG,GAAG,IAAIV,OAAJ,EAAN;AACH;;AACD,UAAIgE,YAAJ,EAAkB;AACdhE,QAAAA,OAAO,CAACoE,GAAR,CAAYJ,YAAZ,EAA2B,IAAIG,CAAJ,GAAQ1C,CAAnC,EAAuC0C,CAAvC,EAA0C1C,CAA1C;AACH;;AACDxB,MAAAA,IAAI,CAACoB,WAAL,CAAiBX,GAAG,CAACG,KAArB,EAA4BT,MAA5B,EAAoCyC,GAApC,EAAyCzB,CAAzC;AAEA,aAAOV,GAAP;AACH,KAtDD;AAuDH,GA9DkB,EAvMP;;AAuQZ;AACJ;AACA;AACA;AACI2D,EAAAA,cAAc,EAAE,UAAUC,MAAV,EAAkB;AAC9BtE,IAAAA,OAAO,CAACuE,GAAR,CAAY,KAAKlE,SAAjB,EAA4B,KAAKA,SAAjC,EAA4C,KAAKD,MAAjD;AACAJ,IAAAA,OAAO,CAACwE,aAAR,CAAsB,KAAKpE,MAA3B,EAAmC,KAAKA,MAAxC,EAAgDkE,MAAhD;AACAtE,IAAAA,OAAO,CAACwE,aAAR,CAAsB,KAAKnE,SAA3B,EAAsC,KAAKA,SAA3C,EAAsDiE,MAAtD;AAEAtE,IAAAA,OAAO,CAAC4B,GAAR,CAAY,KAAKvB,SAAjB,EAA4B,KAAKA,SAAjC,EAA4C,KAAKD,MAAjD;AACAJ,IAAAA,OAAO,CAACyE,SAAR,CAAkB,KAAKpE,SAAvB,EAAkC,KAAKA,SAAvC;AACH,GAlRW;;AAoRZ;AACJ;AACA;AACA;AACIqE,EAAAA,IAAI,EAAE,UAAUC,GAAV,EAAe;AACjB3E,IAAAA,OAAO,CAAC0E,IAAR,CAAa,KAAKtE,MAAlB,EAA0BuE,GAAG,CAACvE,MAA9B;AACAJ,IAAAA,OAAO,CAAC0E,IAAR,CAAa,KAAKrE,SAAlB,EAA6BsE,GAAG,CAACtE,SAAjC;AACH,GA3RW;;AA6RZ;AACJ;AACA;AACA;AACIuE,EAAAA,KAAK,EAAE,YAAY;AACf,QAAID,GAAG,GAAG,IAAIxE,GAAJ,EAAV;AACAwE,IAAAA,GAAG,CAACD,IAAJ,CAAS,IAAT;AACA,WAAOC,GAAP;AACH;AArSW,CAAhB;AAwSA,eAAexE,GAAf","sourcesContent":["import Vector3 from './Vector3';\nimport vec3 from '../glmatrix/vec3';\n\nvar EPSILON = 1e-5;\n\n/**\n * @constructor\n * @alias clay.Ray\n * @param {clay.Vector3} [origin]\n * @param {clay.Vector3} [direction]\n */\nvar Ray = function (origin, direction) {\n    /**\n     * @type {clay.Vector3}\n     */\n    this.origin = origin || new Vector3();\n    /**\n     * @type {clay.Vector3}\n     */\n    this.direction = direction || new Vector3();\n};\n\nRay.prototype = {\n\n    constructor: Ray,\n\n    // http://www.siggraph.org/education/materials/HyperGraph/raytrace/rayplane_intersection.htm\n    /**\n     * Calculate intersection point between ray and a give plane\n     * @param  {clay.Plane} plane\n     * @param  {clay.Vector3} [out]\n     * @return {clay.Vector3}\n     */\n    intersectPlane: function (plane, out) {\n        var pn = plane.normal.array;\n        var d = plane.distance;\n        var ro = this.origin.array;\n        var rd = this.direction.array;\n\n        var divider = vec3.dot(pn, rd);\n        // ray is parallel to the plane\n        if (divider === 0) {\n            return null;\n        }\n        if (!out) {\n            out = new Vector3();\n        }\n        var t = (vec3.dot(pn, ro) - d) / divider;\n        vec3.scaleAndAdd(out.array, ro, rd, -t);\n        out._dirty = true;\n        return out;\n    },\n\n    /**\n     * Mirror the ray against plane\n     * @param  {clay.Plane} plane\n     */\n    mirrorAgainstPlane: function (plane) {\n        // Distance to plane\n        var d = vec3.dot(plane.normal.array, this.direction.array);\n        vec3.scaleAndAdd(this.direction.array, this.direction.array, plane.normal.array, -d * 2);\n        this.direction._dirty = true;\n    },\n\n    distanceToPoint: (function () {\n        var v = vec3.create();\n        return function (point) {\n            vec3.sub(v, point, this.origin.array);\n            // Distance from projection point to origin\n            var b = vec3.dot(v, this.direction.array);\n            if (b < 0) {\n                return vec3.distance(this.origin.array, point);\n            }\n            // Squared distance from center to origin\n            var c2 = vec3.lenSquared(v);\n            // Squared distance from center to projection point\n            return Math.sqrt(c2 - b * b);\n        };\n    })(),\n\n    /**\n     * Calculate intersection point between ray and sphere\n     * @param  {clay.Vector3} center\n     * @param  {number} radius\n     * @param  {clay.Vector3} out\n     * @return {clay.Vector3}\n     */\n    intersectSphere: (function () {\n        var v = vec3.create();\n        return function (center, radius, out) {\n            var origin = this.origin.array;\n            var direction = this.direction.array;\n            center = center.array;\n            vec3.sub(v, center, origin);\n            // Distance from projection point to origin\n            var b = vec3.dot(v, direction);\n            // Squared distance from center to origin\n            var c2 = vec3.squaredLength(v);\n            // Squared distance from center to projection point\n            var d2 = c2 - b * b;\n\n            var r2 = radius * radius;\n            // No intersection\n            if (d2 > r2) {\n                return;\n            }\n\n            var a = Math.sqrt(r2 - d2);\n            // First intersect point\n            var t0 = b - a;\n            // Second intersect point\n            var t1 = b + a;\n\n            if (!out) {\n                out = new Vector3();\n            }\n            if (t0 < 0) {\n                if (t1 < 0) {\n                    return null;\n                }\n                else {\n                    vec3.scaleAndAdd(out.array, origin, direction, t1);\n                    return out;\n                }\n            }\n            else {\n                vec3.scaleAndAdd(out.array, origin, direction, t0);\n                return out;\n            }\n        };\n    })(),\n\n    // http://www.scratchapixel.com/lessons/3d-basic-lessons/lesson-7-intersecting-simple-shapes/ray-box-intersection/\n    /**\n     * Calculate intersection point between ray and bounding box\n     * @param {clay.BoundingBox} bbox\n     * @param {clay.Vector3}\n     * @return {clay.Vector3}\n     */\n    intersectBoundingBox: function (bbox, out) {\n        var dir = this.direction.array;\n        var origin = this.origin.array;\n        var min = bbox.min.array;\n        var max = bbox.max.array;\n\n        var invdirx = 1 / dir[0];\n        var invdiry = 1 / dir[1];\n        var invdirz = 1 / dir[2];\n\n        var tmin, tmax, tymin, tymax, tzmin, tzmax;\n        if (invdirx >= 0) {\n            tmin = (min[0] - origin[0]) * invdirx;\n            tmax = (max[0] - origin[0]) * invdirx;\n        }\n        else {\n            tmax = (min[0] - origin[0]) * invdirx;\n            tmin = (max[0] - origin[0]) * invdirx;\n        }\n        if (invdiry >= 0) {\n            tymin = (min[1] - origin[1]) * invdiry;\n            tymax = (max[1] - origin[1]) * invdiry;\n        }\n        else {\n            tymax = (min[1] - origin[1]) * invdiry;\n            tymin = (max[1] - origin[1]) * invdiry;\n        }\n\n        if ((tmin > tymax) || (tymin > tmax)) {\n            return null;\n        }\n\n        if (tymin > tmin || tmin !== tmin) {\n            tmin = tymin;\n        }\n        if (tymax < tmax || tmax !== tmax) {\n            tmax = tymax;\n        }\n\n        if (invdirz >= 0) {\n            tzmin = (min[2] - origin[2]) * invdirz;\n            tzmax = (max[2] - origin[2]) * invdirz;\n        }\n        else {\n            tzmax = (min[2] - origin[2]) * invdirz;\n            tzmin = (max[2] - origin[2]) * invdirz;\n        }\n\n        if ((tmin > tzmax) || (tzmin > tmax)) {\n            return null;\n        }\n\n        if (tzmin > tmin || tmin !== tmin) {\n            tmin = tzmin;\n        }\n        if (tzmax < tmax || tmax !== tmax) {\n            tmax = tzmax;\n        }\n        if (tmax < 0) {\n            return null;\n        }\n\n        var t = tmin >= 0 ? tmin : tmax;\n\n        if (!out) {\n            out = new Vector3();\n        }\n        vec3.scaleAndAdd(out.array, origin, dir, t);\n        return out;\n    },\n\n    // http://en.wikipedia.org/wiki/M%C3%B6ller%E2%80%93Trumbore_intersection_algorithm\n    /**\n     * Calculate intersection point between ray and three triangle vertices\n     * @param {clay.Vector3} a\n     * @param {clay.Vector3} b\n     * @param {clay.Vector3} c\n     * @param {boolean}           singleSided, CW triangle will be ignored\n     * @param {clay.Vector3} [out]\n     * @param {clay.Vector3} [barycenteric] barycentric coords\n     * @return {clay.Vector3}\n     */\n    intersectTriangle: (function () {\n\n        var eBA = vec3.create();\n        var eCA = vec3.create();\n        var AO = vec3.create();\n        var vCross = vec3.create();\n\n        return function (a, b, c, singleSided, out, barycenteric) {\n            var dir = this.direction.array;\n            var origin = this.origin.array;\n            a = a.array;\n            b = b.array;\n            c = c.array;\n\n            vec3.sub(eBA, b, a);\n            vec3.sub(eCA, c, a);\n\n            vec3.cross(vCross, eCA, dir);\n\n            var det = vec3.dot(eBA, vCross);\n\n            if (singleSided) {\n                if (det > -EPSILON) {\n                    return null;\n                }\n            }\n            else {\n                if (det > -EPSILON && det < EPSILON) {\n                    return null;\n                }\n            }\n\n            vec3.sub(AO, origin, a);\n            var u = vec3.dot(vCross, AO) / det;\n            if (u < 0 || u > 1) {\n                return null;\n            }\n\n            vec3.cross(vCross, eBA, AO);\n            var v = vec3.dot(dir, vCross) / det;\n\n            if (v < 0 || v > 1 || (u + v > 1)) {\n                return null;\n            }\n\n            vec3.cross(vCross, eBA, eCA);\n            var t = -vec3.dot(AO, vCross) / det;\n\n            if (t < 0) {\n                return null;\n            }\n\n            if (!out) {\n                out = new Vector3();\n            }\n            if (barycenteric) {\n                Vector3.set(barycenteric, (1 - u - v), u, v);\n            }\n            vec3.scaleAndAdd(out.array, origin, dir, t);\n\n            return out;\n        };\n    })(),\n\n    /**\n     * Apply an affine transform matrix to the ray\n     * @return {clay.Matrix4} matrix\n     */\n    applyTransform: function (matrix) {\n        Vector3.add(this.direction, this.direction, this.origin);\n        Vector3.transformMat4(this.origin, this.origin, matrix);\n        Vector3.transformMat4(this.direction, this.direction, matrix);\n\n        Vector3.sub(this.direction, this.direction, this.origin);\n        Vector3.normalize(this.direction, this.direction);\n    },\n\n    /**\n     * Copy values from another ray\n     * @param {clay.Ray} ray\n     */\n    copy: function (ray) {\n        Vector3.copy(this.origin, ray.origin);\n        Vector3.copy(this.direction, ray.direction);\n    },\n\n    /**\n     * Clone a new ray\n     * @return {clay.Ray}\n     */\n    clone: function () {\n        var ray = new Ray();\n        ray.copy(this);\n        return ray;\n    }\n};\n\nexport default Ray;\n"]},"metadata":{},"sourceType":"module"}