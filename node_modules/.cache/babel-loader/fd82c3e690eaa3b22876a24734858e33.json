{"ast":null,"code":"'use strict';\n\nvar _typeof2 = require(\"C:/Users/Administrator/Desktop/data_view/my_project/vue2_app/myapp/node_modules/@babel/runtime/helpers/typeof.js\").default;\n\nrequire(\"core-js/modules/es.symbol.js\");\n\nrequire(\"core-js/modules/es.symbol.description.js\");\n\nrequire(\"core-js/modules/es.object.to-string.js\");\n\nrequire(\"core-js/modules/es.symbol.iterator.js\");\n\nrequire(\"core-js/modules/es.string.iterator.js\");\n\nrequire(\"core-js/modules/web.dom-collections.iterator.js\");\n\nrequire(\"core-js/modules/es.error.cause.js\");\n\nrequire(\"core-js/modules/es.array.map.js\");\n\nrequire(\"core-js/modules/es.regexp.to-string.js\");\n\nrequire(\"core-js/modules/es.function.name.js\");\n\nrequire(\"core-js/modules/es.regexp.exec.js\");\n\nrequire(\"core-js/modules/es.string.split.js\");\n\nexports.__esModule = true;\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _typeof = typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\" ? function (obj) {\n  return _typeof2(obj);\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : _typeof2(obj);\n};\n\nvar _mapGenerator = require('./map-generator');\n\nvar _mapGenerator2 = _interopRequireDefault(_mapGenerator);\n\nvar _stringify2 = require('./stringify');\n\nvar _stringify3 = _interopRequireDefault(_stringify2);\n\nvar _warnOnce = require('./warn-once');\n\nvar _warnOnce2 = _interopRequireDefault(_warnOnce);\n\nvar _result = require('./result');\n\nvar _result2 = _interopRequireDefault(_result);\n\nvar _parse = require('./parse');\n\nvar _parse2 = _interopRequireDefault(_parse);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction isPromise(obj) {\n  return (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' && typeof obj.then === 'function';\n}\n/**\n * A Promise proxy for the result of PostCSS transformations.\n *\n * A `LazyResult` instance is returned by {@link Processor#process}.\n *\n * @example\n * const lazy = postcss([cssnext]).process(css);\n */\n\n\nvar LazyResult = function () {\n  function LazyResult(processor, css, opts) {\n    _classCallCheck(this, LazyResult);\n\n    this.stringified = false;\n    this.processed = false;\n    var root = void 0;\n\n    if ((typeof css === 'undefined' ? 'undefined' : _typeof(css)) === 'object' && css.type === 'root') {\n      root = css;\n    } else if (css instanceof LazyResult || css instanceof _result2.default) {\n      root = css.root;\n\n      if (css.map) {\n        if (typeof opts.map === 'undefined') opts.map = {};\n        if (!opts.map.inline) opts.map.inline = false;\n        opts.map.prev = css.map;\n      }\n    } else {\n      var parser = _parse2.default;\n      if (opts.syntax) parser = opts.syntax.parse;\n      if (opts.parser) parser = opts.parser;\n      if (parser.parse) parser = parser.parse;\n\n      try {\n        root = parser(css, opts);\n      } catch (error) {\n        this.error = error;\n      }\n    }\n\n    this.result = new _result2.default(processor, root, opts);\n  }\n  /**\n   * Returns a {@link Processor} instance, which will be used\n   * for CSS transformations.\n   * @type {Processor}\n   */\n\n  /**\n   * Processes input CSS through synchronous plugins\n   * and calls {@link Result#warnings()}.\n   *\n   * @return {Warning[]} warnings from plugins\n   */\n\n\n  LazyResult.prototype.warnings = function warnings() {\n    return this.sync().warnings();\n  };\n  /**\n   * Alias for the {@link LazyResult#css} property.\n   *\n   * @example\n   * lazy + '' === lazy.css;\n   *\n   * @return {string} output CSS\n   */\n\n\n  LazyResult.prototype.toString = function toString() {\n    return this.css;\n  };\n  /**\n   * Processes input CSS through synchronous and asynchronous plugins\n   * and calls `onFulfilled` with a Result instance. If a plugin throws\n   * an error, the `onRejected` callback will be executed.\n   *\n   * It implements standard Promise API.\n   *\n   * @param {onFulfilled} onFulfilled - callback will be executed\n   *                                    when all plugins will finish work\n   * @param {onRejected}  onRejected  - callback will be executed on any error\n   *\n   * @return {Promise} Promise API to make queue\n   *\n   * @example\n   * postcss([cssnext]).process(css).then(result => {\n   *   console.log(result.css);\n   * });\n   */\n\n\n  LazyResult.prototype.then = function then(onFulfilled, onRejected) {\n    return this.async().then(onFulfilled, onRejected);\n  };\n  /**\n   * Processes input CSS through synchronous and asynchronous plugins\n   * and calls onRejected for each error thrown in any plugin.\n   *\n   * It implements standard Promise API.\n   *\n   * @param {onRejected} onRejected - callback will be executed on any error\n   *\n   * @return {Promise} Promise API to make queue\n   *\n   * @example\n   * postcss([cssnext]).process(css).then(result => {\n   *   console.log(result.css);\n   * }).catch(error => {\n   *   console.error(error);\n   * });\n   */\n\n\n  LazyResult.prototype.catch = function _catch(onRejected) {\n    return this.async().catch(onRejected);\n  };\n\n  LazyResult.prototype.handleError = function handleError(error, plugin) {\n    try {\n      this.error = error;\n\n      if (error.name === 'CssSyntaxError' && !error.plugin) {\n        error.plugin = plugin.postcssPlugin;\n        error.setMessage();\n      } else if (plugin.postcssVersion) {\n        var pluginName = plugin.postcssPlugin;\n        var pluginVer = plugin.postcssVersion;\n        var runtimeVer = this.result.processor.version;\n        var a = pluginVer.split('.');\n        var b = runtimeVer.split('.');\n\n        if (a[0] !== b[0] || parseInt(a[1]) > parseInt(b[1])) {\n          (0, _warnOnce2.default)('Your current PostCSS version ' + 'is ' + runtimeVer + ', but ' + pluginName + ' ' + 'uses ' + pluginVer + '. Perhaps this is ' + 'the source of the error below.');\n        }\n      }\n    } catch (err) {\n      if (console && console.error) console.error(err);\n    }\n  };\n\n  LazyResult.prototype.asyncTick = function asyncTick(resolve, reject) {\n    var _this = this;\n\n    if (this.plugin >= this.processor.plugins.length) {\n      this.processed = true;\n      return resolve();\n    }\n\n    try {\n      var plugin = this.processor.plugins[this.plugin];\n      var promise = this.run(plugin);\n      this.plugin += 1;\n\n      if (isPromise(promise)) {\n        promise.then(function () {\n          _this.asyncTick(resolve, reject);\n        }).catch(function (error) {\n          _this.handleError(error, plugin);\n\n          _this.processed = true;\n          reject(error);\n        });\n      } else {\n        this.asyncTick(resolve, reject);\n      }\n    } catch (error) {\n      this.processed = true;\n      reject(error);\n    }\n  };\n\n  LazyResult.prototype.async = function async() {\n    var _this2 = this;\n\n    if (this.processed) {\n      return new Promise(function (resolve, reject) {\n        if (_this2.error) {\n          reject(_this2.error);\n        } else {\n          resolve(_this2.stringify());\n        }\n      });\n    }\n\n    if (this.processing) {\n      return this.processing;\n    }\n\n    this.processing = new Promise(function (resolve, reject) {\n      if (_this2.error) return reject(_this2.error);\n      _this2.plugin = 0;\n\n      _this2.asyncTick(resolve, reject);\n    }).then(function () {\n      _this2.processed = true;\n      return _this2.stringify();\n    });\n    return this.processing;\n  };\n\n  LazyResult.prototype.sync = function sync() {\n    if (this.processed) return this.result;\n    this.processed = true;\n\n    if (this.processing) {\n      throw new Error('Use process(css).then(cb) to work with async plugins');\n    }\n\n    if (this.error) throw this.error;\n\n    for (var _iterator = this.result.processor.plugins, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var plugin = _ref;\n      var promise = this.run(plugin);\n\n      if (isPromise(promise)) {\n        throw new Error('Use process(css).then(cb) to work with async plugins');\n      }\n    }\n\n    return this.result;\n  };\n\n  LazyResult.prototype.run = function run(plugin) {\n    this.result.lastPlugin = plugin;\n\n    try {\n      return plugin(this.result.root, this.result);\n    } catch (error) {\n      this.handleError(error, plugin);\n      throw error;\n    }\n  };\n\n  LazyResult.prototype.stringify = function stringify() {\n    if (this.stringified) return this.result;\n    this.stringified = true;\n    this.sync();\n    var opts = this.result.opts;\n    var str = _stringify3.default;\n    if (opts.syntax) str = opts.syntax.stringify;\n    if (opts.stringifier) str = opts.stringifier;\n    if (str.stringify) str = str.stringify;\n    var map = new _mapGenerator2.default(str, this.result.root, this.result.opts);\n    var data = map.generate();\n    this.result.css = data[0];\n    this.result.map = data[1];\n    return this.result;\n  };\n\n  _createClass(LazyResult, [{\n    key: 'processor',\n    get: function get() {\n      return this.result.processor;\n    }\n    /**\n     * Options from the {@link Processor#process} call.\n     * @type {processOptions}\n     */\n\n  }, {\n    key: 'opts',\n    get: function get() {\n      return this.result.opts;\n    }\n    /**\n     * Processes input CSS through synchronous plugins, converts `Root`\n     * to a CSS string and returns {@link Result#css}.\n     *\n     * This property will only work with synchronous plugins.\n     * If the processor contains any asynchronous plugins\n     * it will throw an error. This is why this method is only\n     * for debug purpose, you should always use {@link LazyResult#then}.\n     *\n     * @type {string}\n     * @see Result#css\n     */\n\n  }, {\n    key: 'css',\n    get: function get() {\n      return this.stringify().css;\n    }\n    /**\n     * An alias for the `css` property. Use it with syntaxes\n     * that generate non-CSS output.\n     *\n     * This property will only work with synchronous plugins.\n     * If the processor contains any asynchronous plugins\n     * it will throw an error. This is why this method is only\n     * for debug purpose, you should always use {@link LazyResult#then}.\n     *\n     * @type {string}\n     * @see Result#content\n     */\n\n  }, {\n    key: 'content',\n    get: function get() {\n      return this.stringify().content;\n    }\n    /**\n     * Processes input CSS through synchronous plugins\n     * and returns {@link Result#map}.\n     *\n     * This property will only work with synchronous plugins.\n     * If the processor contains any asynchronous plugins\n     * it will throw an error. This is why this method is only\n     * for debug purpose, you should always use {@link LazyResult#then}.\n     *\n     * @type {SourceMapGenerator}\n     * @see Result#map\n     */\n\n  }, {\n    key: 'map',\n    get: function get() {\n      return this.stringify().map;\n    }\n    /**\n     * Processes input CSS through synchronous plugins\n     * and returns {@link Result#root}.\n     *\n     * This property will only work with synchronous plugins. If the processor\n     * contains any asynchronous plugins it will throw an error.\n     *\n     * This is why this method is only for debug purpose,\n     * you should always use {@link LazyResult#then}.\n     *\n     * @type {Root}\n     * @see Result#root\n     */\n\n  }, {\n    key: 'root',\n    get: function get() {\n      return this.sync().root;\n    }\n    /**\n     * Processes input CSS through synchronous plugins\n     * and returns {@link Result#messages}.\n     *\n     * This property will only work with synchronous plugins. If the processor\n     * contains any asynchronous plugins it will throw an error.\n     *\n     * This is why this method is only for debug purpose,\n     * you should always use {@link LazyResult#then}.\n     *\n     * @type {Message[]}\n     * @see Result#messages\n     */\n\n  }, {\n    key: 'messages',\n    get: function get() {\n      return this.sync().messages;\n    }\n  }]);\n\n  return LazyResult;\n}();\n\nexports.default = LazyResult;\n/**\n * @callback onFulfilled\n * @param {Result} result\n */\n\n/**\n * @callback onRejected\n * @param {Error} error\n */\n\nmodule.exports = exports['default'];","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;;;;;;;;;;;;;AAEA,SAASA,SAAT,CAAmBC,GAAnB,EAAwB;AACpB,SAAO,QAAOA,GAAP,yCAAOA,GAAP,OAAe,QAAf,IAA2B,OAAOA,IAAIC,IAAX,KAAoB,UAAtD;AACH;AAED;;;;;;;;;;IAQMC,U;AAEF,sBAAYC,SAAZ,EAAuBC,GAAvB,EAA4BC,IAA5B,EAAkC;AAAAC;;AAC9B,SAAKC,WAAL,GAAmB,KAAnB;AACA,SAAKC,SAAL,GAAmB,KAAnB;AAEA,QAAIC,aAAJ;;AACA,QAAK,QAAOL,GAAP,yCAAOA,GAAP,OAAe,QAAf,IAA2BA,IAAIM,IAAJN,KAAa,MAA7C,EAAsD;AAClDK,aAAOL,GAAPK;AADJ,WAEO,IAAKL,eAAeF,UAAfE,IAA6BA,+BAAlC,EAA0D;AAC7DK,aAAOL,IAAIK,IAAXA;;AACA,UAAKL,IAAIO,GAAT,EAAe;AACX,YAAK,OAAON,KAAKM,GAAZ,KAAoB,WAAzB,EAAuCN,KAAKM,GAALN,GAAW,EAAXA;AACvC,YAAK,CAACA,KAAKM,GAALN,CAASO,MAAf,EAAwBP,KAAKM,GAALN,CAASO,MAATP,GAAkB,KAAlBA;AACxBA,aAAKM,GAALN,CAASQ,IAATR,GAAgBD,IAAIO,GAApBN;AACH;AANE,WAOA;AACH,UAAIS,wBAAJ;AACA,UAAKT,KAAKU,MAAV,EAAoBD,SAAST,KAAKU,MAALV,CAAYW,KAArBF;AACpB,UAAKT,KAAKS,MAAV,EAAoBA,SAAST,KAAKS,MAAdA;AACpB,UAAKA,OAAOE,KAAZ,EAAoBF,SAASA,OAAOE,KAAhBF;;AAEpB,UAAI;AACAL,eAAOK,OAAOV,GAAPU,EAAYT,IAAZS,CAAPL;AADJ,QAEE,OAAOQ,KAAP,EAAc;AACZ,aAAKA,KAAL,GAAaA,KAAb;AACH;AACJ;;AAED,SAAKC,MAAL,GAAc,qBAAWf,SAAX,EAAsBM,IAAtB,EAA4BJ,IAA5B,CAAd;AACH;AAED;;;;;;AAmGA;;;;;;;;uBAMAc,W,oBAAW;AACP,WAAO,KAAKC,IAAL,GAAYD,QAAZ,EAAP;;AAGJ;;;;;;;;;;uBAQAE,W,oBAAW;AACP,WAAO,KAAKjB,GAAZ;;AAGJ;;;;;;;;;;;;;;;;;;;;uBAkBAH,O,cAAKqB,W,EAAaC,U,EAAY;AAC1B,WAAO,KAAKC,KAAL,GAAavB,IAAb,CAAkBqB,WAAlB,EAA+BC,UAA/B,CAAP;;AAGJ;;;;;;;;;;;;;;;;;;;uBAiBAE,Q,gBAAMF,U,EAAY;AACd,WAAO,KAAKC,KAAL,GAAaC,KAAb,CAAmBF,UAAnB,CAAP;;;uBAGJG,c,qBAAYT,K,EAAOU,M,EAAQ;AACvB,QAAI;AACA,WAAKV,KAAL,GAAaA,KAAb;;AACA,UAAKA,MAAMW,IAANX,KAAe,gBAAfA,IAAmC,CAACA,MAAMU,MAA/C,EAAwD;AACpDV,cAAMU,MAANV,GAAeU,OAAOE,aAAtBZ;AACAA,cAAMa,UAANb;AAFJ,aAGO,IAAKU,OAAOI,cAAZ,EAA6B;AAChC,YAAIC,aAAaL,OAAOE,aAAxB;AACA,YAAII,YAAaN,OAAOI,cAAxB;AACA,YAAIG,aAAa,KAAKhB,MAAL,CAAYf,SAAZ,CAAsBgC,OAAvC;AACA,YAAIC,IAAIH,UAAUI,KAAVJ,CAAgB,GAAhBA,CAAR;AACA,YAAIK,IAAIJ,WAAWG,KAAXH,CAAiB,GAAjBA,CAAR;;AAEA,YAAKE,EAAE,CAAFA,MAASE,EAAE,CAAFA,CAATF,IAAiBG,SAASH,EAAE,CAAFA,CAATG,IAAiBA,SAASD,EAAE,CAAFA,CAATC,CAAvC,EAAwD;AACpD,kCAAS,kCACA,KADA,GACQL,UADR,GACqB,QADrB,GACgCF,UADhC,GAC6C,GAD7C,GAEA,OAFA,GAEUC,SAFV,GAEsB,oBAFtB,GAGA,gCAHT;AAIH;AACJ;AAlBL,MAmBE,OAAOO,GAAP,EAAY;AACV,UAAKC,WAAWA,QAAQxB,KAAxB,EAAgCwB,QAAQxB,KAARwB,CAAcD,GAAdC;AACnC;;;uBAGLC,Y,mBAAUC,O,EAASC,M,EAAQ;AAAA;;AACvB,QAAK,KAAKjB,MAAL,IAAe,KAAKxB,SAAL,CAAe0C,OAAf,CAAuBC,MAA3C,EAAoD;AAChD,WAAKtC,SAAL,GAAiB,IAAjB;AACA,aAAOmC,SAAP;AACH;;AAED,QAAI;AACA,UAAIhB,SAAU,KAAKxB,SAAL,CAAe0C,OAAf,CAAuB,KAAKlB,MAA5B,CAAd;AACA,UAAIoB,UAAU,KAAKC,GAAL,CAASrB,MAAT,CAAd;AACA,WAAKA,MAAL,IAAe,CAAf;;AAEA,UAAK5B,UAAUgD,OAAVhD,CAAL,EAA0B;AACtBgD,gBAAQ9C,IAAR8C,CAAc,YAAM;AAChBE,gBAAKP,SAAL,CAAeC,OAAf,EAAwBC,MAAxB;AADJ,WAEGnB,KAFHsB,CAEU,iBAAS;AACfE,gBAAKvB,WAAL,CAAiBT,KAAjB,EAAwBU,MAAxB;;AACAsB,gBAAKzC,SAAL,GAAiB,IAAjB;AACAoC,iBAAO3B,KAAP2B;AALJ;AADJ,aAQO;AACH,aAAKF,SAAL,CAAeC,OAAf,EAAwBC,MAAxB;AACH;AAfL,MAiBE,OAAO3B,KAAP,EAAc;AACZ,WAAKT,SAAL,GAAiB,IAAjB;AACAoC,aAAO3B,KAAP2B;AACH;;;uBAGLpB,Q,iBAAQ;AAAA;;AACJ,QAAK,KAAKhB,SAAV,EAAsB;AAClB,aAAO,IAAI0C,OAAJ,CAAa,UAACP,OAAD,EAAUC,MAAV,EAAqB;AACrC,YAAKO,OAAKlC,KAAV,EAAkB;AACd2B,iBAAOO,OAAKlC,KAAZ2B;AADJ,eAEO;AACHD,kBAAQQ,OAAKC,SAAL,EAART;AACH;AALE,QAAP;AAOH;;AACD,QAAK,KAAKU,UAAV,EAAuB;AACnB,aAAO,KAAKA,UAAZ;AACH;;AAED,SAAKA,UAAL,GAAkB,IAAIH,OAAJ,CAAa,UAACP,OAAD,EAAUC,MAAV,EAAqB;AAChD,UAAKO,OAAKlC,KAAV,EAAkB,OAAO2B,OAAOO,OAAKlC,KAAZ2B,CAAP;AAClBO,aAAKxB,MAAL,GAAc,CAAd;;AACAwB,aAAKT,SAAL,CAAeC,OAAf,EAAwBC,MAAxB;AAHc,OAIf3C,IAJe,CAIT,YAAM;AACXkD,aAAK3C,SAAL,GAAiB,IAAjB;AACA,aAAO2C,OAAKC,SAAL,EAAP;AANc,MAAlB;AASA,WAAO,KAAKC,UAAZ;;;uBAGJjC,O,gBAAO;AACH,QAAK,KAAKZ,SAAV,EAAsB,OAAO,KAAKU,MAAZ;AACtB,SAAKV,SAAL,GAAiB,IAAjB;;AAEA,QAAK,KAAK6C,UAAV,EAAuB;AACnB,YAAM,IAAIC,KAAJ,CACF,sDADE,CAAN;AAEH;;AAED,QAAK,KAAKrC,KAAV,EAAkB,MAAM,KAAKA,KAAX;;AAElB,yBAAoB,KAAKC,MAAL,CAAYf,SAAZ,CAAsB0C,OAA1C,kHAAoD;AAAA;;AAAA;AAAA;AAAAU;AAAA;AAAAC;AAAA;AAAAD;AAAA;;AAAA,UAA1C5B,MAA0C;AAChD,UAAIoB,UAAU,KAAKC,GAAL,CAASrB,MAAT,CAAd;;AACA,UAAK5B,UAAUgD,OAAVhD,CAAL,EAA0B;AACtB,cAAM,IAAIuD,KAAJ,CACF,sDADE,CAAN;AAEH;AACJ;;AAED,WAAO,KAAKpC,MAAZ;;;uBAGJ8B,M,aAAIrB,M,EAAQ;AACR,SAAKT,MAAL,CAAYuC,UAAZ,GAAyB9B,MAAzB;;AAEA,QAAI;AACA,aAAOA,OAAO,KAAKT,MAAL,CAAYT,IAAnBkB,EAAyB,KAAKT,MAA9BS,CAAP;AADJ,MAEE,OAAOV,KAAP,EAAc;AACZ,WAAKS,WAAL,CAAiBT,KAAjB,EAAwBU,MAAxB;AACA,YAAMV,KAAN;AACH;;;uBAGLmC,Y,qBAAY;AACR,QAAK,KAAK7C,WAAV,EAAwB,OAAO,KAAKW,MAAZ;AACxB,SAAKX,WAAL,GAAmB,IAAnB;AAEA,SAAKa,IAAL;AAEA,QAAIf,OAAO,KAAKa,MAAL,CAAYb,IAAvB;AACA,QAAIqD,yBAAJ;AACA,QAAKrD,KAAKU,MAAV,EAAwB2C,MAAMrD,KAAKU,MAALV,CAAY+C,SAAlBM;AACxB,QAAKrD,KAAKsD,WAAV,EAAwBD,MAAMrD,KAAKsD,WAAXD;AACxB,QAAKA,IAAIN,SAAT,EAAwBM,MAAMA,IAAIN,SAAVM;AAExB,QAAI/C,MAAO,2BAAiB+C,GAAjB,EAAsB,KAAKxC,MAAL,CAAYT,IAAlC,EAAwC,KAAKS,MAAL,CAAYb,IAApD,CAAX;AACA,QAAIuD,OAAOjD,IAAIkD,QAAJlD,EAAX;AACA,SAAKO,MAAL,CAAYd,GAAZ,GAAkBwD,KAAK,CAALA,CAAlB;AACA,SAAK1C,MAAL,CAAYP,GAAZ,GAAkBiD,KAAK,CAALA,CAAlB;AAEA,WAAO,KAAK1C,MAAZ;;;;;wBAjSY;AACZ,aAAO,KAAKA,MAAL,CAAYf,SAAnB;AACH;AAED;;;;;;;wBAIW;AACP,aAAO,KAAKe,MAAL,CAAYb,IAAnB;AACH;AAED;;;;;;;;;;;;;;;wBAYU;AACN,aAAO,KAAK+C,SAAL,GAAiBhD,GAAxB;AACH;AAED;;;;;;;;;;;;;;;wBAYc;AACV,aAAO,KAAKgD,SAAL,GAAiBU,OAAxB;AACH;AAED;;;;;;;;;;;;;;;wBAYU;AACN,aAAO,KAAKV,SAAL,GAAiBzC,GAAxB;AACH;AAED;;;;;;;;;;;;;;;;wBAaW;AACP,aAAO,KAAKS,IAAL,GAAYX,IAAnB;AACH;AAED;;;;;;;;;;;;;;;;wBAae;AACX,aAAO,KAAKW,IAAL,GAAY2C,QAAnB;AACH;;;;;;kBA0MU7D;AAEf;;;;;AAKA","names":["isPromise","obj","then","LazyResult","processor","css","opts","_classCallCheck","stringified","processed","root","type","map","inline","prev","parser","syntax","parse","error","result","warnings","sync","toString","onFulfilled","onRejected","async","catch","handleError","plugin","name","postcssPlugin","setMessage","postcssVersion","pluginName","pluginVer","runtimeVer","version","a","split","b","parseInt","err","console","asyncTick","resolve","reject","plugins","length","promise","run","_this","Promise","_this2","stringify","processing","Error","_ref","_i","lastPlugin","str","stringifier","data","generate","content","messages"],"sources":["lazy-result.es6"],"sourcesContent":["import MapGenerator from './map-generator';\nimport stringify    from './stringify';\nimport warnOnce     from './warn-once';\nimport Result       from './result';\nimport parse        from './parse';\n\nfunction isPromise(obj) {\n    return typeof obj === 'object' && typeof obj.then === 'function';\n}\n\n/**\n * A Promise proxy for the result of PostCSS transformations.\n *\n * A `LazyResult` instance is returned by {@link Processor#process}.\n *\n * @example\n * const lazy = postcss([cssnext]).process(css);\n */\nclass LazyResult {\n\n    constructor(processor, css, opts) {\n        this.stringified = false;\n        this.processed   = false;\n\n        let root;\n        if ( typeof css === 'object' && css.type === 'root' ) {\n            root = css;\n        } else if ( css instanceof LazyResult || css instanceof Result ) {\n            root = css.root;\n            if ( css.map ) {\n                if ( typeof opts.map === 'undefined' ) opts.map = { };\n                if ( !opts.map.inline ) opts.map.inline = false;\n                opts.map.prev = css.map;\n            }\n        } else {\n            let parser = parse;\n            if ( opts.syntax )  parser = opts.syntax.parse;\n            if ( opts.parser )  parser = opts.parser;\n            if ( parser.parse ) parser = parser.parse;\n\n            try {\n                root = parser(css, opts);\n            } catch (error) {\n                this.error = error;\n            }\n        }\n\n        this.result = new Result(processor, root, opts);\n    }\n\n    /**\n     * Returns a {@link Processor} instance, which will be used\n     * for CSS transformations.\n     * @type {Processor}\n     */\n    get processor() {\n        return this.result.processor;\n    }\n\n    /**\n     * Options from the {@link Processor#process} call.\n     * @type {processOptions}\n     */\n    get opts() {\n        return this.result.opts;\n    }\n\n    /**\n     * Processes input CSS through synchronous plugins, converts `Root`\n     * to a CSS string and returns {@link Result#css}.\n     *\n     * This property will only work with synchronous plugins.\n     * If the processor contains any asynchronous plugins\n     * it will throw an error. This is why this method is only\n     * for debug purpose, you should always use {@link LazyResult#then}.\n     *\n     * @type {string}\n     * @see Result#css\n     */\n    get css() {\n        return this.stringify().css;\n    }\n\n    /**\n     * An alias for the `css` property. Use it with syntaxes\n     * that generate non-CSS output.\n     *\n     * This property will only work with synchronous plugins.\n     * If the processor contains any asynchronous plugins\n     * it will throw an error. This is why this method is only\n     * for debug purpose, you should always use {@link LazyResult#then}.\n     *\n     * @type {string}\n     * @see Result#content\n     */\n    get content() {\n        return this.stringify().content;\n    }\n\n    /**\n     * Processes input CSS through synchronous plugins\n     * and returns {@link Result#map}.\n     *\n     * This property will only work with synchronous plugins.\n     * If the processor contains any asynchronous plugins\n     * it will throw an error. This is why this method is only\n     * for debug purpose, you should always use {@link LazyResult#then}.\n     *\n     * @type {SourceMapGenerator}\n     * @see Result#map\n     */\n    get map() {\n        return this.stringify().map;\n    }\n\n    /**\n     * Processes input CSS through synchronous plugins\n     * and returns {@link Result#root}.\n     *\n     * This property will only work with synchronous plugins. If the processor\n     * contains any asynchronous plugins it will throw an error.\n     *\n     * This is why this method is only for debug purpose,\n     * you should always use {@link LazyResult#then}.\n     *\n     * @type {Root}\n     * @see Result#root\n     */\n    get root() {\n        return this.sync().root;\n    }\n\n    /**\n     * Processes input CSS through synchronous plugins\n     * and returns {@link Result#messages}.\n     *\n     * This property will only work with synchronous plugins. If the processor\n     * contains any asynchronous plugins it will throw an error.\n     *\n     * This is why this method is only for debug purpose,\n     * you should always use {@link LazyResult#then}.\n     *\n     * @type {Message[]}\n     * @see Result#messages\n     */\n    get messages() {\n        return this.sync().messages;\n    }\n\n    /**\n     * Processes input CSS through synchronous plugins\n     * and calls {@link Result#warnings()}.\n     *\n     * @return {Warning[]} warnings from plugins\n     */\n    warnings() {\n        return this.sync().warnings();\n    }\n\n    /**\n     * Alias for the {@link LazyResult#css} property.\n     *\n     * @example\n     * lazy + '' === lazy.css;\n     *\n     * @return {string} output CSS\n     */\n    toString() {\n        return this.css;\n    }\n\n    /**\n     * Processes input CSS through synchronous and asynchronous plugins\n     * and calls `onFulfilled` with a Result instance. If a plugin throws\n     * an error, the `onRejected` callback will be executed.\n     *\n     * It implements standard Promise API.\n     *\n     * @param {onFulfilled} onFulfilled - callback will be executed\n     *                                    when all plugins will finish work\n     * @param {onRejected}  onRejected  - callback will be executed on any error\n     *\n     * @return {Promise} Promise API to make queue\n     *\n     * @example\n     * postcss([cssnext]).process(css).then(result => {\n     *   console.log(result.css);\n     * });\n     */\n    then(onFulfilled, onRejected) {\n        return this.async().then(onFulfilled, onRejected);\n    }\n\n    /**\n     * Processes input CSS through synchronous and asynchronous plugins\n     * and calls onRejected for each error thrown in any plugin.\n     *\n     * It implements standard Promise API.\n     *\n     * @param {onRejected} onRejected - callback will be executed on any error\n     *\n     * @return {Promise} Promise API to make queue\n     *\n     * @example\n     * postcss([cssnext]).process(css).then(result => {\n     *   console.log(result.css);\n     * }).catch(error => {\n     *   console.error(error);\n     * });\n     */\n    catch(onRejected) {\n        return this.async().catch(onRejected);\n    }\n\n    handleError(error, plugin) {\n        try {\n            this.error = error;\n            if ( error.name === 'CssSyntaxError' && !error.plugin ) {\n                error.plugin = plugin.postcssPlugin;\n                error.setMessage();\n            } else if ( plugin.postcssVersion ) {\n                let pluginName = plugin.postcssPlugin;\n                let pluginVer  = plugin.postcssVersion;\n                let runtimeVer = this.result.processor.version;\n                let a = pluginVer.split('.');\n                let b = runtimeVer.split('.');\n\n                if ( a[0] !== b[0] || parseInt(a[1]) > parseInt(b[1]) ) {\n                    warnOnce('Your current PostCSS version ' +\n                             'is ' + runtimeVer + ', but ' + pluginName + ' ' +\n                             'uses ' + pluginVer + '. Perhaps this is ' +\n                             'the source of the error below.');\n                }\n            }\n        } catch (err) {\n            if ( console && console.error ) console.error(err);\n        }\n    }\n\n    asyncTick(resolve, reject) {\n        if ( this.plugin >= this.processor.plugins.length ) {\n            this.processed = true;\n            return resolve();\n        }\n\n        try {\n            let plugin  = this.processor.plugins[this.plugin];\n            let promise = this.run(plugin);\n            this.plugin += 1;\n\n            if ( isPromise(promise) ) {\n                promise.then( () => {\n                    this.asyncTick(resolve, reject);\n                }).catch( error => {\n                    this.handleError(error, plugin);\n                    this.processed = true;\n                    reject(error);\n                });\n            } else {\n                this.asyncTick(resolve, reject);\n            }\n\n        } catch (error) {\n            this.processed = true;\n            reject(error);\n        }\n    }\n\n    async() {\n        if ( this.processed ) {\n            return new Promise( (resolve, reject) => {\n                if ( this.error ) {\n                    reject(this.error);\n                } else {\n                    resolve(this.stringify());\n                }\n            });\n        }\n        if ( this.processing ) {\n            return this.processing;\n        }\n\n        this.processing = new Promise( (resolve, reject) => {\n            if ( this.error ) return reject(this.error);\n            this.plugin = 0;\n            this.asyncTick(resolve, reject);\n        }).then( () => {\n            this.processed = true;\n            return this.stringify();\n        });\n\n        return this.processing;\n    }\n\n    sync() {\n        if ( this.processed ) return this.result;\n        this.processed = true;\n\n        if ( this.processing ) {\n            throw new Error(\n                'Use process(css).then(cb) to work with async plugins');\n        }\n\n        if ( this.error ) throw this.error;\n\n        for ( let plugin of this.result.processor.plugins ) {\n            let promise = this.run(plugin);\n            if ( isPromise(promise) ) {\n                throw new Error(\n                    'Use process(css).then(cb) to work with async plugins');\n            }\n        }\n\n        return this.result;\n    }\n\n    run(plugin) {\n        this.result.lastPlugin = plugin;\n\n        try {\n            return plugin(this.result.root, this.result);\n        } catch (error) {\n            this.handleError(error, plugin);\n            throw error;\n        }\n    }\n\n    stringify() {\n        if ( this.stringified ) return this.result;\n        this.stringified = true;\n\n        this.sync();\n\n        let opts = this.result.opts;\n        let str  = stringify;\n        if ( opts.syntax )      str = opts.syntax.stringify;\n        if ( opts.stringifier ) str = opts.stringifier;\n        if ( str.stringify )    str = str.stringify;\n\n        let map  = new MapGenerator(str, this.result.root, this.result.opts);\n        let data = map.generate();\n        this.result.css = data[0];\n        this.result.map = data[1];\n\n        return this.result;\n    }\n\n}\n\nexport default LazyResult;\n\n/**\n * @callback onFulfilled\n * @param {Result} result\n */\n\n/**\n * @callback onRejected\n * @param {Error} error\n */\n"]},"metadata":{},"sourceType":"script"}