{"ast":null,"code":"var _typeof = require(\"C:/Users/Administrator/Desktop/data_view/my_project/vue2_app/myapp/node_modules/@babel/runtime/helpers/typeof.js\").default;\n\nrequire(\"core-js/modules/es.array.fill.js\");\n\nrequire(\"core-js/modules/web.immediate.js\");\n\nrequire(\"core-js/modules/es.object.to-string.js\");\n\nrequire(\"core-js/modules/es.regexp.to-string.js\");\n\nrequire(\"core-js/modules/web.dom-collections.for-each.js\");\n\nrequire(\"core-js/modules/es.number.to-fixed.js\");\n\nrequire(\"core-js/modules/es.array.concat.js\");\n\nrequire(\"core-js/modules/es.error.cause.js\");\n\nrequire(\"core-js/modules/es.array.sort.js\");\n\nrequire(\"core-js/modules/es.symbol.js\");\n\nrequire(\"core-js/modules/es.symbol.description.js\");\n\nrequire(\"core-js/modules/es.symbol.to-string-tag.js\");\n\nrequire(\"core-js/modules/es.json.to-string-tag.js\");\n\nrequire(\"core-js/modules/es.math.to-string-tag.js\");\n\n(function webpackUniversalModuleDefinition(root, factory) {\n  if ((typeof exports === \"undefined\" ? \"undefined\" : _typeof(exports)) === 'object' && (typeof module === \"undefined\" ? \"undefined\" : _typeof(module)) === 'object') module.exports = factory(require(\"echarts\"));else if (typeof define === 'function' && define.amd) define([\"echarts\"], factory);else if ((typeof exports === \"undefined\" ? \"undefined\" : _typeof(exports)) === 'object') exports[\"echarts-wordcloud\"] = factory(require(\"echarts\"));else root[\"echarts-wordcloud\"] = factory(root[\"echarts\"]);\n})(self, function (__WEBPACK_EXTERNAL_MODULE_echarts_lib_echarts__) {\n  return (\n    /******/\n    function () {\n      // webpackBootstrap\n\n      /******/\n      \"use strict\";\n      /******/\n\n      var __webpack_modules__ = {\n        /***/\n        \"./index.js\":\n        /*!******************************!*\\\n          !*** ./index.js + 4 modules ***!\n          \\******************************/\n\n        /***/\n        function indexJs(__unused_webpack_module, __webpack_exports__, __webpack_require__) {\n          // ESM COMPAT FLAG\n          __webpack_require__.r(__webpack_exports__); // EXTERNAL MODULE: external \"echarts\"\n\n\n          var external_echarts_ = __webpack_require__(\"echarts/lib/echarts\");\n\n          ; // CONCATENATED MODULE: ./src/WordCloudSeries.js\n\n          external_echarts_.extendSeriesModel({\n            type: 'series.wordCloud',\n            visualStyleAccessPath: 'textStyle',\n            visualStyleMapper: function visualStyleMapper(model) {\n              return {\n                fill: model.get('color')\n              };\n            },\n            visualDrawType: 'fill',\n            optionUpdated: function optionUpdated() {\n              var option = this.option;\n              option.gridSize = Math.max(Math.floor(option.gridSize), 4);\n            },\n            getInitialData: function getInitialData(option, ecModel) {\n              var dimensions = external_echarts_.helper.createDimensions(option.data, {\n                coordDimensions: ['value']\n              });\n              var list = new external_echarts_.List(dimensions, this);\n              list.initData(option.data);\n              return list;\n            },\n            // Most of options are from https://github.com/timdream/wordcloud2.js/blob/gh-pages/API.md\n            defaultOption: {\n              maskImage: null,\n              // Shape can be 'circle', 'cardioid', 'diamond', 'triangle-forward', 'triangle', 'pentagon', 'star'\n              shape: 'circle',\n              left: 'center',\n              top: 'center',\n              width: '70%',\n              height: '80%',\n              sizeRange: [12, 60],\n              rotationRange: [-90, 90],\n              rotationStep: 45,\n              gridSize: 8,\n              drawOutOfBound: false,\n              textStyle: {\n                fontWeight: 'normal'\n              }\n            }\n          });\n          ; // CONCATENATED MODULE: ./src/WordCloudView.js\n\n          external_echarts_.extendChartView({\n            type: 'wordCloud',\n            render: function render(seriesModel, ecModel, api) {\n              var group = this.group;\n              group.removeAll();\n              var data = seriesModel.getData();\n              var gridSize = seriesModel.get('gridSize');\n\n              seriesModel.layoutInstance.ondraw = function (text, size, dataIdx, drawn) {\n                var itemModel = data.getItemModel(dataIdx);\n                var textStyleModel = itemModel.getModel('textStyle');\n                var textEl = new external_echarts_.graphic.Text({\n                  style: external_echarts_.helper.createTextStyle(textStyleModel),\n                  scaleX: 1 / drawn.info.mu,\n                  scaleY: 1 / drawn.info.mu,\n                  x: (drawn.gx + drawn.info.gw / 2) * gridSize,\n                  y: (drawn.gy + drawn.info.gh / 2) * gridSize,\n                  rotation: drawn.rot\n                });\n                textEl.setStyle({\n                  x: drawn.info.fillTextOffsetX,\n                  y: drawn.info.fillTextOffsetY + size * 0.5,\n                  text: text,\n                  verticalAlign: 'middle',\n                  fill: data.getItemVisual(dataIdx, 'style').fill,\n                  fontSize: size\n                });\n                group.add(textEl);\n                data.setItemGraphicEl(dataIdx, textEl);\n                textEl.ensureState('emphasis').style = external_echarts_.helper.createTextStyle(itemModel.getModel(['emphasis', 'textStyle']), {\n                  state: 'emphasis'\n                });\n                textEl.ensureState('blur').style = external_echarts_.helper.createTextStyle(itemModel.getModel(['blur', 'textStyle']), {\n                  state: 'blur'\n                });\n                external_echarts_.helper.enableHoverEmphasis(textEl, itemModel.get(['emphasis', 'focus']), itemModel.get(['emphasis', 'blurScope']));\n                textEl.stateTransition = {\n                  duration: seriesModel.get('animation') ? seriesModel.get(['stateAnimation', 'duration']) : 0,\n                  easing: seriesModel.get(['stateAnimation', 'easing'])\n                }; // TODO\n\n                textEl.__highDownDispatcher = true;\n              };\n\n              this._model = seriesModel;\n            },\n            remove: function remove() {\n              this.group.removeAll();\n\n              this._model.layoutInstance.dispose();\n            },\n            dispose: function dispose() {\n              this._model.layoutInstance.dispose();\n            }\n          });\n          ; // CONCATENATED MODULE: ./src/layout.js\n\n          /*!\n           * wordcloud2.js\n           * http://timdream.org/wordcloud2.js/\n           *\n           * Copyright 2011 - 2013 Tim Chien\n           * Released under the MIT license\n           */\n          // setImmediate\n\n          if (!window.setImmediate) {\n            window.setImmediate = function setupSetImmediate() {\n              return window.msSetImmediate || window.webkitSetImmediate || window.mozSetImmediate || window.oSetImmediate || function setupSetZeroTimeout() {\n                if (!window.postMessage || !window.addEventListener) {\n                  return null;\n                }\n\n                var callbacks = [undefined];\n                var message = 'zero-timeout-message'; // Like setTimeout, but only takes a function argument.  There's\n                // no time argument (always zero) and no arguments (you have to\n                // use a closure).\n\n                var setZeroTimeout = function setZeroTimeout(callback) {\n                  var id = callbacks.length;\n                  callbacks.push(callback);\n                  window.postMessage(message + id.toString(36), '*');\n                  return id;\n                };\n\n                window.addEventListener('message', function setZeroTimeoutMessage(evt) {\n                  // Skipping checking event source, retarded IE confused this window\n                  // object with another in the presence of iframe\n                  if (typeof evt.data !== 'string' || evt.data.substr(0, message.length) !== message\n                  /* ||\n                  evt.source !== window */\n                  ) {\n                    return;\n                  }\n\n                  evt.stopImmediatePropagation();\n                  var id = parseInt(evt.data.substr(message.length), 36);\n\n                  if (!callbacks[id]) {\n                    return;\n                  }\n\n                  callbacks[id]();\n                  callbacks[id] = undefined;\n                }, true);\n                /* specify clearImmediate() here since we need the scope */\n\n                window.clearImmediate = function clearZeroTimeout(id) {\n                  if (!callbacks[id]) {\n                    return;\n                  }\n\n                  callbacks[id] = undefined;\n                };\n\n                return setZeroTimeout;\n              }() || // fallback\n              function setImmediateFallback(fn) {\n                window.setTimeout(fn, 0);\n              };\n            }();\n          }\n\n          if (!window.clearImmediate) {\n            window.clearImmediate = function setupClearImmediate() {\n              return window.msClearImmediate || window.webkitClearImmediate || window.mozClearImmediate || window.oClearImmediate || // \"clearZeroTimeout\" is implement on the previous block ||\n              // fallback\n              function clearImmediateFallback(timer) {\n                window.clearTimeout(timer);\n              };\n            }();\n          } // Check if WordCloud can run on this browser\n\n\n          var isSupported = function isSupported() {\n            var canvas = document.createElement('canvas');\n\n            if (!canvas || !canvas.getContext) {\n              return false;\n            }\n\n            var ctx = canvas.getContext('2d');\n\n            if (!ctx.getImageData) {\n              return false;\n            }\n\n            if (!ctx.fillText) {\n              return false;\n            }\n\n            if (!Array.prototype.some) {\n              return false;\n            }\n\n            if (!Array.prototype.push) {\n              return false;\n            }\n\n            return true;\n          }(); // Find out if the browser impose minium font size by\n          // drawing small texts on a canvas and measure it's width.\n\n\n          var minFontSize = function getMinFontSize() {\n            if (!isSupported) {\n              return;\n            }\n\n            var ctx = document.createElement('canvas').getContext('2d'); // start from 20\n\n            var size = 20; // two sizes to measure\n\n            var hanWidth, mWidth;\n\n            while (size) {\n              ctx.font = size.toString(10) + 'px sans-serif';\n\n              if (ctx.measureText(\"\\uFF37\").width === hanWidth && ctx.measureText('m').width === mWidth) {\n                return size + 1;\n              }\n\n              hanWidth = ctx.measureText(\"\\uFF37\").width;\n              mWidth = ctx.measureText('m').width;\n              size--;\n            }\n\n            return 0;\n          }(); // Based on http://jsfromhell.com/array/shuffle\n\n\n          var shuffleArray = function shuffleArray(arr) {\n            for (var j, x, i = arr.length; i; j = Math.floor(Math.random() * i), x = arr[--i], arr[i] = arr[j], arr[j] = x) {}\n\n            return arr;\n          };\n\n          var WordCloud = function WordCloud(elements, options) {\n            if (!isSupported) {\n              return;\n            }\n\n            if (!Array.isArray(elements)) {\n              elements = [elements];\n            }\n\n            elements.forEach(function (el, i) {\n              if (typeof el === 'string') {\n                elements[i] = document.getElementById(el);\n\n                if (!elements[i]) {\n                  throw 'The element id specified is not found.';\n                }\n              } else if (!el.tagName && !el.appendChild) {\n                throw 'You must pass valid HTML elements, or ID of the element.';\n              }\n            });\n            /* Default values to be overwritten by options object */\n\n            var settings = {\n              list: [],\n              fontFamily: '\"Trebuchet MS\", \"Heiti TC\", \"微軟正黑體\", ' + '\"Arial Unicode MS\", \"Droid Fallback Sans\", sans-serif',\n              fontWeight: 'normal',\n              color: 'random-dark',\n              minSize: 0,\n              // 0 to disable\n              weightFactor: 1,\n              clearCanvas: true,\n              backgroundColor: '#fff',\n              // opaque white = rgba(255, 255, 255, 1)\n              gridSize: 8,\n              drawOutOfBound: false,\n              origin: null,\n              drawMask: false,\n              maskColor: 'rgba(255,0,0,0.3)',\n              maskGapWidth: 0.3,\n              layoutAnimation: true,\n              wait: 0,\n              abortThreshold: 0,\n              // disabled\n              abort: function noop() {},\n              minRotation: -Math.PI / 2,\n              maxRotation: Math.PI / 2,\n              rotationStep: 0.1,\n              shuffle: true,\n              rotateRatio: 0.1,\n              shape: 'circle',\n              ellipticity: 0.65,\n              classes: null,\n              hover: null,\n              click: null\n            };\n\n            if (options) {\n              for (var key in options) {\n                if (key in settings) {\n                  settings[key] = options[key];\n                }\n              }\n            }\n            /* Convert weightFactor into a function */\n\n\n            if (typeof settings.weightFactor !== 'function') {\n              var factor = settings.weightFactor;\n\n              settings.weightFactor = function weightFactor(pt) {\n                return pt * factor; //in px\n              };\n            }\n            /* Convert shape into a function */\n\n\n            if (typeof settings.shape !== 'function') {\n              switch (settings.shape) {\n                case 'circle':\n                /* falls through */\n\n                default:\n                  // 'circle' is the default and a shortcut in the code loop.\n                  settings.shape = 'circle';\n                  break;\n\n                case 'cardioid':\n                  settings.shape = function shapeCardioid(theta) {\n                    return 1 - Math.sin(theta);\n                  };\n\n                  break;\n\n                /*\n                To work out an X-gon, one has to calculate \"m\",\n                where 1/(cos(2*PI/X)+m*sin(2*PI/X)) = 1/(cos(0)+m*sin(0))\n                http://www.wolframalpha.com/input/?i=1%2F%28cos%282*PI%2FX%29%2Bm*sin%28\n                2*PI%2FX%29%29+%3D+1%2F%28cos%280%29%2Bm*sin%280%29%29\n                Copy the solution into polar equation r = 1/(cos(t') + m*sin(t'))\n                where t' equals to mod(t, 2PI/X);\n                */\n\n                case 'diamond':\n                case 'square':\n                  // http://www.wolframalpha.com/input/?i=plot+r+%3D+1%2F%28cos%28mod+\n                  // %28t%2C+PI%2F2%29%29%2Bsin%28mod+%28t%2C+PI%2F2%29%29%29%2C+t+%3D\n                  // +0+..+2*PI\n                  settings.shape = function shapeSquare(theta) {\n                    var thetaPrime = theta % (2 * Math.PI / 4);\n                    return 1 / (Math.cos(thetaPrime) + Math.sin(thetaPrime));\n                  };\n\n                  break;\n\n                case 'triangle-forward':\n                  // http://www.wolframalpha.com/input/?i=plot+r+%3D+1%2F%28cos%28mod+\n                  // %28t%2C+2*PI%2F3%29%29%2Bsqrt%283%29sin%28mod+%28t%2C+2*PI%2F3%29\n                  // %29%29%2C+t+%3D+0+..+2*PI\n                  settings.shape = function shapeTriangle(theta) {\n                    var thetaPrime = theta % (2 * Math.PI / 3);\n                    return 1 / (Math.cos(thetaPrime) + Math.sqrt(3) * Math.sin(thetaPrime));\n                  };\n\n                  break;\n\n                case 'triangle':\n                case 'triangle-upright':\n                  settings.shape = function shapeTriangle(theta) {\n                    var thetaPrime = (theta + Math.PI * 3 / 2) % (2 * Math.PI / 3);\n                    return 1 / (Math.cos(thetaPrime) + Math.sqrt(3) * Math.sin(thetaPrime));\n                  };\n\n                  break;\n\n                case 'pentagon':\n                  settings.shape = function shapePentagon(theta) {\n                    var thetaPrime = (theta + 0.955) % (2 * Math.PI / 5);\n                    return 1 / (Math.cos(thetaPrime) + 0.726543 * Math.sin(thetaPrime));\n                  };\n\n                  break;\n\n                case 'star':\n                  settings.shape = function shapeStar(theta) {\n                    var thetaPrime = (theta + 0.955) % (2 * Math.PI / 10);\n\n                    if ((theta + 0.955) % (2 * Math.PI / 5) - 2 * Math.PI / 10 >= 0) {\n                      return 1 / (Math.cos(2 * Math.PI / 10 - thetaPrime) + 3.07768 * Math.sin(2 * Math.PI / 10 - thetaPrime));\n                    } else {\n                      return 1 / (Math.cos(thetaPrime) + 3.07768 * Math.sin(thetaPrime));\n                    }\n                  };\n\n                  break;\n              }\n            }\n            /* Make sure gridSize is a whole number and is not smaller than 4px */\n\n\n            settings.gridSize = Math.max(Math.floor(settings.gridSize), 4);\n            /* shorthand */\n\n            var g = settings.gridSize;\n            var maskRectWidth = g - settings.maskGapWidth;\n            /* normalize rotation settings */\n\n            var rotationRange = Math.abs(settings.maxRotation - settings.minRotation);\n            var minRotation = Math.min(settings.maxRotation, settings.minRotation);\n            var rotationStep = settings.rotationStep;\n            /* information/object available to all functions, set when start() */\n\n            var grid, // 2d array containing filling information\n            ngx, ngy, // width and height of the grid\n            center, // position of the center of the cloud\n            maxRadius;\n            /* timestamp for measuring each putWord() action */\n\n            var escapeTime;\n            /* function for getting the color of the text */\n\n            var getTextColor;\n\n            function random_hsl_color(min, max) {\n              return 'hsl(' + (Math.random() * 360).toFixed() + ',' + (Math.random() * 30 + 70).toFixed() + '%,' + (Math.random() * (max - min) + min).toFixed() + '%)';\n            }\n\n            switch (settings.color) {\n              case 'random-dark':\n                getTextColor = function getRandomDarkColor() {\n                  return random_hsl_color(10, 50);\n                };\n\n                break;\n\n              case 'random-light':\n                getTextColor = function getRandomLightColor() {\n                  return random_hsl_color(50, 90);\n                };\n\n                break;\n\n              default:\n                if (typeof settings.color === 'function') {\n                  getTextColor = settings.color;\n                }\n\n                break;\n            }\n            /* function for getting the classes of the text */\n\n\n            var getTextClasses = null;\n\n            if (typeof settings.classes === 'function') {\n              getTextClasses = settings.classes;\n            }\n            /* Interactive */\n\n\n            var interactive = false;\n            var infoGrid = [];\n            var hovered;\n\n            var getInfoGridFromMouseTouchEvent = function getInfoGridFromMouseTouchEvent(evt) {\n              var canvas = evt.currentTarget;\n              var rect = canvas.getBoundingClientRect();\n              var clientX;\n              var clientY;\n              /** Detect if touches are available */\n\n              if (evt.touches) {\n                clientX = evt.touches[0].clientX;\n                clientY = evt.touches[0].clientY;\n              } else {\n                clientX = evt.clientX;\n                clientY = evt.clientY;\n              }\n\n              var eventX = clientX - rect.left;\n              var eventY = clientY - rect.top;\n              var x = Math.floor(eventX * (canvas.width / rect.width || 1) / g);\n              var y = Math.floor(eventY * (canvas.height / rect.height || 1) / g);\n              return infoGrid[x][y];\n            };\n\n            var wordcloudhover = function wordcloudhover(evt) {\n              var info = getInfoGridFromMouseTouchEvent(evt);\n\n              if (hovered === info) {\n                return;\n              }\n\n              hovered = info;\n\n              if (!info) {\n                settings.hover(undefined, undefined, evt);\n                return;\n              }\n\n              settings.hover(info.item, info.dimension, evt);\n            };\n\n            var wordcloudclick = function wordcloudclick(evt) {\n              var info = getInfoGridFromMouseTouchEvent(evt);\n\n              if (!info) {\n                return;\n              }\n\n              settings.click(info.item, info.dimension, evt);\n              evt.preventDefault();\n            };\n            /* Get points on the grid for a given radius away from the center */\n\n\n            var pointsAtRadius = [];\n\n            var getPointsAtRadius = function getPointsAtRadius(radius) {\n              if (pointsAtRadius[radius]) {\n                return pointsAtRadius[radius];\n              } // Look for these number of points on each radius\n\n\n              var T = radius * 8; // Getting all the points at this radius\n\n              var t = T;\n              var points = [];\n\n              if (radius === 0) {\n                points.push([center[0], center[1], 0]);\n              }\n\n              while (t--) {\n                // distort the radius to put the cloud in shape\n                var rx = 1;\n\n                if (settings.shape !== 'circle') {\n                  rx = settings.shape(t / T * 2 * Math.PI); // 0 to 1\n                } // Push [x, y, t]; t is used solely for getTextColor()\n\n\n                points.push([center[0] + radius * rx * Math.cos(-t / T * 2 * Math.PI), center[1] + radius * rx * Math.sin(-t / T * 2 * Math.PI) * settings.ellipticity, t / T * 2 * Math.PI]);\n              }\n\n              pointsAtRadius[radius] = points;\n              return points;\n            };\n            /* Return true if we had spent too much time */\n\n\n            var exceedTime = function exceedTime() {\n              return settings.abortThreshold > 0 && new Date().getTime() - escapeTime > settings.abortThreshold;\n            };\n            /* Get the deg of rotation according to settings, and luck. */\n\n\n            var getRotateDeg = function getRotateDeg() {\n              if (settings.rotateRatio === 0) {\n                return 0;\n              }\n\n              if (Math.random() > settings.rotateRatio) {\n                return 0;\n              }\n\n              if (rotationRange === 0) {\n                return minRotation;\n              }\n\n              return minRotation + Math.round(Math.random() * rotationRange / rotationStep) * rotationStep;\n            };\n\n            var getTextInfo = function getTextInfo(word, weight, rotateDeg) {\n              // calculate the acutal font size\n              // fontSize === 0 means weightFactor function wants the text skipped,\n              // and size < minSize means we cannot draw the text.\n              var debug = false;\n              var fontSize = settings.weightFactor(weight);\n\n              if (fontSize <= settings.minSize) {\n                return false;\n              } // Scale factor here is to make sure fillText is not limited by\n              // the minium font size set by browser.\n              // It will always be 1 or 2n.\n\n\n              var mu = 1;\n\n              if (fontSize < minFontSize) {\n                mu = function calculateScaleFactor() {\n                  var mu = 2;\n\n                  while (mu * fontSize < minFontSize) {\n                    mu += 2;\n                  }\n\n                  return mu;\n                }();\n              }\n\n              var fcanvas = document.createElement('canvas');\n              var fctx = fcanvas.getContext('2d', {\n                willReadFrequently: true\n              });\n              fctx.font = settings.fontWeight + ' ' + (fontSize * mu).toString(10) + 'px ' + settings.fontFamily; // Estimate the dimension of the text with measureText().\n\n              var fw = fctx.measureText(word).width / mu;\n              var fh = Math.max(fontSize * mu, fctx.measureText('m').width, fctx.measureText(\"\\uFF37\").width) / mu; // Create a boundary box that is larger than our estimates,\n              // so text don't get cut of (it sill might)\n\n              var boxWidth = fw + fh * 2;\n              var boxHeight = fh * 3;\n              var fgw = Math.ceil(boxWidth / g);\n              var fgh = Math.ceil(boxHeight / g);\n              boxWidth = fgw * g;\n              boxHeight = fgh * g; // Calculate the proper offsets to make the text centered at\n              // the preferred position.\n              // This is simply half of the width.\n\n              var fillTextOffsetX = -fw / 2; // Instead of moving the box to the exact middle of the preferred\n              // position, for Y-offset we move 0.4 instead, so Latin alphabets look\n              // vertical centered.\n\n              var fillTextOffsetY = -fh * 0.4; // Calculate the actual dimension of the canvas, considering the rotation.\n\n              var cgh = Math.ceil((boxWidth * Math.abs(Math.sin(rotateDeg)) + boxHeight * Math.abs(Math.cos(rotateDeg))) / g);\n              var cgw = Math.ceil((boxWidth * Math.abs(Math.cos(rotateDeg)) + boxHeight * Math.abs(Math.sin(rotateDeg))) / g);\n              var width = cgw * g;\n              var height = cgh * g;\n              fcanvas.setAttribute('width', width);\n              fcanvas.setAttribute('height', height);\n\n              if (debug) {\n                // Attach fcanvas to the DOM\n                document.body.appendChild(fcanvas); // Save it's state so that we could restore and draw the grid correctly.\n\n                fctx.save();\n              } // Scale the canvas with |mu|.\n\n\n              fctx.scale(1 / mu, 1 / mu);\n              fctx.translate(width * mu / 2, height * mu / 2);\n              fctx.rotate(-rotateDeg); // Once the width/height is set, ctx info will be reset.\n              // Set it again here.\n\n              fctx.font = settings.fontWeight + ' ' + (fontSize * mu).toString(10) + 'px ' + settings.fontFamily; // Fill the text into the fcanvas.\n              // XXX: We cannot because textBaseline = 'top' here because\n              // Firefox and Chrome uses different default line-height for canvas.\n              // Please read https://bugzil.la/737852#c6.\n              // Here, we use textBaseline = 'middle' and draw the text at exactly\n              // 0.5 * fontSize lower.\n\n              fctx.fillStyle = '#000';\n              fctx.textBaseline = 'middle';\n              fctx.fillText(word, fillTextOffsetX * mu, (fillTextOffsetY + fontSize * 0.5) * mu); // Get the pixels of the text\n\n              var imageData = fctx.getImageData(0, 0, width, height).data;\n\n              if (exceedTime()) {\n                return false;\n              }\n\n              if (debug) {\n                // Draw the box of the original estimation\n                fctx.strokeRect(fillTextOffsetX * mu, fillTextOffsetY, fw * mu, fh * mu);\n                fctx.restore();\n              } // Read the pixels and save the information to the occupied array\n\n\n              var occupied = [];\n              var gx = cgw,\n                  gy,\n                  x,\n                  y;\n              var bounds = [cgh / 2, cgw / 2, cgh / 2, cgw / 2];\n\n              while (gx--) {\n                gy = cgh;\n\n                while (gy--) {\n                  y = g;\n\n                  singleGridLoop: {\n                    while (y--) {\n                      x = g;\n\n                      while (x--) {\n                        if (imageData[((gy * g + y) * width + (gx * g + x)) * 4 + 3]) {\n                          occupied.push([gx, gy]);\n\n                          if (gx < bounds[3]) {\n                            bounds[3] = gx;\n                          }\n\n                          if (gx > bounds[1]) {\n                            bounds[1] = gx;\n                          }\n\n                          if (gy < bounds[0]) {\n                            bounds[0] = gy;\n                          }\n\n                          if (gy > bounds[2]) {\n                            bounds[2] = gy;\n                          }\n\n                          if (debug) {\n                            fctx.fillStyle = 'rgba(255, 0, 0, 0.5)';\n                            fctx.fillRect(gx * g, gy * g, g - 0.5, g - 0.5);\n                          }\n\n                          break singleGridLoop;\n                        }\n                      }\n                    }\n\n                    if (debug) {\n                      fctx.fillStyle = 'rgba(0, 0, 255, 0.5)';\n                      fctx.fillRect(gx * g, gy * g, g - 0.5, g - 0.5);\n                    }\n                  }\n                }\n              }\n\n              if (debug) {\n                fctx.fillStyle = 'rgba(0, 255, 0, 0.5)';\n                fctx.fillRect(bounds[3] * g, bounds[0] * g, (bounds[1] - bounds[3] + 1) * g, (bounds[2] - bounds[0] + 1) * g);\n              } // Return information needed to create the text on the real canvas\n\n\n              return {\n                mu: mu,\n                occupied: occupied,\n                bounds: bounds,\n                gw: cgw,\n                gh: cgh,\n                fillTextOffsetX: fillTextOffsetX,\n                fillTextOffsetY: fillTextOffsetY,\n                fillTextWidth: fw,\n                fillTextHeight: fh,\n                fontSize: fontSize\n              };\n            };\n            /* Determine if there is room available in the given dimension */\n\n\n            var canFitText = function canFitText(gx, gy, gw, gh, occupied) {\n              // Go through the occupied points,\n              // return false if the space is not available.\n              var i = occupied.length;\n\n              while (i--) {\n                var px = gx + occupied[i][0];\n                var py = gy + occupied[i][1];\n\n                if (px >= ngx || py >= ngy || px < 0 || py < 0) {\n                  if (!settings.drawOutOfBound) {\n                    return false;\n                  }\n\n                  continue;\n                }\n\n                if (!grid[px][py]) {\n                  return false;\n                }\n              }\n\n              return true;\n            };\n            /* Actually draw the text on the grid */\n\n\n            var drawText = function drawText(gx, gy, info, word, weight, distance, theta, rotateDeg, attributes) {\n              var fontSize = info.fontSize;\n              var color;\n\n              if (getTextColor) {\n                color = getTextColor(word, weight, fontSize, distance, theta);\n              } else {\n                color = settings.color;\n              }\n\n              var classes;\n\n              if (getTextClasses) {\n                classes = getTextClasses(word, weight, fontSize, distance, theta);\n              } else {\n                classes = settings.classes;\n              }\n\n              var dimension;\n              var bounds = info.bounds;\n              dimension = {\n                x: (gx + bounds[3]) * g,\n                y: (gy + bounds[0]) * g,\n                w: (bounds[1] - bounds[3] + 1) * g,\n                h: (bounds[2] - bounds[0] + 1) * g\n              };\n              elements.forEach(function (el) {\n                if (el.getContext) {\n                  var ctx = el.getContext('2d');\n                  var mu = info.mu; // Save the current state before messing it\n\n                  ctx.save();\n                  ctx.scale(1 / mu, 1 / mu);\n                  ctx.font = settings.fontWeight + ' ' + (fontSize * mu).toString(10) + 'px ' + settings.fontFamily;\n                  ctx.fillStyle = color; // Translate the canvas position to the origin coordinate of where\n                  // the text should be put.\n\n                  ctx.translate((gx + info.gw / 2) * g * mu, (gy + info.gh / 2) * g * mu);\n\n                  if (rotateDeg !== 0) {\n                    ctx.rotate(-rotateDeg);\n                  } // Finally, fill the text.\n                  // XXX: We cannot because textBaseline = 'top' here because\n                  // Firefox and Chrome uses different default line-height for canvas.\n                  // Please read https://bugzil.la/737852#c6.\n                  // Here, we use textBaseline = 'middle' and draw the text at exactly\n                  // 0.5 * fontSize lower.\n\n\n                  ctx.textBaseline = 'middle';\n                  ctx.fillText(word, info.fillTextOffsetX * mu, (info.fillTextOffsetY + fontSize * 0.5) * mu); // The below box is always matches how <span>s are positioned\n\n                  /* ctx.strokeRect(info.fillTextOffsetX, info.fillTextOffsetY,\n                    info.fillTextWidth, info.fillTextHeight); */\n                  // Restore the state.\n\n                  ctx.restore();\n                } else {\n                  // drawText on DIV element\n                  var span = document.createElement('span');\n                  var transformRule = '';\n                  transformRule = 'rotate(' + -rotateDeg / Math.PI * 180 + 'deg) ';\n\n                  if (info.mu !== 1) {\n                    transformRule += 'translateX(-' + info.fillTextWidth / 4 + 'px) ' + 'scale(' + 1 / info.mu + ')';\n                  }\n\n                  var styleRules = {\n                    'position': 'absolute',\n                    'display': 'block',\n                    'font': settings.fontWeight + ' ' + fontSize * info.mu + 'px ' + settings.fontFamily,\n                    'left': (gx + info.gw / 2) * g + info.fillTextOffsetX + 'px',\n                    'top': (gy + info.gh / 2) * g + info.fillTextOffsetY + 'px',\n                    'width': info.fillTextWidth + 'px',\n                    'height': info.fillTextHeight + 'px',\n                    'lineHeight': fontSize + 'px',\n                    'whiteSpace': 'nowrap',\n                    'transform': transformRule,\n                    'webkitTransform': transformRule,\n                    'msTransform': transformRule,\n                    'transformOrigin': '50% 40%',\n                    'webkitTransformOrigin': '50% 40%',\n                    'msTransformOrigin': '50% 40%'\n                  };\n\n                  if (color) {\n                    styleRules.color = color;\n                  }\n\n                  span.textContent = word;\n\n                  for (var cssProp in styleRules) {\n                    span.style[cssProp] = styleRules[cssProp];\n                  }\n\n                  if (attributes) {\n                    for (var attribute in attributes) {\n                      span.setAttribute(attribute, attributes[attribute]);\n                    }\n                  }\n\n                  if (classes) {\n                    span.className += classes;\n                  }\n\n                  el.appendChild(span);\n                }\n              });\n            };\n            /* Help function to updateGrid */\n\n\n            var fillGridAt = function fillGridAt(x, y, drawMask, dimension, item) {\n              if (x >= ngx || y >= ngy || x < 0 || y < 0) {\n                return;\n              }\n\n              grid[x][y] = false;\n\n              if (drawMask) {\n                var ctx = elements[0].getContext('2d');\n                ctx.fillRect(x * g, y * g, maskRectWidth, maskRectWidth);\n              }\n\n              if (interactive) {\n                infoGrid[x][y] = {\n                  item: item,\n                  dimension: dimension\n                };\n              }\n            };\n            /* Update the filling information of the given space with occupied points.\n               Draw the mask on the canvas if necessary. */\n\n\n            var updateGrid = function updateGrid(gx, gy, gw, gh, info, item) {\n              var occupied = info.occupied;\n              var drawMask = settings.drawMask;\n              var ctx;\n\n              if (drawMask) {\n                ctx = elements[0].getContext('2d');\n                ctx.save();\n                ctx.fillStyle = settings.maskColor;\n              }\n\n              var dimension;\n\n              if (interactive) {\n                var bounds = info.bounds;\n                dimension = {\n                  x: (gx + bounds[3]) * g,\n                  y: (gy + bounds[0]) * g,\n                  w: (bounds[1] - bounds[3] + 1) * g,\n                  h: (bounds[2] - bounds[0] + 1) * g\n                };\n              }\n\n              var i = occupied.length;\n\n              while (i--) {\n                var px = gx + occupied[i][0];\n                var py = gy + occupied[i][1];\n\n                if (px >= ngx || py >= ngy || px < 0 || py < 0) {\n                  continue;\n                }\n\n                fillGridAt(px, py, drawMask, dimension, item);\n              }\n\n              if (drawMask) {\n                ctx.restore();\n              }\n            };\n            /* putWord() processes each item on the list,\n               calculate it's size and determine it's position, and actually\n               put it on the canvas. */\n\n\n            var putWord = function putWord(item) {\n              var word, weight, attributes;\n\n              if (Array.isArray(item)) {\n                word = item[0];\n                weight = item[1];\n              } else {\n                word = item.word;\n                weight = item.weight;\n                attributes = item.attributes;\n              }\n\n              var rotateDeg = getRotateDeg(); // get info needed to put the text onto the canvas\n\n              var info = getTextInfo(word, weight, rotateDeg); // not getting the info means we shouldn't be drawing this one.\n\n              if (!info) {\n                return false;\n              }\n\n              if (exceedTime()) {\n                return false;\n              } // If drawOutOfBound is set to false,\n              // skip the loop if we have already know the bounding box of\n              // word is larger than the canvas.\n\n\n              if (!settings.drawOutOfBound) {\n                var bounds = info.bounds;\n\n                if (bounds[1] - bounds[3] + 1 > ngx || bounds[2] - bounds[0] + 1 > ngy) {\n                  return false;\n                }\n              } // Determine the position to put the text by\n              // start looking for the nearest points\n\n\n              var r = maxRadius + 1;\n\n              var tryToPutWordAtPoint = function tryToPutWordAtPoint(gxy) {\n                var gx = Math.floor(gxy[0] - info.gw / 2);\n                var gy = Math.floor(gxy[1] - info.gh / 2);\n                var gw = info.gw;\n                var gh = info.gh; // If we cannot fit the text at this position, return false\n                // and go to the next position.\n\n                if (!canFitText(gx, gy, gw, gh, info.occupied)) {\n                  return false;\n                } // Actually put the text on the canvas\n\n\n                drawText(gx, gy, info, word, weight, maxRadius - r, gxy[2], rotateDeg, attributes); // Mark the spaces on the grid as filled\n\n                updateGrid(gx, gy, gw, gh, info, item);\n                return {\n                  gx: gx,\n                  gy: gy,\n                  rot: rotateDeg,\n                  info: info\n                };\n              };\n\n              while (r--) {\n                var points = getPointsAtRadius(maxRadius - r);\n\n                if (settings.shuffle) {\n                  points = [].concat(points);\n                  shuffleArray(points);\n                } // Try to fit the words by looking at each point.\n                // array.some() will stop and return true\n                // when putWordAtPoint() returns true.\n\n\n                for (var i = 0; i < points.length; i++) {\n                  var res = tryToPutWordAtPoint(points[i]);\n\n                  if (res) {\n                    return res;\n                  }\n                } // var drawn = points.some(tryToPutWordAtPoint);\n                // if (drawn) {\n                //   // leave putWord() and return true\n                //   return true;\n                // }\n\n              } // we tried all distances but text won't fit, return null\n\n\n              return null;\n            };\n            /* Send DOM event to all elements. Will stop sending event and return\n               if the previous one is canceled (for cancelable events). */\n\n\n            var sendEvent = function sendEvent(type, cancelable, detail) {\n              if (cancelable) {\n                return !elements.some(function (el) {\n                  var evt = document.createEvent('CustomEvent');\n                  evt.initCustomEvent(type, true, cancelable, detail || {});\n                  return !el.dispatchEvent(evt);\n                }, this);\n              } else {\n                elements.forEach(function (el) {\n                  var evt = document.createEvent('CustomEvent');\n                  evt.initCustomEvent(type, true, cancelable, detail || {});\n                  el.dispatchEvent(evt);\n                }, this);\n              }\n            };\n            /* Start drawing on a canvas */\n\n\n            var start = function start() {\n              // For dimensions, clearCanvas etc.,\n              // we only care about the first element.\n              var canvas = elements[0];\n\n              if (canvas.getContext) {\n                ngx = Math.ceil(canvas.width / g);\n                ngy = Math.ceil(canvas.height / g);\n              } else {\n                var rect = canvas.getBoundingClientRect();\n                ngx = Math.ceil(rect.width / g);\n                ngy = Math.ceil(rect.height / g);\n              } // Sending a wordcloudstart event which cause the previous loop to stop.\n              // Do nothing if the event is canceled.\n\n\n              if (!sendEvent('wordcloudstart', true)) {\n                return;\n              } // Determine the center of the word cloud\n\n\n              center = settings.origin ? [settings.origin[0] / g, settings.origin[1] / g] : [ngx / 2, ngy / 2]; // Maxium radius to look for space\n\n              maxRadius = Math.floor(Math.sqrt(ngx * ngx + ngy * ngy));\n              /* Clear the canvas only if the clearCanvas is set,\n                 if not, update the grid to the current canvas state */\n\n              grid = [];\n              var gx, gy, i;\n\n              if (!canvas.getContext || settings.clearCanvas) {\n                elements.forEach(function (el) {\n                  if (el.getContext) {\n                    var ctx = el.getContext('2d');\n                    ctx.fillStyle = settings.backgroundColor;\n                    ctx.clearRect(0, 0, ngx * (g + 1), ngy * (g + 1));\n                    ctx.fillRect(0, 0, ngx * (g + 1), ngy * (g + 1));\n                  } else {\n                    el.textContent = '';\n                    el.style.backgroundColor = settings.backgroundColor;\n                    el.style.position = 'relative';\n                  }\n                });\n                /* fill the grid with empty state */\n\n                gx = ngx;\n\n                while (gx--) {\n                  grid[gx] = [];\n                  gy = ngy;\n\n                  while (gy--) {\n                    grid[gx][gy] = true;\n                  }\n                }\n              } else {\n                /* Determine bgPixel by creating\n                   another canvas and fill the specified background color. */\n                var bctx = document.createElement('canvas').getContext('2d');\n                bctx.fillStyle = settings.backgroundColor;\n                bctx.fillRect(0, 0, 1, 1);\n                var bgPixel = bctx.getImageData(0, 0, 1, 1).data;\n                /* Read back the pixels of the canvas we got to tell which part of the\n                   canvas is empty.\n                   (no clearCanvas only works with a canvas, not divs) */\n\n                var imageData = canvas.getContext('2d').getImageData(0, 0, ngx * g, ngy * g).data;\n                gx = ngx;\n                var x, y;\n\n                while (gx--) {\n                  grid[gx] = [];\n                  gy = ngy;\n\n                  while (gy--) {\n                    y = g;\n\n                    singleGridLoop: while (y--) {\n                      x = g;\n\n                      while (x--) {\n                        i = 4;\n\n                        while (i--) {\n                          if (imageData[((gy * g + y) * ngx * g + (gx * g + x)) * 4 + i] !== bgPixel[i]) {\n                            grid[gx][gy] = false;\n                            break singleGridLoop;\n                          }\n                        }\n                      }\n                    }\n\n                    if (grid[gx][gy] !== false) {\n                      grid[gx][gy] = true;\n                    }\n                  }\n                }\n\n                imageData = bctx = bgPixel = undefined;\n              } // fill the infoGrid with empty state if we need it\n\n\n              if (settings.hover || settings.click) {\n                interactive = true;\n                /* fill the grid with empty state */\n\n                gx = ngx + 1;\n\n                while (gx--) {\n                  infoGrid[gx] = [];\n                }\n\n                if (settings.hover) {\n                  canvas.addEventListener('mousemove', wordcloudhover);\n                }\n\n                if (settings.click) {\n                  canvas.addEventListener('click', wordcloudclick);\n                  canvas.addEventListener('touchstart', wordcloudclick);\n                  canvas.addEventListener('touchend', function (e) {\n                    e.preventDefault();\n                  });\n                  canvas.style.webkitTapHighlightColor = 'rgba(0, 0, 0, 0)';\n                }\n\n                canvas.addEventListener('wordcloudstart', function stopInteraction() {\n                  canvas.removeEventListener('wordcloudstart', stopInteraction);\n                  canvas.removeEventListener('mousemove', wordcloudhover);\n                  canvas.removeEventListener('click', wordcloudclick);\n                  hovered = undefined;\n                });\n              }\n\n              i = 0;\n              var loopingFunction, stoppingFunction;\n              var layouting = true;\n\n              if (!settings.layoutAnimation) {\n                loopingFunction = function loopingFunction(cb) {\n                  cb();\n                };\n\n                stoppingFunction = function stoppingFunction() {\n                  layouting = false;\n                };\n              } else if (settings.wait !== 0) {\n                loopingFunction = window.setTimeout;\n                stoppingFunction = window.clearTimeout;\n              } else {\n                loopingFunction = window.setImmediate;\n                stoppingFunction = window.clearImmediate;\n              }\n\n              var addEventListener = function addEventListener(type, listener) {\n                elements.forEach(function (el) {\n                  el.addEventListener(type, listener);\n                }, this);\n              };\n\n              var removeEventListener = function removeEventListener(type, listener) {\n                elements.forEach(function (el) {\n                  el.removeEventListener(type, listener);\n                }, this);\n              };\n\n              var anotherWordCloudStart = function anotherWordCloudStart() {\n                removeEventListener('wordcloudstart', anotherWordCloudStart);\n                stoppingFunction(timer);\n              };\n\n              addEventListener('wordcloudstart', anotherWordCloudStart); // At least wait the following code before call the first iteration.\n\n              var timer = (settings.layoutAnimation ? loopingFunction : setTimeout)(function loop() {\n                if (!layouting) {\n                  return;\n                }\n\n                if (i >= settings.list.length) {\n                  stoppingFunction(timer);\n                  sendEvent('wordcloudstop', false);\n                  removeEventListener('wordcloudstart', anotherWordCloudStart);\n                  return;\n                }\n\n                escapeTime = new Date().getTime();\n                var drawn = putWord(settings.list[i]);\n                var canceled = !sendEvent('wordclouddrawn', true, {\n                  item: settings.list[i],\n                  drawn: drawn\n                });\n\n                if (exceedTime() || canceled) {\n                  stoppingFunction(timer);\n                  settings.abort();\n                  sendEvent('wordcloudabort', false);\n                  sendEvent('wordcloudstop', false);\n                  removeEventListener('wordcloudstart', anotherWordCloudStart);\n                  return;\n                }\n\n                i++;\n                timer = loopingFunction(loop, settings.wait);\n              }, settings.wait);\n            }; // All set, start the drawing\n\n\n            start();\n          };\n\n          WordCloud.isSupported = isSupported;\n          WordCloud.minFontSize = minFontSize;\n          /* harmony default export */\n\n          var layout = WordCloud;\n          ; // CONCATENATED MODULE: ./src/wordCloud.js\n\n          if (!layout.isSupported) {\n            throw new Error('Sorry your browser not support wordCloud');\n          } // https://github.com/timdream/wordcloud2.js/blob/c236bee60436e048949f9becc4f0f67bd832dc5c/index.js#L233\n\n\n          function updateCanvasMask(maskCanvas) {\n            var ctx = maskCanvas.getContext('2d');\n            var imageData = ctx.getImageData(0, 0, maskCanvas.width, maskCanvas.height);\n            var newImageData = ctx.createImageData(imageData);\n            var toneSum = 0;\n            var toneCnt = 0;\n\n            for (var i = 0; i < imageData.data.length; i += 4) {\n              var alpha = imageData.data[i + 3];\n\n              if (alpha > 128) {\n                var tone = imageData.data[i] + imageData.data[i + 1] + imageData.data[i + 2];\n                toneSum += tone;\n                ++toneCnt;\n              }\n            }\n\n            var threshold = toneSum / toneCnt;\n\n            for (var i = 0; i < imageData.data.length; i += 4) {\n              var tone = imageData.data[i] + imageData.data[i + 1] + imageData.data[i + 2];\n              var alpha = imageData.data[i + 3];\n\n              if (alpha < 128 || tone > threshold) {\n                // Area not to draw\n                newImageData.data[i] = 0;\n                newImageData.data[i + 1] = 0;\n                newImageData.data[i + 2] = 0;\n                newImageData.data[i + 3] = 0;\n              } else {\n                // Area to draw\n                // The color must be same with backgroundColor\n                newImageData.data[i] = 255;\n                newImageData.data[i + 1] = 255;\n                newImageData.data[i + 2] = 255;\n                newImageData.data[i + 3] = 255;\n              }\n            }\n\n            ctx.putImageData(newImageData, 0, 0);\n          }\n\n          external_echarts_.registerLayout(function (ecModel, api) {\n            ecModel.eachSeriesByType('wordCloud', function (seriesModel) {\n              var gridRect = external_echarts_.helper.getLayoutRect(seriesModel.getBoxLayoutParams(), {\n                width: api.getWidth(),\n                height: api.getHeight()\n              });\n              var data = seriesModel.getData();\n              var canvas = document.createElement('canvas');\n              canvas.width = gridRect.width;\n              canvas.height = gridRect.height;\n              var ctx = canvas.getContext('2d');\n              var maskImage = seriesModel.get('maskImage');\n\n              if (maskImage) {\n                try {\n                  ctx.drawImage(maskImage, 0, 0, canvas.width, canvas.height);\n                  updateCanvasMask(canvas);\n                } catch (e) {\n                  console.error('Invalid mask image');\n                  console.error(e.toString());\n                }\n              }\n\n              var sizeRange = seriesModel.get('sizeRange');\n              var rotationRange = seriesModel.get('rotationRange');\n              var valueExtent = data.getDataExtent('value');\n              var DEGREE_TO_RAD = Math.PI / 180;\n              var gridSize = seriesModel.get('gridSize');\n              layout(canvas, {\n                list: data.mapArray('value', function (value, idx) {\n                  var itemModel = data.getItemModel(idx);\n                  return [data.getName(idx), itemModel.get('textStyle.fontSize', true) || external_echarts_.number.linearMap(value, valueExtent, sizeRange), idx];\n                }).sort(function (a, b) {\n                  // Sort from large to small in case there is no more room for more words\n                  return b[1] - a[1];\n                }),\n                fontFamily: seriesModel.get('textStyle.fontFamily') || seriesModel.get('emphasis.textStyle.fontFamily') || ecModel.get('textStyle.fontFamily'),\n                fontWeight: seriesModel.get('textStyle.fontWeight') || seriesModel.get('emphasis.textStyle.fontWeight') || ecModel.get('textStyle.fontWeight'),\n                gridSize: gridSize,\n                ellipticity: gridRect.height / gridRect.width,\n                minRotation: rotationRange[0] * DEGREE_TO_RAD,\n                maxRotation: rotationRange[1] * DEGREE_TO_RAD,\n                clearCanvas: !maskImage,\n                rotateRatio: 1,\n                rotationStep: seriesModel.get('rotationStep') * DEGREE_TO_RAD,\n                drawOutOfBound: seriesModel.get('drawOutOfBound'),\n                layoutAnimation: seriesModel.get('layoutAnimation'),\n                shuffle: false,\n                shape: seriesModel.get('shape')\n              });\n\n              function onWordCloudDrawn(e) {\n                var item = e.detail.item;\n\n                if (e.detail.drawn && seriesModel.layoutInstance.ondraw) {\n                  e.detail.drawn.gx += gridRect.x / gridSize;\n                  e.detail.drawn.gy += gridRect.y / gridSize;\n                  seriesModel.layoutInstance.ondraw(item[0], item[1], item[2], e.detail.drawn);\n                }\n              }\n\n              canvas.addEventListener('wordclouddrawn', onWordCloudDrawn);\n\n              if (seriesModel.layoutInstance) {\n                // Dispose previous\n                seriesModel.layoutInstance.dispose();\n              }\n\n              seriesModel.layoutInstance = {\n                ondraw: null,\n                dispose: function dispose() {\n                  canvas.removeEventListener('wordclouddrawn', onWordCloudDrawn); // Abort\n\n                  canvas.addEventListener('wordclouddrawn', function (e) {\n                    // Prevent default to cancle the event and stop the loop\n                    e.preventDefault();\n                  });\n                }\n              };\n            });\n          });\n          external_echarts_.registerPreprocessor(function (option) {\n            var series = (option || {}).series;\n            !external_echarts_.util.isArray(series) && (series = series ? [series] : []);\n            var compats = ['shadowColor', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY'];\n            external_echarts_.util.each(series, function (seriesItem) {\n              if (seriesItem && seriesItem.type === 'wordCloud') {\n                var textStyle = seriesItem.textStyle || {};\n                compatTextStyle(textStyle.normal);\n                compatTextStyle(textStyle.emphasis);\n              }\n            });\n\n            function compatTextStyle(textStyle) {\n              textStyle && external_echarts_.util.each(compats, function (key) {\n                if (textStyle.hasOwnProperty(key)) {\n                  textStyle['text' + external_echarts_.format.capitalFirst(key)] = textStyle[key];\n                }\n              });\n            }\n          });\n          ; // CONCATENATED MODULE: ./index.js\n\n          /***/\n        },\n\n        /***/\n        \"echarts/lib/echarts\":\n        /*!**************************!*\\\n          !*** external \"echarts\" ***!\n          \\**************************/\n\n        /***/\n        function echartsLibEcharts(module) {\n          module.exports = __WEBPACK_EXTERNAL_MODULE_echarts_lib_echarts__;\n          /***/\n        }\n        /******/\n\n      };\n      /************************************************************************/\n\n      /******/\n      // The module cache\n\n      /******/\n\n      var __webpack_module_cache__ = {};\n      /******/\n\n      /******/\n      // The require function\n\n      /******/\n\n      function __webpack_require__(moduleId) {\n        /******/\n        // Check if module is in cache\n\n        /******/\n        if (__webpack_module_cache__[moduleId]) {\n          /******/\n          return __webpack_module_cache__[moduleId].exports;\n          /******/\n        }\n        /******/\n        // Create a new module (and put it into the cache)\n\n        /******/\n\n\n        var module = __webpack_module_cache__[moduleId] = {\n          /******/\n          // no module.id needed\n\n          /******/\n          // no module.loaded needed\n\n          /******/\n          exports: {}\n          /******/\n\n        };\n        /******/\n\n        /******/\n        // Execute the module function\n\n        /******/\n\n        __webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n        /******/\n\n        /******/\n        // Return the exports of the module\n\n        /******/\n\n\n        return module.exports;\n        /******/\n      }\n      /******/\n\n      /************************************************************************/\n\n      /******/\n\n      /* webpack/runtime/make namespace object */\n\n      /******/\n\n\n      (function () {\n        /******/\n        // define __esModule on exports\n\n        /******/\n        __webpack_require__.r = function (exports) {\n          /******/\n          if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n            /******/\n            Object.defineProperty(exports, Symbol.toStringTag, {\n              value: 'Module'\n            });\n            /******/\n          }\n          /******/\n\n\n          Object.defineProperty(exports, '__esModule', {\n            value: true\n          });\n          /******/\n        };\n        /******/\n\n      })();\n      /******/\n\n      /************************************************************************/\n\n      /******/\n      // module exports must be returned from runtime so entry inlining is disabled\n\n      /******/\n      // startup\n\n      /******/\n      // Load entry module and return exports\n\n      /******/\n\n\n      return __webpack_require__(\"./index.js\");\n      /******/\n    }()\n  );\n});","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA,sKACAA,6CADA,KAEA,gDACAC,6BADA,KAEA,oFACAC,2DADA,KAGAC;AACC,CATD,EASCC,IATD,EASC;AACD;;;;;;;;;;;;;;;;;;;;;;;;;;ACRAC,8CAAyB;AAEzBC,oCAFyB;AAIzBC,8CAJyB;AAKzBC;AACA;AACAC;AADA;AAGK,aAToB;AAUzBC,kCAVyB;AAYzBC;AACA;AACAC;AACK,aAfoB;AAiBzBC;AACA,+BAAyBR,0CAA+BO,WAA/B,EAA+B;AACxDE;AADwD,eAA/B,CAAzB;AAGA,6BAAuBT,sBAAvB,CAAmCU,UAAnC,EAAmC,IAAnC;AACAC;AACA;AACK,aAxBoB;AA0BzB;AACAC;AAEAC,6BAFA;AAIA;AACAC,6BALA;AAOAC,4BAPA;AASAC,2BATA;AAWAC,0BAXA;AAaAC,2BAbA;AAeAC,iCAfA;AAiBAC,sCAjBA;AAmBAC,8BAnBA;AAqBAC,yBArBA;AAuBAC,mCAvBA;AAyBAC;AACAC;AADA;AAzBA;AA3ByB,WAAzB;;;ACAAzB,4CAAuB;AAEvBC,6BAFuB;AAIvByB;AACA;AACAC;AAEA;AAEA;;AAEAC;AACA;AACA;AAEA,iCAA6B5B,8BAA7B,CAAiD;AACjD6B,yBAAuB7B,yCAA8B8B,cAA9B,CAD0B;AAEjDC,2CAFiD;AAGjDC,2CAHiD;AAIjDC,8DAJiD;AAKjDC,8DALiD;AAMjDC;AANiD,iBAAjD;AAQAC;AACAH,+CADA;AAEAC,4DAFA;AAGAG,4BAHA;AAIAC,yCAJA;AAKAlC,iEALA;AAMAmC;AANA;AASAZ;AAEAa;AAEAJ,uDAAmDpC,yCAA8ByC,6CAA9B,EAA8B;AACjFC;AADiF,iBAA9B,CAAnD;AAGAN,mDAA+CpC,yCAA8ByC,yCAA9B,EAA8B;AAC7EC;AAD6E,iBAA9B,CAA/C;AAIY1C,6DACZoC,MADY,EAEZK,oCAFY,EAGZA,wCAHY;AAMZL;AACAO,8GADA;AAEAC;AAFA,kBAtCA,CA0CA;;AACAR;AACA,eA5CA;;AA8CA;AACK,aA3DkB;AA6DvBS;AACA;;AAEA;AACK,aAjEkB;AAmEvBC;AACA;AACA;AArEuB,WAAvB;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;;AACA;AACAC;AACA,8CACAA,yBADA,IAEAA,sBAFA,IAGAA,oBAHA,IAIA;AACA;AACA;AACA;;AAEA;AACA,qDANA,CAQA;AACA;AACA;;AACA;AACA;AACAC;AACAD;AAEA;AACA,iBANA;;AAQAA;AACA;AACA;AACA,sDACAE;AAAA;AACA;AAFA,oBAEA;AACA;AACA;;AAEAA;AAEA;;AACA;AACA;AACA;;AAEAD;AACAA;AACO,iBAlBP,EAkBO,IAlBP;AAoBA;;AACAD;AACA;AACA;AACA;;AAEAC;AACA,iBANA;;AAQA;AACK,eAjDL,EAJA,IAsDA;AACA;AACAD;AACA,eAzDA;AA0DG,aA3DH;AA4DA;;AAEA;AACAA;AACA,gDACAA,2BADA,IAEAA,wBAFA,IAGAA,sBAHA,IAIA;AACA;AACA;AACAA;AACA,eARA;AASG,aAVH;AAWA,YAEA;;;AACA;AACA;;AACA;AACA;AACA;;AAEA;;AACA;AACA;AACA;;AACA;AACA;AACA;;AAEA;AACA;AACA;;AACA;AACA;AACA;;AAEA;AACG,WAtBH,IAwBA;AACA;;;AACA;AACA;AACA;AACA;;AAEA,wEALA,CAOA;;AACA,0BARA,CAUA;;AACA;;AAEA;AACAG;;AACA,kEACAA,qCADA,EACA;AACA;AACA;;AAEAC;AACAC;AAEAC;AACA;;AAEA;AACG,WA3BH,IA6BA;;;AACA;AACA,2CAAkCC,CAAlC,EACAC,mCACAtB,YADA,EACAuB,eADA,EAEAA,UAHA,EAGA;;AACA;AACA,WANA;;AAQA;AACA;AACA;AACA;;AAEA;AACAC;AACA;;AAEAA;AACA;AACAA;;AACA;AACA;AACA;AACO,eALP,MAKO;AACP;AACA;AACK,aATL;AAWA;;AACA;AACA9C,sBADA;AAEA+C,oEACA,uDAHA;AAIAjC,kCAJA;AAKAkC,kCALA;AAMAC,wBANA;AAMA;AACAC,6BAPA;AAQAC,+BARA;AASAC,qCATA;AASA;AAEAzC,yBAXA;AAYAC,mCAZA;AAaAyC,0BAbA;AAeAC,6BAfA;AAgBAC,4CAhBA;AAiBAC,+BAjBA;AAmBAC,mCAnBA;AAqBAC,qBArBA;AAsBAC,+BAtBA;AAsBA;AACAC,sCAA+B,CAvB/B;AAyBAC,uCAzBA;AA0BAC,sCA1BA;AA2BApD,+BA3BA;AA6BAqD,2BA7BA;AA8BAC,8BA9BA;AAgCA7D,6BAhCA;AAiCA8D,+BAjCA;AAmCAC,2BAnCA;AAqCAC,yBArCA;AAsCAC;AAtCA;;AAyCA;AACA;AACA;AACAC;AACA;AACA;AACA;AAEA;;;AACA;AACA;;AACAA;AACA,mCADA,CAC2B;AAC3B,eAFA;AAGA;AAEA;;;AACA;AACA;AACA;AACA;;AACA;AACA;AACAA;AACA;;AAEA;AACAA;AACA;AACA,mBAFA;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACAA;AACA;AACA;AACA,mBAHA;;AAIA;;AAEA;AACA;AACA;AACA;AACAA;AACA;AACA,uDACAC,mCADA;AAEA,mBAJA;;AAKA;;AAEA;AACA;AACAD;AACA;AACA,uDACAC,mCADA;AAEA,mBAJA;;AAKA;;AAEA;AACAD;AACA;AACA,uDACA,+BADA;AAEA,mBAJA;;AAKA;;AAEA;AACAA;AACA;;AACA;AACA,4EACA,iDADA;AAEa,qBAHb,MAGa;AACb,yDACA,8BADA;AAEA;AACA,mBATA;;AAUA;AAzEA;AA2EA;AAEA;;;AACAA;AAEA;;AACA;AACA;AAEA;;AACA;AACA;AACA;AAEA;;AACA;AACAE,eADA,EACAC,GADA,EACA;AACAC,kBAFA,EAEA;AACAC,qBAHA;AAKA;;AACA;AAEA;;AACA;;AACA;AACA,8BACA,+BADA,GACA,GADA,GAEA,mCAFA,GAEA,IAFA,GAGA,6CAHA,GAGA,IAHA;AAIA;;AACA;AACA;AACAC;AACA;AACA,iBAFA;;AAGA;;AAEA;AACAA;AACA;AACA,iBAFA;;AAGA;;AAEA;AACA;AACAA;AACA;;AACA;AAjBA;AAoBA;;;AACA;;AACA;AACAC;AACA;AAEA;;;AACA;AACA;AACA;;AAEA,iDACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACAC;AACAC;AACO,eAHP,MAGO;AACPD;AACAC;AACA;;AACA;AACA;AAEA;AACA;AAEA;AACA,aArBA;;AAuBA;AACA;;AAEA;AACA;AACA;;AAEAC;;AACA;AACAV;AAEA;AACA;;AAEAA;AAEA,aAhBA;;AAkBA;AACA;;AACA;AACA;AACA;;AAEAA;AACA/B;AACA,aARA;AAUA;;;AACA;;AACA;AACA;AACA;AACA,eAHA,CAKA;;;AACA,iCANA,CAQA;;AACA;AACA;;AAEA;AACA0C;AACA;;AAEA;AACA;AACA;;AACA;AACAC,2DADA,CACmD;AACnD,iBALA,CAOA;;;AACAD,6BACAP,wDADA,EAEAA,2DACAJ,oBAHA,EAIAa,mBAJA;AAKA;;AAEAC;AACA;AACA,aAjCA;AAmCA;;;AACA;AACA,oDACA,2DADA;AAEA,aAHA;AAKA;;;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAdA;;AAgBA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA,eARA,CAUA;AACA;AACA;;;AACA;;AACA;AACAC;AACA;;AACA;AACAA;AACA;;AACA;AACS,iBANT;AAOA;;AAEA;AACA;AAA2CC;AAA3C;AAEAC,sDACA,4BADA,GACA,KADA,GACAjB,mBADA,CA3BA,CA8BA;;AACA;AACA,+CACAiB,2BADA,EAEAA,gCAFA,IAEAF,EAFA,CAhCA,CAoCA;AACA;;AACA;AACA;AACA;AACA;AACAG;AACAC,kCA3CA,CA6CA;AACA;AAEA;;AACA,4CAjDA,CAkDA;AACA;AACA;;AACA,8CArDA,CAuDA;;AACA,8EACAA,yCADA,IACAC,CADA;AAEA,8EACAD,yCADA,IACAC,CADA;AAEA;AACA;AAEAC;AACAA;;AAEA;AACA;AACAC,mDAFA,CAGA;;AACAL;AACA,eAvEA,CAyEA;;;AACAA;AACAA;AACAA,sCA5EA,CA8EA;AACA;;AACAA,sDACA,4BADA,GACA,KADA,GACAjB,mBADA,CAhFA,CAmFA;AACA;AACA;AACA;AACA;AACA;;AACAiB;AACAA;AACAA,wDACA,uCADA,EA3FA,CA8FA;;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACAA,sDACAM,eADA,EACAC,OADA,EACAC,OADA;AAEAR;AACA,eA1GA,CA4GA;;;AACA;AACA;AAAA;AAAA;AAAA;AACA;;AACA;AACAS;;AACA;AACAxE;;AACAyE;AACA;AACA1E;;AACA;AACA,+DACA2E,UADA,KACA,CADA,GACA,CADA,GACA;AACAC;;AAEA;AACAC;AACA;;AACA;AACAA;AACA;;AACA;AACAA;AACA;;AACA;AACAA;AACA;;AAEA;AACAb;AACAA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACAA;AACAA;AACA;AACA;AACA;AACA;;AAEA;AACAA;AACAA,6CACAa,aADA,EAEA,+BAFA,EAGA,+BAHA;AAIA,eA/JA,CAiKA;;;AACA;AACAf,sBADA;AAEAc,kCAFA;AAGAC,8BAHA;AAIAC,uBAJA;AAKAC,uBALA;AAMAC,gDANA;AAOAV,gDAPA;AAQAW,iCARA;AASAC,kCATA;AAUA5E;AAVA;AAYA,aA9KA;AAgLA;;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AACA;AACA;;AAEA;AACA;AACA;AACA;;AACA;AACA,aApBA;AAsBA;;;AACA,yEACA6E,QADA,EACAC,KADA,EACAC,SADA,EACAC,UADA,EACA;AAEA;AACA;;AACA;AACA5D;AACO,eAFP,MAEO;AACPA;AACA;;AAEA;;AACA;AACAkB;AACO,eAFP,MAEO;AACPA;AACA;;AAEA;AACA;AACA2C;AACAvF,uCADA;AAEAC,uCAFA;AAGAuF,kDAHA;AAIAC;AAJA;AAOAjE;AACA;AACA;AACA,mCAFA,CAIA;;AACAP;AACAA;AAEAA,yDACA,4BADA,GACA,KADA,GACA8B,mBADA;AAEA9B,wCAVA,CAYA;AACA;;AACAA,6DACA,2BADA;;AAGA;AACAA;AACA,mBAnBA,CAqBA;AAEA;AACA;AACA;AACA;AACA;;;AACAA;AACAA,gEACA,4CADA,EA7BA,CAgCA;;AACA;AACA;AAEA;;AACAA;AACS,iBAtCT,MAsCS;AACT;AACA;AACA;AACAyE;;AACA;AACAA,qCACA,mDACA,QADA,GACA,WADA,GACA,GAFA;AAGA;;AACA;AACA,0CADA;AAEA,sCAFA;AAGA,wDACApF,kBADA,GACA,KADA,GACAyC,mBAJA;AAKA,gFALA;AAMA,+EANA;AAOA,sDAPA;AAQA,wDARA;AASA,iDATA;AAUA,0CAVA;AAWA,8CAXA;AAYA,oDAZA;AAaA,gDAbA;AAcA,gDAdA;AAeA,sDAfA;AAgBA;AAhBA;;AAkBA;AACA4C;AACA;;AACAC;;AACA;AACAA;AACA;;AACA;AACA;AACAA;AACA;AACA;;AACA;AACAA;AACA;;AACAC;AACA;AACO,eApFP;AAqFA,aAhHA;AAkHA;;;AACA;AACA;AACA;AACA;;AAEAC;;AAEA;AACA;AACA7E;AACA;;AAEA;AACA8E;AAA0BC,4BAA1B;AAA0BT;AAA1B;AACA;AACA,aAfA;AAiBA;AACA;;;AACA;AACA;AACA;AACA;;AACA;AACAtE;AACAA;AACAA;AACA;;AAEA;;AACA;AACA;AACAsE;AACAvF,yCADA;AAEAC,yCAFA;AAGAuF,oDAHA;AAIAC;AAJA;AAMA;;AAEA;;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEAQ;AACA;;AAEA;AACAhF;AACA;AACA,aApCA;AAsCA;AACA;AACA;;;AACA;AACA;;AACA;AACAiF;AACAC;AACO,eAHP,MAGO;AACPD;AACAC;AACAb;AACA;;AACA,6CAVA,CAYA;;AACA,8DAbA,CAeA;;AACA;AACA;AACA;;AAEA;AACA;AACA,eAtBA,CAwBA;AACA;AACA;;;AACA;AACA;;AACA,uDACAT,+BADA,EACA;AACA;AACA;AACA,eAjCA,CAmCA;AACA;;;AACA;;AAEA;AACA;AACA;AACA;AACA,iCAJA,CAMA;AACA;;AACA;AACA;AACA,iBAVA,CAYA;;;AACAuB,qDACAhD,aADA,EACAiD,MADA,EACAhB,SADA,EACAC,UADA,EAbA,CAgBA;;AACAgB;AAEA;AACA3B,wBADA;AAEAF,wBAFA;AAGA8B,gCAHA;AAIAC;AAJA;AAMA,eAzBA;;AA2BA;AACA;;AAEA;AACA9C;AACA+C;AACA,iBANA,CAQA;AACA;AACA;;;AACA,gCAAuBpF,iBAAvB,EAA0CA,GAA1C,EAA0C;AAC1C;;AACA;AACA;AACA;AACA,iBAhBA,CAkBA;AACA;AACA;AACA;AACA;;AACA,eAzFA,CA0FA;;;AACA;AACA,aA5FA;AA8FA;AACA;;;AACA;AACA;AACA;AACA;AACAL;AACA;AACS,iBAJT,EAIS,IAJT;AAKO,eANP,MAMO;AACPQ;AACA;AACAR;AACA6E;AACS,iBAJT,EAIS,IAJT;AAKA;AACA,aAdA;AAgBA;;;AACA;AACA;AACA;AACA;;AAEA;AACA5C;AACAC;AACO,eAHP,MAGO;AACP;AACAD;AACAC;AACA,eAZA,CAcA;AACA;;;AACA;AACA;AACA,eAlBA,CAoBA;;;AACAC,yCACA,gDADA,GAEA,kBAFA,CArBA,CAyBA;;AACAC;AAEA;AACA;;AACA0C;AAEA;;AACA;AACAtE;AACA;AACA;AACAP;AACAA;AACAA;AACW,mBALX,MAKW;AACX4E;AACAA;AACAA;AACA;AACS,iBAXT;AAaA;;AACAlB;;AACA;AACAmB;AACArB;;AACA;AACAqB;AACA;AACA;AACO,eAvBP,MAuBO;AACP;AACA;AACA;AAEAY;AACAA;AACA;AAEA;AACA;AACA;;AACA,gCACAC,iEADA;AAGAhC;AACA;;AACA;AACAmB;AACArB;;AACA;AACAxE;;AACAyE;AACA1E;;AACA;AACAqB;;AACA;AACA,mEACAsD,UADA,KACA,CADA,GACAtD,CADA,MACAuF,UADA,EACA;AACAd;AACA;AACA;AACA;AACA;AACA;;AACA;AACAA;AACA;AACA;AACA;;AAEAe;AACA,eAlGA,CAoGA;;;AACA;AAEAC;AAEA;;AACAnC;;AACA;AACAoB;AACA;;AAEA;AACAY;AACA;;AAEA;AACAA;AACAA;AACAA;AACAI;AACW,mBAFX;AAGAJ;AACA;;AAEAA;AACAA;AAEAA;AACAA;AACAlD;AACS,iBANT;AAOA;;AAEApC;AACA;AACA;;AACA;AACA2F;AACAC;AACA,iBAFA;;AAGAC;AACAC;AACA,iBAFA;AAGA,eAPA,MAQA;AACAH;AACAE;AACO,eAHP,MAGO;AACPF;AACAE;AACA;;AAEA;AACA1F;AACAqE;AACS,iBAFT,EAES,IAFT;AAGA,eAJA;;AAMA;AACArE;AACAqE;AACS,iBAFT,EAES,IAFT;AAGA,eAJA;;AAMA;AACAuB;AACAF;AACA,eAHA;;AAKAG,wEAzKA,CA2KA;;AACA;AACA;AACA;AACA;;AACA;AACAH;AACAI;AACAF;AAEA;AACA;;AACAG;AACA;AACA;AACAvB,wCADA;AACAwB;AADA;;AAEA;AACAN;AACAnE;AACAuE;AACAA;AACAF;AACA;AACA;;AACA/F;AACAoG;AACO,eAzBP,EAyBO1E,aAzBP;AA0BA,aAtMA,CAhzBA,CAw/BA;;;AACA2E;AACA,WA1/BA;;AA4/BAC;AACAA;AAEE;;AAAA,uBAAeA,SAAf;;;ACjpCF,eAAKC,kBAAL,EAAsC;AACtC;AACA,YAEA;;;AACA;AACA;AACA,6CACA,CADA,EACA,CADA,EACAC,gBADA,EACAA,iBADA;AAEA;AAEA;AACA;;AACA,4BAAmBxG,yBAAnB,EAA8CA,MAA9C,EAA8C;AAC9C;;AACA;AACA,+CACAwF,qBADA,GAEAA,qBAFA;AAGAiB;AACA;AACA;AACA;;AACA;;AAEA,4BAAmBzG,yBAAnB,EAA8CA,MAA9C,EAA8C;AAC9C,6CACAwF,qBADA,GAEAA,qBAFA;AAGA;;AAEA;AACA;AACAkB;AACAA;AACAA;AACAA;AACA,eANA,MAOA;AACA;AACA;AACAA;AACAA;AACAA;AACAA;AACA;AACA;;AAEA9G;AACA;;AAEAlD,2CAAsB;AACtBiK;AACA,6BAAuBjK,uCACvB4B,gCADuB,EACvB;AACAX,qCADA;AAEAC;AAFA,eADuB,CAAvB;AAMA;AAEA;AACA0H;AACAA;AAEA;AACA;;AACA;AACA;AACA1F;AACAgH;AACA,iBAHA,CAIA;AACAC;AACAA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACQN,oBAAqB;AAC7BlJ;AACA;AACA,0BACA6B,iBADA,EAEAC,6CAC2BzC,mCAAwBoK,KAAxB,EAAwBC,WAAxB,EAAwBlJ,SAAxB,CAH3B,EAIAmJ,GAJA;AAMa,iBARb,EAQaC,IARb,CAQa;AACb;AACA;AACa,iBAXb,CAD6B;AAa7B7G,uEACA9B,gDADA,IAEAqI,mCAf6B;AAgB7BxI,uEACAG,gDADA,IAEAqI,mCAlB6B;AAoB7B3I,kCApB6B;AAsB7BsD,6DAtB6B;AAwB7BJ,6DAxB6B;AAyB7BC,6DAzB6B;AA2B7BX,uCA3B6B;AA6B7Ba,8BA7B6B;AA+B7BtD,6EA/B6B;AAiC7BE,iEAjC6B;AAmC7B6C,mEAnC6B;AAqC7BM,8BArC6B;AAuC7B5D;AAvC6B,gBAArB;;AA0CR;AACA;;AACA;AACAkI;AACAA;AACApH,oDACAqG,OADA,EACAA,OADA,EACAA,OADA,EACAe,cADA;AAGA;AACA;;AAEAJ;;AAEA;AACA;AACAhH;AACA;;AAEAA;AACA4I,4BADA;AAGA1H;AACA8F,iFADA,CAEA;;AACAA;AACA;AACAI;AACiB,mBAHjB;AAIA;AAVA;AAYK,aAxGL;AAyGC,WA1GD;AA4GAhJ,iDAA4B;AAC5B,wCAA8ByK,MAA9B;AACA,aAAKzK,+BAAoByK,MAApB,CAAL,KAAyBA,+BAAzB;AAEA;AAEIzK,wCAAiByK,MAAjB,EAAiB;AACrB;AACA;AAEAC;AACAA;AACA;AACK,aAPD;;AASJ;AACAlJ,2BAAqBxB,4BAAiB2K,OAAjB,EAAiB;AACtC;AACAnJ,qCAAmCxB,sCAA2B4K,GAA3B,CAAnC,IAA8DpJ,cAA9D;AACA;AACS,eAJY,CAArB;AAKA;AACC,WAtBD;;;;;;;;;;;;;;ACtKA7B;;;;;;;;;ACAA;;;;AACA;;;;AAEA;;;;AACA;;AACA;;;AACA;;AACA;;AACA;;AACA;;;;;AACA;;AACA;;;AACA;;;AACAE;;;AAHA;;;;AAMA;;;;AACAgL;;;;AAEA;;;;;AACA;;AACA;;;;;;;;;;;;;;ACrBA;;;AACAC;;AACA;;AACAC;AAAsDX;AAAtD;;AACA;;;;AACAW;AAA+CX;AAA/C;;AACA,SALA;;;;;;;;;ACDA;;;AACA;;;AACA;;;;;AACA;;;AROA;CAVA","names":["module","define","exports","root","self","external_echarts_","type","visualStyleAccessPath","visualStyleMapper","fill","visualDrawType","optionUpdated","option","getInitialData","coordDimensions","dimensions","list","defaultOption","maskImage","shape","left","top","width","height","sizeRange","rotationRange","rotationStep","gridSize","drawOutOfBound","textStyle","fontWeight","render","group","seriesModel","style","textStyleModel","scaleX","scaleY","x","y","rotation","textEl","text","verticalAlign","fontSize","data","itemModel","state","duration","easing","remove","dispose","window","callbacks","evt","ctx","hanWidth","mWidth","size","i","j","arr","elements","fontFamily","color","minSize","weightFactor","clearCanvas","backgroundColor","origin","drawMask","maskColor","maskGapWidth","layoutAnimation","wait","abortThreshold","abort","minRotation","maxRotation","shuffle","rotateRatio","ellipticity","classes","hover","click","settings","Math","ngx","ngy","center","maxRadius","getTextColor","getTextClasses","clientX","clientY","hovered","points","rx","t","pointsAtRadius","mu","willReadFrequently","fctx","boxWidth","boxHeight","g","fcanvas","document","fillTextOffsetY","fw","fh","gy","singleGridLoop","gx","occupied","bounds","gw","gh","fillTextOffsetX","fillTextWidth","fillTextHeight","distance","theta","rotateDeg","attributes","dimension","w","h","transformRule","styleRules","span","el","grid","infoGrid","item","fillGridAt","word","weight","drawText","gxy","updateGrid","rot","info","shuffleArray","bctx","canvas","bgPixel","imageData","interactive","e","loopingFunction","cb","stoppingFunction","layouting","removeEventListener","addEventListener","sendEvent","escapeTime","drawn","timer","start","WordCloud","layout","maskCanvas","toneSum","newImageData","ecModel","updateCanvasMask","console","value","valueExtent","idx","sort","ondraw","series","compatTextStyle","compats","key","__webpack_modules__","__webpack_require__","Object"],"sourceRoot":"","sources":["webpack://echarts-wordcloud/webpack/universalModuleDefinition","webpack://echarts-wordcloud/./src/WordCloudSeries.js","webpack://echarts-wordcloud/./src/WordCloudView.js","webpack://echarts-wordcloud/./src/layout.js","webpack://echarts-wordcloud/./src/wordCloud.js","webpack://echarts-wordcloud/external \"echarts\"","webpack://echarts-wordcloud/webpack/bootstrap","webpack://echarts-wordcloud/webpack/runtime/make namespace object","webpack://echarts-wordcloud/webpack/startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"echarts\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"echarts\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"echarts-wordcloud\"] = factory(require(\"echarts\"));\n\telse\n\t\troot[\"echarts-wordcloud\"] = factory(root[\"echarts\"]);\n})(self, function(__WEBPACK_EXTERNAL_MODULE_echarts_lib_echarts__) {\nreturn ","import * as echarts from 'echarts/lib/echarts';\n\necharts.extendSeriesModel({\n\n    type: 'series.wordCloud',\n\n    visualStyleAccessPath: 'textStyle',\n    visualStyleMapper: function (model) {\n        return {\n            fill: model.get('color')\n        };\n    },\n    visualDrawType: 'fill',\n\n    optionUpdated: function () {\n        var option = this.option;\n        option.gridSize = Math.max(Math.floor(option.gridSize), 4);\n    },\n\n    getInitialData: function (option, ecModel) {\n        var dimensions = echarts.helper.createDimensions(option.data, {\n            coordDimensions: ['value']\n        });\n        var list = new echarts.List(dimensions, this);\n        list.initData(option.data);\n        return list;\n    },\n\n    // Most of options are from https://github.com/timdream/wordcloud2.js/blob/gh-pages/API.md\n    defaultOption: {\n\n        maskImage: null,\n\n        // Shape can be 'circle', 'cardioid', 'diamond', 'triangle-forward', 'triangle', 'pentagon', 'star'\n        shape: 'circle',\n\n        left: 'center',\n\n        top: 'center',\n\n        width: '70%',\n\n        height: '80%',\n\n        sizeRange: [12, 60],\n\n        rotationRange: [-90, 90],\n\n        rotationStep: 45,\n\n        gridSize: 8,\n\n        drawOutOfBound: false,\n\n        textStyle: {\n            fontWeight: 'normal'\n        }\n    }\n});\n","import * as echarts from 'echarts/lib/echarts';\n\necharts.extendChartView({\n\n    type: 'wordCloud',\n\n    render: function (seriesModel, ecModel, api) {\n        var group = this.group;\n        group.removeAll();\n\n        var data = seriesModel.getData();\n\n        var gridSize = seriesModel.get('gridSize');\n\n        seriesModel.layoutInstance.ondraw = function (text, size, dataIdx, drawn) {\n            var itemModel = data.getItemModel(dataIdx);\n            var textStyleModel = itemModel.getModel('textStyle');\n\n            var textEl = new echarts.graphic.Text({\n                style: echarts.helper.createTextStyle(textStyleModel),\n                scaleX: 1 / drawn.info.mu,\n                scaleY: 1 / drawn.info.mu,\n                x: (drawn.gx + drawn.info.gw / 2) * gridSize,\n                y: (drawn.gy + drawn.info.gh / 2) * gridSize,\n                rotation: drawn.rot\n            });\n            textEl.setStyle({\n                x: drawn.info.fillTextOffsetX,\n                y: drawn.info.fillTextOffsetY + size * 0.5,\n                text: text,\n                verticalAlign: 'middle',\n                fill: data.getItemVisual(dataIdx, 'style').fill,\n                fontSize: size\n            });\n\n            group.add(textEl);\n\n            data.setItemGraphicEl(dataIdx, textEl);\n\n            textEl.ensureState('emphasis').style = echarts.helper.createTextStyle(itemModel.getModel(['emphasis', 'textStyle']), {\n                state: 'emphasis'\n            });\n            textEl.ensureState('blur').style = echarts.helper.createTextStyle(itemModel.getModel(['blur', 'textStyle']), {\n                state: 'blur'\n            });\n\n            echarts.helper.enableHoverEmphasis(\n                textEl,\n                itemModel.get(['emphasis', 'focus']),\n                itemModel.get(['emphasis', 'blurScope'])\n            );\n\n            textEl.stateTransition = {\n                duration: seriesModel.get('animation') ? seriesModel.get(['stateAnimation', 'duration']) : 0,\n                easing: seriesModel.get(['stateAnimation', 'easing'])\n            };\n            // TODO\n            textEl.__highDownDispatcher = true;\n        };\n\n        this._model = seriesModel;\n    },\n\n    remove: function () {\n        this.group.removeAll();\n\n        this._model.layoutInstance.dispose();\n    },\n\n    dispose: function () {\n        this._model.layoutInstance.dispose();\n    }\n});\n","/*!\n * wordcloud2.js\n * http://timdream.org/wordcloud2.js/\n *\n * Copyright 2011 - 2013 Tim Chien\n * Released under the MIT license\n */\n\n'use strict';\n\n// setImmediate\nif (!window.setImmediate) {\n  window.setImmediate = (function setupSetImmediate() {\n    return window.msSetImmediate ||\n    window.webkitSetImmediate ||\n    window.mozSetImmediate ||\n    window.oSetImmediate ||\n    (function setupSetZeroTimeout() {\n      if (!window.postMessage || !window.addEventListener) {\n        return null;\n      }\n\n      var callbacks = [undefined];\n      var message = 'zero-timeout-message';\n\n      // Like setTimeout, but only takes a function argument.  There's\n      // no time argument (always zero) and no arguments (you have to\n      // use a closure).\n      var setZeroTimeout = function setZeroTimeout(callback) {\n        var id = callbacks.length;\n        callbacks.push(callback);\n        window.postMessage(message + id.toString(36), '*');\n\n        return id;\n      };\n\n      window.addEventListener('message', function setZeroTimeoutMessage(evt) {\n        // Skipping checking event source, retarded IE confused this window\n        // object with another in the presence of iframe\n        if (typeof evt.data !== 'string' ||\n            evt.data.substr(0, message.length) !== message/* ||\n            evt.source !== window */) {\n          return;\n        }\n\n        evt.stopImmediatePropagation();\n\n        var id = parseInt(evt.data.substr(message.length), 36);\n        if (!callbacks[id]) {\n          return;\n        }\n\n        callbacks[id]();\n        callbacks[id] = undefined;\n      }, true);\n\n      /* specify clearImmediate() here since we need the scope */\n      window.clearImmediate = function clearZeroTimeout(id) {\n        if (!callbacks[id]) {\n          return;\n        }\n\n        callbacks[id] = undefined;\n      };\n\n      return setZeroTimeout;\n    })() ||\n    // fallback\n    function setImmediateFallback(fn) {\n      window.setTimeout(fn, 0);\n    };\n  })();\n}\n\nif (!window.clearImmediate) {\n  window.clearImmediate = (function setupClearImmediate() {\n    return window.msClearImmediate ||\n    window.webkitClearImmediate ||\n    window.mozClearImmediate ||\n    window.oClearImmediate ||\n    // \"clearZeroTimeout\" is implement on the previous block ||\n    // fallback\n    function clearImmediateFallback(timer) {\n      window.clearTimeout(timer);\n    };\n  })();\n}\n\n  // Check if WordCloud can run on this browser\n  var isSupported = (function isSupported() {\n    var canvas = document.createElement('canvas');\n    if (!canvas || !canvas.getContext) {\n      return false;\n    }\n\n    var ctx = canvas.getContext('2d');\n    if (!ctx.getImageData) {\n      return false;\n    }\n    if (!ctx.fillText) {\n      return false;\n    }\n\n    if (!Array.prototype.some) {\n      return false;\n    }\n    if (!Array.prototype.push) {\n      return false;\n    }\n\n    return true;\n  }());\n\n  // Find out if the browser impose minium font size by\n  // drawing small texts on a canvas and measure it's width.\n  var minFontSize = (function getMinFontSize() {\n    if (!isSupported) {\n      return;\n    }\n\n    var ctx = document.createElement('canvas').getContext('2d');\n\n    // start from 20\n    var size = 20;\n\n    // two sizes to measure\n    var hanWidth, mWidth;\n\n    while (size) {\n      ctx.font = size.toString(10) + 'px sans-serif';\n      if ((ctx.measureText('\\uFF37').width === hanWidth) &&\n          (ctx.measureText('m').width) === mWidth) {\n        return (size + 1);\n      }\n\n      hanWidth = ctx.measureText('\\uFF37').width;\n      mWidth = ctx.measureText('m').width;\n\n      size--;\n    }\n\n    return 0;\n  })();\n\n  // Based on http://jsfromhell.com/array/shuffle\n  var shuffleArray = function shuffleArray(arr) {\n    for (var j, x, i = arr.length; i;\n      j = Math.floor(Math.random() * i),\n      x = arr[--i], arr[i] = arr[j],\n      arr[j] = x) {}\n    return arr;\n  };\n\n  var WordCloud = function WordCloud(elements, options) {\n    if (!isSupported) {\n      return;\n    }\n\n    if (!Array.isArray(elements)) {\n      elements = [elements];\n    }\n\n    elements.forEach(function(el, i) {\n      if (typeof el === 'string') {\n        elements[i] = document.getElementById(el);\n        if (!elements[i]) {\n          throw 'The element id specified is not found.';\n        }\n      } else if (!el.tagName && !el.appendChild) {\n        throw 'You must pass valid HTML elements, or ID of the element.';\n      }\n    });\n\n    /* Default values to be overwritten by options object */\n    var settings = {\n      list: [],\n      fontFamily: '\"Trebuchet MS\", \"Heiti TC\", \"微軟正黑體\", ' +\n                  '\"Arial Unicode MS\", \"Droid Fallback Sans\", sans-serif',\n      fontWeight: 'normal',\n      color: 'random-dark',\n      minSize: 0, // 0 to disable\n      weightFactor: 1,\n      clearCanvas: true,\n      backgroundColor: '#fff',  // opaque white = rgba(255, 255, 255, 1)\n\n      gridSize: 8,\n      drawOutOfBound: false,\n      origin: null,\n\n      drawMask: false,\n      maskColor: 'rgba(255,0,0,0.3)',\n      maskGapWidth: 0.3,\n\n      layoutAnimation: true,\n\n      wait: 0,\n      abortThreshold: 0, // disabled\n      abort: function noop() {},\n\n      minRotation: - Math.PI / 2,\n      maxRotation: Math.PI / 2,\n      rotationStep: 0.1,\n\n      shuffle: true,\n      rotateRatio: 0.1,\n\n      shape: 'circle',\n      ellipticity: 0.65,\n\n      classes: null,\n\n      hover: null,\n      click: null\n    };\n\n    if (options) {\n      for (var key in options) {\n        if (key in settings) {\n          settings[key] = options[key];\n        }\n      }\n    }\n\n    /* Convert weightFactor into a function */\n    if (typeof settings.weightFactor !== 'function') {\n      var factor = settings.weightFactor;\n      settings.weightFactor = function weightFactor(pt) {\n        return pt * factor; //in px\n      };\n    }\n\n    /* Convert shape into a function */\n    if (typeof settings.shape !== 'function') {\n      switch (settings.shape) {\n        case 'circle':\n        /* falls through */\n        default:\n          // 'circle' is the default and a shortcut in the code loop.\n          settings.shape = 'circle';\n          break;\n\n        case 'cardioid':\n          settings.shape = function shapeCardioid(theta) {\n            return 1 - Math.sin(theta);\n          };\n          break;\n\n        /*\n        To work out an X-gon, one has to calculate \"m\",\n        where 1/(cos(2*PI/X)+m*sin(2*PI/X)) = 1/(cos(0)+m*sin(0))\n        http://www.wolframalpha.com/input/?i=1%2F%28cos%282*PI%2FX%29%2Bm*sin%28\n        2*PI%2FX%29%29+%3D+1%2F%28cos%280%29%2Bm*sin%280%29%29\n        Copy the solution into polar equation r = 1/(cos(t') + m*sin(t'))\n        where t' equals to mod(t, 2PI/X);\n        */\n\n        case 'diamond':\n        case 'square':\n          // http://www.wolframalpha.com/input/?i=plot+r+%3D+1%2F%28cos%28mod+\n          // %28t%2C+PI%2F2%29%29%2Bsin%28mod+%28t%2C+PI%2F2%29%29%29%2C+t+%3D\n          // +0+..+2*PI\n          settings.shape = function shapeSquare(theta) {\n            var thetaPrime = theta % (2 * Math.PI / 4);\n            return 1 / (Math.cos(thetaPrime) + Math.sin(thetaPrime));\n          };\n          break;\n\n        case 'triangle-forward':\n          // http://www.wolframalpha.com/input/?i=plot+r+%3D+1%2F%28cos%28mod+\n          // %28t%2C+2*PI%2F3%29%29%2Bsqrt%283%29sin%28mod+%28t%2C+2*PI%2F3%29\n          // %29%29%2C+t+%3D+0+..+2*PI\n          settings.shape = function shapeTriangle(theta) {\n            var thetaPrime = theta % (2 * Math.PI / 3);\n            return 1 / (Math.cos(thetaPrime) +\n                        Math.sqrt(3) * Math.sin(thetaPrime));\n          };\n          break;\n\n        case 'triangle':\n        case 'triangle-upright':\n          settings.shape = function shapeTriangle(theta) {\n            var thetaPrime = (theta + Math.PI * 3 / 2) % (2 * Math.PI / 3);\n            return 1 / (Math.cos(thetaPrime) +\n                        Math.sqrt(3) * Math.sin(thetaPrime));\n          };\n          break;\n\n        case 'pentagon':\n          settings.shape = function shapePentagon(theta) {\n            var thetaPrime = (theta + 0.955) % (2 * Math.PI / 5);\n            return 1 / (Math.cos(thetaPrime) +\n                        0.726543 * Math.sin(thetaPrime));\n          };\n          break;\n\n        case 'star':\n          settings.shape = function shapeStar(theta) {\n            var thetaPrime = (theta + 0.955) % (2 * Math.PI / 10);\n            if ((theta + 0.955) % (2 * Math.PI / 5) - (2 * Math.PI / 10) >= 0) {\n              return 1 / (Math.cos((2 * Math.PI / 10) - thetaPrime) +\n                          3.07768 * Math.sin((2 * Math.PI / 10) - thetaPrime));\n            } else {\n              return 1 / (Math.cos(thetaPrime) +\n                          3.07768 * Math.sin(thetaPrime));\n            }\n          };\n          break;\n      }\n    }\n\n    /* Make sure gridSize is a whole number and is not smaller than 4px */\n    settings.gridSize = Math.max(Math.floor(settings.gridSize), 4);\n\n    /* shorthand */\n    var g = settings.gridSize;\n    var maskRectWidth = g - settings.maskGapWidth;\n\n    /* normalize rotation settings */\n    var rotationRange = Math.abs(settings.maxRotation - settings.minRotation);\n    var minRotation = Math.min(settings.maxRotation, settings.minRotation);\n    var rotationStep = settings.rotationStep;\n\n    /* information/object available to all functions, set when start() */\n    var grid, // 2d array containing filling information\n      ngx, ngy, // width and height of the grid\n      center, // position of the center of the cloud\n      maxRadius;\n\n    /* timestamp for measuring each putWord() action */\n    var escapeTime;\n\n    /* function for getting the color of the text */\n    var getTextColor;\n    function random_hsl_color(min, max) {\n      return 'hsl(' +\n        (Math.random() * 360).toFixed() + ',' +\n        (Math.random() * 30 + 70).toFixed() + '%,' +\n        (Math.random() * (max - min) + min).toFixed() + '%)';\n    }\n    switch (settings.color) {\n      case 'random-dark':\n        getTextColor = function getRandomDarkColor() {\n          return random_hsl_color(10, 50);\n        };\n        break;\n\n      case 'random-light':\n        getTextColor = function getRandomLightColor() {\n          return random_hsl_color(50, 90);\n        };\n        break;\n\n      default:\n        if (typeof settings.color === 'function') {\n          getTextColor = settings.color;\n        }\n        break;\n    }\n\n    /* function for getting the classes of the text */\n    var getTextClasses = null;\n    if (typeof settings.classes === 'function') {\n      getTextClasses = settings.classes;\n    }\n\n    /* Interactive */\n    var interactive = false;\n    var infoGrid = [];\n    var hovered;\n\n    var getInfoGridFromMouseTouchEvent =\n    function getInfoGridFromMouseTouchEvent(evt) {\n      var canvas = evt.currentTarget;\n      var rect = canvas.getBoundingClientRect();\n      var clientX;\n      var clientY;\n      /** Detect if touches are available */\n      if (evt.touches) {\n        clientX = evt.touches[0].clientX;\n        clientY = evt.touches[0].clientY;\n      } else {\n        clientX = evt.clientX;\n        clientY = evt.clientY;\n      }\n      var eventX = clientX - rect.left;\n      var eventY = clientY - rect.top;\n\n      var x = Math.floor(eventX * ((canvas.width / rect.width) || 1) / g);\n      var y = Math.floor(eventY * ((canvas.height / rect.height) || 1) / g);\n\n      return infoGrid[x][y];\n    };\n\n    var wordcloudhover = function wordcloudhover(evt) {\n      var info = getInfoGridFromMouseTouchEvent(evt);\n\n      if (hovered === info) {\n        return;\n      }\n\n      hovered = info;\n      if (!info) {\n        settings.hover(undefined, undefined, evt);\n\n        return;\n      }\n\n      settings.hover(info.item, info.dimension, evt);\n\n    };\n\n    var wordcloudclick = function wordcloudclick(evt) {\n      var info = getInfoGridFromMouseTouchEvent(evt);\n      if (!info) {\n        return;\n      }\n\n      settings.click(info.item, info.dimension, evt);\n      evt.preventDefault();\n    };\n\n    /* Get points on the grid for a given radius away from the center */\n    var pointsAtRadius = [];\n    var getPointsAtRadius = function getPointsAtRadius(radius) {\n      if (pointsAtRadius[radius]) {\n        return pointsAtRadius[radius];\n      }\n\n      // Look for these number of points on each radius\n      var T = radius * 8;\n\n      // Getting all the points at this radius\n      var t = T;\n      var points = [];\n\n      if (radius === 0) {\n        points.push([center[0], center[1], 0]);\n      }\n\n      while (t--) {\n        // distort the radius to put the cloud in shape\n        var rx = 1;\n        if (settings.shape !== 'circle') {\n          rx = settings.shape(t / T * 2 * Math.PI); // 0 to 1\n        }\n\n        // Push [x, y, t]; t is used solely for getTextColor()\n        points.push([\n          center[0] + radius * rx * Math.cos(-t / T * 2 * Math.PI),\n          center[1] + radius * rx * Math.sin(-t / T * 2 * Math.PI) *\n            settings.ellipticity,\n          t / T * 2 * Math.PI]);\n      }\n\n      pointsAtRadius[radius] = points;\n      return points;\n    };\n\n    /* Return true if we had spent too much time */\n    var exceedTime = function exceedTime() {\n      return ((settings.abortThreshold > 0) &&\n        ((new Date()).getTime() - escapeTime > settings.abortThreshold));\n    };\n\n    /* Get the deg of rotation according to settings, and luck. */\n    var getRotateDeg = function getRotateDeg() {\n      if (settings.rotateRatio === 0) {\n        return 0;\n      }\n\n      if (Math.random() > settings.rotateRatio) {\n        return 0;\n      }\n\n      if (rotationRange === 0) {\n        return minRotation;\n      }\n\n      return minRotation + Math.round(Math.random() * rotationRange / rotationStep) * rotationStep;\n    };\n\n    var getTextInfo = function getTextInfo(word, weight, rotateDeg) {\n      // calculate the acutal font size\n      // fontSize === 0 means weightFactor function wants the text skipped,\n      // and size < minSize means we cannot draw the text.\n      var debug = false;\n      var fontSize = settings.weightFactor(weight);\n      if (fontSize <= settings.minSize) {\n        return false;\n      }\n\n      // Scale factor here is to make sure fillText is not limited by\n      // the minium font size set by browser.\n      // It will always be 1 or 2n.\n      var mu = 1;\n      if (fontSize < minFontSize) {\n        mu = (function calculateScaleFactor() {\n          var mu = 2;\n          while (mu * fontSize < minFontSize) {\n            mu += 2;\n          }\n          return mu;\n        })();\n      }\n\n      var fcanvas = document.createElement('canvas');\n      var fctx = fcanvas.getContext('2d', { willReadFrequently: true });\n\n      fctx.font = settings.fontWeight + ' ' +\n        (fontSize * mu).toString(10) + 'px ' + settings.fontFamily;\n\n      // Estimate the dimension of the text with measureText().\n      var fw = fctx.measureText(word).width / mu;\n      var fh = Math.max(fontSize * mu,\n                        fctx.measureText('m').width,\n                        fctx.measureText('\\uFF37').width) / mu;\n\n      // Create a boundary box that is larger than our estimates,\n      // so text don't get cut of (it sill might)\n      var boxWidth = fw + fh * 2;\n      var boxHeight = fh * 3;\n      var fgw = Math.ceil(boxWidth / g);\n      var fgh = Math.ceil(boxHeight / g);\n      boxWidth = fgw * g;\n      boxHeight = fgh * g;\n\n      // Calculate the proper offsets to make the text centered at\n      // the preferred position.\n\n      // This is simply half of the width.\n      var fillTextOffsetX = - fw / 2;\n      // Instead of moving the box to the exact middle of the preferred\n      // position, for Y-offset we move 0.4 instead, so Latin alphabets look\n      // vertical centered.\n      var fillTextOffsetY = - fh * 0.4;\n\n      // Calculate the actual dimension of the canvas, considering the rotation.\n      var cgh = Math.ceil((boxWidth * Math.abs(Math.sin(rotateDeg)) +\n                           boxHeight * Math.abs(Math.cos(rotateDeg))) / g);\n      var cgw = Math.ceil((boxWidth * Math.abs(Math.cos(rotateDeg)) +\n                           boxHeight * Math.abs(Math.sin(rotateDeg))) / g);\n      var width = cgw * g;\n      var height = cgh * g;\n\n      fcanvas.setAttribute('width', width);\n      fcanvas.setAttribute('height', height);\n\n      if (debug) {\n        // Attach fcanvas to the DOM\n        document.body.appendChild(fcanvas);\n        // Save it's state so that we could restore and draw the grid correctly.\n        fctx.save();\n      }\n\n      // Scale the canvas with |mu|.\n      fctx.scale(1 / mu, 1 / mu);\n      fctx.translate(width * mu / 2, height * mu / 2);\n      fctx.rotate(- rotateDeg);\n\n      // Once the width/height is set, ctx info will be reset.\n      // Set it again here.\n      fctx.font = settings.fontWeight + ' ' +\n        (fontSize * mu).toString(10) + 'px ' + settings.fontFamily;\n\n      // Fill the text into the fcanvas.\n      // XXX: We cannot because textBaseline = 'top' here because\n      // Firefox and Chrome uses different default line-height for canvas.\n      // Please read https://bugzil.la/737852#c6.\n      // Here, we use textBaseline = 'middle' and draw the text at exactly\n      // 0.5 * fontSize lower.\n      fctx.fillStyle = '#000';\n      fctx.textBaseline = 'middle';\n      fctx.fillText(word, fillTextOffsetX * mu,\n                    (fillTextOffsetY + fontSize * 0.5) * mu);\n\n      // Get the pixels of the text\n      var imageData = fctx.getImageData(0, 0, width, height).data;\n\n      if (exceedTime()) {\n        return false;\n      }\n\n      if (debug) {\n        // Draw the box of the original estimation\n        fctx.strokeRect(fillTextOffsetX * mu,\n                        fillTextOffsetY, fw * mu, fh * mu);\n        fctx.restore();\n      }\n\n      // Read the pixels and save the information to the occupied array\n      var occupied = [];\n      var gx = cgw, gy, x, y;\n      var bounds = [cgh / 2, cgw / 2, cgh / 2, cgw / 2];\n      while (gx--) {\n        gy = cgh;\n        while (gy--) {\n          y = g;\n          singleGridLoop: {\n            while (y--) {\n              x = g;\n              while (x--) {\n                if (imageData[((gy * g + y) * width +\n                               (gx * g + x)) * 4 + 3]) {\n                  occupied.push([gx, gy]);\n\n                  if (gx < bounds[3]) {\n                    bounds[3] = gx;\n                  }\n                  if (gx > bounds[1]) {\n                    bounds[1] = gx;\n                  }\n                  if (gy < bounds[0]) {\n                    bounds[0] = gy;\n                  }\n                  if (gy > bounds[2]) {\n                    bounds[2] = gy;\n                  }\n\n                  if (debug) {\n                    fctx.fillStyle = 'rgba(255, 0, 0, 0.5)';\n                    fctx.fillRect(gx * g, gy * g, g - 0.5, g - 0.5);\n                  }\n                  break singleGridLoop;\n                }\n              }\n            }\n            if (debug) {\n              fctx.fillStyle = 'rgba(0, 0, 255, 0.5)';\n              fctx.fillRect(gx * g, gy * g, g - 0.5, g - 0.5);\n            }\n          }\n        }\n      }\n\n      if (debug) {\n        fctx.fillStyle = 'rgba(0, 255, 0, 0.5)';\n        fctx.fillRect(bounds[3] * g,\n                      bounds[0] * g,\n                      (bounds[1] - bounds[3] + 1) * g,\n                      (bounds[2] - bounds[0] + 1) * g);\n      }\n\n      // Return information needed to create the text on the real canvas\n      return {\n        mu: mu,\n        occupied: occupied,\n        bounds: bounds,\n        gw: cgw,\n        gh: cgh,\n        fillTextOffsetX: fillTextOffsetX,\n        fillTextOffsetY: fillTextOffsetY,\n        fillTextWidth: fw,\n        fillTextHeight: fh,\n        fontSize: fontSize\n      };\n    };\n\n    /* Determine if there is room available in the given dimension */\n    var canFitText = function canFitText(gx, gy, gw, gh, occupied) {\n      // Go through the occupied points,\n      // return false if the space is not available.\n      var i = occupied.length;\n      while (i--) {\n        var px = gx + occupied[i][0];\n        var py = gy + occupied[i][1];\n\n        if (px >= ngx || py >= ngy || px < 0 || py < 0) {\n          if (!settings.drawOutOfBound) {\n            return false;\n          }\n          continue;\n        }\n\n        if (!grid[px][py]) {\n          return false;\n        }\n      }\n      return true;\n    };\n\n    /* Actually draw the text on the grid */\n    var drawText = function drawText(gx, gy, info, word, weight,\n                                     distance, theta, rotateDeg, attributes) {\n\n      var fontSize = info.fontSize;\n      var color;\n      if (getTextColor) {\n        color = getTextColor(word, weight, fontSize, distance, theta);\n      } else {\n        color = settings.color;\n      }\n\n      var classes;\n      if (getTextClasses) {\n        classes = getTextClasses(word, weight, fontSize, distance, theta);\n      } else {\n        classes = settings.classes;\n      }\n\n      var dimension;\n      var bounds = info.bounds;\n      dimension = {\n        x: (gx + bounds[3]) * g,\n        y: (gy + bounds[0]) * g,\n        w: (bounds[1] - bounds[3] + 1) * g,\n        h: (bounds[2] - bounds[0] + 1) * g\n      };\n\n      elements.forEach(function(el) {\n        if (el.getContext) {\n          var ctx = el.getContext('2d');\n          var mu = info.mu;\n\n          // Save the current state before messing it\n          ctx.save();\n          ctx.scale(1 / mu, 1 / mu);\n\n          ctx.font = settings.fontWeight + ' ' +\n                     (fontSize * mu).toString(10) + 'px ' + settings.fontFamily;\n          ctx.fillStyle = color;\n\n          // Translate the canvas position to the origin coordinate of where\n          // the text should be put.\n          ctx.translate((gx + info.gw / 2) * g * mu,\n                        (gy + info.gh / 2) * g * mu);\n\n          if (rotateDeg !== 0) {\n            ctx.rotate(- rotateDeg);\n          }\n\n          // Finally, fill the text.\n\n          // XXX: We cannot because textBaseline = 'top' here because\n          // Firefox and Chrome uses different default line-height for canvas.\n          // Please read https://bugzil.la/737852#c6.\n          // Here, we use textBaseline = 'middle' and draw the text at exactly\n          // 0.5 * fontSize lower.\n          ctx.textBaseline = 'middle';\n          ctx.fillText(word, info.fillTextOffsetX * mu,\n                             (info.fillTextOffsetY + fontSize * 0.5) * mu);\n\n          // The below box is always matches how <span>s are positioned\n          /* ctx.strokeRect(info.fillTextOffsetX, info.fillTextOffsetY,\n            info.fillTextWidth, info.fillTextHeight); */\n\n          // Restore the state.\n          ctx.restore();\n        } else {\n          // drawText on DIV element\n          var span = document.createElement('span');\n          var transformRule = '';\n          transformRule = 'rotate(' + (- rotateDeg / Math.PI * 180) + 'deg) ';\n          if (info.mu !== 1) {\n            transformRule +=\n              'translateX(-' + (info.fillTextWidth / 4) + 'px) ' +\n              'scale(' + (1 / info.mu) + ')';\n          }\n          var styleRules = {\n            'position': 'absolute',\n            'display': 'block',\n            'font': settings.fontWeight + ' ' +\n                    (fontSize * info.mu) + 'px ' + settings.fontFamily,\n            'left': ((gx + info.gw / 2) * g + info.fillTextOffsetX) + 'px',\n            'top': ((gy + info.gh / 2) * g + info.fillTextOffsetY) + 'px',\n            'width': info.fillTextWidth + 'px',\n            'height': info.fillTextHeight + 'px',\n            'lineHeight': fontSize + 'px',\n            'whiteSpace': 'nowrap',\n            'transform': transformRule,\n            'webkitTransform': transformRule,\n            'msTransform': transformRule,\n            'transformOrigin': '50% 40%',\n            'webkitTransformOrigin': '50% 40%',\n            'msTransformOrigin': '50% 40%'\n          };\n          if (color) {\n            styleRules.color = color;\n          }\n          span.textContent = word;\n          for (var cssProp in styleRules) {\n            span.style[cssProp] = styleRules[cssProp];\n          }\n          if (attributes) {\n            for (var attribute in attributes) {\n              span.setAttribute(attribute, attributes[attribute]);\n            }\n          }\n          if (classes) {\n            span.className += classes;\n          }\n          el.appendChild(span);\n        }\n      });\n    };\n\n    /* Help function to updateGrid */\n    var fillGridAt = function fillGridAt(x, y, drawMask, dimension, item) {\n      if (x >= ngx || y >= ngy || x < 0 || y < 0) {\n        return;\n      }\n\n      grid[x][y] = false;\n\n      if (drawMask) {\n        var ctx = elements[0].getContext('2d');\n        ctx.fillRect(x * g, y * g, maskRectWidth, maskRectWidth);\n      }\n\n      if (interactive) {\n        infoGrid[x][y] = { item: item, dimension: dimension };\n      }\n    };\n\n    /* Update the filling information of the given space with occupied points.\n       Draw the mask on the canvas if necessary. */\n    var updateGrid = function updateGrid(gx, gy, gw, gh, info, item) {\n      var occupied = info.occupied;\n      var drawMask = settings.drawMask;\n      var ctx;\n      if (drawMask) {\n        ctx = elements[0].getContext('2d');\n        ctx.save();\n        ctx.fillStyle = settings.maskColor;\n      }\n\n      var dimension;\n      if (interactive) {\n        var bounds = info.bounds;\n        dimension = {\n          x: (gx + bounds[3]) * g,\n          y: (gy + bounds[0]) * g,\n          w: (bounds[1] - bounds[3] + 1) * g,\n          h: (bounds[2] - bounds[0] + 1) * g\n        };\n      }\n\n      var i = occupied.length;\n      while (i--) {\n        var px = gx + occupied[i][0];\n        var py = gy + occupied[i][1];\n\n        if (px >= ngx || py >= ngy || px < 0 || py < 0) {\n          continue;\n        }\n\n        fillGridAt(px, py, drawMask, dimension, item);\n      }\n\n      if (drawMask) {\n        ctx.restore();\n      }\n    };\n\n    /* putWord() processes each item on the list,\n       calculate it's size and determine it's position, and actually\n       put it on the canvas. */\n    var putWord = function putWord(item) {\n      var word, weight, attributes;\n      if (Array.isArray(item)) {\n        word = item[0];\n        weight = item[1];\n      } else {\n        word = item.word;\n        weight = item.weight;\n        attributes = item.attributes;\n      }\n      var rotateDeg = getRotateDeg();\n\n      // get info needed to put the text onto the canvas\n      var info = getTextInfo(word, weight, rotateDeg);\n\n      // not getting the info means we shouldn't be drawing this one.\n      if (!info) {\n        return false;\n      }\n\n      if (exceedTime()) {\n        return false;\n      }\n\n      // If drawOutOfBound is set to false,\n      // skip the loop if we have already know the bounding box of\n      // word is larger than the canvas.\n      if (!settings.drawOutOfBound) {\n        var bounds = info.bounds;\n        if ((bounds[1] - bounds[3] + 1) > ngx ||\n          (bounds[2] - bounds[0] + 1) > ngy) {\n          return false;\n        }\n      }\n\n      // Determine the position to put the text by\n      // start looking for the nearest points\n      var r = maxRadius + 1;\n\n      var tryToPutWordAtPoint = function(gxy) {\n        var gx = Math.floor(gxy[0] - info.gw / 2);\n        var gy = Math.floor(gxy[1] - info.gh / 2);\n        var gw = info.gw;\n        var gh = info.gh;\n\n        // If we cannot fit the text at this position, return false\n        // and go to the next position.\n        if (!canFitText(gx, gy, gw, gh, info.occupied)) {\n          return false;\n        }\n\n        // Actually put the text on the canvas\n        drawText(gx, gy, info, word, weight,\n                 (maxRadius - r), gxy[2], rotateDeg, attributes);\n\n        // Mark the spaces on the grid as filled\n        updateGrid(gx, gy, gw, gh, info, item);\n\n        return {\n          gx: gx,\n          gy: gy,\n          rot: rotateDeg,\n          info: info\n        };\n      };\n\n      while (r--) {\n        var points = getPointsAtRadius(maxRadius - r);\n\n        if (settings.shuffle) {\n          points = [].concat(points);\n          shuffleArray(points);\n        }\n\n        // Try to fit the words by looking at each point.\n        // array.some() will stop and return true\n        // when putWordAtPoint() returns true.\n        for (var i = 0; i < points.length; i++) {\n          var res = tryToPutWordAtPoint(points[i]);\n          if (res) {\n            return res;\n          }\n        }\n\n        // var drawn = points.some(tryToPutWordAtPoint);\n        // if (drawn) {\n        //   // leave putWord() and return true\n        //   return true;\n        // }\n      }\n      // we tried all distances but text won't fit, return null\n      return null;\n    };\n\n    /* Send DOM event to all elements. Will stop sending event and return\n       if the previous one is canceled (for cancelable events). */\n    var sendEvent = function sendEvent(type, cancelable, detail) {\n      if (cancelable) {\n        return !elements.some(function(el) {\n          var evt = document.createEvent('CustomEvent');\n          evt.initCustomEvent(type, true, cancelable, detail || {});\n          return !el.dispatchEvent(evt);\n        }, this);\n      } else {\n        elements.forEach(function(el) {\n          var evt = document.createEvent('CustomEvent');\n          evt.initCustomEvent(type, true, cancelable, detail || {});\n          el.dispatchEvent(evt);\n        }, this);\n      }\n    };\n\n    /* Start drawing on a canvas */\n    var start = function start() {\n      // For dimensions, clearCanvas etc.,\n      // we only care about the first element.\n      var canvas = elements[0];\n\n      if (canvas.getContext) {\n        ngx = Math.ceil(canvas.width / g);\n        ngy = Math.ceil(canvas.height / g);\n      } else {\n        var rect = canvas.getBoundingClientRect();\n        ngx = Math.ceil(rect.width / g);\n        ngy = Math.ceil(rect.height / g);\n      }\n\n      // Sending a wordcloudstart event which cause the previous loop to stop.\n      // Do nothing if the event is canceled.\n      if (!sendEvent('wordcloudstart', true)) {\n        return;\n      }\n\n      // Determine the center of the word cloud\n      center = (settings.origin) ?\n        [settings.origin[0]/g, settings.origin[1]/g] :\n        [ngx / 2, ngy / 2];\n\n      // Maxium radius to look for space\n      maxRadius = Math.floor(Math.sqrt(ngx * ngx + ngy * ngy));\n\n      /* Clear the canvas only if the clearCanvas is set,\n         if not, update the grid to the current canvas state */\n      grid = [];\n\n      var gx, gy, i;\n      if (!canvas.getContext || settings.clearCanvas) {\n        elements.forEach(function(el) {\n          if (el.getContext) {\n            var ctx = el.getContext('2d');\n            ctx.fillStyle = settings.backgroundColor;\n            ctx.clearRect(0, 0, ngx * (g + 1), ngy * (g + 1));\n            ctx.fillRect(0, 0, ngx * (g + 1), ngy * (g + 1));\n          } else {\n            el.textContent = '';\n            el.style.backgroundColor = settings.backgroundColor;\n            el.style.position = 'relative';\n          }\n        });\n\n        /* fill the grid with empty state */\n        gx = ngx;\n        while (gx--) {\n          grid[gx] = [];\n          gy = ngy;\n          while (gy--) {\n            grid[gx][gy] = true;\n          }\n        }\n      } else {\n        /* Determine bgPixel by creating\n           another canvas and fill the specified background color. */\n        var bctx = document.createElement('canvas').getContext('2d');\n\n        bctx.fillStyle = settings.backgroundColor;\n        bctx.fillRect(0, 0, 1, 1);\n        var bgPixel = bctx.getImageData(0, 0, 1, 1).data;\n\n        /* Read back the pixels of the canvas we got to tell which part of the\n           canvas is empty.\n           (no clearCanvas only works with a canvas, not divs) */\n        var imageData =\n          canvas.getContext('2d').getImageData(0, 0, ngx * g, ngy * g).data;\n\n        gx = ngx;\n        var x, y;\n        while (gx--) {\n          grid[gx] = [];\n          gy = ngy;\n          while (gy--) {\n            y = g;\n            singleGridLoop: while (y--) {\n              x = g;\n              while (x--) {\n                i = 4;\n                while (i--) {\n                  if (imageData[((gy * g + y) * ngx * g +\n                                 (gx * g + x)) * 4 + i] !== bgPixel[i]) {\n                    grid[gx][gy] = false;\n                    break singleGridLoop;\n                  }\n                }\n              }\n            }\n            if (grid[gx][gy] !== false) {\n              grid[gx][gy] = true;\n            }\n          }\n        }\n\n        imageData = bctx = bgPixel = undefined;\n      }\n\n      // fill the infoGrid with empty state if we need it\n      if (settings.hover || settings.click) {\n\n        interactive = true;\n\n        /* fill the grid with empty state */\n        gx = ngx + 1;\n        while (gx--) {\n          infoGrid[gx] = [];\n        }\n\n        if (settings.hover) {\n          canvas.addEventListener('mousemove', wordcloudhover);\n        }\n\n        if (settings.click) {\n          canvas.addEventListener('click', wordcloudclick);\n          canvas.addEventListener('touchstart', wordcloudclick);\n          canvas.addEventListener('touchend', function (e) {\n            e.preventDefault();\n          });\n          canvas.style.webkitTapHighlightColor = 'rgba(0, 0, 0, 0)';\n        }\n\n        canvas.addEventListener('wordcloudstart', function stopInteraction() {\n          canvas.removeEventListener('wordcloudstart', stopInteraction);\n\n          canvas.removeEventListener('mousemove', wordcloudhover);\n          canvas.removeEventListener('click', wordcloudclick);\n          hovered = undefined;\n        });\n      }\n\n      i = 0;\n      var loopingFunction, stoppingFunction;\n      var layouting = true;\n      if (!settings.layoutAnimation) {\n        loopingFunction = function (cb) {\n          cb();\n        }\n        stoppingFunction = function () {\n          layouting = false;\n        }\n      }\n      else if (settings.wait !== 0) {\n        loopingFunction = window.setTimeout;\n        stoppingFunction = window.clearTimeout;\n      } else {\n        loopingFunction = window.setImmediate;\n        stoppingFunction = window.clearImmediate;\n      }\n\n      var addEventListener = function addEventListener(type, listener) {\n        elements.forEach(function(el) {\n          el.addEventListener(type, listener);\n        }, this);\n      };\n\n      var removeEventListener = function removeEventListener(type, listener) {\n        elements.forEach(function(el) {\n          el.removeEventListener(type, listener);\n        }, this);\n      };\n\n      var anotherWordCloudStart = function anotherWordCloudStart() {\n        removeEventListener('wordcloudstart', anotherWordCloudStart);\n        stoppingFunction(timer);\n      };\n\n      addEventListener('wordcloudstart', anotherWordCloudStart);\n\n      // At least wait the following code before call the first iteration.\n      var timer = (settings.layoutAnimation ? loopingFunction : setTimeout)(function loop() {\n        if (!layouting) {\n          return;\n        }\n        if (i >= settings.list.length) {\n          stoppingFunction(timer);\n          sendEvent('wordcloudstop', false);\n          removeEventListener('wordcloudstart', anotherWordCloudStart);\n\n          return;\n        }\n        escapeTime = (new Date()).getTime();\n        var drawn = putWord(settings.list[i]);\n        var canceled = !sendEvent('wordclouddrawn', true, {\n          item: settings.list[i], drawn: drawn });\n        if (exceedTime() || canceled) {\n          stoppingFunction(timer);\n          settings.abort();\n          sendEvent('wordcloudabort', false);\n          sendEvent('wordcloudstop', false);\n          removeEventListener('wordcloudstart', anotherWordCloudStart);\n          return;\n        }\n        i++;\n        timer = loopingFunction(loop, settings.wait);\n      }, settings.wait);\n    };\n\n    // All set, start the drawing\n    start();\n  };\n\n  WordCloud.isSupported = isSupported;\n  WordCloud.minFontSize = minFontSize;\n\n  export default WordCloud;","import * as echarts from 'echarts/lib/echarts';\n\nimport './WordCloudSeries';\nimport './WordCloudView';\n\nimport wordCloudLayoutHelper from './layout';\n\nif (!wordCloudLayoutHelper.isSupported) {\n    throw new Error('Sorry your browser not support wordCloud');\n}\n\n// https://github.com/timdream/wordcloud2.js/blob/c236bee60436e048949f9becc4f0f67bd832dc5c/index.js#L233\nfunction updateCanvasMask(maskCanvas) {\n    var ctx = maskCanvas.getContext('2d');\n    var imageData = ctx.getImageData(\n        0, 0, maskCanvas.width, maskCanvas.height);\n    var newImageData = ctx.createImageData(imageData);\n\n    var toneSum = 0;\n    var toneCnt = 0;\n    for (var i = 0; i < imageData.data.length; i += 4) {\n        var alpha = imageData.data[i + 3];\n        if (alpha > 128) {\n            var tone = imageData.data[i]\n                + imageData.data[i + 1]\n                + imageData.data[i + 2];\n            toneSum += tone;\n            ++toneCnt;\n        }\n    }\n    var threshold = toneSum / toneCnt;\n\n    for (var i = 0; i < imageData.data.length; i += 4) {\n        var tone = imageData.data[i]\n            + imageData.data[i + 1]\n            + imageData.data[i + 2];\n        var alpha = imageData.data[i + 3];\n\n        if (alpha < 128 || tone > threshold) {\n            // Area not to draw\n            newImageData.data[i] = 0;\n            newImageData.data[i + 1] = 0;\n            newImageData.data[i + 2] = 0;\n            newImageData.data[i + 3] = 0;\n        }\n        else {\n            // Area to draw\n            // The color must be same with backgroundColor\n            newImageData.data[i] = 255;\n            newImageData.data[i + 1] = 255;\n            newImageData.data[i + 2] = 255;\n            newImageData.data[i + 3] = 255;\n        }\n    }\n\n    ctx.putImageData(newImageData, 0, 0);\n}\n\necharts.registerLayout(function (ecModel, api) {\n    ecModel.eachSeriesByType('wordCloud', function (seriesModel) {\n        var gridRect = echarts.helper.getLayoutRect(\n            seriesModel.getBoxLayoutParams(), {\n                width: api.getWidth(),\n                height: api.getHeight()\n            }\n        );\n        var data = seriesModel.getData();\n\n        var canvas = document.createElement('canvas');\n        canvas.width = gridRect.width;\n        canvas.height = gridRect.height;\n\n        var ctx = canvas.getContext('2d');\n        var maskImage = seriesModel.get('maskImage');\n        if (maskImage) {\n            try {\n                ctx.drawImage(maskImage, 0, 0, canvas.width, canvas.height);\n                updateCanvasMask(canvas);\n            }\n            catch (e) {\n                console.error('Invalid mask image');\n                console.error(e.toString());\n            }\n        }\n\n        var sizeRange = seriesModel.get('sizeRange');\n        var rotationRange = seriesModel.get('rotationRange');\n        var valueExtent = data.getDataExtent('value');\n\n        var DEGREE_TO_RAD = Math.PI / 180;\n        var gridSize = seriesModel.get('gridSize');\n        wordCloudLayoutHelper(canvas, {\n            list: data.mapArray('value', function (value, idx) {\n                var itemModel = data.getItemModel(idx);\n                return [\n                    data.getName(idx),\n                    itemModel.get('textStyle.fontSize', true)\n                        || echarts.number.linearMap(value, valueExtent, sizeRange),\n                    idx\n                ];\n            }).sort(function (a, b) {\n                // Sort from large to small in case there is no more room for more words\n                return b[1] - a[1];\n            }),\n            fontFamily: seriesModel.get('textStyle.fontFamily')\n                || seriesModel.get('emphasis.textStyle.fontFamily')\n                || ecModel.get('textStyle.fontFamily'),\n            fontWeight: seriesModel.get('textStyle.fontWeight')\n                || seriesModel.get('emphasis.textStyle.fontWeight')\n                || ecModel.get('textStyle.fontWeight'),\n\n            gridSize: gridSize,\n\n            ellipticity: gridRect.height / gridRect.width,\n\n            minRotation: rotationRange[0] * DEGREE_TO_RAD,\n            maxRotation: rotationRange[1] * DEGREE_TO_RAD,\n\n            clearCanvas: !maskImage,\n\n            rotateRatio: 1,\n\n            rotationStep: seriesModel.get('rotationStep') * DEGREE_TO_RAD,\n\n            drawOutOfBound: seriesModel.get('drawOutOfBound'),\n\n            layoutAnimation: seriesModel.get('layoutAnimation'),\n\n            shuffle: false,\n\n            shape: seriesModel.get('shape')\n        });\n\n        function onWordCloudDrawn(e) {\n            var item = e.detail.item;\n            if (e.detail.drawn && seriesModel.layoutInstance.ondraw) {\n                e.detail.drawn.gx += gridRect.x / gridSize;\n                e.detail.drawn.gy += gridRect.y / gridSize;\n                seriesModel.layoutInstance.ondraw(\n                    item[0], item[1], item[2], e.detail.drawn\n                );\n            }\n        }\n\n        canvas.addEventListener('wordclouddrawn', onWordCloudDrawn);\n\n        if (seriesModel.layoutInstance) {\n            // Dispose previous\n            seriesModel.layoutInstance.dispose();\n        }\n\n        seriesModel.layoutInstance = {\n            ondraw: null,\n\n            dispose: function () {\n                canvas.removeEventListener('wordclouddrawn', onWordCloudDrawn);\n                // Abort\n                canvas.addEventListener('wordclouddrawn', function (e) {\n                    // Prevent default to cancle the event and stop the loop\n                    e.preventDefault();\n                });\n            }\n        };\n    });\n});\n\necharts.registerPreprocessor(function (option) {\n    var series = (option || {}).series;\n    !echarts.util.isArray(series) && (series = series ? [series] : []);\n\n    var compats = ['shadowColor', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY'];\n\n    echarts.util.each(series, function (seriesItem) {\n        if (seriesItem && seriesItem.type === 'wordCloud') {\n            var textStyle = seriesItem.textStyle || {};\n\n            compatTextStyle(textStyle.normal);\n            compatTextStyle(textStyle.emphasis);\n        }\n    });\n\n    function compatTextStyle(textStyle) {\n        textStyle && echarts.util.each(compats, function (key) {\n            if (textStyle.hasOwnProperty(key)) {\n                textStyle['text' + echarts.format.capitalFirst(key)] = textStyle[key];\n            }\n        });\n    }\n});\n","module.exports = __WEBPACK_EXTERNAL_MODULE_echarts_lib_echarts__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// module exports must be returned from runtime so entry inlining is disabled\n// startup\n// Load entry module and return exports\nreturn __webpack_require__(\"./index.js\");\n"]},"metadata":{},"sourceType":"script"}