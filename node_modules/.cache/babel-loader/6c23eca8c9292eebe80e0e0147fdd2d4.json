{"ast":null,"code":"import _typeof from \"C:/Users/Administrator/Desktop/data_view/my_project/vue2_app/myapp/node_modules/@babel/runtime/helpers/esm/typeof.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.match.js\";\nimport graphicGL from '../../util/graphicGL';\nimport Skybox from 'claygl/src/plugin/Skybox';\nimport * as echarts from 'echarts/lib/echarts';\n\nfunction SceneHelper() {}\n\nSceneHelper.prototype = {\n  constructor: SceneHelper,\n  setScene: function setScene(scene) {\n    this._scene = scene;\n\n    if (this._skybox) {\n      this._skybox.attachScene(this._scene);\n    }\n  },\n  initLight: function initLight(rootNode) {\n    this._lightRoot = rootNode;\n    /**\n     * @type {clay.light.Directional}\n     */\n\n    this.mainLight = new graphicGL.DirectionalLight({\n      shadowBias: 0.005\n    });\n    /**\n     * @type {clay.light.Ambient}\n     */\n\n    this.ambientLight = new graphicGL.AmbientLight();\n    rootNode.add(this.mainLight);\n    rootNode.add(this.ambientLight);\n  },\n  dispose: function dispose() {\n    if (this._lightRoot) {\n      this._lightRoot.remove(this.mainLight);\n\n      this._lightRoot.remove(this.ambientLight);\n    }\n  },\n  updateLight: function updateLight(componentModel) {\n    var mainLight = this.mainLight;\n    var ambientLight = this.ambientLight;\n    var lightModel = componentModel.getModel('light');\n    var mainLightModel = lightModel.getModel('main');\n    var ambientLightModel = lightModel.getModel('ambient');\n    mainLight.intensity = mainLightModel.get('intensity');\n    ambientLight.intensity = ambientLightModel.get('intensity');\n    mainLight.color = graphicGL.parseColor(mainLightModel.get('color')).slice(0, 3);\n    ambientLight.color = graphicGL.parseColor(ambientLightModel.get('color')).slice(0, 3);\n    var alpha = mainLightModel.get('alpha') || 0;\n    var beta = mainLightModel.get('beta') || 0;\n    mainLight.position.setArray(graphicGL.directionFromAlphaBeta(alpha, beta));\n    mainLight.lookAt(graphicGL.Vector3.ZERO);\n    mainLight.castShadow = mainLightModel.get('shadow');\n    mainLight.shadowResolution = graphicGL.getShadowResolution(mainLightModel.get('shadowQuality'));\n  },\n  updateAmbientCubemap: function updateAmbientCubemap(renderer, componentModel, api) {\n    var ambientCubemapModel = componentModel.getModel('light.ambientCubemap');\n    var textureUrl = ambientCubemapModel.get('texture');\n\n    if (textureUrl) {\n      this._cubemapLightsCache = this._cubemapLightsCache || {};\n      var lights = this._cubemapLightsCache[textureUrl];\n\n      if (!lights) {\n        var self = this;\n        lights = this._cubemapLightsCache[textureUrl] = graphicGL.createAmbientCubemap(ambientCubemapModel.option, renderer, api, function () {\n          // Use prefitered cubemap\n          if (self._isSkyboxFromAmbientCubemap) {\n            self._skybox.setEnvironmentMap(lights.specular.cubemap);\n          }\n\n          api.getZr().refresh();\n        });\n      }\n\n      this._lightRoot.add(lights.diffuse);\n\n      this._lightRoot.add(lights.specular);\n\n      this._currentCubemapLights = lights;\n    } else if (this._currentCubemapLights) {\n      this._lightRoot.remove(this._currentCubemapLights.diffuse);\n\n      this._lightRoot.remove(this._currentCubemapLights.specular);\n\n      this._currentCubemapLights = null;\n    }\n  },\n  updateSkybox: function updateSkybox(renderer, componentModel, api) {\n    var environmentUrl = componentModel.get('environment');\n    var self = this;\n\n    function getSkybox() {\n      self._skybox = self._skybox || new Skybox();\n      return self._skybox;\n    }\n\n    var skybox = getSkybox();\n\n    if (environmentUrl && environmentUrl !== 'none') {\n      if (environmentUrl === 'auto') {\n        this._isSkyboxFromAmbientCubemap = true; // Use environment in ambient cubemap\n\n        if (this._currentCubemapLights) {\n          var cubemap = this._currentCubemapLights.specular.cubemap;\n          skybox.setEnvironmentMap(cubemap);\n\n          if (this._scene) {\n            skybox.attachScene(this._scene);\n          }\n\n          skybox.material.set('lod', 3);\n        } else if (this._skybox) {\n          this._skybox.detachScene();\n        }\n      } // Is gradient or color string\n      else if (_typeof(environmentUrl) === 'object' && environmentUrl.colorStops || typeof environmentUrl === 'string' && echarts.color.parse(environmentUrl)) {\n        this._isSkyboxFromAmbientCubemap = false;\n        var texture = new graphicGL.Texture2D({\n          anisotropic: 8,\n          flipY: false\n        });\n        skybox.setEnvironmentMap(texture);\n        var canvas = texture.image = document.createElement('canvas');\n        canvas.width = canvas.height = 16;\n        var ctx = canvas.getContext('2d');\n        var rect = new echarts.graphic.Rect({\n          shape: {\n            x: 0,\n            y: 0,\n            width: 16,\n            height: 16\n          },\n          style: {\n            fill: environmentUrl\n          }\n        });\n        echarts.innerDrawElementOnCanvas(ctx, rect);\n        skybox.attachScene(this._scene);\n      } else {\n        this._isSkyboxFromAmbientCubemap = false; // Panorama\n\n        var texture = graphicGL.loadTexture(environmentUrl, api, {\n          anisotropic: 8,\n          flipY: false\n        });\n        skybox.setEnvironmentMap(texture);\n        skybox.attachScene(this._scene);\n      }\n    } else {\n      if (this._skybox) {\n        this._skybox.detachScene(this._scene);\n      }\n\n      this._skybox = null;\n    }\n\n    var coordSys = componentModel.coordinateSystem;\n\n    if (this._skybox) {\n      if (coordSys && coordSys.viewGL && environmentUrl !== 'auto' && !(environmentUrl.match && environmentUrl.match(/.hdr$/))) {\n        var srgbDefineMethod = coordSys.viewGL.isLinearSpace() ? 'define' : 'undefine';\n\n        this._skybox.material[srgbDefineMethod]('fragment', 'SRGB_DECODE');\n      } else {\n        this._skybox.material.undefine('fragment', 'SRGB_DECODE');\n      } // var ambientCubemapUrl = environmentUrl === 'auto'\n      //     ? componentModel.get('light.ambientCubemap.texture')\n      //     : environmentUrl;\n\n    }\n  }\n};\nexport default SceneHelper;","map":{"version":3,"sources":["C:/Users/Administrator/Desktop/data_view/my_project/vue2_app/myapp/node_modules/echarts-gl/lib/component/common/SceneHelper.js"],"names":["graphicGL","Skybox","echarts","SceneHelper","prototype","constructor","setScene","scene","_scene","_skybox","attachScene","initLight","rootNode","_lightRoot","mainLight","DirectionalLight","shadowBias","ambientLight","AmbientLight","add","dispose","remove","updateLight","componentModel","lightModel","getModel","mainLightModel","ambientLightModel","intensity","get","color","parseColor","slice","alpha","beta","position","setArray","directionFromAlphaBeta","lookAt","Vector3","ZERO","castShadow","shadowResolution","getShadowResolution","updateAmbientCubemap","renderer","api","ambientCubemapModel","textureUrl","_cubemapLightsCache","lights","self","createAmbientCubemap","option","_isSkyboxFromAmbientCubemap","setEnvironmentMap","specular","cubemap","getZr","refresh","diffuse","_currentCubemapLights","updateSkybox","environmentUrl","getSkybox","skybox","material","set","detachScene","colorStops","parse","texture","Texture2D","anisotropic","flipY","canvas","image","document","createElement","width","height","ctx","getContext","rect","graphic","Rect","shape","x","y","style","fill","innerDrawElementOnCanvas","loadTexture","coordSys","coordinateSystem","viewGL","match","srgbDefineMethod","isLinearSpace","undefine"],"mappings":"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","sourcesContent":["import graphicGL from '../../util/graphicGL';\nimport Skybox from 'claygl/src/plugin/Skybox';\nimport * as echarts from 'echarts/lib/echarts';\n\nfunction SceneHelper() {}\n\nSceneHelper.prototype = {\n  constructor: SceneHelper,\n  setScene: function (scene) {\n    this._scene = scene;\n\n    if (this._skybox) {\n      this._skybox.attachScene(this._scene);\n    }\n  },\n  initLight: function (rootNode) {\n    this._lightRoot = rootNode;\n    /**\n     * @type {clay.light.Directional}\n     */\n\n    this.mainLight = new graphicGL.DirectionalLight({\n      shadowBias: 0.005\n    });\n    /**\n     * @type {clay.light.Ambient}\n     */\n\n    this.ambientLight = new graphicGL.AmbientLight();\n    rootNode.add(this.mainLight);\n    rootNode.add(this.ambientLight);\n  },\n  dispose: function () {\n    if (this._lightRoot) {\n      this._lightRoot.remove(this.mainLight);\n\n      this._lightRoot.remove(this.ambientLight);\n    }\n  },\n  updateLight: function (componentModel) {\n    var mainLight = this.mainLight;\n    var ambientLight = this.ambientLight;\n    var lightModel = componentModel.getModel('light');\n    var mainLightModel = lightModel.getModel('main');\n    var ambientLightModel = lightModel.getModel('ambient');\n    mainLight.intensity = mainLightModel.get('intensity');\n    ambientLight.intensity = ambientLightModel.get('intensity');\n    mainLight.color = graphicGL.parseColor(mainLightModel.get('color')).slice(0, 3);\n    ambientLight.color = graphicGL.parseColor(ambientLightModel.get('color')).slice(0, 3);\n    var alpha = mainLightModel.get('alpha') || 0;\n    var beta = mainLightModel.get('beta') || 0;\n    mainLight.position.setArray(graphicGL.directionFromAlphaBeta(alpha, beta));\n    mainLight.lookAt(graphicGL.Vector3.ZERO);\n    mainLight.castShadow = mainLightModel.get('shadow');\n    mainLight.shadowResolution = graphicGL.getShadowResolution(mainLightModel.get('shadowQuality'));\n  },\n  updateAmbientCubemap: function (renderer, componentModel, api) {\n    var ambientCubemapModel = componentModel.getModel('light.ambientCubemap');\n    var textureUrl = ambientCubemapModel.get('texture');\n\n    if (textureUrl) {\n      this._cubemapLightsCache = this._cubemapLightsCache || {};\n      var lights = this._cubemapLightsCache[textureUrl];\n\n      if (!lights) {\n        var self = this;\n        lights = this._cubemapLightsCache[textureUrl] = graphicGL.createAmbientCubemap(ambientCubemapModel.option, renderer, api, function () {\n          // Use prefitered cubemap\n          if (self._isSkyboxFromAmbientCubemap) {\n            self._skybox.setEnvironmentMap(lights.specular.cubemap);\n          }\n\n          api.getZr().refresh();\n        });\n      }\n\n      this._lightRoot.add(lights.diffuse);\n\n      this._lightRoot.add(lights.specular);\n\n      this._currentCubemapLights = lights;\n    } else if (this._currentCubemapLights) {\n      this._lightRoot.remove(this._currentCubemapLights.diffuse);\n\n      this._lightRoot.remove(this._currentCubemapLights.specular);\n\n      this._currentCubemapLights = null;\n    }\n  },\n  updateSkybox: function (renderer, componentModel, api) {\n    var environmentUrl = componentModel.get('environment');\n    var self = this;\n\n    function getSkybox() {\n      self._skybox = self._skybox || new Skybox();\n      return self._skybox;\n    }\n\n    var skybox = getSkybox();\n\n    if (environmentUrl && environmentUrl !== 'none') {\n      if (environmentUrl === 'auto') {\n        this._isSkyboxFromAmbientCubemap = true; // Use environment in ambient cubemap\n\n        if (this._currentCubemapLights) {\n          var cubemap = this._currentCubemapLights.specular.cubemap;\n          skybox.setEnvironmentMap(cubemap);\n\n          if (this._scene) {\n            skybox.attachScene(this._scene);\n          }\n\n          skybox.material.set('lod', 3);\n        } else if (this._skybox) {\n          this._skybox.detachScene();\n        }\n      } // Is gradient or color string\n      else if (typeof environmentUrl === 'object' && environmentUrl.colorStops || typeof environmentUrl === 'string' && echarts.color.parse(environmentUrl)) {\n          this._isSkyboxFromAmbientCubemap = false;\n          var texture = new graphicGL.Texture2D({\n            anisotropic: 8,\n            flipY: false\n          });\n          skybox.setEnvironmentMap(texture);\n          var canvas = texture.image = document.createElement('canvas');\n          canvas.width = canvas.height = 16;\n          var ctx = canvas.getContext('2d');\n          var rect = new echarts.graphic.Rect({\n            shape: {\n              x: 0,\n              y: 0,\n              width: 16,\n              height: 16\n            },\n            style: {\n              fill: environmentUrl\n            }\n          });\n          echarts.innerDrawElementOnCanvas(ctx, rect);\n          skybox.attachScene(this._scene);\n        } else {\n          this._isSkyboxFromAmbientCubemap = false; // Panorama\n\n          var texture = graphicGL.loadTexture(environmentUrl, api, {\n            anisotropic: 8,\n            flipY: false\n          });\n          skybox.setEnvironmentMap(texture);\n          skybox.attachScene(this._scene);\n        }\n    } else {\n      if (this._skybox) {\n        this._skybox.detachScene(this._scene);\n      }\n\n      this._skybox = null;\n    }\n\n    var coordSys = componentModel.coordinateSystem;\n\n    if (this._skybox) {\n      if (coordSys && coordSys.viewGL && environmentUrl !== 'auto' && !(environmentUrl.match && environmentUrl.match(/.hdr$/))) {\n        var srgbDefineMethod = coordSys.viewGL.isLinearSpace() ? 'define' : 'undefine';\n\n        this._skybox.material[srgbDefineMethod]('fragment', 'SRGB_DECODE');\n      } else {\n        this._skybox.material.undefine('fragment', 'SRGB_DECODE');\n      } // var ambientCubemapUrl = environmentUrl === 'auto'\n      //     ? componentModel.get('light.ambientCubemap.texture')\n      //     : environmentUrl;\n\n    }\n  }\n};\nexport default SceneHelper;"]},"metadata":{},"sourceType":"module"}