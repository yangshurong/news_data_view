{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport Base from './core/Base';\nimport Texture from './Texture';\nimport TextureCube from './TextureCube';\nimport glenum from './core/glenum';\nimport Cache from './core/Cache';\nvar KEY_FRAMEBUFFER = 'framebuffer';\nvar KEY_RENDERBUFFER = 'renderbuffer';\nvar KEY_RENDERBUFFER_WIDTH = KEY_RENDERBUFFER + '_width';\nvar KEY_RENDERBUFFER_HEIGHT = KEY_RENDERBUFFER + '_height';\nvar KEY_RENDERBUFFER_ATTACHED = KEY_RENDERBUFFER + '_attached';\nvar KEY_DEPTHTEXTURE_ATTACHED = 'depthtexture_attached';\nvar GL_FRAMEBUFFER = glenum.FRAMEBUFFER;\nvar GL_RENDERBUFFER = glenum.RENDERBUFFER;\nvar GL_DEPTH_ATTACHMENT = glenum.DEPTH_ATTACHMENT;\nvar GL_COLOR_ATTACHMENT0 = glenum.COLOR_ATTACHMENT0;\n/**\n * @constructor clay.FrameBuffer\n * @extends clay.core.Base\n */\n\nvar FrameBuffer = Base.extend(\n/** @lends clay.FrameBuffer# */\n{\n  /**\n   * If use depth buffer\n   * @type {boolean}\n   */\n  depthBuffer: true,\n\n  /**\n   * @type {Object}\n   */\n  viewport: null,\n  _width: 0,\n  _height: 0,\n  _textures: null,\n  _boundRenderer: null\n}, function () {\n  // Use cache\n  this._cache = new Cache();\n  this._textures = {};\n},\n/**@lends clay.FrameBuffer.prototype. */\n{\n  /**\n   * Get attached texture width\n   * {number}\n   */\n  // FIXME Can't use before #bind\n  getTextureWidth: function getTextureWidth() {\n    return this._width;\n  },\n\n  /**\n   * Get attached texture height\n   * {number}\n   */\n  getTextureHeight: function getTextureHeight() {\n    return this._height;\n  },\n\n  /**\n   * Bind the framebuffer to given renderer before rendering\n   * @param  {clay.Renderer} renderer\n   */\n  bind: function bind(renderer) {\n    if (renderer.__currentFrameBuffer) {\n      // Already bound\n      if (renderer.__currentFrameBuffer === this) {\n        return;\n      }\n\n      console.warn('Renderer already bound with another framebuffer. Unbind it first');\n    }\n\n    renderer.__currentFrameBuffer = this;\n    var _gl = renderer.gl;\n\n    _gl.bindFramebuffer(GL_FRAMEBUFFER, this._getFrameBufferGL(renderer));\n\n    this._boundRenderer = renderer;\n    var cache = this._cache;\n    cache.put('viewport', renderer.viewport);\n    var hasTextureAttached = false;\n    var width;\n    var height;\n\n    for (var attachment in this._textures) {\n      hasTextureAttached = true;\n      var obj = this._textures[attachment];\n\n      if (obj) {\n        // TODO Do width, height checking, make sure size are same\n        width = obj.texture.width;\n        height = obj.texture.height; // Attach textures\n\n        this._doAttach(renderer, obj.texture, attachment, obj.target);\n      }\n    }\n\n    this._width = width;\n    this._height = height;\n\n    if (!hasTextureAttached && this.depthBuffer) {\n      console.error('Must attach texture before bind, or renderbuffer may have incorrect width and height.');\n    }\n\n    if (this.viewport) {\n      renderer.setViewport(this.viewport);\n    } else {\n      renderer.setViewport(0, 0, width, height, 1);\n    }\n\n    var attachedTextures = cache.get('attached_textures');\n\n    if (attachedTextures) {\n      for (var attachment in attachedTextures) {\n        if (!this._textures[attachment]) {\n          var target = attachedTextures[attachment];\n\n          this._doDetach(_gl, attachment, target);\n        }\n      }\n    }\n\n    if (!cache.get(KEY_DEPTHTEXTURE_ATTACHED) && this.depthBuffer) {\n      // Create a new render buffer\n      if (cache.miss(KEY_RENDERBUFFER)) {\n        cache.put(KEY_RENDERBUFFER, _gl.createRenderbuffer());\n      }\n\n      var renderbuffer = cache.get(KEY_RENDERBUFFER);\n\n      if (width !== cache.get(KEY_RENDERBUFFER_WIDTH) || height !== cache.get(KEY_RENDERBUFFER_HEIGHT)) {\n        _gl.bindRenderbuffer(GL_RENDERBUFFER, renderbuffer);\n\n        _gl.renderbufferStorage(GL_RENDERBUFFER, _gl.DEPTH_COMPONENT16, width, height);\n\n        cache.put(KEY_RENDERBUFFER_WIDTH, width);\n        cache.put(KEY_RENDERBUFFER_HEIGHT, height);\n\n        _gl.bindRenderbuffer(GL_RENDERBUFFER, null);\n      }\n\n      if (!cache.get(KEY_RENDERBUFFER_ATTACHED)) {\n        _gl.framebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, renderbuffer);\n\n        cache.put(KEY_RENDERBUFFER_ATTACHED, true);\n      }\n    }\n  },\n\n  /**\n   * Unbind the frame buffer after rendering\n   * @param  {clay.Renderer} renderer\n   */\n  unbind: function unbind(renderer) {\n    // Remove status record on renderer\n    renderer.__currentFrameBuffer = null;\n    var _gl = renderer.gl;\n\n    _gl.bindFramebuffer(GL_FRAMEBUFFER, null);\n\n    this._boundRenderer = null;\n\n    this._cache.use(renderer.__uid__);\n\n    var viewport = this._cache.get('viewport'); // Reset viewport;\n\n\n    if (viewport) {\n      renderer.setViewport(viewport);\n    }\n\n    this.updateMipmap(renderer);\n  },\n  // Because the data of texture is changed over time,\n  // Here update the mipmaps of texture each time after rendered;\n  updateMipmap: function updateMipmap(renderer) {\n    var _gl = renderer.gl;\n\n    for (var attachment in this._textures) {\n      var obj = this._textures[attachment];\n\n      if (obj) {\n        var texture = obj.texture; // FIXME some texture format can't generate mipmap\n\n        if (!texture.NPOT && texture.useMipmap && texture.minFilter === Texture.LINEAR_MIPMAP_LINEAR) {\n          var target = texture.textureType === 'textureCube' ? glenum.TEXTURE_CUBE_MAP : glenum.TEXTURE_2D;\n\n          _gl.bindTexture(target, texture.getWebGLTexture(renderer));\n\n          _gl.generateMipmap(target);\n\n          _gl.bindTexture(target, null);\n        }\n      }\n    }\n  },\n  // 0x8CD5, 36053, FRAMEBUFFER_COMPLETE\n  // 0x8CD6, 36054, FRAMEBUFFER_INCOMPLETE_ATTACHMENT\n  // 0x8CD7, 36055, FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT\n  // 0x8CD9, 36057, FRAMEBUFFER_INCOMPLETE_DIMENSIONS\n  // 0x8CDD, 36061, FRAMEBUFFER_UNSUPPORTED\n  checkStatus: function checkStatus(_gl) {\n    return _gl.checkFramebufferStatus(GL_FRAMEBUFFER);\n  },\n  _getFrameBufferGL: function _getFrameBufferGL(renderer) {\n    var cache = this._cache;\n    cache.use(renderer.__uid__);\n\n    if (cache.miss(KEY_FRAMEBUFFER)) {\n      cache.put(KEY_FRAMEBUFFER, renderer.gl.createFramebuffer());\n    }\n\n    return cache.get(KEY_FRAMEBUFFER);\n  },\n\n  /**\n   * Attach a texture(RTT) to the framebuffer\n   * @param  {clay.Texture} texture\n   * @param  {number} [attachment=gl.COLOR_ATTACHMENT0]\n   * @param  {number} [target=gl.TEXTURE_2D]\n   */\n  attach: function attach(texture, attachment, target) {\n    if (!texture.width) {\n      throw new Error('The texture attached to color buffer is not a valid.');\n    } // TODO width and height check\n    // If the depth_texture extension is enabled, developers\n    // Can attach a depth texture to the depth buffer\n    // http://blog.tojicode.com/2012/07/using-webgldepthtexture.html\n\n\n    attachment = attachment || GL_COLOR_ATTACHMENT0;\n    target = target || glenum.TEXTURE_2D;\n    var boundRenderer = this._boundRenderer;\n\n    var _gl = boundRenderer && boundRenderer.gl;\n\n    var attachedTextures;\n\n    if (_gl) {\n      var cache = this._cache;\n      cache.use(boundRenderer.__uid__);\n      attachedTextures = cache.get('attached_textures');\n    } // Check if texture attached\n\n\n    var previous = this._textures[attachment];\n\n    if (previous && previous.target === target && previous.texture === texture && attachedTextures && attachedTextures[attachment] != null) {\n      return;\n    }\n\n    var canAttach = true;\n\n    if (boundRenderer) {\n      canAttach = this._doAttach(boundRenderer, texture, attachment, target); // Set viewport again incase attached to different size textures.\n\n      if (!this.viewport) {\n        boundRenderer.setViewport(0, 0, texture.width, texture.height, 1);\n      }\n    }\n\n    if (canAttach) {\n      this._textures[attachment] = this._textures[attachment] || {};\n      this._textures[attachment].texture = texture;\n      this._textures[attachment].target = target;\n    }\n  },\n  _doAttach: function _doAttach(renderer, texture, attachment, target) {\n    var _gl = renderer.gl; // Make sure texture is always updated\n    // Because texture width or height may be changed and in this we can't be notified\n    // FIXME awkward;\n\n    var webglTexture = texture.getWebGLTexture(renderer); // Assume cache has been used.\n\n    var attachedTextures = this._cache.get('attached_textures');\n\n    if (attachedTextures && attachedTextures[attachment]) {\n      var obj = attachedTextures[attachment]; // Check if texture and target not changed\n\n      if (obj.texture === texture && obj.target === target) {\n        return;\n      }\n    }\n\n    attachment = +attachment;\n    var canAttach = true;\n\n    if (attachment === GL_DEPTH_ATTACHMENT || attachment === glenum.DEPTH_STENCIL_ATTACHMENT) {\n      var extension = renderer.getGLExtension('WEBGL_depth_texture');\n\n      if (!extension) {\n        console.error('Depth texture is not supported by the browser');\n        canAttach = false;\n      }\n\n      if (texture.format !== glenum.DEPTH_COMPONENT && texture.format !== glenum.DEPTH_STENCIL) {\n        console.error('The texture attached to depth buffer is not a valid.');\n        canAttach = false;\n      } // Dispose render buffer created previous\n\n\n      if (canAttach) {\n        var renderbuffer = this._cache.get(KEY_RENDERBUFFER);\n\n        if (renderbuffer) {\n          _gl.framebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, null);\n\n          _gl.deleteRenderbuffer(renderbuffer);\n\n          this._cache.put(KEY_RENDERBUFFER, false);\n        }\n\n        this._cache.put(KEY_RENDERBUFFER_ATTACHED, false);\n\n        this._cache.put(KEY_DEPTHTEXTURE_ATTACHED, true);\n      }\n    } // Mipmap level can only be 0\n\n\n    _gl.framebufferTexture2D(GL_FRAMEBUFFER, attachment, target, webglTexture, 0);\n\n    if (!attachedTextures) {\n      attachedTextures = {};\n\n      this._cache.put('attached_textures', attachedTextures);\n    }\n\n    attachedTextures[attachment] = attachedTextures[attachment] || {};\n    attachedTextures[attachment].texture = texture;\n    attachedTextures[attachment].target = target;\n    return canAttach;\n  },\n  _doDetach: function _doDetach(_gl, attachment, target) {\n    // Detach a texture from framebuffer\n    // https://github.com/KhronosGroup/WebGL/blob/master/conformance-suites/1.0.0/conformance/framebuffer-test.html#L145\n    _gl.framebufferTexture2D(GL_FRAMEBUFFER, attachment, target, null, 0); // Assume cache has been used.\n\n\n    var attachedTextures = this._cache.get('attached_textures');\n\n    if (attachedTextures && attachedTextures[attachment]) {\n      attachedTextures[attachment] = null;\n    }\n\n    if (attachment === GL_DEPTH_ATTACHMENT || attachment === glenum.DEPTH_STENCIL_ATTACHMENT) {\n      this._cache.put(KEY_DEPTHTEXTURE_ATTACHED, false);\n    }\n  },\n\n  /**\n   * Detach a texture\n   * @param  {number} [attachment=gl.COLOR_ATTACHMENT0]\n   * @param  {number} [target=gl.TEXTURE_2D]\n   */\n  detach: function detach(attachment, target) {\n    // TODO depth extension check ?\n    this._textures[attachment] = null;\n\n    if (this._boundRenderer) {\n      var cache = this._cache;\n      cache.use(this._boundRenderer.__uid__);\n\n      this._doDetach(this._boundRenderer.gl, attachment, target);\n    }\n  },\n\n  /**\n   * Dispose\n   * @param  {WebGLRenderingContext} _gl\n   */\n  dispose: function dispose(renderer) {\n    var _gl = renderer.gl;\n    var cache = this._cache;\n    cache.use(renderer.__uid__);\n    var renderBuffer = cache.get(KEY_RENDERBUFFER);\n\n    if (renderBuffer) {\n      _gl.deleteRenderbuffer(renderBuffer);\n    }\n\n    var frameBuffer = cache.get(KEY_FRAMEBUFFER);\n\n    if (frameBuffer) {\n      _gl.deleteFramebuffer(frameBuffer);\n    }\n\n    cache.deleteContext(renderer.__uid__); // Clear cache for reusing\n\n    this._textures = {};\n  }\n});\nFrameBuffer.DEPTH_ATTACHMENT = GL_DEPTH_ATTACHMENT;\nFrameBuffer.COLOR_ATTACHMENT0 = GL_COLOR_ATTACHMENT0;\nFrameBuffer.STENCIL_ATTACHMENT = glenum.STENCIL_ATTACHMENT;\nFrameBuffer.DEPTH_STENCIL_ATTACHMENT = glenum.DEPTH_STENCIL_ATTACHMENT;\nexport default FrameBuffer;","map":{"version":3,"sources":["C:/Users/Administrator/Desktop/data_view/my_project/vue2_app/myapp/node_modules/claygl/src/FrameBuffer.js"],"names":["Base","Texture","TextureCube","glenum","Cache","KEY_FRAMEBUFFER","KEY_RENDERBUFFER","KEY_RENDERBUFFER_WIDTH","KEY_RENDERBUFFER_HEIGHT","KEY_RENDERBUFFER_ATTACHED","KEY_DEPTHTEXTURE_ATTACHED","GL_FRAMEBUFFER","FRAMEBUFFER","GL_RENDERBUFFER","RENDERBUFFER","GL_DEPTH_ATTACHMENT","DEPTH_ATTACHMENT","GL_COLOR_ATTACHMENT0","COLOR_ATTACHMENT0","FrameBuffer","extend","depthBuffer","viewport","_width","_height","_textures","_boundRenderer","_cache","getTextureWidth","getTextureHeight","bind","renderer","__currentFrameBuffer","console","warn","_gl","gl","bindFramebuffer","_getFrameBufferGL","cache","put","hasTextureAttached","width","height","attachment","obj","texture","_doAttach","target","error","setViewport","attachedTextures","get","_doDetach","miss","createRenderbuffer","renderbuffer","bindRenderbuffer","renderbufferStorage","DEPTH_COMPONENT16","framebufferRenderbuffer","unbind","use","__uid__","updateMipmap","NPOT","useMipmap","minFilter","LINEAR_MIPMAP_LINEAR","textureType","TEXTURE_CUBE_MAP","TEXTURE_2D","bindTexture","getWebGLTexture","generateMipmap","checkStatus","checkFramebufferStatus","createFramebuffer","attach","Error","boundRenderer","previous","canAttach","webglTexture","DEPTH_STENCIL_ATTACHMENT","extension","getGLExtension","format","DEPTH_COMPONENT","DEPTH_STENCIL","deleteRenderbuffer","framebufferTexture2D","detach","dispose","renderBuffer","frameBuffer","deleteFramebuffer","deleteContext","STENCIL_ATTACHMENT"],"mappings":"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","sourcesContent":["import Base from './core/Base';\nimport Texture from './Texture';\nimport TextureCube from './TextureCube';\nimport glenum from './core/glenum';\nimport Cache from './core/Cache';\n\nvar KEY_FRAMEBUFFER = 'framebuffer';\nvar KEY_RENDERBUFFER = 'renderbuffer';\nvar KEY_RENDERBUFFER_WIDTH = KEY_RENDERBUFFER + '_width';\nvar KEY_RENDERBUFFER_HEIGHT = KEY_RENDERBUFFER + '_height';\nvar KEY_RENDERBUFFER_ATTACHED = KEY_RENDERBUFFER + '_attached';\nvar KEY_DEPTHTEXTURE_ATTACHED = 'depthtexture_attached';\n\nvar GL_FRAMEBUFFER = glenum.FRAMEBUFFER;\nvar GL_RENDERBUFFER = glenum.RENDERBUFFER;\nvar GL_DEPTH_ATTACHMENT = glenum.DEPTH_ATTACHMENT;\nvar GL_COLOR_ATTACHMENT0 = glenum.COLOR_ATTACHMENT0;\n/**\n * @constructor clay.FrameBuffer\n * @extends clay.core.Base\n */\nvar FrameBuffer = Base.extend(\n/** @lends clay.FrameBuffer# */\n{\n    /**\n     * If use depth buffer\n     * @type {boolean}\n     */\n    depthBuffer: true,\n\n    /**\n     * @type {Object}\n     */\n    viewport: null,\n\n    _width: 0,\n    _height: 0,\n\n    _textures: null,\n\n    _boundRenderer: null,\n}, function () {\n    // Use cache\n    this._cache = new Cache();\n\n    this._textures = {};\n},\n\n/**@lends clay.FrameBuffer.prototype. */\n{\n    /**\n     * Get attached texture width\n     * {number}\n     */\n    // FIXME Can't use before #bind\n    getTextureWidth: function () {\n        return this._width;\n    },\n\n    /**\n     * Get attached texture height\n     * {number}\n     */\n    getTextureHeight: function () {\n        return this._height;\n    },\n\n    /**\n     * Bind the framebuffer to given renderer before rendering\n     * @param  {clay.Renderer} renderer\n     */\n    bind: function (renderer) {\n\n        if (renderer.__currentFrameBuffer) {\n            // Already bound\n            if (renderer.__currentFrameBuffer === this) {\n                return;\n            }\n\n            console.warn('Renderer already bound with another framebuffer. Unbind it first');\n        }\n        renderer.__currentFrameBuffer = this;\n\n        var _gl = renderer.gl;\n\n        _gl.bindFramebuffer(GL_FRAMEBUFFER, this._getFrameBufferGL(renderer));\n        this._boundRenderer = renderer;\n        var cache = this._cache;\n\n        cache.put('viewport', renderer.viewport);\n\n        var hasTextureAttached = false;\n        var width;\n        var height;\n        for (var attachment in this._textures) {\n            hasTextureAttached = true;\n            var obj = this._textures[attachment];\n            if (obj) {\n                // TODO Do width, height checking, make sure size are same\n                width = obj.texture.width;\n                height = obj.texture.height;\n                // Attach textures\n                this._doAttach(renderer, obj.texture, attachment, obj.target);\n            }\n        }\n\n        this._width = width;\n        this._height = height;\n\n        if (!hasTextureAttached && this.depthBuffer) {\n            console.error('Must attach texture before bind, or renderbuffer may have incorrect width and height.')\n        }\n\n        if (this.viewport) {\n            renderer.setViewport(this.viewport);\n        }\n        else {\n            renderer.setViewport(0, 0, width, height, 1);\n        }\n\n        var attachedTextures = cache.get('attached_textures');\n        if (attachedTextures) {\n            for (var attachment in attachedTextures) {\n                if (!this._textures[attachment]) {\n                    var target = attachedTextures[attachment];\n                    this._doDetach(_gl, attachment, target);\n                }\n            }\n        }\n        if (!cache.get(KEY_DEPTHTEXTURE_ATTACHED) && this.depthBuffer) {\n            // Create a new render buffer\n            if (cache.miss(KEY_RENDERBUFFER)) {\n                cache.put(KEY_RENDERBUFFER, _gl.createRenderbuffer());\n            }\n            var renderbuffer = cache.get(KEY_RENDERBUFFER);\n\n            if (width !== cache.get(KEY_RENDERBUFFER_WIDTH)\n                    || height !== cache.get(KEY_RENDERBUFFER_HEIGHT)) {\n                _gl.bindRenderbuffer(GL_RENDERBUFFER, renderbuffer);\n                _gl.renderbufferStorage(GL_RENDERBUFFER, _gl.DEPTH_COMPONENT16, width, height);\n                cache.put(KEY_RENDERBUFFER_WIDTH, width);\n                cache.put(KEY_RENDERBUFFER_HEIGHT, height);\n                _gl.bindRenderbuffer(GL_RENDERBUFFER, null);\n            }\n            if (!cache.get(KEY_RENDERBUFFER_ATTACHED)) {\n                _gl.framebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, renderbuffer);\n                cache.put(KEY_RENDERBUFFER_ATTACHED, true);\n            }\n        }\n    },\n\n    /**\n     * Unbind the frame buffer after rendering\n     * @param  {clay.Renderer} renderer\n     */\n    unbind: function (renderer) {\n        // Remove status record on renderer\n        renderer.__currentFrameBuffer = null;\n\n        var _gl = renderer.gl;\n\n        _gl.bindFramebuffer(GL_FRAMEBUFFER, null);\n        this._boundRenderer = null;\n\n        this._cache.use(renderer.__uid__);\n        var viewport = this._cache.get('viewport');\n        // Reset viewport;\n        if (viewport) {\n            renderer.setViewport(viewport);\n        }\n\n        this.updateMipmap(renderer);\n    },\n\n    // Because the data of texture is changed over time,\n    // Here update the mipmaps of texture each time after rendered;\n    updateMipmap: function (renderer) {\n        var _gl = renderer.gl;\n        for (var attachment in this._textures) {\n            var obj = this._textures[attachment];\n            if (obj) {\n                var texture = obj.texture;\n                // FIXME some texture format can't generate mipmap\n                if (!texture.NPOT && texture.useMipmap\n                    && texture.minFilter === Texture.LINEAR_MIPMAP_LINEAR) {\n                    var target = texture.textureType === 'textureCube' ? glenum.TEXTURE_CUBE_MAP : glenum.TEXTURE_2D;\n                    _gl.bindTexture(target, texture.getWebGLTexture(renderer));\n                    _gl.generateMipmap(target);\n                    _gl.bindTexture(target, null);\n                }\n            }\n        }\n    },\n\n\n    // 0x8CD5, 36053, FRAMEBUFFER_COMPLETE\n    // 0x8CD6, 36054, FRAMEBUFFER_INCOMPLETE_ATTACHMENT\n    // 0x8CD7, 36055, FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT\n    // 0x8CD9, 36057, FRAMEBUFFER_INCOMPLETE_DIMENSIONS\n    // 0x8CDD, 36061, FRAMEBUFFER_UNSUPPORTED\n    checkStatus: function (_gl) {\n        return _gl.checkFramebufferStatus(GL_FRAMEBUFFER);\n    },\n\n    _getFrameBufferGL: function (renderer) {\n        var cache = this._cache;\n        cache.use(renderer.__uid__);\n\n        if (cache.miss(KEY_FRAMEBUFFER)) {\n            cache.put(KEY_FRAMEBUFFER, renderer.gl.createFramebuffer());\n        }\n\n        return cache.get(KEY_FRAMEBUFFER);\n    },\n\n    /**\n     * Attach a texture(RTT) to the framebuffer\n     * @param  {clay.Texture} texture\n     * @param  {number} [attachment=gl.COLOR_ATTACHMENT0]\n     * @param  {number} [target=gl.TEXTURE_2D]\n     */\n    attach: function (texture, attachment, target) {\n\n        if (!texture.width) {\n            throw new Error('The texture attached to color buffer is not a valid.');\n        }\n        // TODO width and height check\n\n        // If the depth_texture extension is enabled, developers\n        // Can attach a depth texture to the depth buffer\n        // http://blog.tojicode.com/2012/07/using-webgldepthtexture.html\n        attachment = attachment || GL_COLOR_ATTACHMENT0;\n        target = target || glenum.TEXTURE_2D;\n\n        var boundRenderer = this._boundRenderer;\n        var _gl = boundRenderer && boundRenderer.gl;\n        var attachedTextures;\n\n        if (_gl) {\n            var cache = this._cache;\n            cache.use(boundRenderer.__uid__);\n            attachedTextures = cache.get('attached_textures');\n        }\n\n        // Check if texture attached\n        var previous = this._textures[attachment];\n        if (previous && previous.target === target\n            && previous.texture === texture\n            && (attachedTextures && attachedTextures[attachment] != null)\n        ) {\n            return;\n        }\n\n        var canAttach = true;\n        if (boundRenderer) {\n            canAttach = this._doAttach(boundRenderer, texture, attachment, target);\n            // Set viewport again incase attached to different size textures.\n            if (!this.viewport) {\n                boundRenderer.setViewport(0, 0, texture.width, texture.height, 1);\n            }\n        }\n\n        if (canAttach) {\n            this._textures[attachment] = this._textures[attachment] || {};\n            this._textures[attachment].texture = texture;\n            this._textures[attachment].target = target;\n        }\n    },\n\n    _doAttach: function (renderer, texture, attachment, target) {\n        var _gl = renderer.gl;\n        // Make sure texture is always updated\n        // Because texture width or height may be changed and in this we can't be notified\n        // FIXME awkward;\n        var webglTexture = texture.getWebGLTexture(renderer);\n        // Assume cache has been used.\n        var attachedTextures = this._cache.get('attached_textures');\n        if (attachedTextures && attachedTextures[attachment]) {\n            var obj = attachedTextures[attachment];\n            // Check if texture and target not changed\n            if (obj.texture === texture && obj.target === target) {\n                return;\n            }\n        }\n        attachment = +attachment;\n\n        var canAttach = true;\n        if (attachment === GL_DEPTH_ATTACHMENT || attachment === glenum.DEPTH_STENCIL_ATTACHMENT) {\n            var extension = renderer.getGLExtension('WEBGL_depth_texture');\n\n            if (!extension) {\n                console.error('Depth texture is not supported by the browser');\n                canAttach = false;\n            }\n            if (texture.format !== glenum.DEPTH_COMPONENT\n                && texture.format !== glenum.DEPTH_STENCIL\n            ) {\n                console.error('The texture attached to depth buffer is not a valid.');\n                canAttach = false;\n            }\n\n            // Dispose render buffer created previous\n            if (canAttach) {\n                var renderbuffer = this._cache.get(KEY_RENDERBUFFER);\n                if (renderbuffer) {\n                    _gl.framebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, null);\n                    _gl.deleteRenderbuffer(renderbuffer);\n                    this._cache.put(KEY_RENDERBUFFER, false);\n                }\n\n                this._cache.put(KEY_RENDERBUFFER_ATTACHED, false);\n                this._cache.put(KEY_DEPTHTEXTURE_ATTACHED, true);\n            }\n        }\n\n        // Mipmap level can only be 0\n        _gl.framebufferTexture2D(GL_FRAMEBUFFER, attachment, target, webglTexture, 0);\n\n        if (!attachedTextures) {\n            attachedTextures = {};\n            this._cache.put('attached_textures', attachedTextures);\n        }\n        attachedTextures[attachment] = attachedTextures[attachment] || {};\n        attachedTextures[attachment].texture = texture;\n        attachedTextures[attachment].target = target;\n\n        return canAttach;\n    },\n\n    _doDetach: function (_gl, attachment, target) {\n        // Detach a texture from framebuffer\n        // https://github.com/KhronosGroup/WebGL/blob/master/conformance-suites/1.0.0/conformance/framebuffer-test.html#L145\n        _gl.framebufferTexture2D(GL_FRAMEBUFFER, attachment, target, null, 0);\n\n        // Assume cache has been used.\n        var attachedTextures = this._cache.get('attached_textures');\n        if (attachedTextures && attachedTextures[attachment]) {\n            attachedTextures[attachment] = null;\n        }\n\n        if (attachment === GL_DEPTH_ATTACHMENT || attachment === glenum.DEPTH_STENCIL_ATTACHMENT) {\n            this._cache.put(KEY_DEPTHTEXTURE_ATTACHED, false);\n        }\n    },\n\n    /**\n     * Detach a texture\n     * @param  {number} [attachment=gl.COLOR_ATTACHMENT0]\n     * @param  {number} [target=gl.TEXTURE_2D]\n     */\n    detach: function (attachment, target) {\n        // TODO depth extension check ?\n        this._textures[attachment] = null;\n        if (this._boundRenderer) {\n            var cache = this._cache;\n            cache.use(this._boundRenderer.__uid__);\n            this._doDetach(this._boundRenderer.gl, attachment, target);\n        }\n    },\n    /**\n     * Dispose\n     * @param  {WebGLRenderingContext} _gl\n     */\n    dispose: function (renderer) {\n\n        var _gl = renderer.gl;\n        var cache = this._cache;\n\n        cache.use(renderer.__uid__);\n\n        var renderBuffer = cache.get(KEY_RENDERBUFFER);\n        if (renderBuffer) {\n            _gl.deleteRenderbuffer(renderBuffer);\n        }\n        var frameBuffer = cache.get(KEY_FRAMEBUFFER);\n        if (frameBuffer) {\n            _gl.deleteFramebuffer(frameBuffer);\n        }\n        cache.deleteContext(renderer.__uid__);\n\n        // Clear cache for reusing\n        this._textures = {};\n\n    }\n});\n\nFrameBuffer.DEPTH_ATTACHMENT = GL_DEPTH_ATTACHMENT;\nFrameBuffer.COLOR_ATTACHMENT0 = GL_COLOR_ATTACHMENT0;\nFrameBuffer.STENCIL_ATTACHMENT = glenum.STENCIL_ATTACHMENT;\nFrameBuffer.DEPTH_STENCIL_ATTACHMENT = glenum.DEPTH_STENCIL_ATTACHMENT;\n\nexport default FrameBuffer;\n"]},"metadata":{},"sourceType":"module"}