{"ast":null,"code":"import Vector3 from './Vector3';\nimport mat4 from '../glmatrix/mat4';\nimport vec3 from '../glmatrix/vec3';\nimport vec4 from '../glmatrix/vec4';\n/**\n * @constructor\n * @alias clay.Plane\n * @param {clay.Vector3} [normal]\n * @param {number} [distance]\n */\n\nvar Plane = function (normal, distance) {\n  /**\n   * Normal of the plane\n   * @type {clay.Vector3}\n   */\n  this.normal = normal || new Vector3(0, 1, 0);\n  /**\n   * Constant of the plane equation, used as distance to the origin\n   * @type {number}\n   */\n\n  this.distance = distance || 0;\n};\n\nPlane.prototype = {\n  constructor: Plane,\n\n  /**\n   * Distance from a given point to the plane\n   * @param  {clay.Vector3} point\n   * @return {number}\n   */\n  distanceToPoint: function (point) {\n    return vec3.dot(point.array, this.normal.array) - this.distance;\n  },\n\n  /**\n   * Calculate the projection point on the plane\n   * @param  {clay.Vector3} point\n   * @param  {clay.Vector3} out\n   * @return {clay.Vector3}\n   */\n  projectPoint: function (point, out) {\n    if (!out) {\n      out = new Vector3();\n    }\n\n    var d = this.distanceToPoint(point);\n    vec3.scaleAndAdd(out.array, point.array, this.normal.array, -d);\n    out._dirty = true;\n    return out;\n  },\n\n  /**\n   * Normalize the plane's normal and calculate the distance\n   */\n  normalize: function () {\n    var invLen = 1 / vec3.len(this.normal.array);\n    vec3.scale(this.normal.array, invLen);\n    this.distance *= invLen;\n  },\n\n  /**\n   * If the plane intersect a frustum\n   * @param  {clay.Frustum} Frustum\n   * @return {boolean}\n   */\n  intersectFrustum: function (frustum) {\n    // Check if all coords of frustum is on plane all under plane\n    var coords = frustum.vertices;\n    var normal = this.normal.array;\n    var onPlane = vec3.dot(coords[0].array, normal) > this.distance;\n\n    for (var i = 1; i < 8; i++) {\n      if (vec3.dot(coords[i].array, normal) > this.distance != onPlane) {\n        return true;\n      }\n    }\n  },\n\n  /**\n   * Calculate the intersection point between plane and a given line\n   * @function\n   * @param {clay.Vector3} start start point of line\n   * @param {clay.Vector3} end end point of line\n   * @param {clay.Vector3} [out]\n   * @return {clay.Vector3}\n   */\n  intersectLine: function () {\n    var rd = vec3.create();\n    return function (start, end, out) {\n      var d0 = this.distanceToPoint(start);\n      var d1 = this.distanceToPoint(end);\n\n      if (d0 > 0 && d1 > 0 || d0 < 0 && d1 < 0) {\n        return null;\n      } // Ray intersection\n\n\n      var pn = this.normal.array;\n      var d = this.distance;\n      var ro = start.array; // direction\n\n      vec3.sub(rd, end.array, start.array);\n      vec3.normalize(rd, rd);\n      var divider = vec3.dot(pn, rd); // ray is parallel to the plane\n\n      if (divider === 0) {\n        return null;\n      }\n\n      if (!out) {\n        out = new Vector3();\n      }\n\n      var t = (vec3.dot(pn, ro) - d) / divider;\n      vec3.scaleAndAdd(out.array, ro, rd, -t);\n      out._dirty = true;\n      return out;\n    };\n  }(),\n\n  /**\n   * Apply an affine transform matrix to plane\n   * @function\n   * @return {clay.Matrix4}\n   */\n  applyTransform: function () {\n    var inverseTranspose = mat4.create();\n    var normalv4 = vec4.create();\n    var pointv4 = vec4.create();\n    pointv4[3] = 1;\n    return function (m4) {\n      m4 = m4.array; // Transform point on plane\n\n      vec3.scale(pointv4, this.normal.array, this.distance);\n      vec4.transformMat4(pointv4, pointv4, m4);\n      this.distance = vec3.dot(pointv4, this.normal.array); // Transform plane normal\n\n      mat4.invert(inverseTranspose, m4);\n      mat4.transpose(inverseTranspose, inverseTranspose);\n      normalv4[3] = 0;\n      vec3.copy(normalv4, this.normal.array);\n      vec4.transformMat4(normalv4, normalv4, inverseTranspose);\n      vec3.copy(this.normal.array, normalv4);\n    };\n  }(),\n\n  /**\n   * Copy from another plane\n   * @param  {clay.Vector3} plane\n   */\n  copy: function (plane) {\n    vec3.copy(this.normal.array, plane.normal.array);\n    this.normal._dirty = true;\n    this.distance = plane.distance;\n  },\n\n  /**\n   * Clone a new plane\n   * @return {clay.Plane}\n   */\n  clone: function () {\n    var plane = new Plane();\n    plane.copy(this);\n    return plane;\n  }\n};\nexport default Plane;","map":{"version":3,"sources":["C:/Users/Administrator/Desktop/data_view/my_project/vue2_app/myapp/node_modules/claygl/src/math/Plane.js"],"names":["Vector3","mat4","vec3","vec4","Plane","normal","distance","prototype","constructor","distanceToPoint","point","dot","array","projectPoint","out","d","scaleAndAdd","_dirty","normalize","invLen","len","scale","intersectFrustum","frustum","coords","vertices","onPlane","i","intersectLine","rd","create","start","end","d0","d1","pn","ro","sub","divider","t","applyTransform","inverseTranspose","normalv4","pointv4","m4","transformMat4","invert","transpose","copy","plane","clone"],"mappings":"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","sourcesContent":["import Vector3 from './Vector3';\nimport mat4 from '../glmatrix/mat4';\nimport vec3 from '../glmatrix/vec3';\nimport vec4 from '../glmatrix/vec4';\n\n/**\n * @constructor\n * @alias clay.Plane\n * @param {clay.Vector3} [normal]\n * @param {number} [distance]\n */\nvar Plane = function(normal, distance) {\n    /**\n     * Normal of the plane\n     * @type {clay.Vector3}\n     */\n    this.normal = normal || new Vector3(0, 1, 0);\n\n    /**\n     * Constant of the plane equation, used as distance to the origin\n     * @type {number}\n     */\n    this.distance = distance || 0;\n};\n\nPlane.prototype = {\n\n    constructor: Plane,\n\n    /**\n     * Distance from a given point to the plane\n     * @param  {clay.Vector3} point\n     * @return {number}\n     */\n    distanceToPoint: function(point) {\n        return vec3.dot(point.array, this.normal.array) - this.distance;\n    },\n\n    /**\n     * Calculate the projection point on the plane\n     * @param  {clay.Vector3} point\n     * @param  {clay.Vector3} out\n     * @return {clay.Vector3}\n     */\n    projectPoint: function(point, out) {\n        if (!out) {\n            out = new Vector3();\n        }\n        var d = this.distanceToPoint(point);\n        vec3.scaleAndAdd(out.array, point.array, this.normal.array, -d);\n        out._dirty = true;\n        return out;\n    },\n\n    /**\n     * Normalize the plane's normal and calculate the distance\n     */\n    normalize: function() {\n        var invLen = 1 / vec3.len(this.normal.array);\n        vec3.scale(this.normal.array, invLen);\n        this.distance *= invLen;\n    },\n\n    /**\n     * If the plane intersect a frustum\n     * @param  {clay.Frustum} Frustum\n     * @return {boolean}\n     */\n    intersectFrustum: function(frustum) {\n        // Check if all coords of frustum is on plane all under plane\n        var coords = frustum.vertices;\n        var normal = this.normal.array;\n        var onPlane = vec3.dot(coords[0].array, normal) > this.distance;\n        for (var i = 1; i < 8; i++) {\n            if ((vec3.dot(coords[i].array, normal) > this.distance) != onPlane) {\n                return true;\n            }\n        }\n    },\n\n    /**\n     * Calculate the intersection point between plane and a given line\n     * @function\n     * @param {clay.Vector3} start start point of line\n     * @param {clay.Vector3} end end point of line\n     * @param {clay.Vector3} [out]\n     * @return {clay.Vector3}\n     */\n    intersectLine: (function() {\n        var rd = vec3.create();\n        return function(start, end, out) {\n            var d0 = this.distanceToPoint(start);\n            var d1 = this.distanceToPoint(end);\n            if ((d0 > 0 && d1 > 0) || (d0 < 0 && d1 < 0)) {\n                return null;\n            }\n            // Ray intersection\n            var pn = this.normal.array;\n            var d = this.distance;\n            var ro = start.array;\n            // direction\n            vec3.sub(rd, end.array, start.array);\n            vec3.normalize(rd, rd);\n\n            var divider = vec3.dot(pn, rd);\n            // ray is parallel to the plane\n            if (divider === 0) {\n                return null;\n            }\n            if (!out) {\n                out = new Vector3();\n            }\n            var t = (vec3.dot(pn, ro) - d) / divider;\n            vec3.scaleAndAdd(out.array, ro, rd, -t);\n            out._dirty = true;\n            return out;\n        };\n    })(),\n\n    /**\n     * Apply an affine transform matrix to plane\n     * @function\n     * @return {clay.Matrix4}\n     */\n    applyTransform: (function() {\n        var inverseTranspose = mat4.create();\n        var normalv4 = vec4.create();\n        var pointv4 = vec4.create();\n        pointv4[3] = 1;\n        return function(m4) {\n            m4 = m4.array;\n            // Transform point on plane\n            vec3.scale(pointv4, this.normal.array, this.distance);\n            vec4.transformMat4(pointv4, pointv4, m4);\n            this.distance = vec3.dot(pointv4, this.normal.array);\n            // Transform plane normal\n            mat4.invert(inverseTranspose, m4);\n            mat4.transpose(inverseTranspose, inverseTranspose);\n            normalv4[3] = 0;\n            vec3.copy(normalv4, this.normal.array);\n            vec4.transformMat4(normalv4, normalv4, inverseTranspose);\n            vec3.copy(this.normal.array, normalv4);\n        };\n    })(),\n\n    /**\n     * Copy from another plane\n     * @param  {clay.Vector3} plane\n     */\n    copy: function(plane) {\n        vec3.copy(this.normal.array, plane.normal.array);\n        this.normal._dirty = true;\n        this.distance = plane.distance;\n    },\n\n    /**\n     * Clone a new plane\n     * @return {clay.Plane}\n     */\n    clone: function() {\n        var plane = new Plane();\n        plane.copy(this);\n        return plane;\n    }\n};\n\nexport default Plane;\n"]},"metadata":{},"sourceType":"module"}