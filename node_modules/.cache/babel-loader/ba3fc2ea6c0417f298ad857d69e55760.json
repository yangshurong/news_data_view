{"ast":null,"code":"import \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.object.keys.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport Base from './core/Base';\nimport glenum from './core/glenum';\nimport Cache from './core/Cache';\nimport vendor from './core/vendor';\n\nfunction getArrayCtorByType(type) {\n  return {\n    'byte': vendor.Int8Array,\n    'ubyte': vendor.Uint8Array,\n    'short': vendor.Int16Array,\n    'ushort': vendor.Uint16Array\n  }[type] || vendor.Float32Array;\n}\n\nfunction makeAttrKey(attrName) {\n  return 'attr_' + attrName;\n}\n/**\n * GeometryBase attribute\n * @alias clay.GeometryBase.Attribute\n * @constructor\n */\n\n\nfunction Attribute(name, type, size, semantic) {\n  /**\n   * Attribute name\n   * @type {string}\n   */\n  this.name = name;\n  /**\n   * Attribute type\n   * Possible values:\n   *  + `'byte'`\n   *  + `'ubyte'`\n   *  + `'short'`\n   *  + `'ushort'`\n   *  + `'float'` Most commonly used.\n   * @type {string}\n   */\n\n  this.type = type;\n  /**\n   * Size of attribute component. 1 - 4.\n   * @type {number}\n   */\n\n  this.size = size;\n  /**\n   * Semantic of this attribute.\n   * Possible values:\n   *  + `'POSITION'`\n   *  + `'NORMAL'`\n   *  + `'BINORMAL'`\n   *  + `'TANGENT'`\n   *  + `'TEXCOORD'`\n   *  + `'TEXCOORD_0'`\n   *  + `'TEXCOORD_1'`\n   *  + `'COLOR'`\n   *  + `'JOINT'`\n   *  + `'WEIGHT'`\n   *\n   * In shader, attribute with same semantic will be automatically mapped. For example:\n   * ```glsl\n   * attribute vec3 pos: POSITION\n   * ```\n   * will use the attribute value with semantic POSITION in geometry, no matter what name it used.\n   * @type {string}\n   */\n\n  this.semantic = semantic || '';\n  /**\n   * Value of the attribute.\n   * @type {TypedArray}\n   */\n\n  this.value = null; // Init getter setter\n\n  switch (size) {\n    case 1:\n      this.get = function (idx) {\n        return this.value[idx];\n      };\n\n      this.set = function (idx, value) {\n        this.value[idx] = value;\n      }; // Copy from source to target\n\n\n      this.copy = function (target, source) {\n        this.value[target] = this.value[target];\n      };\n\n      break;\n\n    case 2:\n      this.get = function (idx, out) {\n        var arr = this.value;\n        out[0] = arr[idx * 2];\n        out[1] = arr[idx * 2 + 1];\n        return out;\n      };\n\n      this.set = function (idx, val) {\n        var arr = this.value;\n        arr[idx * 2] = val[0];\n        arr[idx * 2 + 1] = val[1];\n      };\n\n      this.copy = function (target, source) {\n        var arr = this.value;\n        source *= 2;\n        target *= 2;\n        arr[target] = arr[source];\n        arr[target + 1] = arr[source + 1];\n      };\n\n      break;\n\n    case 3:\n      this.get = function (idx, out) {\n        var idx3 = idx * 3;\n        var arr = this.value;\n        out[0] = arr[idx3];\n        out[1] = arr[idx3 + 1];\n        out[2] = arr[idx3 + 2];\n        return out;\n      };\n\n      this.set = function (idx, val) {\n        var idx3 = idx * 3;\n        var arr = this.value;\n        arr[idx3] = val[0];\n        arr[idx3 + 1] = val[1];\n        arr[idx3 + 2] = val[2];\n      };\n\n      this.copy = function (target, source) {\n        var arr = this.value;\n        source *= 3;\n        target *= 3;\n        arr[target] = arr[source];\n        arr[target + 1] = arr[source + 1];\n        arr[target + 2] = arr[source + 2];\n      };\n\n      break;\n\n    case 4:\n      this.get = function (idx, out) {\n        var arr = this.value;\n        var idx4 = idx * 4;\n        out[0] = arr[idx4];\n        out[1] = arr[idx4 + 1];\n        out[2] = arr[idx4 + 2];\n        out[3] = arr[idx4 + 3];\n        return out;\n      };\n\n      this.set = function (idx, val) {\n        var arr = this.value;\n        var idx4 = idx * 4;\n        arr[idx4] = val[0];\n        arr[idx4 + 1] = val[1];\n        arr[idx4 + 2] = val[2];\n        arr[idx4 + 3] = val[3];\n      };\n\n      this.copy = function (target, source) {\n        var arr = this.value;\n        source *= 4;\n        target *= 4; // copyWithin is extremely slow\n\n        arr[target] = arr[source];\n        arr[target + 1] = arr[source + 1];\n        arr[target + 2] = arr[source + 2];\n        arr[target + 3] = arr[source + 3];\n      };\n\n  }\n}\n/**\n * Set item value at give index. Second parameter val is number if size is 1\n * @function\n * @name clay.GeometryBase.Attribute#set\n * @param {number} idx\n * @param {number[]|number} val\n * @example\n * geometry.getAttribute('position').set(0, [1, 1, 1]);\n */\n\n/**\n * Get item value at give index. Second parameter out is no need if size is 1\n * @function\n * @name clay.GeometryBase.Attribute#set\n * @param {number} idx\n * @param {number[]} [out]\n * @example\n * geometry.getAttribute('position').get(0, out);\n */\n\n/**\n * Initialize attribute with given vertex count\n * @param {number} nVertex\n */\n\n\nAttribute.prototype.init = function (nVertex) {\n  if (!this.value || this.value.length !== nVertex * this.size) {\n    var ArrayConstructor = getArrayCtorByType(this.type);\n    this.value = new ArrayConstructor(nVertex * this.size);\n  }\n};\n/**\n * Initialize attribute with given array. Which can be 1 dimensional or 2 dimensional\n * @param {Array} array\n * @example\n *  geometry.getAttribute('position').fromArray(\n *      [-1, 0, 0, 1, 0, 0, 0, 1, 0]\n *  );\n *  geometry.getAttribute('position').fromArray(\n *      [ [-1, 0, 0], [1, 0, 0], [0, 1, 0] ]\n *  );\n */\n\n\nAttribute.prototype.fromArray = function (array) {\n  var ArrayConstructor = getArrayCtorByType(this.type);\n  var value; // Convert 2d array to flat\n\n  if (array[0] && array[0].length) {\n    var n = 0;\n    var size = this.size;\n    value = new ArrayConstructor(array.length * size);\n\n    for (var i = 0; i < array.length; i++) {\n      for (var j = 0; j < size; j++) {\n        value[n++] = array[i][j];\n      }\n    }\n  } else {\n    value = new ArrayConstructor(array);\n  }\n\n  this.value = value;\n};\n\nAttribute.prototype.clone = function (copyValue) {\n  var ret = new Attribute(this.name, this.type, this.size, this.semantic); // FIXME\n\n  if (copyValue) {\n    console.warn('todo');\n  }\n\n  return ret;\n};\n\nfunction AttributeBuffer(name, type, buffer, size, semantic) {\n  this.name = name;\n  this.type = type;\n  this.buffer = buffer;\n  this.size = size;\n  this.semantic = semantic; // To be set in mesh\n  // symbol in the shader\n\n  this.symbol = ''; // Needs remove flag\n\n  this.needsRemove = false;\n}\n\nfunction IndicesBuffer(buffer) {\n  this.buffer = buffer;\n  this.count = 0;\n}\n/**\n * Base of all geometry. Use {@link clay.Geometry} for common 3D usage.\n * @constructor clay.GeometryBase\n * @extends clay.core.Base\n */\n\n\nvar GeometryBase = Base.extend(function () {\n  return (\n    /** @lends clay.GeometryBase# */\n    {\n      /**\n       * Attributes of geometry.\n       * @type {Object.<string, clay.GeometryBase.Attribute>}\n       */\n      attributes: {},\n\n      /**\n       * Indices of geometry.\n       * @type {Uint16Array|Uint32Array}\n       */\n      indices: null,\n\n      /**\n       * Is vertices data dynamically updated.\n       * Attributes value can't be changed after first render if dyanmic is false.\n       * @type {boolean}\n       */\n      dynamic: true,\n      _enabledAttributes: null,\n      // PENDING\n      // Init it here to avoid deoptimization when it's assigned in application dynamically\n      __used: 0\n    }\n  );\n}, function () {\n  // Use cache\n  this._cache = new Cache();\n  this._attributeList = Object.keys(this.attributes);\n  this.__vaoCache = {};\n},\n/** @lends clay.GeometryBase.prototype */\n{\n  /**\n   * Main attribute will be used to count vertex number\n   * @type {string}\n   */\n  mainAttribute: '',\n\n  /**\n   * User defined picking algorithm instead of default\n   * triangle ray intersection\n   * x, y are NDC.\n   * ```typescript\n   * (x, y, renderer, camera, renderable, out) => boolean\n   * ```\n   * @type {?Function}\n   */\n  pick: null,\n\n  /**\n   * User defined ray picking algorithm instead of default\n   * triangle ray intersection\n   * ```typescript\n   * (ray: clay.Ray, renderable: clay.Renderable, out: Array) => boolean\n   * ```\n   * @type {?Function}\n   */\n  pickByRay: null,\n\n  /**\n   * Mark attributes and indices in geometry needs to update.\n   * Usually called after you change the data in attributes.\n   */\n  dirty: function dirty() {\n    var enabledAttributes = this.getEnabledAttributes();\n\n    for (var i = 0; i < enabledAttributes.length; i++) {\n      this.dirtyAttribute(enabledAttributes[i]);\n    }\n\n    this.dirtyIndices();\n    this._enabledAttributes = null;\n\n    this._cache.dirty('any');\n  },\n\n  /**\n   * Mark the indices needs to update.\n   */\n  dirtyIndices: function dirtyIndices() {\n    this._cache.dirtyAll('indices');\n  },\n\n  /**\n   * Mark the attributes needs to update.\n   * @param {string} [attrName]\n   */\n  dirtyAttribute: function dirtyAttribute(attrName) {\n    this._cache.dirtyAll(makeAttrKey(attrName));\n\n    this._cache.dirtyAll('attributes');\n  },\n\n  /**\n   * Get indices of triangle at given index.\n   * @param {number} idx\n   * @param {Array.<number>} out\n   * @return {Array.<number>}\n   */\n  getTriangleIndices: function getTriangleIndices(idx, out) {\n    if (idx < this.triangleCount && idx >= 0) {\n      if (!out) {\n        out = [];\n      }\n\n      var indices = this.indices;\n      out[0] = indices[idx * 3];\n      out[1] = indices[idx * 3 + 1];\n      out[2] = indices[idx * 3 + 2];\n      return out;\n    }\n  },\n\n  /**\n   * Set indices of triangle at given index.\n   * @param {number} idx\n   * @param {Array.<number>} arr\n   */\n  setTriangleIndices: function setTriangleIndices(idx, arr) {\n    var indices = this.indices;\n    indices[idx * 3] = arr[0];\n    indices[idx * 3 + 1] = arr[1];\n    indices[idx * 3 + 2] = arr[2];\n  },\n  isUseIndices: function isUseIndices() {\n    return !!this.indices;\n  },\n\n  /**\n   * Initialize indices from an array.\n   * @param {Array} array\n   */\n  initIndicesFromArray: function initIndicesFromArray(array) {\n    var value;\n    var ArrayConstructor = this.vertexCount > 0xffff ? vendor.Uint32Array : vendor.Uint16Array; // Convert 2d array to flat\n\n    if (array[0] && array[0].length) {\n      var n = 0;\n      var size = 3;\n      value = new ArrayConstructor(array.length * size);\n\n      for (var i = 0; i < array.length; i++) {\n        for (var j = 0; j < size; j++) {\n          value[n++] = array[i][j];\n        }\n      }\n    } else {\n      value = new ArrayConstructor(array);\n    }\n\n    this.indices = value;\n  },\n\n  /**\n   * Create a new attribute\n   * @param {string} name\n   * @param {string} type\n   * @param {number} size\n   * @param {string} [semantic]\n   */\n  createAttribute: function createAttribute(name, type, size, semantic) {\n    var attrib = new Attribute(name, type, size, semantic);\n\n    if (this.attributes[name]) {\n      this.removeAttribute(name);\n    }\n\n    this.attributes[name] = attrib;\n\n    this._attributeList.push(name);\n\n    return attrib;\n  },\n\n  /**\n   * Remove attribute\n   * @param {string} name\n   */\n  removeAttribute: function removeAttribute(name) {\n    var attributeList = this._attributeList;\n    var idx = attributeList.indexOf(name);\n\n    if (idx >= 0) {\n      attributeList.splice(idx, 1);\n      delete this.attributes[name];\n      return true;\n    }\n\n    return false;\n  },\n\n  /**\n   * Get attribute\n   * @param {string} name\n   * @return {clay.GeometryBase.Attribute}\n   */\n  getAttribute: function getAttribute(name) {\n    return this.attributes[name];\n  },\n\n  /**\n   * Get enabled attributes name list\n   * Attribute which has the same vertex number with position is treated as a enabled attribute\n   * @return {string[]}\n   */\n  getEnabledAttributes: function getEnabledAttributes() {\n    var enabledAttributes = this._enabledAttributes;\n    var attributeList = this._attributeList; // Cache\n\n    if (enabledAttributes) {\n      return enabledAttributes;\n    }\n\n    var result = [];\n    var nVertex = this.vertexCount;\n\n    for (var i = 0; i < attributeList.length; i++) {\n      var name = attributeList[i];\n      var attrib = this.attributes[name];\n\n      if (attrib.value) {\n        if (attrib.value.length === nVertex * attrib.size) {\n          result.push(name);\n        }\n      }\n    }\n\n    this._enabledAttributes = result;\n    return result;\n  },\n  getBufferChunks: function getBufferChunks(renderer) {\n    var cache = this._cache;\n    cache.use(renderer.__uid__);\n    var isAttributesDirty = cache.isDirty('attributes');\n    var isIndicesDirty = cache.isDirty('indices');\n\n    if (isAttributesDirty || isIndicesDirty) {\n      this._updateBuffer(renderer.gl, isAttributesDirty, isIndicesDirty);\n\n      var enabledAttributes = this.getEnabledAttributes();\n\n      for (var i = 0; i < enabledAttributes.length; i++) {\n        cache.fresh(makeAttrKey(enabledAttributes[i]));\n      }\n\n      cache.fresh('attributes');\n      cache.fresh('indices');\n    }\n\n    cache.fresh('any');\n    return cache.get('chunks');\n  },\n  _updateBuffer: function _updateBuffer(_gl, isAttributesDirty, isIndicesDirty) {\n    var cache = this._cache;\n    var chunks = cache.get('chunks');\n    var firstUpdate = false;\n\n    if (!chunks) {\n      chunks = []; // Intialize\n\n      chunks[0] = {\n        attributeBuffers: [],\n        indicesBuffer: null\n      };\n      cache.put('chunks', chunks);\n      firstUpdate = true;\n    }\n\n    var chunk = chunks[0];\n    var attributeBuffers = chunk.attributeBuffers;\n    var indicesBuffer = chunk.indicesBuffer;\n\n    if (isAttributesDirty || firstUpdate) {\n      var attributeList = this.getEnabledAttributes();\n      var attributeBufferMap = {};\n\n      if (!firstUpdate) {\n        for (var i = 0; i < attributeBuffers.length; i++) {\n          attributeBufferMap[attributeBuffers[i].name] = attributeBuffers[i];\n        }\n      } // FIXME If some attributes removed\n\n\n      for (var k = 0; k < attributeList.length; k++) {\n        var name = attributeList[k];\n        var attribute = this.attributes[name];\n        var bufferInfo;\n\n        if (!firstUpdate) {\n          bufferInfo = attributeBufferMap[name];\n        }\n\n        var buffer;\n\n        if (bufferInfo) {\n          buffer = bufferInfo.buffer;\n        } else {\n          buffer = _gl.createBuffer();\n        }\n\n        if (cache.isDirty(makeAttrKey(name))) {\n          // Only update when they are dirty.\n          // TODO: Use BufferSubData?\n          _gl.bindBuffer(_gl.ARRAY_BUFFER, buffer);\n\n          _gl.bufferData(_gl.ARRAY_BUFFER, attribute.value, this.dynamic ? _gl.DYNAMIC_DRAW : _gl.STATIC_DRAW);\n        }\n\n        attributeBuffers[k] = new AttributeBuffer(name, attribute.type, buffer, attribute.size, attribute.semantic);\n      } // Remove unused attributes buffers.\n      // PENDING\n\n\n      for (var i = k; i < attributeBuffers.length; i++) {\n        _gl.deleteBuffer(attributeBuffers[i].buffer);\n      }\n\n      attributeBuffers.length = k;\n    }\n\n    if (this.isUseIndices() && (isIndicesDirty || firstUpdate)) {\n      if (!indicesBuffer) {\n        indicesBuffer = new IndicesBuffer(_gl.createBuffer());\n        chunk.indicesBuffer = indicesBuffer;\n      }\n\n      indicesBuffer.count = this.indices.length;\n\n      _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, indicesBuffer.buffer);\n\n      _gl.bufferData(_gl.ELEMENT_ARRAY_BUFFER, this.indices, this.dynamic ? _gl.DYNAMIC_DRAW : _gl.STATIC_DRAW);\n    }\n  },\n\n  /**\n   * Dispose geometry data in GL context.\n   * @param {clay.Renderer} renderer\n   */\n  dispose: function dispose(renderer) {\n    var cache = this._cache;\n    cache.use(renderer.__uid__);\n    var chunks = cache.get('chunks');\n\n    if (chunks) {\n      for (var c = 0; c < chunks.length; c++) {\n        var chunk = chunks[c];\n\n        for (var k = 0; k < chunk.attributeBuffers.length; k++) {\n          var attribs = chunk.attributeBuffers[k];\n          renderer.gl.deleteBuffer(attribs.buffer);\n        }\n\n        if (chunk.indicesBuffer) {\n          renderer.gl.deleteBuffer(chunk.indicesBuffer.buffer);\n        }\n      }\n    }\n\n    if (this.__vaoCache) {\n      var vaoExt = renderer.getGLExtension('OES_vertex_array_object');\n\n      for (var id in this.__vaoCache) {\n        var vao = this.__vaoCache[id].vao;\n\n        if (vao) {\n          vaoExt.deleteVertexArrayOES(vao);\n        }\n      }\n    }\n\n    this.__vaoCache = {};\n    cache.deleteContext(renderer.__uid__);\n  }\n});\n\nif (Object.defineProperty) {\n  /**\n   * @name clay.GeometryBase#vertexCount\n   * @type {number}\n   * @readOnly\n   */\n  Object.defineProperty(GeometryBase.prototype, 'vertexCount', {\n    enumerable: false,\n    get: function get() {\n      var mainAttribute = this.attributes[this.mainAttribute];\n\n      if (!mainAttribute) {\n        mainAttribute = this.attributes[this._attributeList[0]];\n      }\n\n      if (!mainAttribute || !mainAttribute.value) {\n        return 0;\n      }\n\n      return mainAttribute.value.length / mainAttribute.size;\n    }\n  });\n  /**\n   * @name clay.GeometryBase#triangleCount\n   * @type {number}\n   * @readOnly\n   */\n\n  Object.defineProperty(GeometryBase.prototype, 'triangleCount', {\n    enumerable: false,\n    get: function get() {\n      var indices = this.indices;\n\n      if (!indices) {\n        return 0;\n      } else {\n        return indices.length / 3;\n      }\n    }\n  });\n}\n\nGeometryBase.STATIC_DRAW = glenum.STATIC_DRAW;\nGeometryBase.DYNAMIC_DRAW = glenum.DYNAMIC_DRAW;\nGeometryBase.STREAM_DRAW = glenum.STREAM_DRAW;\nGeometryBase.AttributeBuffer = AttributeBuffer;\nGeometryBase.IndicesBuffer = IndicesBuffer;\nGeometryBase.Attribute = Attribute;\nexport default GeometryBase;","map":{"version":3,"sources":["C:/Users/Administrator/Desktop/data_view/my_project/vue2_app/myapp/node_modules/_claygl@1.3.0@claygl/src/GeometryBase.js"],"names":["Base","glenum","Cache","vendor","getArrayCtorByType","type","Int8Array","Uint8Array","Int16Array","Uint16Array","Float32Array","makeAttrKey","attrName","Attribute","name","size","semantic","value","get","idx","set","copy","target","source","out","arr","val","idx3","idx4","prototype","init","nVertex","length","ArrayConstructor","fromArray","array","n","i","j","clone","copyValue","ret","console","warn","AttributeBuffer","buffer","symbol","needsRemove","IndicesBuffer","count","GeometryBase","extend","attributes","indices","dynamic","_enabledAttributes","__used","_cache","_attributeList","Object","keys","__vaoCache","mainAttribute","pick","pickByRay","dirty","enabledAttributes","getEnabledAttributes","dirtyAttribute","dirtyIndices","dirtyAll","getTriangleIndices","triangleCount","setTriangleIndices","isUseIndices","initIndicesFromArray","vertexCount","Uint32Array","createAttribute","attrib","removeAttribute","push","attributeList","indexOf","splice","getAttribute","result","getBufferChunks","renderer","cache","use","__uid__","isAttributesDirty","isDirty","isIndicesDirty","_updateBuffer","gl","fresh","_gl","chunks","firstUpdate","attributeBuffers","indicesBuffer","put","chunk","attributeBufferMap","k","attribute","bufferInfo","createBuffer","bindBuffer","ARRAY_BUFFER","bufferData","DYNAMIC_DRAW","STATIC_DRAW","deleteBuffer","ELEMENT_ARRAY_BUFFER","dispose","c","attribs","vaoExt","getGLExtension","id","vao","deleteVertexArrayOES","deleteContext","defineProperty","enumerable","STREAM_DRAW"],"mappings":"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","sourcesContent":["import Base from './core/Base';\nimport glenum from './core/glenum';\nimport Cache from './core/Cache';\nimport vendor from './core/vendor';\n\nfunction getArrayCtorByType (type) {\n    return ({\n        'byte': vendor.Int8Array,\n        'ubyte': vendor.Uint8Array,\n        'short': vendor.Int16Array,\n        'ushort': vendor.Uint16Array\n    })[type] || vendor.Float32Array;\n}\n\nfunction makeAttrKey(attrName) {\n    return 'attr_' + attrName;\n}\n/**\n * GeometryBase attribute\n * @alias clay.GeometryBase.Attribute\n * @constructor\n */\nfunction Attribute(name, type, size, semantic) {\n    /**\n     * Attribute name\n     * @type {string}\n     */\n    this.name = name;\n    /**\n     * Attribute type\n     * Possible values:\n     *  + `'byte'`\n     *  + `'ubyte'`\n     *  + `'short'`\n     *  + `'ushort'`\n     *  + `'float'` Most commonly used.\n     * @type {string}\n     */\n    this.type = type;\n    /**\n     * Size of attribute component. 1 - 4.\n     * @type {number}\n     */\n    this.size = size;\n    /**\n     * Semantic of this attribute.\n     * Possible values:\n     *  + `'POSITION'`\n     *  + `'NORMAL'`\n     *  + `'BINORMAL'`\n     *  + `'TANGENT'`\n     *  + `'TEXCOORD'`\n     *  + `'TEXCOORD_0'`\n     *  + `'TEXCOORD_1'`\n     *  + `'COLOR'`\n     *  + `'JOINT'`\n     *  + `'WEIGHT'`\n     *\n     * In shader, attribute with same semantic will be automatically mapped. For example:\n     * ```glsl\n     * attribute vec3 pos: POSITION\n     * ```\n     * will use the attribute value with semantic POSITION in geometry, no matter what name it used.\n     * @type {string}\n     */\n    this.semantic = semantic || '';\n\n    /**\n     * Value of the attribute.\n     * @type {TypedArray}\n     */\n    this.value = null;\n\n    // Init getter setter\n    switch (size) {\n        case 1:\n            this.get = function (idx) {\n                return this.value[idx];\n            };\n            this.set = function (idx, value) {\n                this.value[idx] = value;\n            };\n            // Copy from source to target\n            this.copy = function (target, source) {\n                this.value[target] = this.value[target];\n            };\n            break;\n        case 2:\n            this.get = function (idx, out) {\n                var arr = this.value;\n                out[0] = arr[idx * 2];\n                out[1] = arr[idx * 2 + 1];\n                return out;\n            };\n            this.set = function (idx, val) {\n                var arr = this.value;\n                arr[idx * 2] = val[0];\n                arr[idx * 2 + 1] = val[1];\n            };\n            this.copy = function (target, source) {\n                var arr = this.value;\n                source *= 2;\n                target *= 2;\n                arr[target] = arr[source];\n                arr[target + 1] = arr[source + 1];\n            };\n            break;\n        case 3:\n            this.get = function (idx, out) {\n                var idx3 = idx * 3;\n                var arr = this.value;\n                out[0] = arr[idx3];\n                out[1] = arr[idx3 + 1];\n                out[2] = arr[idx3 + 2];\n                return out;\n            };\n            this.set = function (idx, val) {\n                var idx3 = idx * 3;\n                var arr = this.value;\n                arr[idx3] = val[0];\n                arr[idx3 + 1] = val[1];\n                arr[idx3 + 2] = val[2];\n            };\n            this.copy = function (target, source) {\n                var arr = this.value;\n                source *= 3;\n                target *= 3;\n                arr[target] = arr[source];\n                arr[target + 1] = arr[source + 1];\n                arr[target + 2] = arr[source + 2];\n            };\n            break;\n        case 4:\n            this.get = function (idx, out) {\n                var arr = this.value;\n                var idx4 = idx * 4;\n                out[0] = arr[idx4];\n                out[1] = arr[idx4 + 1];\n                out[2] = arr[idx4 + 2];\n                out[3] = arr[idx4 + 3];\n                return out;\n            };\n            this.set = function (idx, val) {\n                var arr = this.value;\n                var idx4 = idx * 4;\n                arr[idx4] = val[0];\n                arr[idx4 + 1] = val[1];\n                arr[idx4 + 2] = val[2];\n                arr[idx4 + 3] = val[3];\n            };\n            this.copy = function (target, source) {\n                var arr = this.value;\n                source *= 4;\n                target *= 4;\n                // copyWithin is extremely slow\n                arr[target] = arr[source];\n                arr[target + 1] = arr[source + 1];\n                arr[target + 2] = arr[source + 2];\n                arr[target + 3] = arr[source + 3];\n            };\n    }\n}\n\n/**\n * Set item value at give index. Second parameter val is number if size is 1\n * @function\n * @name clay.GeometryBase.Attribute#set\n * @param {number} idx\n * @param {number[]|number} val\n * @example\n * geometry.getAttribute('position').set(0, [1, 1, 1]);\n */\n\n/**\n * Get item value at give index. Second parameter out is no need if size is 1\n * @function\n * @name clay.GeometryBase.Attribute#set\n * @param {number} idx\n * @param {number[]} [out]\n * @example\n * geometry.getAttribute('position').get(0, out);\n */\n\n/**\n * Initialize attribute with given vertex count\n * @param {number} nVertex\n */\nAttribute.prototype.init = function (nVertex) {\n    if (!this.value || this.value.length !== nVertex * this.size) {\n        var ArrayConstructor = getArrayCtorByType(this.type);\n        this.value = new ArrayConstructor(nVertex * this.size);\n    }\n};\n\n/**\n * Initialize attribute with given array. Which can be 1 dimensional or 2 dimensional\n * @param {Array} array\n * @example\n *  geometry.getAttribute('position').fromArray(\n *      [-1, 0, 0, 1, 0, 0, 0, 1, 0]\n *  );\n *  geometry.getAttribute('position').fromArray(\n *      [ [-1, 0, 0], [1, 0, 0], [0, 1, 0] ]\n *  );\n */\nAttribute.prototype.fromArray = function (array) {\n    var ArrayConstructor = getArrayCtorByType(this.type);\n    var value;\n    // Convert 2d array to flat\n    if (array[0] && (array[0].length)) {\n        var n = 0;\n        var size = this.size;\n        value = new ArrayConstructor(array.length * size);\n        for (var i = 0; i < array.length; i++) {\n            for (var j = 0; j < size; j++) {\n                value[n++] = array[i][j];\n            }\n        }\n    }\n    else {\n        value = new ArrayConstructor(array);\n    }\n    this.value = value;\n};\n\nAttribute.prototype.clone = function(copyValue) {\n    var ret = new Attribute(this.name, this.type, this.size, this.semantic);\n    // FIXME\n    if (copyValue) {\n        console.warn('todo');\n    }\n    return ret;\n};\n\nfunction AttributeBuffer(name, type, buffer, size, semantic) {\n    this.name = name;\n    this.type = type;\n    this.buffer = buffer;\n    this.size = size;\n    this.semantic = semantic;\n\n    // To be set in mesh\n    // symbol in the shader\n    this.symbol = '';\n\n    // Needs remove flag\n    this.needsRemove = false;\n}\n\nfunction IndicesBuffer(buffer) {\n    this.buffer = buffer;\n    this.count = 0;\n}\n\n/**\n * Base of all geometry. Use {@link clay.Geometry} for common 3D usage.\n * @constructor clay.GeometryBase\n * @extends clay.core.Base\n */\nvar GeometryBase = Base.extend(function () {\n    return /** @lends clay.GeometryBase# */ {\n        /**\n         * Attributes of geometry.\n         * @type {Object.<string, clay.GeometryBase.Attribute>}\n         */\n        attributes: {},\n\n        /**\n         * Indices of geometry.\n         * @type {Uint16Array|Uint32Array}\n         */\n        indices: null,\n\n        /**\n         * Is vertices data dynamically updated.\n         * Attributes value can't be changed after first render if dyanmic is false.\n         * @type {boolean}\n         */\n        dynamic: true,\n\n        _enabledAttributes: null,\n\n        // PENDING\n        // Init it here to avoid deoptimization when it's assigned in application dynamically\n        __used: 0\n    };\n}, function () {\n    // Use cache\n    this._cache = new Cache();\n\n    this._attributeList = Object.keys(this.attributes);\n\n    this.__vaoCache = {};\n},\n/** @lends clay.GeometryBase.prototype */\n{\n    /**\n     * Main attribute will be used to count vertex number\n     * @type {string}\n     */\n    mainAttribute: '',\n    /**\n     * User defined picking algorithm instead of default\n     * triangle ray intersection\n     * x, y are NDC.\n     * ```typescript\n     * (x, y, renderer, camera, renderable, out) => boolean\n     * ```\n     * @type {?Function}\n     */\n    pick: null,\n\n    /**\n     * User defined ray picking algorithm instead of default\n     * triangle ray intersection\n     * ```typescript\n     * (ray: clay.Ray, renderable: clay.Renderable, out: Array) => boolean\n     * ```\n     * @type {?Function}\n     */\n    pickByRay: null,\n\n    /**\n     * Mark attributes and indices in geometry needs to update.\n     * Usually called after you change the data in attributes.\n     */\n    dirty: function () {\n        var enabledAttributes = this.getEnabledAttributes();\n        for (var i = 0; i < enabledAttributes.length; i++) {\n            this.dirtyAttribute(enabledAttributes[i]);\n        }\n        this.dirtyIndices();\n        this._enabledAttributes = null;\n\n        this._cache.dirty('any');\n    },\n    /**\n     * Mark the indices needs to update.\n     */\n    dirtyIndices: function () {\n        this._cache.dirtyAll('indices');\n    },\n    /**\n     * Mark the attributes needs to update.\n     * @param {string} [attrName]\n     */\n    dirtyAttribute: function (attrName) {\n        this._cache.dirtyAll(makeAttrKey(attrName));\n        this._cache.dirtyAll('attributes');\n    },\n    /**\n     * Get indices of triangle at given index.\n     * @param {number} idx\n     * @param {Array.<number>} out\n     * @return {Array.<number>}\n     */\n    getTriangleIndices: function (idx, out) {\n        if (idx < this.triangleCount && idx >= 0) {\n            if (!out) {\n                out = [];\n            }\n            var indices = this.indices;\n            out[0] = indices[idx * 3];\n            out[1] = indices[idx * 3 + 1];\n            out[2] = indices[idx * 3 + 2];\n            return out;\n        }\n    },\n\n    /**\n     * Set indices of triangle at given index.\n     * @param {number} idx\n     * @param {Array.<number>} arr\n     */\n    setTriangleIndices: function (idx, arr) {\n        var indices = this.indices;\n        indices[idx * 3] = arr[0];\n        indices[idx * 3 + 1] = arr[1];\n        indices[idx * 3 + 2] = arr[2];\n    },\n\n    isUseIndices: function () {\n        return !!this.indices;\n    },\n\n    /**\n     * Initialize indices from an array.\n     * @param {Array} array\n     */\n    initIndicesFromArray: function (array) {\n        var value;\n        var ArrayConstructor = this.vertexCount > 0xffff\n            ? vendor.Uint32Array : vendor.Uint16Array;\n        // Convert 2d array to flat\n        if (array[0] && (array[0].length)) {\n            var n = 0;\n            var size = 3;\n\n            value = new ArrayConstructor(array.length * size);\n            for (var i = 0; i < array.length; i++) {\n                for (var j = 0; j < size; j++) {\n                    value[n++] = array[i][j];\n                }\n            }\n        }\n        else {\n            value = new ArrayConstructor(array);\n        }\n\n        this.indices = value;\n    },\n    /**\n     * Create a new attribute\n     * @param {string} name\n     * @param {string} type\n     * @param {number} size\n     * @param {string} [semantic]\n     */\n    createAttribute: function (name, type, size, semantic) {\n        var attrib = new Attribute(name, type, size, semantic);\n        if (this.attributes[name]) {\n            this.removeAttribute(name);\n        }\n        this.attributes[name] = attrib;\n        this._attributeList.push(name);\n        return attrib;\n    },\n    /**\n     * Remove attribute\n     * @param {string} name\n     */\n    removeAttribute: function (name) {\n        var attributeList = this._attributeList;\n        var idx = attributeList.indexOf(name);\n        if (idx >= 0) {\n            attributeList.splice(idx, 1);\n            delete this.attributes[name];\n            return true;\n        }\n        return false;\n    },\n\n    /**\n     * Get attribute\n     * @param {string} name\n     * @return {clay.GeometryBase.Attribute}\n     */\n    getAttribute: function (name) {\n        return this.attributes[name];\n    },\n\n    /**\n     * Get enabled attributes name list\n     * Attribute which has the same vertex number with position is treated as a enabled attribute\n     * @return {string[]}\n     */\n    getEnabledAttributes: function () {\n        var enabledAttributes = this._enabledAttributes;\n        var attributeList = this._attributeList;\n        // Cache\n        if (enabledAttributes) {\n            return enabledAttributes;\n        }\n\n        var result = [];\n        var nVertex = this.vertexCount;\n\n        for (var i = 0; i < attributeList.length; i++) {\n            var name = attributeList[i];\n            var attrib = this.attributes[name];\n            if (attrib.value) {\n                if (attrib.value.length === nVertex * attrib.size) {\n                    result.push(name);\n                }\n            }\n        }\n\n        this._enabledAttributes = result;\n\n        return result;\n    },\n\n    getBufferChunks: function (renderer) {\n        var cache = this._cache;\n        cache.use(renderer.__uid__);\n        var isAttributesDirty = cache.isDirty('attributes');\n        var isIndicesDirty = cache.isDirty('indices');\n        if (isAttributesDirty || isIndicesDirty) {\n            this._updateBuffer(renderer.gl, isAttributesDirty, isIndicesDirty);\n            var enabledAttributes = this.getEnabledAttributes();\n            for (var i = 0; i < enabledAttributes.length; i++) {\n                cache.fresh(makeAttrKey(enabledAttributes[i]));\n            }\n            cache.fresh('attributes');\n            cache.fresh('indices');\n        }\n        cache.fresh('any');\n        return cache.get('chunks');\n    },\n\n    _updateBuffer: function (_gl, isAttributesDirty, isIndicesDirty) {\n        var cache = this._cache;\n        var chunks = cache.get('chunks');\n        var firstUpdate = false;\n        if (!chunks) {\n            chunks = [];\n            // Intialize\n            chunks[0] = {\n                attributeBuffers: [],\n                indicesBuffer: null\n            };\n            cache.put('chunks', chunks);\n            firstUpdate = true;\n        }\n\n        var chunk = chunks[0];\n        var attributeBuffers = chunk.attributeBuffers;\n        var indicesBuffer = chunk.indicesBuffer;\n\n        if (isAttributesDirty || firstUpdate) {\n            var attributeList = this.getEnabledAttributes();\n\n            var attributeBufferMap = {};\n            if (!firstUpdate) {\n                for (var i = 0; i < attributeBuffers.length; i++) {\n                    attributeBufferMap[attributeBuffers[i].name] = attributeBuffers[i];\n                }\n            }\n            // FIXME If some attributes removed\n            for (var k = 0; k < attributeList.length; k++) {\n                var name = attributeList[k];\n                var attribute = this.attributes[name];\n\n                var bufferInfo;\n\n                if (!firstUpdate) {\n                    bufferInfo = attributeBufferMap[name];\n                }\n                var buffer;\n                if (bufferInfo) {\n                    buffer = bufferInfo.buffer;\n                }\n                else {\n                    buffer = _gl.createBuffer();\n                }\n                if (cache.isDirty(makeAttrKey(name))) {\n                    // Only update when they are dirty.\n                    // TODO: Use BufferSubData?\n                    _gl.bindBuffer(_gl.ARRAY_BUFFER, buffer);\n                    _gl.bufferData(_gl.ARRAY_BUFFER, attribute.value, this.dynamic ? _gl.DYNAMIC_DRAW : _gl.STATIC_DRAW);\n                }\n\n                attributeBuffers[k] = new AttributeBuffer(name, attribute.type, buffer, attribute.size, attribute.semantic);\n            }\n            // Remove unused attributes buffers.\n            // PENDING\n            for (var i = k; i < attributeBuffers.length; i++) {\n                _gl.deleteBuffer(attributeBuffers[i].buffer);\n            }\n            attributeBuffers.length = k;\n\n        }\n\n        if (this.isUseIndices() && (isIndicesDirty || firstUpdate)) {\n            if (!indicesBuffer) {\n                indicesBuffer = new IndicesBuffer(_gl.createBuffer());\n                chunk.indicesBuffer = indicesBuffer;\n            }\n            indicesBuffer.count = this.indices.length;\n            _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, indicesBuffer.buffer);\n            _gl.bufferData(_gl.ELEMENT_ARRAY_BUFFER, this.indices, this.dynamic ? _gl.DYNAMIC_DRAW : _gl.STATIC_DRAW);\n        }\n    },\n\n    /**\n     * Dispose geometry data in GL context.\n     * @param {clay.Renderer} renderer\n     */\n    dispose: function (renderer) {\n\n        var cache = this._cache;\n\n        cache.use(renderer.__uid__);\n        var chunks = cache.get('chunks');\n        if (chunks) {\n            for (var c = 0; c < chunks.length; c++) {\n                var chunk = chunks[c];\n\n                for (var k = 0; k < chunk.attributeBuffers.length; k++) {\n                    var attribs = chunk.attributeBuffers[k];\n                    renderer.gl.deleteBuffer(attribs.buffer);\n                }\n\n                if (chunk.indicesBuffer) {\n                    renderer.gl.deleteBuffer(chunk.indicesBuffer.buffer);\n                }\n            }\n        }\n        if (this.__vaoCache) {\n            var vaoExt = renderer.getGLExtension('OES_vertex_array_object');\n            for (var id in this.__vaoCache) {\n                var vao = this.__vaoCache[id].vao;\n                if (vao) {\n                    vaoExt.deleteVertexArrayOES(vao);\n                }\n            }\n        }\n        this.__vaoCache = {};\n        cache.deleteContext(renderer.__uid__);\n    }\n\n});\n\nif (Object.defineProperty) {\n    /**\n     * @name clay.GeometryBase#vertexCount\n     * @type {number}\n     * @readOnly\n     */\n    Object.defineProperty(GeometryBase.prototype, 'vertexCount', {\n\n        enumerable: false,\n\n        get: function () {\n\n            var mainAttribute = this.attributes[this.mainAttribute];\n\n            if (!mainAttribute) {\n                mainAttribute = this.attributes[this._attributeList[0]];\n            }\n\n            if (!mainAttribute || !mainAttribute.value) {\n                return 0;\n            }\n            return mainAttribute.value.length / mainAttribute.size;\n        }\n    });\n    /**\n     * @name clay.GeometryBase#triangleCount\n     * @type {number}\n     * @readOnly\n     */\n    Object.defineProperty(GeometryBase.prototype, 'triangleCount', {\n\n        enumerable: false,\n\n        get: function () {\n            var indices = this.indices;\n            if (!indices) {\n                return 0;\n            }\n            else {\n                return indices.length / 3;\n            }\n        }\n    });\n}\n\nGeometryBase.STATIC_DRAW = glenum.STATIC_DRAW;\nGeometryBase.DYNAMIC_DRAW = glenum.DYNAMIC_DRAW;\nGeometryBase.STREAM_DRAW = glenum.STREAM_DRAW;\n\nGeometryBase.AttributeBuffer = AttributeBuffer;\nGeometryBase.IndicesBuffer = IndicesBuffer;\n\nGeometryBase.Attribute = Attribute;\n\nexport default GeometryBase;\n"]},"metadata":{},"sourceType":"module"}