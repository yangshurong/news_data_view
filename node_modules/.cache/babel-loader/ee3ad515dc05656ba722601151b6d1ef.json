{"ast":null,"code":"'use strict';\n\nvar _typeof = require(\"C:/Users/Administrator/Desktop/data_view/my_project/vue2_app/myapp/node_modules/@babel/runtime/helpers/typeof.js\").default;\n\nrequire(\"core-js/modules/es.error.cause.js\");\n\nrequire(\"core-js/modules/es.array.map.js\");\n\nrequire(\"core-js/modules/es.regexp.constructor.js\");\n\nrequire(\"core-js/modules/es.regexp.dot-all.js\");\n\nrequire(\"core-js/modules/es.regexp.exec.js\");\n\nrequire(\"core-js/modules/es.regexp.sticky.js\");\n\nrequire(\"core-js/modules/es.regexp.to-string.js\");\n\nrequire(\"core-js/modules/es.regexp.test.js\");\n\nrequire(\"core-js/modules/es.function.name.js\");\n\nrequire(\"core-js/modules/es.symbol.iterator.js\");\n\nrequire(\"core-js/modules/es.object.to-string.js\");\n\nrequire(\"core-js/modules/es.string.iterator.js\");\n\nrequire(\"core-js/modules/web.dom-collections.iterator.js\");\n\nrequire(\"core-js/modules/es.symbol.js\");\n\nrequire(\"core-js/modules/es.symbol.description.js\");\n\nrequire(\"core-js/modules/es.array.splice.js\");\n\nrequire(\"core-js/modules/es.string.replace.js\");\n\nexports.__esModule = true;\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _declaration = require('./declaration');\n\nvar _declaration2 = _interopRequireDefault(_declaration);\n\nvar _warnOnce = require('./warn-once');\n\nvar _warnOnce2 = _interopRequireDefault(_warnOnce);\n\nvar _comment = require('./comment');\n\nvar _comment2 = _interopRequireDefault(_comment);\n\nvar _node = require('./node');\n\nvar _node2 = _interopRequireDefault(_node);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (_typeof(call) === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + _typeof(superClass));\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nfunction cleanSource(nodes) {\n  return nodes.map(function (i) {\n    if (i.nodes) i.nodes = cleanSource(i.nodes);\n    delete i.source;\n    return i;\n  });\n}\n/**\n * The {@link Root}, {@link AtRule}, and {@link Rule} container nodes\n * inherit some common methods to help work with their children.\n *\n * Note that all containers can store any content. If you write a rule inside\n * a rule, PostCSS will parse it.\n *\n * @extends Node\n * @abstract\n */\n\n\nvar Container = function (_Node) {\n  _inherits(Container, _Node);\n\n  function Container() {\n    _classCallCheck(this, Container);\n\n    return _possibleConstructorReturn(this, _Node.apply(this, arguments));\n  }\n\n  Container.prototype.push = function push(child) {\n    child.parent = this;\n    this.nodes.push(child);\n    return this;\n  };\n  /**\n   * Iterates through the container’s immediate children,\n   * calling `callback` for each child.\n   *\n   * Returning `false` in the callback will break iteration.\n   *\n   * This method only iterates through the container’s immediate children.\n   * If you need to recursively iterate through all the container’s descendant\n   * nodes, use {@link Container#walk}.\n   *\n   * Unlike the for `{}`-cycle or `Array#forEach` this iterator is safe\n   * if you are mutating the array of child nodes during iteration.\n   * PostCSS will adjust the current index to match the mutations.\n   *\n   * @param {childIterator} callback - iterator receives each node and index\n   *\n   * @return {false|undefined} returns `false` if iteration was broke\n   *\n   * @example\n   * const root = postcss.parse('a { color: black; z-index: 1 }');\n   * const rule = root.first;\n   *\n   * for ( let decl of rule.nodes ) {\n   *     decl.cloneBefore({ prop: '-webkit-' + decl.prop });\n   *     // Cycle will be infinite, because cloneBefore moves the current node\n   *     // to the next index\n   * }\n   *\n   * rule.each(decl => {\n   *     decl.cloneBefore({ prop: '-webkit-' + decl.prop });\n   *     // Will be executed only for color and z-index\n   * });\n   */\n\n\n  Container.prototype.each = function each(callback) {\n    if (!this.lastEach) this.lastEach = 0;\n    if (!this.indexes) this.indexes = {};\n    this.lastEach += 1;\n    var id = this.lastEach;\n    this.indexes[id] = 0;\n    if (!this.nodes) return undefined;\n    var index = void 0,\n        result = void 0;\n\n    while (this.indexes[id] < this.nodes.length) {\n      index = this.indexes[id];\n      result = callback(this.nodes[index], index);\n      if (result === false) break;\n      this.indexes[id] += 1;\n    }\n\n    delete this.indexes[id];\n    return result;\n  };\n  /**\n   * Traverses the container’s descendant nodes, calling callback\n   * for each node.\n   *\n   * Like container.each(), this method is safe to use\n   * if you are mutating arrays during iteration.\n   *\n   * If you only need to iterate through the container’s immediate children,\n   * use {@link Container#each}.\n   *\n   * @param {childIterator} callback - iterator receives each node and index\n   *\n   * @return {false|undefined} returns `false` if iteration was broke\n   *\n   * @example\n   * root.walk(node => {\n   *   // Traverses all descendant nodes.\n   * });\n   */\n\n\n  Container.prototype.walk = function walk(callback) {\n    return this.each(function (child, i) {\n      var result = callback(child, i);\n\n      if (result !== false && child.walk) {\n        result = child.walk(callback);\n      }\n\n      return result;\n    });\n  };\n  /**\n   * Traverses the container’s descendant nodes, calling callback\n   * for each declaration node.\n   *\n   * If you pass a filter, iteration will only happen over declarations\n   * with matching properties.\n   *\n   * Like {@link Container#each}, this method is safe\n   * to use if you are mutating arrays during iteration.\n   *\n   * @param {string|RegExp} [prop]   - string or regular expression\n   *                                   to filter declarations by property name\n   * @param {childIterator} callback - iterator receives each node and index\n   *\n   * @return {false|undefined} returns `false` if iteration was broke\n   *\n   * @example\n   * root.walkDecls(decl => {\n   *   checkPropertySupport(decl.prop);\n   * });\n   *\n   * root.walkDecls('border-radius', decl => {\n   *   decl.remove();\n   * });\n   *\n   * root.walkDecls(/^background/, decl => {\n   *   decl.value = takeFirstColorFromGradient(decl.value);\n   * });\n   */\n\n\n  Container.prototype.walkDecls = function walkDecls(prop, callback) {\n    if (!callback) {\n      callback = prop;\n      return this.walk(function (child, i) {\n        if (child.type === 'decl') {\n          return callback(child, i);\n        }\n      });\n    } else if (prop instanceof RegExp) {\n      return this.walk(function (child, i) {\n        if (child.type === 'decl' && prop.test(child.prop)) {\n          return callback(child, i);\n        }\n      });\n    } else {\n      return this.walk(function (child, i) {\n        if (child.type === 'decl' && child.prop === prop) {\n          return callback(child, i);\n        }\n      });\n    }\n  };\n  /**\n   * Traverses the container’s descendant nodes, calling callback\n   * for each rule node.\n   *\n   * If you pass a filter, iteration will only happen over rules\n   * with matching selectors.\n   *\n   * Like {@link Container#each}, this method is safe\n   * to use if you are mutating arrays during iteration.\n   *\n   * @param {string|RegExp} [selector] - string or regular expression\n   *                                     to filter rules by selector\n   * @param {childIterator} callback   - iterator receives each node and index\n   *\n   * @return {false|undefined} returns `false` if iteration was broke\n   *\n   * @example\n   * const selectors = [];\n   * root.walkRules(rule => {\n   *   selectors.push(rule.selector);\n   * });\n   * console.log(`Your CSS uses ${selectors.length} selectors`);\n   */\n\n\n  Container.prototype.walkRules = function walkRules(selector, callback) {\n    if (!callback) {\n      callback = selector;\n      return this.walk(function (child, i) {\n        if (child.type === 'rule') {\n          return callback(child, i);\n        }\n      });\n    } else if (selector instanceof RegExp) {\n      return this.walk(function (child, i) {\n        if (child.type === 'rule' && selector.test(child.selector)) {\n          return callback(child, i);\n        }\n      });\n    } else {\n      return this.walk(function (child, i) {\n        if (child.type === 'rule' && child.selector === selector) {\n          return callback(child, i);\n        }\n      });\n    }\n  };\n  /**\n   * Traverses the container’s descendant nodes, calling callback\n   * for each at-rule node.\n   *\n   * If you pass a filter, iteration will only happen over at-rules\n   * that have matching names.\n   *\n   * Like {@link Container#each}, this method is safe\n   * to use if you are mutating arrays during iteration.\n   *\n   * @param {string|RegExp} [name]   - string or regular expression\n   *                                   to filter at-rules by name\n   * @param {childIterator} callback - iterator receives each node and index\n   *\n   * @return {false|undefined} returns `false` if iteration was broke\n   *\n   * @example\n   * root.walkAtRules(rule => {\n   *   if ( isOld(rule.name) ) rule.remove();\n   * });\n   *\n   * let first = false;\n   * root.walkAtRules('charset', rule => {\n   *   if ( !first ) {\n   *     first = true;\n   *   } else {\n   *     rule.remove();\n   *   }\n   * });\n   */\n\n\n  Container.prototype.walkAtRules = function walkAtRules(name, callback) {\n    if (!callback) {\n      callback = name;\n      return this.walk(function (child, i) {\n        if (child.type === 'atrule') {\n          return callback(child, i);\n        }\n      });\n    } else if (name instanceof RegExp) {\n      return this.walk(function (child, i) {\n        if (child.type === 'atrule' && name.test(child.name)) {\n          return callback(child, i);\n        }\n      });\n    } else {\n      return this.walk(function (child, i) {\n        if (child.type === 'atrule' && child.name === name) {\n          return callback(child, i);\n        }\n      });\n    }\n  };\n  /**\n   * Traverses the container’s descendant nodes, calling callback\n   * for each comment node.\n   *\n   * Like {@link Container#each}, this method is safe\n   * to use if you are mutating arrays during iteration.\n   *\n   * @param {childIterator} callback - iterator receives each node and index\n   *\n   * @return {false|undefined} returns `false` if iteration was broke\n   *\n   * @example\n   * root.walkComments(comment => {\n   *   comment.remove();\n   * });\n   */\n\n\n  Container.prototype.walkComments = function walkComments(callback) {\n    return this.walk(function (child, i) {\n      if (child.type === 'comment') {\n        return callback(child, i);\n      }\n    });\n  };\n  /**\n   * Inserts new nodes to the end of the container.\n   *\n   * @param {...(Node|object|string|Node[])} children - new nodes\n   *\n   * @return {Node} this node for methods chain\n   *\n   * @example\n   * const decl1 = postcss.decl({ prop: 'color', value: 'black' });\n   * const decl2 = postcss.decl({ prop: 'background-color', value: 'white' });\n   * rule.append(decl1, decl2);\n   *\n   * root.append({ name: 'charset', params: '\"UTF-8\"' });  // at-rule\n   * root.append({ selector: 'a' });                       // rule\n   * rule.append({ prop: 'color', value: 'black' });       // declaration\n   * rule.append({ text: 'Comment' })                      // comment\n   *\n   * root.append('a {}');\n   * root.first.append('color: black; z-index: 1');\n   */\n\n\n  Container.prototype.append = function append() {\n    for (var _len = arguments.length, children = Array(_len), _key = 0; _key < _len; _key++) {\n      children[_key] = arguments[_key];\n    }\n\n    for (var _iterator = children, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var child = _ref;\n      var nodes = this.normalize(child, this.last);\n\n      for (var _iterator2 = nodes, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n        var _ref2;\n\n        if (_isArray2) {\n          if (_i2 >= _iterator2.length) break;\n          _ref2 = _iterator2[_i2++];\n        } else {\n          _i2 = _iterator2.next();\n          if (_i2.done) break;\n          _ref2 = _i2.value;\n        }\n\n        var node = _ref2;\n        this.nodes.push(node);\n      }\n    }\n\n    return this;\n  };\n  /**\n   * Inserts new nodes to the start of the container.\n   *\n   * @param {...(Node|object|string|Node[])} children - new nodes\n   *\n   * @return {Node} this node for methods chain\n   *\n   * @example\n   * const decl1 = postcss.decl({ prop: 'color', value: 'black' });\n   * const decl2 = postcss.decl({ prop: 'background-color', value: 'white' });\n   * rule.prepend(decl1, decl2);\n   *\n   * root.append({ name: 'charset', params: '\"UTF-8\"' });  // at-rule\n   * root.append({ selector: 'a' });                       // rule\n   * rule.append({ prop: 'color', value: 'black' });       // declaration\n   * rule.append({ text: 'Comment' })                      // comment\n   *\n   * root.append('a {}');\n   * root.first.append('color: black; z-index: 1');\n   */\n\n\n  Container.prototype.prepend = function prepend() {\n    for (var _len2 = arguments.length, children = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      children[_key2] = arguments[_key2];\n    }\n\n    children = children.reverse();\n\n    for (var _iterator3 = children, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {\n      var _ref3;\n\n      if (_isArray3) {\n        if (_i3 >= _iterator3.length) break;\n        _ref3 = _iterator3[_i3++];\n      } else {\n        _i3 = _iterator3.next();\n        if (_i3.done) break;\n        _ref3 = _i3.value;\n      }\n\n      var child = _ref3;\n      var nodes = this.normalize(child, this.first, 'prepend').reverse();\n\n      for (var _iterator4 = nodes, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {\n        var _ref4;\n\n        if (_isArray4) {\n          if (_i4 >= _iterator4.length) break;\n          _ref4 = _iterator4[_i4++];\n        } else {\n          _i4 = _iterator4.next();\n          if (_i4.done) break;\n          _ref4 = _i4.value;\n        }\n\n        var node = _ref4;\n        this.nodes.unshift(node);\n      }\n\n      for (var id in this.indexes) {\n        this.indexes[id] = this.indexes[id] + nodes.length;\n      }\n    }\n\n    return this;\n  };\n\n  Container.prototype.cleanRaws = function cleanRaws(keepBetween) {\n    _Node.prototype.cleanRaws.call(this, keepBetween);\n\n    if (this.nodes) {\n      for (var _iterator5 = this.nodes, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator]();;) {\n        var _ref5;\n\n        if (_isArray5) {\n          if (_i5 >= _iterator5.length) break;\n          _ref5 = _iterator5[_i5++];\n        } else {\n          _i5 = _iterator5.next();\n          if (_i5.done) break;\n          _ref5 = _i5.value;\n        }\n\n        var node = _ref5;\n        node.cleanRaws(keepBetween);\n      }\n    }\n  };\n  /**\n   * Insert new node before old node within the container.\n   *\n   * @param {Node|number} exist             - child or child’s index.\n   * @param {Node|object|string|Node[]} add - new node\n   *\n   * @return {Node} this node for methods chain\n   *\n   * @example\n   * rule.insertBefore(decl, decl.clone({ prop: '-webkit-' + decl.prop }));\n   */\n\n\n  Container.prototype.insertBefore = function insertBefore(exist, add) {\n    exist = this.index(exist);\n    var type = exist === 0 ? 'prepend' : false;\n    var nodes = this.normalize(add, this.nodes[exist], type).reverse();\n\n    for (var _iterator6 = nodes, _isArray6 = Array.isArray(_iterator6), _i6 = 0, _iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator]();;) {\n      var _ref6;\n\n      if (_isArray6) {\n        if (_i6 >= _iterator6.length) break;\n        _ref6 = _iterator6[_i6++];\n      } else {\n        _i6 = _iterator6.next();\n        if (_i6.done) break;\n        _ref6 = _i6.value;\n      }\n\n      var node = _ref6;\n      this.nodes.splice(exist, 0, node);\n    }\n\n    var index = void 0;\n\n    for (var id in this.indexes) {\n      index = this.indexes[id];\n\n      if (exist <= index) {\n        this.indexes[id] = index + nodes.length;\n      }\n    }\n\n    return this;\n  };\n  /**\n   * Insert new node after old node within the container.\n   *\n   * @param {Node|number} exist             - child or child’s index\n   * @param {Node|object|string|Node[]} add - new node\n   *\n   * @return {Node} this node for methods chain\n   */\n\n\n  Container.prototype.insertAfter = function insertAfter(exist, add) {\n    exist = this.index(exist);\n    var nodes = this.normalize(add, this.nodes[exist]).reverse();\n\n    for (var _iterator7 = nodes, _isArray7 = Array.isArray(_iterator7), _i7 = 0, _iterator7 = _isArray7 ? _iterator7 : _iterator7[Symbol.iterator]();;) {\n      var _ref7;\n\n      if (_isArray7) {\n        if (_i7 >= _iterator7.length) break;\n        _ref7 = _iterator7[_i7++];\n      } else {\n        _i7 = _iterator7.next();\n        if (_i7.done) break;\n        _ref7 = _i7.value;\n      }\n\n      var node = _ref7;\n      this.nodes.splice(exist + 1, 0, node);\n    }\n\n    var index = void 0;\n\n    for (var id in this.indexes) {\n      index = this.indexes[id];\n\n      if (exist < index) {\n        this.indexes[id] = index + nodes.length;\n      }\n    }\n\n    return this;\n  };\n\n  Container.prototype.remove = function remove(child) {\n    if (typeof child !== 'undefined') {\n      (0, _warnOnce2.default)('Container#remove is deprecated. ' + 'Use Container#removeChild');\n      this.removeChild(child);\n    } else {\n      _Node.prototype.remove.call(this);\n    }\n\n    return this;\n  };\n  /**\n   * Removes node from the container and cleans the parent properties\n   * from the node and its children.\n   *\n   * @param {Node|number} child - child or child’s index\n   *\n   * @return {Node} this node for methods chain\n   *\n   * @example\n   * rule.nodes.length  //=> 5\n   * rule.removeChild(decl);\n   * rule.nodes.length  //=> 4\n   * decl.parent        //=> undefined\n   */\n\n\n  Container.prototype.removeChild = function removeChild(child) {\n    child = this.index(child);\n    this.nodes[child].parent = undefined;\n    this.nodes.splice(child, 1);\n    var index = void 0;\n\n    for (var id in this.indexes) {\n      index = this.indexes[id];\n\n      if (index >= child) {\n        this.indexes[id] = index - 1;\n      }\n    }\n\n    return this;\n  };\n  /**\n   * Removes all children from the container\n   * and cleans their parent properties.\n   *\n   * @return {Node} this node for methods chain\n   *\n   * @example\n   * rule.removeAll();\n   * rule.nodes.length //=> 0\n   */\n\n\n  Container.prototype.removeAll = function removeAll() {\n    for (var _iterator8 = this.nodes, _isArray8 = Array.isArray(_iterator8), _i8 = 0, _iterator8 = _isArray8 ? _iterator8 : _iterator8[Symbol.iterator]();;) {\n      var _ref8;\n\n      if (_isArray8) {\n        if (_i8 >= _iterator8.length) break;\n        _ref8 = _iterator8[_i8++];\n      } else {\n        _i8 = _iterator8.next();\n        if (_i8.done) break;\n        _ref8 = _i8.value;\n      }\n\n      var node = _ref8;\n      node.parent = undefined;\n    }\n\n    this.nodes = [];\n    return this;\n  };\n  /**\n   * Passes all declaration values within the container that match pattern\n   * through callback, replacing those values with the returned result\n   * of callback.\n   *\n   * This method is useful if you are using a custom unit or function\n   * and need to iterate through all values.\n   *\n   * @param {string|RegExp} pattern      - replace pattern\n   * @param {object} opts                - options to speed up the search\n   * @param {string|string[]} opts.props - an array of property names\n   * @param {string} opts.fast           - string that’s used\n   *                                       to narrow down values and speed up\n                                           the regexp search\n   * @param {function|string} callback   - string to replace pattern\n   *                                       or callback that returns a new\n   *                                       value.\n   *                                       The callback will receive\n   *                                       the same arguments as those\n   *                                       passed to a function parameter\n   *                                       of `String#replace`.\n   *\n   * @return {Node} this node for methods chain\n   *\n   * @example\n   * root.replaceValues(/\\d+rem/, { fast: 'rem' }, string => {\n   *   return 15 * parseInt(string) + 'px';\n   * });\n   */\n\n\n  Container.prototype.replaceValues = function replaceValues(pattern, opts, callback) {\n    if (!callback) {\n      callback = opts;\n      opts = {};\n    }\n\n    this.walkDecls(function (decl) {\n      if (opts.props && opts.props.indexOf(decl.prop) === -1) return;\n      if (opts.fast && decl.value.indexOf(opts.fast) === -1) return;\n      decl.value = decl.value.replace(pattern, callback);\n    });\n    return this;\n  };\n  /**\n   * Returns `true` if callback returns `true`\n   * for all of the container’s children.\n   *\n   * @param {childCondition} condition - iterator returns true or false.\n   *\n   * @return {boolean} is every child pass condition\n   *\n   * @example\n   * const noPrefixes = rule.every(i => i.prop[0] !== '-');\n   */\n\n\n  Container.prototype.every = function every(condition) {\n    return this.nodes.every(condition);\n  };\n  /**\n   * Returns `true` if callback returns `true` for (at least) one\n   * of the container’s children.\n   *\n   * @param {childCondition} condition - iterator returns true or false.\n   *\n   * @return {boolean} is some child pass condition\n   *\n   * @example\n   * const hasPrefix = rule.some(i => i.prop[0] === '-');\n   */\n\n\n  Container.prototype.some = function some(condition) {\n    return this.nodes.some(condition);\n  };\n  /**\n   * Returns a `child`’s index within the {@link Container#nodes} array.\n   *\n   * @param {Node} child - child of the current container.\n   *\n   * @return {number} child index\n   *\n   * @example\n   * rule.index( rule.nodes[2] ) //=> 2\n   */\n\n\n  Container.prototype.index = function index(child) {\n    if (typeof child === 'number') {\n      return child;\n    } else {\n      return this.nodes.indexOf(child);\n    }\n  };\n  /**\n   * The container’s first child.\n   *\n   * @type {Node}\n   *\n   * @example\n   * rule.first == rules.nodes[0];\n   */\n\n\n  Container.prototype.normalize = function normalize(nodes, sample) {\n    var _this2 = this;\n\n    if (typeof nodes === 'string') {\n      var parse = require('./parse');\n\n      nodes = cleanSource(parse(nodes).nodes);\n    } else if (!Array.isArray(nodes)) {\n      if (nodes.type === 'root') {\n        nodes = nodes.nodes;\n      } else if (nodes.type) {\n        nodes = [nodes];\n      } else if (nodes.prop) {\n        if (typeof nodes.value === 'undefined') {\n          throw new Error('Value field is missed in node creation');\n        } else if (typeof nodes.value !== 'string') {\n          nodes.value = String(nodes.value);\n        }\n\n        nodes = [new _declaration2.default(nodes)];\n      } else if (nodes.selector) {\n        var Rule = require('./rule');\n\n        nodes = [new Rule(nodes)];\n      } else if (nodes.name) {\n        var AtRule = require('./at-rule');\n\n        nodes = [new AtRule(nodes)];\n      } else if (nodes.text) {\n        nodes = [new _comment2.default(nodes)];\n      } else {\n        throw new Error('Unknown node type in node creation');\n      }\n    }\n\n    var processed = nodes.map(function (i) {\n      if (typeof i.raws === 'undefined') i = _this2.rebuild(i);\n      if (i.parent) i = i.clone();\n\n      if (typeof i.raws.before === 'undefined') {\n        if (sample && typeof sample.raws.before !== 'undefined') {\n          i.raws.before = sample.raws.before.replace(/[^\\s]/g, '');\n        }\n      }\n\n      i.parent = _this2;\n      return i;\n    });\n    return processed;\n  };\n\n  Container.prototype.rebuild = function rebuild(node, parent) {\n    var _this3 = this;\n\n    var fix = void 0;\n\n    if (node.type === 'root') {\n      var Root = require('./root');\n\n      fix = new Root();\n    } else if (node.type === 'atrule') {\n      var AtRule = require('./at-rule');\n\n      fix = new AtRule();\n    } else if (node.type === 'rule') {\n      var Rule = require('./rule');\n\n      fix = new Rule();\n    } else if (node.type === 'decl') {\n      fix = new _declaration2.default();\n    } else if (node.type === 'comment') {\n      fix = new _comment2.default();\n    }\n\n    for (var i in node) {\n      if (i === 'nodes') {\n        fix.nodes = node.nodes.map(function (j) {\n          return _this3.rebuild(j, fix);\n        });\n      } else if (i === 'parent' && parent) {\n        fix.parent = parent;\n      } else if (node.hasOwnProperty(i)) {\n        fix[i] = node[i];\n      }\n    }\n\n    return fix;\n  };\n\n  Container.prototype.eachInside = function eachInside(callback) {\n    (0, _warnOnce2.default)('Container#eachInside is deprecated. ' + 'Use Container#walk instead.');\n    return this.walk(callback);\n  };\n\n  Container.prototype.eachDecl = function eachDecl(prop, callback) {\n    (0, _warnOnce2.default)('Container#eachDecl is deprecated. ' + 'Use Container#walkDecls instead.');\n    return this.walkDecls(prop, callback);\n  };\n\n  Container.prototype.eachRule = function eachRule(selector, callback) {\n    (0, _warnOnce2.default)('Container#eachRule is deprecated. ' + 'Use Container#walkRules instead.');\n    return this.walkRules(selector, callback);\n  };\n\n  Container.prototype.eachAtRule = function eachAtRule(name, callback) {\n    (0, _warnOnce2.default)('Container#eachAtRule is deprecated. ' + 'Use Container#walkAtRules instead.');\n    return this.walkAtRules(name, callback);\n  };\n\n  Container.prototype.eachComment = function eachComment(callback) {\n    (0, _warnOnce2.default)('Container#eachComment is deprecated. ' + 'Use Container#walkComments instead.');\n    return this.walkComments(callback);\n  };\n\n  _createClass(Container, [{\n    key: 'first',\n    get: function get() {\n      if (!this.nodes) return undefined;\n      return this.nodes[0];\n    }\n    /**\n     * The container’s last child.\n     *\n     * @type {Node}\n     *\n     * @example\n     * rule.last == rule.nodes[rule.nodes.length - 1];\n     */\n\n  }, {\n    key: 'last',\n    get: function get() {\n      if (!this.nodes) return undefined;\n      return this.nodes[this.nodes.length - 1];\n    }\n  }, {\n    key: 'semicolon',\n    get: function get() {\n      (0, _warnOnce2.default)('Node#semicolon is deprecated. Use Node#raws.semicolon');\n      return this.raws.semicolon;\n    },\n    set: function set(val) {\n      (0, _warnOnce2.default)('Node#semicolon is deprecated. Use Node#raws.semicolon');\n      this.raws.semicolon = val;\n    }\n  }, {\n    key: 'after',\n    get: function get() {\n      (0, _warnOnce2.default)('Node#after is deprecated. Use Node#raws.after');\n      return this.raws.after;\n    },\n    set: function set(val) {\n      (0, _warnOnce2.default)('Node#after is deprecated. Use Node#raws.after');\n      this.raws.after = val;\n    }\n    /**\n     * @memberof Container#\n     * @member {Node[]} nodes - an array containing the container’s children\n     *\n     * @example\n     * const root = postcss.parse('a { color: black }');\n     * root.nodes.length           //=> 1\n     * root.nodes[0].selector      //=> 'a'\n     * root.nodes[0].nodes[0].prop //=> 'color'\n     */\n\n  }]);\n\n  return Container;\n}(_node2.default);\n\nexports.default = Container;\n/**\n * @callback childCondition\n * @param {Node} node    - container child\n * @param {number} index - child index\n * @param {Node[]} nodes - all container children\n * @return {boolean}\n */\n\n/**\n * @callback childIterator\n * @param {Node} node    - container child\n * @param {number} index - child index\n * @return {false|undefined} returning `false` will break iteration\n */\n\nmodule.exports = exports['default'];","map":{"version":3,"mappings":"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","names":["cleanSource","nodes","map","i","source","Container","push","child","parent","each","callback","lastEach","indexes","id","undefined","index","result","length","walk","walkDecls","prop","type","RegExp","test","walkRules","selector","walkAtRules","name","walkComments","append","children","arguments","_ref","_i","normalize","last","_ref2","_i2","node","prepend","reverse","_ref3","_i3","first","_ref4","_i4","unshift","cleanRaws","keepBetween","_Node","_ref5","_i5","insertBefore","exist","add","_ref6","_i6","splice","insertAfter","_ref7","_i7","remove","removeChild","removeAll","_ref8","_i8","replaceValues","pattern","opts","props","indexOf","decl","fast","value","replace","every","condition","some","sample","parse","require","Array","isArray","Error","String","Rule","AtRule","text","processed","raws","_this2","rebuild","clone","before","fix","Root","_this3","j","hasOwnProperty","eachInside","eachDecl","eachRule","eachAtRule","eachComment","semicolon","val","after"],"sources":["container.es6"],"sourcesContent":["import Declaration from './declaration';\nimport warnOnce    from './warn-once';\nimport Comment     from './comment';\nimport Node        from './node';\n\nfunction cleanSource(nodes) {\n    return nodes.map( i => {\n        if ( i.nodes ) i.nodes = cleanSource(i.nodes);\n        delete i.source;\n        return i;\n    });\n}\n\n/**\n * The {@link Root}, {@link AtRule}, and {@link Rule} container nodes\n * inherit some common methods to help work with their children.\n *\n * Note that all containers can store any content. If you write a rule inside\n * a rule, PostCSS will parse it.\n *\n * @extends Node\n * @abstract\n */\nclass Container extends Node {\n\n    push(child) {\n        child.parent = this;\n        this.nodes.push(child);\n        return this;\n    }\n\n    /**\n     * Iterates through the container’s immediate children,\n     * calling `callback` for each child.\n     *\n     * Returning `false` in the callback will break iteration.\n     *\n     * This method only iterates through the container’s immediate children.\n     * If you need to recursively iterate through all the container’s descendant\n     * nodes, use {@link Container#walk}.\n     *\n     * Unlike the for `{}`-cycle or `Array#forEach` this iterator is safe\n     * if you are mutating the array of child nodes during iteration.\n     * PostCSS will adjust the current index to match the mutations.\n     *\n     * @param {childIterator} callback - iterator receives each node and index\n     *\n     * @return {false|undefined} returns `false` if iteration was broke\n     *\n     * @example\n     * const root = postcss.parse('a { color: black; z-index: 1 }');\n     * const rule = root.first;\n     *\n     * for ( let decl of rule.nodes ) {\n     *     decl.cloneBefore({ prop: '-webkit-' + decl.prop });\n     *     // Cycle will be infinite, because cloneBefore moves the current node\n     *     // to the next index\n     * }\n     *\n     * rule.each(decl => {\n     *     decl.cloneBefore({ prop: '-webkit-' + decl.prop });\n     *     // Will be executed only for color and z-index\n     * });\n     */\n    each(callback) {\n        if ( !this.lastEach ) this.lastEach = 0;\n        if ( !this.indexes ) this.indexes = { };\n\n        this.lastEach += 1;\n        let id = this.lastEach;\n        this.indexes[id] = 0;\n\n        if ( !this.nodes ) return undefined;\n\n        let index, result;\n        while ( this.indexes[id] < this.nodes.length ) {\n            index  = this.indexes[id];\n            result = callback(this.nodes[index], index);\n            if ( result === false ) break;\n\n            this.indexes[id] += 1;\n        }\n\n        delete this.indexes[id];\n\n        return result;\n    }\n\n    /**\n     * Traverses the container’s descendant nodes, calling callback\n     * for each node.\n     *\n     * Like container.each(), this method is safe to use\n     * if you are mutating arrays during iteration.\n     *\n     * If you only need to iterate through the container’s immediate children,\n     * use {@link Container#each}.\n     *\n     * @param {childIterator} callback - iterator receives each node and index\n     *\n     * @return {false|undefined} returns `false` if iteration was broke\n     *\n     * @example\n     * root.walk(node => {\n     *   // Traverses all descendant nodes.\n     * });\n     */\n    walk(callback) {\n        return this.each( (child, i) => {\n            let result = callback(child, i);\n            if ( result !== false && child.walk ) {\n                result = child.walk(callback);\n            }\n            return result;\n        });\n    }\n\n    /**\n     * Traverses the container’s descendant nodes, calling callback\n     * for each declaration node.\n     *\n     * If you pass a filter, iteration will only happen over declarations\n     * with matching properties.\n     *\n     * Like {@link Container#each}, this method is safe\n     * to use if you are mutating arrays during iteration.\n     *\n     * @param {string|RegExp} [prop]   - string or regular expression\n     *                                   to filter declarations by property name\n     * @param {childIterator} callback - iterator receives each node and index\n     *\n     * @return {false|undefined} returns `false` if iteration was broke\n     *\n     * @example\n     * root.walkDecls(decl => {\n     *   checkPropertySupport(decl.prop);\n     * });\n     *\n     * root.walkDecls('border-radius', decl => {\n     *   decl.remove();\n     * });\n     *\n     * root.walkDecls(/^background/, decl => {\n     *   decl.value = takeFirstColorFromGradient(decl.value);\n     * });\n     */\n    walkDecls(prop, callback) {\n        if ( !callback ) {\n            callback = prop;\n            return this.walk( (child, i) => {\n                if ( child.type === 'decl' ) {\n                    return callback(child, i);\n                }\n            });\n        } else if ( prop instanceof RegExp ) {\n            return this.walk( (child, i) => {\n                if ( child.type === 'decl' && prop.test(child.prop) ) {\n                    return callback(child, i);\n                }\n            });\n        } else {\n            return this.walk( (child, i) => {\n                if ( child.type === 'decl' && child.prop === prop ) {\n                    return callback(child, i);\n                }\n            });\n        }\n    }\n\n    /**\n     * Traverses the container’s descendant nodes, calling callback\n     * for each rule node.\n     *\n     * If you pass a filter, iteration will only happen over rules\n     * with matching selectors.\n     *\n     * Like {@link Container#each}, this method is safe\n     * to use if you are mutating arrays during iteration.\n     *\n     * @param {string|RegExp} [selector] - string or regular expression\n     *                                     to filter rules by selector\n     * @param {childIterator} callback   - iterator receives each node and index\n     *\n     * @return {false|undefined} returns `false` if iteration was broke\n     *\n     * @example\n     * const selectors = [];\n     * root.walkRules(rule => {\n     *   selectors.push(rule.selector);\n     * });\n     * console.log(`Your CSS uses ${selectors.length} selectors`);\n     */\n    walkRules(selector, callback) {\n        if ( !callback ) {\n            callback = selector;\n\n            return this.walk( (child, i) => {\n                if ( child.type === 'rule' ) {\n                    return callback(child, i);\n                }\n            });\n        } else if ( selector instanceof RegExp ) {\n            return this.walk( (child, i) => {\n                if ( child.type === 'rule' && selector.test(child.selector) ) {\n                    return callback(child, i);\n                }\n            });\n        } else {\n            return this.walk( (child, i) => {\n                if ( child.type === 'rule' && child.selector === selector ) {\n                    return callback(child, i);\n                }\n            });\n        }\n    }\n\n    /**\n     * Traverses the container’s descendant nodes, calling callback\n     * for each at-rule node.\n     *\n     * If you pass a filter, iteration will only happen over at-rules\n     * that have matching names.\n     *\n     * Like {@link Container#each}, this method is safe\n     * to use if you are mutating arrays during iteration.\n     *\n     * @param {string|RegExp} [name]   - string or regular expression\n     *                                   to filter at-rules by name\n     * @param {childIterator} callback - iterator receives each node and index\n     *\n     * @return {false|undefined} returns `false` if iteration was broke\n     *\n     * @example\n     * root.walkAtRules(rule => {\n     *   if ( isOld(rule.name) ) rule.remove();\n     * });\n     *\n     * let first = false;\n     * root.walkAtRules('charset', rule => {\n     *   if ( !first ) {\n     *     first = true;\n     *   } else {\n     *     rule.remove();\n     *   }\n     * });\n     */\n    walkAtRules(name, callback) {\n        if ( !callback ) {\n            callback = name;\n            return this.walk( (child, i) => {\n                if ( child.type === 'atrule' ) {\n                    return callback(child, i);\n                }\n            });\n        } else if ( name instanceof RegExp ) {\n            return this.walk( (child, i) => {\n                if ( child.type === 'atrule' && name.test(child.name) ) {\n                    return callback(child, i);\n                }\n            });\n        } else {\n            return this.walk( (child, i) => {\n                if ( child.type === 'atrule' && child.name === name ) {\n                    return callback(child, i);\n                }\n            });\n        }\n    }\n\n    /**\n     * Traverses the container’s descendant nodes, calling callback\n     * for each comment node.\n     *\n     * Like {@link Container#each}, this method is safe\n     * to use if you are mutating arrays during iteration.\n     *\n     * @param {childIterator} callback - iterator receives each node and index\n     *\n     * @return {false|undefined} returns `false` if iteration was broke\n     *\n     * @example\n     * root.walkComments(comment => {\n     *   comment.remove();\n     * });\n     */\n    walkComments(callback) {\n        return this.walk( (child, i) => {\n            if ( child.type === 'comment' ) {\n                return callback(child, i);\n            }\n        });\n    }\n\n    /**\n     * Inserts new nodes to the end of the container.\n     *\n     * @param {...(Node|object|string|Node[])} children - new nodes\n     *\n     * @return {Node} this node for methods chain\n     *\n     * @example\n     * const decl1 = postcss.decl({ prop: 'color', value: 'black' });\n     * const decl2 = postcss.decl({ prop: 'background-color', value: 'white' });\n     * rule.append(decl1, decl2);\n     *\n     * root.append({ name: 'charset', params: '\"UTF-8\"' });  // at-rule\n     * root.append({ selector: 'a' });                       // rule\n     * rule.append({ prop: 'color', value: 'black' });       // declaration\n     * rule.append({ text: 'Comment' })                      // comment\n     *\n     * root.append('a {}');\n     * root.first.append('color: black; z-index: 1');\n     */\n    append(...children) {\n        for ( let child of children ) {\n            let nodes = this.normalize(child, this.last);\n            for ( let node of nodes ) this.nodes.push(node);\n        }\n        return this;\n    }\n\n    /**\n     * Inserts new nodes to the start of the container.\n     *\n     * @param {...(Node|object|string|Node[])} children - new nodes\n     *\n     * @return {Node} this node for methods chain\n     *\n     * @example\n     * const decl1 = postcss.decl({ prop: 'color', value: 'black' });\n     * const decl2 = postcss.decl({ prop: 'background-color', value: 'white' });\n     * rule.prepend(decl1, decl2);\n     *\n     * root.append({ name: 'charset', params: '\"UTF-8\"' });  // at-rule\n     * root.append({ selector: 'a' });                       // rule\n     * rule.append({ prop: 'color', value: 'black' });       // declaration\n     * rule.append({ text: 'Comment' })                      // comment\n     *\n     * root.append('a {}');\n     * root.first.append('color: black; z-index: 1');\n     */\n    prepend(...children) {\n        children = children.reverse();\n        for ( let child of children ) {\n            let nodes = this.normalize(child, this.first, 'prepend').reverse();\n            for ( let node of nodes ) this.nodes.unshift(node);\n            for ( let id in this.indexes ) {\n                this.indexes[id] = this.indexes[id] + nodes.length;\n            }\n        }\n        return this;\n    }\n\n    cleanRaws(keepBetween) {\n        super.cleanRaws(keepBetween);\n        if ( this.nodes ) {\n            for ( let node of this.nodes ) node.cleanRaws(keepBetween);\n        }\n    }\n\n    /**\n     * Insert new node before old node within the container.\n     *\n     * @param {Node|number} exist             - child or child’s index.\n     * @param {Node|object|string|Node[]} add - new node\n     *\n     * @return {Node} this node for methods chain\n     *\n     * @example\n     * rule.insertBefore(decl, decl.clone({ prop: '-webkit-' + decl.prop }));\n     */\n    insertBefore(exist, add) {\n        exist = this.index(exist);\n\n        let type  = exist === 0 ? 'prepend' : false;\n        let nodes = this.normalize(add, this.nodes[exist], type).reverse();\n        for ( let node of nodes ) this.nodes.splice(exist, 0, node);\n\n        let index;\n        for ( let id in this.indexes ) {\n            index = this.indexes[id];\n            if ( exist <= index ) {\n                this.indexes[id] = index + nodes.length;\n            }\n        }\n\n        return this;\n    }\n\n    /**\n     * Insert new node after old node within the container.\n     *\n     * @param {Node|number} exist             - child or child’s index\n     * @param {Node|object|string|Node[]} add - new node\n     *\n     * @return {Node} this node for methods chain\n     */\n    insertAfter(exist, add) {\n        exist = this.index(exist);\n\n        let nodes = this.normalize(add, this.nodes[exist]).reverse();\n        for ( let node of nodes ) this.nodes.splice(exist + 1, 0, node);\n\n        let index;\n        for ( let id in this.indexes ) {\n            index = this.indexes[id];\n            if ( exist < index ) {\n                this.indexes[id] = index + nodes.length;\n            }\n        }\n\n        return this;\n    }\n\n    remove(child) {\n        if ( typeof child !== 'undefined' ) {\n            warnOnce('Container#remove is deprecated. ' +\n                     'Use Container#removeChild');\n            this.removeChild(child);\n        } else {\n            super.remove();\n        }\n        return this;\n    }\n\n    /**\n     * Removes node from the container and cleans the parent properties\n     * from the node and its children.\n     *\n     * @param {Node|number} child - child or child’s index\n     *\n     * @return {Node} this node for methods chain\n     *\n     * @example\n     * rule.nodes.length  //=> 5\n     * rule.removeChild(decl);\n     * rule.nodes.length  //=> 4\n     * decl.parent        //=> undefined\n     */\n    removeChild(child) {\n        child = this.index(child);\n        this.nodes[child].parent = undefined;\n        this.nodes.splice(child, 1);\n\n        let index;\n        for ( let id in this.indexes ) {\n            index = this.indexes[id];\n            if ( index >= child ) {\n                this.indexes[id] = index - 1;\n            }\n        }\n\n        return this;\n    }\n\n    /**\n     * Removes all children from the container\n     * and cleans their parent properties.\n     *\n     * @return {Node} this node for methods chain\n     *\n     * @example\n     * rule.removeAll();\n     * rule.nodes.length //=> 0\n     */\n    removeAll() {\n        for ( let node of this.nodes ) node.parent = undefined;\n        this.nodes = [];\n        return this;\n    }\n\n    /**\n     * Passes all declaration values within the container that match pattern\n     * through callback, replacing those values with the returned result\n     * of callback.\n     *\n     * This method is useful if you are using a custom unit or function\n     * and need to iterate through all values.\n     *\n     * @param {string|RegExp} pattern      - replace pattern\n     * @param {object} opts                - options to speed up the search\n     * @param {string|string[]} opts.props - an array of property names\n     * @param {string} opts.fast           - string that’s used\n     *                                       to narrow down values and speed up\n                                             the regexp search\n     * @param {function|string} callback   - string to replace pattern\n     *                                       or callback that returns a new\n     *                                       value.\n     *                                       The callback will receive\n     *                                       the same arguments as those\n     *                                       passed to a function parameter\n     *                                       of `String#replace`.\n     *\n     * @return {Node} this node for methods chain\n     *\n     * @example\n     * root.replaceValues(/\\d+rem/, { fast: 'rem' }, string => {\n     *   return 15 * parseInt(string) + 'px';\n     * });\n     */\n    replaceValues(pattern, opts, callback) {\n        if ( !callback ) {\n            callback = opts;\n            opts = { };\n        }\n\n        this.walkDecls( decl => {\n            if ( opts.props && opts.props.indexOf(decl.prop) === -1 ) return;\n            if ( opts.fast  && decl.value.indexOf(opts.fast) === -1 ) return;\n\n            decl.value = decl.value.replace(pattern, callback);\n        });\n\n        return this;\n    }\n\n    /**\n     * Returns `true` if callback returns `true`\n     * for all of the container’s children.\n     *\n     * @param {childCondition} condition - iterator returns true or false.\n     *\n     * @return {boolean} is every child pass condition\n     *\n     * @example\n     * const noPrefixes = rule.every(i => i.prop[0] !== '-');\n     */\n    every(condition) {\n        return this.nodes.every(condition);\n    }\n\n    /**\n     * Returns `true` if callback returns `true` for (at least) one\n     * of the container’s children.\n     *\n     * @param {childCondition} condition - iterator returns true or false.\n     *\n     * @return {boolean} is some child pass condition\n     *\n     * @example\n     * const hasPrefix = rule.some(i => i.prop[0] === '-');\n     */\n    some(condition) {\n        return this.nodes.some(condition);\n    }\n\n    /**\n     * Returns a `child`’s index within the {@link Container#nodes} array.\n     *\n     * @param {Node} child - child of the current container.\n     *\n     * @return {number} child index\n     *\n     * @example\n     * rule.index( rule.nodes[2] ) //=> 2\n     */\n    index(child) {\n        if ( typeof child === 'number' ) {\n            return child;\n        } else {\n            return this.nodes.indexOf(child);\n        }\n    }\n\n    /**\n     * The container’s first child.\n     *\n     * @type {Node}\n     *\n     * @example\n     * rule.first == rules.nodes[0];\n     */\n    get first() {\n        if ( !this.nodes ) return undefined;\n        return this.nodes[0];\n    }\n\n    /**\n     * The container’s last child.\n     *\n     * @type {Node}\n     *\n     * @example\n     * rule.last == rule.nodes[rule.nodes.length - 1];\n     */\n    get last() {\n        if ( !this.nodes ) return undefined;\n        return this.nodes[this.nodes.length - 1];\n    }\n\n    normalize(nodes, sample) {\n        if ( typeof nodes === 'string' ) {\n            let parse = require('./parse');\n            nodes = cleanSource(parse(nodes).nodes);\n        } else if ( !Array.isArray(nodes) ) {\n            if ( nodes.type === 'root' ) {\n                nodes = nodes.nodes;\n            } else if ( nodes.type ) {\n                nodes = [nodes];\n            } else if ( nodes.prop ) {\n                if ( typeof nodes.value === 'undefined' ) {\n                    throw new Error('Value field is missed in node creation');\n                } else if ( typeof nodes.value !== 'string' ) {\n                    nodes.value = String(nodes.value);\n                }\n                nodes = [new Declaration(nodes)];\n            } else if ( nodes.selector ) {\n                let Rule = require('./rule');\n                nodes = [new Rule(nodes)];\n            } else if ( nodes.name ) {\n                let AtRule = require('./at-rule');\n                nodes = [new AtRule(nodes)];\n            } else if ( nodes.text ) {\n                nodes = [new Comment(nodes)];\n            } else {\n                throw new Error('Unknown node type in node creation');\n            }\n        }\n\n        let processed = nodes.map( i => {\n            if ( typeof i.raws === 'undefined' ) i = this.rebuild(i);\n\n            if ( i.parent ) i = i.clone();\n            if ( typeof i.raws.before === 'undefined' ) {\n                if ( sample && typeof sample.raws.before !== 'undefined' ) {\n                    i.raws.before = sample.raws.before.replace(/[^\\s]/g, '');\n                }\n            }\n            i.parent = this;\n            return i;\n        });\n\n        return processed;\n    }\n\n    rebuild(node, parent) {\n        let fix;\n        if ( node.type === 'root' ) {\n            let Root = require('./root');\n            fix = new Root();\n        } else if ( node.type === 'atrule' ) {\n            let AtRule = require('./at-rule');\n            fix = new AtRule();\n        } else if ( node.type === 'rule' ) {\n            let Rule = require('./rule');\n            fix = new Rule();\n        } else if ( node.type === 'decl' ) {\n            fix = new Declaration();\n        } else if ( node.type === 'comment' ) {\n            fix = new Comment();\n        }\n\n        for ( let i in node ) {\n            if ( i === 'nodes' ) {\n                fix.nodes = node.nodes.map( j => this.rebuild(j, fix) );\n            } else if ( i === 'parent' && parent ) {\n                fix.parent = parent;\n            } else if ( node.hasOwnProperty(i) ) {\n                fix[i] = node[i];\n            }\n        }\n\n        return fix;\n    }\n\n    eachInside(callback) {\n        warnOnce('Container#eachInside is deprecated. ' +\n                 'Use Container#walk instead.');\n        return this.walk(callback);\n    }\n\n    eachDecl(prop, callback) {\n        warnOnce('Container#eachDecl is deprecated. ' +\n                 'Use Container#walkDecls instead.');\n        return this.walkDecls(prop, callback);\n    }\n\n    eachRule(selector, callback) {\n        warnOnce('Container#eachRule is deprecated. ' +\n                 'Use Container#walkRules instead.');\n        return this.walkRules(selector, callback);\n    }\n\n    eachAtRule(name, callback) {\n        warnOnce('Container#eachAtRule is deprecated. ' +\n                 'Use Container#walkAtRules instead.');\n        return this.walkAtRules(name, callback);\n    }\n\n    eachComment(callback) {\n        warnOnce('Container#eachComment is deprecated. ' +\n                 'Use Container#walkComments instead.');\n        return this.walkComments(callback);\n    }\n\n    get semicolon() {\n        warnOnce('Node#semicolon is deprecated. Use Node#raws.semicolon');\n        return this.raws.semicolon;\n    }\n\n    set semicolon(val) {\n        warnOnce('Node#semicolon is deprecated. Use Node#raws.semicolon');\n        this.raws.semicolon = val;\n    }\n\n    get after() {\n        warnOnce('Node#after is deprecated. Use Node#raws.after');\n        return this.raws.after;\n    }\n\n    set after(val) {\n        warnOnce('Node#after is deprecated. Use Node#raws.after');\n        this.raws.after = val;\n    }\n\n    /**\n     * @memberof Container#\n     * @member {Node[]} nodes - an array containing the container’s children\n     *\n     * @example\n     * const root = postcss.parse('a { color: black }');\n     * root.nodes.length           //=> 1\n     * root.nodes[0].selector      //=> 'a'\n     * root.nodes[0].nodes[0].prop //=> 'color'\n     */\n\n}\n\nexport default Container;\n\n\n/**\n * @callback childCondition\n * @param {Node} node    - container child\n * @param {number} index - child index\n * @param {Node[]} nodes - all container children\n * @return {boolean}\n */\n\n/**\n * @callback childIterator\n * @param {Node} node    - container child\n * @param {number} index - child index\n * @return {false|undefined} returning `false` will break iteration\n */\n"]},"metadata":{},"sourceType":"script"}