{"ast":null,"code":"import _typeof from \"C:/Users/Administrator/Desktop/data_view/my_project/vue2_app/myapp/node_modules/@babel/runtime/helpers/esm/typeof.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.replace.js\";\nimport \"core-js/modules/es.string.split.js\";\nimport \"core-js/modules/es.string.match.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.object.keys.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.string.trim.js\";\n\n/**\n * Mainly do the parse and compile of shader string\n * Support shader code chunk import and export\n * Support shader semantics\n * http://www.nvidia.com/object/using_sas.html\n * https://github.com/KhronosGroup/collada2json/issues/45\n */\nimport util from './core/util';\nimport vendor from './core/vendor';\nvar uniformRegex = /uniform\\s+(bool|float|int|vec2|vec3|vec4|ivec2|ivec3|ivec4|mat2|mat3|mat4|sampler2D|samplerCube)\\s+([\\s\\S]*?);/g;\nvar attributeRegex = /attribute\\s+(float|int|vec2|vec3|vec4)\\s+([\\s\\S]*?);/g; // Only parse number define.\n\nvar defineRegex = /#define\\s+(\\w+)?(\\s+[\\d-.]+)?\\s*;?\\s*\\n/g;\nvar uniformTypeMap = {\n  'bool': '1i',\n  'int': '1i',\n  'sampler2D': 't',\n  'samplerCube': 't',\n  'float': '1f',\n  'vec2': '2f',\n  'vec3': '3f',\n  'vec4': '4f',\n  'ivec2': '2i',\n  'ivec3': '3i',\n  'ivec4': '4i',\n  'mat2': 'm2',\n  'mat3': 'm3',\n  'mat4': 'm4'\n};\n\nfunction createZeroArray(len) {\n  var arr = [];\n\n  for (var i = 0; i < len; i++) {\n    arr[i] = 0;\n  }\n\n  return arr;\n}\n\nvar uniformValueConstructor = {\n  'bool': function bool() {\n    return true;\n  },\n  'int': function int() {\n    return 0;\n  },\n  'float': function float() {\n    return 0;\n  },\n  'sampler2D': function sampler2D() {\n    return null;\n  },\n  'samplerCube': function samplerCube() {\n    return null;\n  },\n  'vec2': function vec2() {\n    return createZeroArray(2);\n  },\n  'vec3': function vec3() {\n    return createZeroArray(3);\n  },\n  'vec4': function vec4() {\n    return createZeroArray(4);\n  },\n  'ivec2': function ivec2() {\n    return createZeroArray(2);\n  },\n  'ivec3': function ivec3() {\n    return createZeroArray(3);\n  },\n  'ivec4': function ivec4() {\n    return createZeroArray(4);\n  },\n  'mat2': function mat2() {\n    return createZeroArray(4);\n  },\n  'mat3': function mat3() {\n    return createZeroArray(9);\n  },\n  'mat4': function mat4() {\n    return createZeroArray(16);\n  },\n  'array': function array() {\n    return [];\n  }\n};\nvar attributeSemantics = ['POSITION', 'NORMAL', 'BINORMAL', 'TANGENT', 'TEXCOORD', 'TEXCOORD_0', 'TEXCOORD_1', 'COLOR', // Skinning\n// https://github.com/KhronosGroup/glTF/blob/master/specification/README.md#semantics\n'JOINT', 'WEIGHT'];\nvar uniformSemantics = ['SKIN_MATRIX', // Information about viewport\n'VIEWPORT_SIZE', 'VIEWPORT', 'DEVICEPIXELRATIO', // Window size for window relative coordinate\n// https://www.opengl.org/sdk/docs/man/html/gl_FragCoord.xhtml\n'WINDOW_SIZE', // Infomation about camera\n'NEAR', 'FAR', // Time\n'TIME'];\nvar matrixSemantics = ['WORLD', 'VIEW', 'PROJECTION', 'WORLDVIEW', 'VIEWPROJECTION', 'WORLDVIEWPROJECTION', 'WORLDINVERSE', 'VIEWINVERSE', 'PROJECTIONINVERSE', 'WORLDVIEWINVERSE', 'VIEWPROJECTIONINVERSE', 'WORLDVIEWPROJECTIONINVERSE', 'WORLDTRANSPOSE', 'VIEWTRANSPOSE', 'PROJECTIONTRANSPOSE', 'WORLDVIEWTRANSPOSE', 'VIEWPROJECTIONTRANSPOSE', 'WORLDVIEWPROJECTIONTRANSPOSE', 'WORLDINVERSETRANSPOSE', 'VIEWINVERSETRANSPOSE', 'PROJECTIONINVERSETRANSPOSE', 'WORLDVIEWINVERSETRANSPOSE', 'VIEWPROJECTIONINVERSETRANSPOSE', 'WORLDVIEWPROJECTIONINVERSETRANSPOSE'];\nvar attributeSizeMap = {\n  // WebGL does not support integer attributes\n  'vec4': 4,\n  'vec3': 3,\n  'vec2': 2,\n  'float': 1\n};\nvar shaderIDCache = {};\nvar shaderCodeCache = {};\n\nfunction getShaderID(vertex, fragment) {\n  var key = 'vertex:' + vertex + 'fragment:' + fragment;\n\n  if (shaderIDCache[key]) {\n    return shaderIDCache[key];\n  }\n\n  var id = util.genGUID();\n  shaderIDCache[key] = id;\n  shaderCodeCache[id] = {\n    vertex: vertex,\n    fragment: fragment\n  };\n  return id;\n}\n\nfunction removeComment(code) {\n  return code.replace(/[ \\t]*\\/\\/.*\\n/g, '') // remove //\n  .replace(/[ \\t]*\\/\\*[\\s\\S]*?\\*\\//g, ''); // remove /* */\n}\n\nfunction logSyntaxError() {\n  console.error('Wrong uniform/attributes syntax');\n}\n\nfunction parseDeclarations(type, line) {\n  var speratorsRegexp = /[,=\\(\\):]/;\n  var tokens = line // Convert `symbol: [1,2,3]` to `symbol: vec3(1,2,3)`\n  .replace(/:\\s*\\[\\s*(.*)\\s*\\]/g, '=' + type + '($1)').replace(/\\s+/g, '').split(/(?=[,=\\(\\):])/g);\n  var newTokens = [];\n\n  for (var i = 0; i < tokens.length; i++) {\n    if (tokens[i].match(speratorsRegexp)) {\n      newTokens.push(tokens[i].charAt(0), tokens[i].slice(1));\n    } else {\n      newTokens.push(tokens[i]);\n    }\n  }\n\n  tokens = newTokens;\n  var TYPE_SYMBOL = 0;\n  var TYPE_ASSIGN = 1;\n  var TYPE_VEC = 2;\n  var TYPE_ARR = 3;\n  var TYPE_SEMANTIC = 4;\n  var TYPE_NORMAL = 5;\n  var opType = TYPE_SYMBOL;\n  var declarations = {};\n  var declarationValue = null;\n  var currentDeclaration;\n  addSymbol(tokens[0]);\n\n  function addSymbol(symbol) {\n    if (!symbol) {\n      logSyntaxError();\n    }\n\n    var arrResult = symbol.match(/\\[(.*?)\\]/);\n    currentDeclaration = symbol.replace(/\\[(.*?)\\]/, '');\n    declarations[currentDeclaration] = {};\n\n    if (arrResult) {\n      declarations[currentDeclaration].isArray = true;\n      declarations[currentDeclaration].arraySize = arrResult[1];\n    }\n  }\n\n  for (var i = 1; i < tokens.length; i++) {\n    var token = tokens[i];\n\n    if (!token) {\n      // Empty token;\n      continue;\n    }\n\n    if (token === '=') {\n      if (opType !== TYPE_SYMBOL && opType !== TYPE_ARR) {\n        logSyntaxError();\n        break;\n      }\n\n      opType = TYPE_ASSIGN;\n      continue;\n    } else if (token === ':') {\n      opType = TYPE_SEMANTIC;\n      continue;\n    } else if (token === ',') {\n      if (opType === TYPE_VEC) {\n        if (!(declarationValue instanceof Array)) {\n          logSyntaxError();\n          break;\n        }\n\n        declarationValue.push(+tokens[++i]);\n      } else {\n        opType = TYPE_NORMAL;\n      }\n\n      continue;\n    } else if (token === ')') {\n      declarations[currentDeclaration].value = new vendor.Float32Array(declarationValue);\n      declarationValue = null;\n      opType = TYPE_NORMAL;\n      continue;\n    } else if (token === '(') {\n      if (opType !== TYPE_VEC) {\n        logSyntaxError();\n        break;\n      }\n\n      if (!(declarationValue instanceof Array)) {\n        logSyntaxError();\n        break;\n      }\n\n      declarationValue.push(+tokens[++i]);\n      continue;\n    } else if (token.indexOf('vec') >= 0) {\n      if (opType !== TYPE_ASSIGN // Compatitable with old syntax `symbol: [1,2,3]`\n      && opType !== TYPE_SEMANTIC) {\n        logSyntaxError();\n        break;\n      }\n\n      opType = TYPE_VEC;\n      declarationValue = [];\n      continue;\n    } else if (opType === TYPE_ASSIGN) {\n      if (type === 'bool') {\n        declarations[currentDeclaration].value = token === 'true';\n      } else {\n        declarations[currentDeclaration].value = parseFloat(token);\n      }\n\n      declarationValue = null;\n      continue;\n    } else if (opType === TYPE_SEMANTIC) {\n      var semantic = token;\n\n      if (attributeSemantics.indexOf(semantic) >= 0 || uniformSemantics.indexOf(semantic) >= 0 || matrixSemantics.indexOf(semantic) >= 0) {\n        declarations[currentDeclaration].semantic = semantic;\n      } else if (semantic === 'ignore' || semantic === 'unconfigurable') {\n        declarations[currentDeclaration].ignore = true;\n      } else {\n        // Try to parse as a default tvalue.\n        if (type === 'bool') {\n          declarations[currentDeclaration].value = semantic === 'true';\n        } else {\n          declarations[currentDeclaration].value = parseFloat(semantic);\n        }\n      }\n\n      continue;\n    } // treat as symbol.\n\n\n    addSymbol(token);\n    opType = TYPE_SYMBOL;\n  }\n\n  return declarations;\n}\n/**\n * @constructor\n * @extends clay.core.Base\n * @alias clay.Shader\n * @param {string} vertex\n * @param {string} fragment\n * @example\n * // Create a phong shader\n * var shader = new clay.Shader(\n *      clay.Shader.source('clay.standard.vertex'),\n *      clay.Shader.source('clay.standard.fragment')\n * );\n */\n\n\nfunction Shader(vertex, fragment) {\n  // First argument can be { vertex, fragment }\n  if (_typeof(vertex) === 'object') {\n    fragment = vertex.fragment;\n    vertex = vertex.vertex;\n  }\n\n  vertex = removeComment(vertex);\n  fragment = removeComment(fragment);\n  this._shaderID = getShaderID(vertex, fragment);\n  this._vertexCode = Shader.parseImport(vertex);\n  this._fragmentCode = Shader.parseImport(fragment);\n  /**\n   * @readOnly\n   */\n\n  this.attributeSemantics = {};\n  /**\n   * @readOnly\n   */\n\n  this.matrixSemantics = {};\n  /**\n   * @readOnly\n   */\n\n  this.uniformSemantics = {};\n  /**\n   * @readOnly\n   */\n\n  this.matrixSemanticKeys = [];\n  /**\n   * @readOnly\n   */\n\n  this.uniformTemplates = {};\n  /**\n   * @readOnly\n   */\n\n  this.attributes = {};\n  /**\n   * @readOnly\n   */\n\n  this.textures = {};\n  /**\n   * @readOnly\n   */\n\n  this.vertexDefines = {};\n  /**\n   * @readOnly\n   */\n\n  this.fragmentDefines = {};\n\n  this._parseAttributes();\n\n  this._parseUniforms();\n\n  this._parseDefines();\n}\n\nShader.prototype = {\n  constructor: Shader,\n  // Create a new uniform instance for material\n  createUniforms: function createUniforms() {\n    var uniforms = {};\n\n    for (var symbol in this.uniformTemplates) {\n      var uniformTpl = this.uniformTemplates[symbol];\n      uniforms[symbol] = {\n        type: uniformTpl.type,\n        value: uniformTpl.value()\n      };\n    }\n\n    return uniforms;\n  },\n  _parseImport: function _parseImport() {\n    this._vertexCode = Shader.parseImport(this.vertex);\n    this._fragmentCode = Shader.parseImport(this.fragment);\n  },\n  _addSemanticUniform: function _addSemanticUniform(symbol, uniformType, semantic) {\n    // This case is only for SKIN_MATRIX\n    // TODO\n    if (attributeSemantics.indexOf(semantic) >= 0) {\n      this.attributeSemantics[semantic] = {\n        symbol: symbol,\n        type: uniformType\n      };\n    } else if (matrixSemantics.indexOf(semantic) >= 0) {\n      var isTranspose = false;\n      var semanticNoTranspose = semantic;\n\n      if (semantic.match(/TRANSPOSE$/)) {\n        isTranspose = true;\n        semanticNoTranspose = semantic.slice(0, -9);\n      }\n\n      this.matrixSemantics[semantic] = {\n        symbol: symbol,\n        type: uniformType,\n        isTranspose: isTranspose,\n        semanticNoTranspose: semanticNoTranspose\n      };\n    } else if (uniformSemantics.indexOf(semantic) >= 0) {\n      this.uniformSemantics[semantic] = {\n        symbol: symbol,\n        type: uniformType\n      };\n    }\n  },\n  _addMaterialUniform: function _addMaterialUniform(symbol, type, uniformType, defaultValueFunc, isArray, materialUniforms) {\n    materialUniforms[symbol] = {\n      type: uniformType,\n      value: isArray ? uniformValueConstructor['array'] : defaultValueFunc || uniformValueConstructor[type],\n      semantic: null\n    };\n  },\n  _parseUniforms: function _parseUniforms() {\n    var uniforms = {};\n    var self = this;\n    var shaderType = 'vertex';\n    this._uniformList = [];\n    this._vertexCode = this._vertexCode.replace(uniformRegex, _uniformParser);\n    shaderType = 'fragment';\n    this._fragmentCode = this._fragmentCode.replace(uniformRegex, _uniformParser);\n    self.matrixSemanticKeys = Object.keys(this.matrixSemantics);\n\n    function makeDefaultValueFunc(value) {\n      return value != null ? function () {\n        return value;\n      } : null;\n    }\n\n    function _uniformParser(str, type, content) {\n      var declaredUniforms = parseDeclarations(type, content);\n      var uniformMainStr = [];\n\n      for (var symbol in declaredUniforms) {\n        var uniformInfo = declaredUniforms[symbol];\n        var semantic = uniformInfo.semantic;\n        var tmpStr = symbol;\n        var uniformType = uniformTypeMap[type];\n        var defaultValueFunc = makeDefaultValueFunc(declaredUniforms[symbol].value);\n\n        if (declaredUniforms[symbol].isArray) {\n          tmpStr += '[' + declaredUniforms[symbol].arraySize + ']';\n          uniformType += 'v';\n        }\n\n        uniformMainStr.push(tmpStr);\n\n        self._uniformList.push(symbol);\n\n        if (!uniformInfo.ignore) {\n          if (type === 'sampler2D' || type === 'samplerCube') {\n            // Texture is default disabled\n            self.textures[symbol] = {\n              shaderType: shaderType,\n              type: type\n            };\n          }\n\n          if (semantic) {\n            // TODO Should not declare multiple symbols if have semantic.\n            self._addSemanticUniform(symbol, uniformType, semantic);\n          } else {\n            self._addMaterialUniform(symbol, type, uniformType, defaultValueFunc, declaredUniforms[symbol].isArray, uniforms);\n          }\n        }\n      }\n\n      return uniformMainStr.length > 0 ? 'uniform ' + type + ' ' + uniformMainStr.join(',') + ';\\n' : '';\n    }\n\n    this.uniformTemplates = uniforms;\n  },\n  _parseAttributes: function _parseAttributes() {\n    var attributes = {};\n    var self = this;\n    this._vertexCode = this._vertexCode.replace(attributeRegex, _attributeParser);\n\n    function _attributeParser(str, type, content) {\n      var declaredAttributes = parseDeclarations(type, content);\n      var size = attributeSizeMap[type] || 1;\n      var attributeMainStr = [];\n\n      for (var symbol in declaredAttributes) {\n        var semantic = declaredAttributes[symbol].semantic;\n        attributes[symbol] = {\n          // TODO Can only be float\n          type: 'float',\n          size: size,\n          semantic: semantic || null\n        }; // TODO Should not declare multiple symbols if have semantic.\n\n        if (semantic) {\n          if (attributeSemantics.indexOf(semantic) < 0) {\n            throw new Error('Unkown semantic \"' + semantic + '\"');\n          } else {\n            self.attributeSemantics[semantic] = {\n              symbol: symbol,\n              type: type\n            };\n          }\n        }\n\n        attributeMainStr.push(symbol);\n      }\n\n      return 'attribute ' + type + ' ' + attributeMainStr.join(',') + ';\\n';\n    }\n\n    this.attributes = attributes;\n  },\n  _parseDefines: function _parseDefines() {\n    var self = this;\n    var shaderType = 'vertex';\n    this._vertexCode = this._vertexCode.replace(defineRegex, _defineParser);\n    shaderType = 'fragment';\n    this._fragmentCode = this._fragmentCode.replace(defineRegex, _defineParser);\n\n    function _defineParser(str, symbol, value) {\n      var defines = shaderType === 'vertex' ? self.vertexDefines : self.fragmentDefines;\n\n      if (!defines[symbol]) {\n        // Haven't been defined by user\n        if (value === 'false') {\n          defines[symbol] = false;\n        } else if (value === 'true') {\n          defines[symbol] = true;\n        } else {\n          defines[symbol] = value // If can parse to float\n          ? isNaN(parseFloat(value)) ? value.trim() : parseFloat(value) : null;\n        }\n      }\n\n      return '';\n    }\n  },\n\n  /**\n   * Clone a new shader\n   * @return {clay.Shader}\n   */\n  clone: function clone() {\n    var code = shaderCodeCache[this._shaderID];\n    var shader = new Shader(code.vertex, code.fragment);\n    return shader;\n  }\n};\n\nif (Object.defineProperty) {\n  Object.defineProperty(Shader.prototype, 'shaderID', {\n    get: function get() {\n      return this._shaderID;\n    }\n  });\n  Object.defineProperty(Shader.prototype, 'vertex', {\n    get: function get() {\n      return this._vertexCode;\n    }\n  });\n  Object.defineProperty(Shader.prototype, 'fragment', {\n    get: function get() {\n      return this._fragmentCode;\n    }\n  });\n  Object.defineProperty(Shader.prototype, 'uniforms', {\n    get: function get() {\n      return this._uniformList;\n    }\n  });\n}\n\nvar importRegex = /(@import)\\s*([0-9a-zA-Z_\\-\\.]*)/g;\n\nShader.parseImport = function (shaderStr) {\n  shaderStr = shaderStr.replace(importRegex, function (str, importSymbol, importName) {\n    var str = Shader.source(importName);\n\n    if (str) {\n      // Recursively parse\n      return Shader.parseImport(str);\n    } else {\n      console.error('Shader chunk \"' + importName + '\" not existed in library');\n      return '';\n    }\n  });\n  return shaderStr;\n};\n\nvar exportRegex = /(@export)\\s*([0-9a-zA-Z_\\-\\.]*)\\s*\\n([\\s\\S]*?)@end/g;\n/**\n * Import shader source\n * @param  {string} shaderStr\n * @memberOf clay.Shader\n */\n\nShader['import'] = function (shaderStr) {\n  shaderStr.replace(exportRegex, function (str, exportSymbol, exportName, code) {\n    var code = code.replace(/(^[\\s\\t\\xa0\\u3000]+)|([\\u3000\\xa0\\s\\t]+\\x24)/g, '');\n\n    if (code) {\n      var parts = exportName.split('.');\n      var obj = Shader.codes;\n      var i = 0;\n      var key;\n\n      while (i < parts.length - 1) {\n        key = parts[i++];\n\n        if (!obj[key]) {\n          obj[key] = {};\n        }\n\n        obj = obj[key];\n      }\n\n      key = parts[i];\n      obj[key] = code;\n    }\n\n    return code;\n  });\n};\n/**\n * Library to store all the loaded shader codes\n * @type {Object}\n * @readOnly\n * @memberOf clay.Shader\n */\n\n\nShader.codes = {};\n/**\n * Get shader source\n * @param  {string} name\n * @return {string}\n */\n\nShader.source = function (name) {\n  var parts = name.split('.');\n  var obj = Shader.codes;\n  var i = 0;\n\n  while (obj && i < parts.length) {\n    var key = parts[i++];\n    obj = obj[key];\n  }\n\n  if (typeof obj !== 'string') {\n    // FIXME Use default instead\n    console.error('Shader \"' + name + '\" not existed in library');\n    return '';\n  }\n\n  return obj;\n};\n\nexport default Shader;","map":{"version":3,"sources":["C:/Users/Administrator/Desktop/data_view/my_project/vue2_app/myapp/node_modules/claygl/src/Shader.js"],"names":["util","vendor","uniformRegex","attributeRegex","defineRegex","uniformTypeMap","createZeroArray","len","arr","i","uniformValueConstructor","attributeSemantics","uniformSemantics","matrixSemantics","attributeSizeMap","shaderIDCache","shaderCodeCache","getShaderID","vertex","fragment","key","id","genGUID","removeComment","code","replace","logSyntaxError","console","error","parseDeclarations","type","line","speratorsRegexp","tokens","split","newTokens","length","match","push","charAt","slice","TYPE_SYMBOL","TYPE_ASSIGN","TYPE_VEC","TYPE_ARR","TYPE_SEMANTIC","TYPE_NORMAL","opType","declarations","declarationValue","currentDeclaration","addSymbol","symbol","arrResult","isArray","arraySize","token","Array","value","Float32Array","indexOf","parseFloat","semantic","ignore","Shader","_shaderID","_vertexCode","parseImport","_fragmentCode","matrixSemanticKeys","uniformTemplates","attributes","textures","vertexDefines","fragmentDefines","_parseAttributes","_parseUniforms","_parseDefines","prototype","constructor","createUniforms","uniforms","uniformTpl","_parseImport","_addSemanticUniform","uniformType","isTranspose","semanticNoTranspose","_addMaterialUniform","defaultValueFunc","materialUniforms","self","shaderType","_uniformList","_uniformParser","Object","keys","makeDefaultValueFunc","str","content","declaredUniforms","uniformMainStr","uniformInfo","tmpStr","join","_attributeParser","declaredAttributes","size","attributeMainStr","Error","_defineParser","defines","isNaN","trim","clone","shader","defineProperty","get","importRegex","shaderStr","importSymbol","importName","source","exportRegex","exportSymbol","exportName","parts","obj","codes","name"],"mappings":";;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAOA,IAAP,MAAiB,aAAjB;AACA,OAAOC,MAAP,MAAmB,eAAnB;AAEA,IAAIC,YAAY,GAAG,iHAAnB;AACA,IAAIC,cAAc,GAAG,uDAArB,C,CACA;;AACA,IAAIC,WAAW,GAAG,0CAAlB;AAEA,IAAIC,cAAc,GAAG;AACjB,UAAQ,IADS;AAEjB,SAAO,IAFU;AAGjB,eAAa,GAHI;AAIjB,iBAAe,GAJE;AAKjB,WAAS,IALQ;AAMjB,UAAQ,IANS;AAOjB,UAAQ,IAPS;AAQjB,UAAQ,IARS;AASjB,WAAS,IATQ;AAUjB,WAAS,IAVQ;AAWjB,WAAS,IAXQ;AAYjB,UAAQ,IAZS;AAajB,UAAQ,IAbS;AAcjB,UAAQ;AAdS,CAArB;;AAiBA,SAASC,eAAT,CAAyBC,GAAzB,EAA8B;AAC1B,MAAIC,GAAG,GAAG,EAAV;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,GAApB,EAAyBE,CAAC,EAA1B,EAA8B;AAC1BD,IAAAA,GAAG,CAACC,CAAD,CAAH,GAAS,CAAT;AACH;;AACD,SAAOD,GAAP;AACH;;AAED,IAAIE,uBAAuB,GAAG;AAC1B,UAAQ,gBAAY;AAAE,WAAO,IAAP;AAAc,GADV;AAE1B,SAAO,eAAY;AAAE,WAAO,CAAP;AAAW,GAFN;AAG1B,WAAS,iBAAY;AAAE,WAAO,CAAP;AAAW,GAHR;AAI1B,eAAa,qBAAY;AAAE,WAAO,IAAP;AAAc,GAJf;AAK1B,iBAAe,uBAAY;AAAE,WAAO,IAAP;AAAc,GALjB;AAO1B,UAAQ,gBAAY;AAAE,WAAOJ,eAAe,CAAC,CAAD,CAAtB;AAA4B,GAPxB;AAQ1B,UAAQ,gBAAY;AAAE,WAAOA,eAAe,CAAC,CAAD,CAAtB;AAA4B,GARxB;AAS1B,UAAQ,gBAAY;AAAE,WAAOA,eAAe,CAAC,CAAD,CAAtB;AAA4B,GATxB;AAW1B,WAAS,iBAAY;AAAE,WAAOA,eAAe,CAAC,CAAD,CAAtB;AAA4B,GAXzB;AAY1B,WAAS,iBAAY;AAAE,WAAOA,eAAe,CAAC,CAAD,CAAtB;AAA4B,GAZzB;AAa1B,WAAS,iBAAY;AAAE,WAAOA,eAAe,CAAC,CAAD,CAAtB;AAA4B,GAbzB;AAe1B,UAAQ,gBAAY;AAAE,WAAOA,eAAe,CAAC,CAAD,CAAtB;AAA4B,GAfxB;AAgB1B,UAAQ,gBAAY;AAAE,WAAOA,eAAe,CAAC,CAAD,CAAtB;AAA4B,GAhBxB;AAiB1B,UAAQ,gBAAY;AAAE,WAAOA,eAAe,CAAC,EAAD,CAAtB;AAA6B,GAjBzB;AAmB1B,WAAS,iBAAY;AAAE,WAAO,EAAP;AAAY;AAnBT,CAA9B;AAsBA,IAAIK,kBAAkB,GAAG,CACrB,UADqB,EAErB,QAFqB,EAGrB,UAHqB,EAIrB,SAJqB,EAKrB,UALqB,EAMrB,YANqB,EAOrB,YAPqB,EAQrB,OARqB,EASrB;AACA;AACA,OAXqB,EAYrB,QAZqB,CAAzB;AAcA,IAAIC,gBAAgB,GAAG,CACnB,aADmB,EAEnB;AACA,eAHmB,EAInB,UAJmB,EAKnB,kBALmB,EAMnB;AACA;AACA,aARmB,EASnB;AACA,MAVmB,EAWnB,KAXmB,EAYnB;AACA,MAbmB,CAAvB;AAeA,IAAIC,eAAe,GAAG,CAClB,OADkB,EAElB,MAFkB,EAGlB,YAHkB,EAIlB,WAJkB,EAKlB,gBALkB,EAMlB,qBANkB,EAOlB,cAPkB,EAQlB,aARkB,EASlB,mBATkB,EAUlB,kBAVkB,EAWlB,uBAXkB,EAYlB,4BAZkB,EAalB,gBAbkB,EAclB,eAdkB,EAelB,qBAfkB,EAgBlB,oBAhBkB,EAiBlB,yBAjBkB,EAkBlB,8BAlBkB,EAmBlB,uBAnBkB,EAoBlB,sBApBkB,EAqBlB,4BArBkB,EAsBlB,2BAtBkB,EAuBlB,gCAvBkB,EAwBlB,qCAxBkB,CAAtB;AA2BA,IAAIC,gBAAgB,GAAG;AACnB;AACA,UAAQ,CAFW;AAGnB,UAAQ,CAHW;AAInB,UAAQ,CAJW;AAKnB,WAAS;AALU,CAAvB;AASA,IAAIC,aAAa,GAAG,EAApB;AACA,IAAIC,eAAe,GAAG,EAAtB;;AAEA,SAASC,WAAT,CAAqBC,MAArB,EAA6BC,QAA7B,EAAuC;AACnC,MAAIC,GAAG,GAAG,YAAYF,MAAZ,GAAqB,WAArB,GAAmCC,QAA7C;;AACA,MAAIJ,aAAa,CAACK,GAAD,CAAjB,EAAwB;AACpB,WAAOL,aAAa,CAACK,GAAD,CAApB;AACH;;AACD,MAAIC,EAAE,GAAGrB,IAAI,CAACsB,OAAL,EAAT;AACAP,EAAAA,aAAa,CAACK,GAAD,CAAb,GAAqBC,EAArB;AAEAL,EAAAA,eAAe,CAACK,EAAD,CAAf,GAAsB;AAClBH,IAAAA,MAAM,EAAEA,MADU;AAElBC,IAAAA,QAAQ,EAAEA;AAFQ,GAAtB;AAKA,SAAOE,EAAP;AACH;;AAED,SAASE,aAAT,CAAuBC,IAAvB,EAA6B;AACzB,SAAOA,IAAI,CAACC,OAAL,CAAa,iBAAb,EAAgC,EAAhC,EAAuC;AAAvC,GACFA,OADE,CACM,yBADN,EACiC,EADjC,CAAP,CADyB,CAEqB;AACjD;;AAED,SAASC,cAAT,GAA0B;AACtBC,EAAAA,OAAO,CAACC,KAAR,CAAc,iCAAd;AACH;;AAED,SAASC,iBAAT,CAA2BC,IAA3B,EAAiCC,IAAjC,EAAuC;AACnC,MAAIC,eAAe,GAAG,WAAtB;AACA,MAAIC,MAAM,GAAGF,IAAI,CACb;AADa,GAEZN,OAFQ,CAEA,qBAFA,EAEuB,MAAMK,IAAN,GAAa,MAFpC,EAGRL,OAHQ,CAGA,MAHA,EAGQ,EAHR,EAIRS,KAJQ,CAIF,gBAJE,CAAb;AAMA,MAAIC,SAAS,GAAG,EAAhB;;AACA,OAAK,IAAI1B,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGwB,MAAM,CAACG,MAA3B,EAAmC3B,CAAC,EAApC,EAAwC;AACpC,QAAIwB,MAAM,CAACxB,CAAD,CAAN,CAAU4B,KAAV,CAAgBL,eAAhB,CAAJ,EAAsC;AAClCG,MAAAA,SAAS,CAACG,IAAV,CACIL,MAAM,CAACxB,CAAD,CAAN,CAAU8B,MAAV,CAAiB,CAAjB,CADJ,EAEIN,MAAM,CAACxB,CAAD,CAAN,CAAU+B,KAAV,CAAgB,CAAhB,CAFJ;AAIH,KALD,MAMK;AACDL,MAAAA,SAAS,CAACG,IAAV,CAAeL,MAAM,CAACxB,CAAD,CAArB;AACH;AACJ;;AACDwB,EAAAA,MAAM,GAAGE,SAAT;AAEA,MAAIM,WAAW,GAAG,CAAlB;AACA,MAAIC,WAAW,GAAG,CAAlB;AACA,MAAIC,QAAQ,GAAG,CAAf;AACA,MAAIC,QAAQ,GAAG,CAAf;AACA,MAAIC,aAAa,GAAG,CAApB;AACA,MAAIC,WAAW,GAAG,CAAlB;AAEA,MAAIC,MAAM,GAAGN,WAAb;AACA,MAAIO,YAAY,GAAG,EAAnB;AACA,MAAIC,gBAAgB,GAAG,IAAvB;AACA,MAAIC,kBAAJ;AAEAC,EAAAA,SAAS,CAAClB,MAAM,CAAC,CAAD,CAAP,CAAT;;AAEA,WAASkB,SAAT,CAAmBC,MAAnB,EAA2B;AACvB,QAAI,CAACA,MAAL,EAAa;AACT1B,MAAAA,cAAc;AACjB;;AACD,QAAI2B,SAAS,GAAGD,MAAM,CAACf,KAAP,CAAa,WAAb,CAAhB;AACAa,IAAAA,kBAAkB,GAAGE,MAAM,CAAC3B,OAAP,CAAe,WAAf,EAA4B,EAA5B,CAArB;AACAuB,IAAAA,YAAY,CAACE,kBAAD,CAAZ,GAAmC,EAAnC;;AACA,QAAIG,SAAJ,EAAe;AACXL,MAAAA,YAAY,CAACE,kBAAD,CAAZ,CAAiCI,OAAjC,GAA2C,IAA3C;AACAN,MAAAA,YAAY,CAACE,kBAAD,CAAZ,CAAiCK,SAAjC,GAA6CF,SAAS,CAAC,CAAD,CAAtD;AACH;AACJ;;AAED,OAAK,IAAI5C,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGwB,MAAM,CAACG,MAA3B,EAAmC3B,CAAC,EAApC,EAAwC;AACpC,QAAI+C,KAAK,GAAGvB,MAAM,CAACxB,CAAD,CAAlB;;AACA,QAAI,CAAC+C,KAAL,EAAY;AAAI;AACZ;AACH;;AACD,QAAIA,KAAK,KAAK,GAAd,EAAmB;AACf,UAAIT,MAAM,KAAKN,WAAX,IACDM,MAAM,KAAKH,QADd,EACwB;AACpBlB,QAAAA,cAAc;AACd;AACH;;AACDqB,MAAAA,MAAM,GAAGL,WAAT;AAEA;AACH,KATD,MAUK,IAAIc,KAAK,KAAK,GAAd,EAAmB;AACpBT,MAAAA,MAAM,GAAGF,aAAT;AAEA;AACH,KAJI,MAKA,IAAIW,KAAK,KAAK,GAAd,EAAmB;AACpB,UAAIT,MAAM,KAAKJ,QAAf,EAAyB;AACrB,YAAI,EAAEM,gBAAgB,YAAYQ,KAA9B,CAAJ,EAA0C;AACtC/B,UAAAA,cAAc;AACd;AACH;;AACDuB,QAAAA,gBAAgB,CAACX,IAAjB,CAAsB,CAACL,MAAM,CAAC,EAAExB,CAAH,CAA7B;AACH,OAND,MAOK;AACDsC,QAAAA,MAAM,GAAGD,WAAT;AACH;;AAED;AACH,KAbI,MAcA,IAAIU,KAAK,KAAK,GAAd,EAAmB;AACpBR,MAAAA,YAAY,CAACE,kBAAD,CAAZ,CAAiCQ,KAAjC,GAAyC,IAAIzD,MAAM,CAAC0D,YAAX,CAAwBV,gBAAxB,CAAzC;AACAA,MAAAA,gBAAgB,GAAG,IAAnB;AACAF,MAAAA,MAAM,GAAGD,WAAT;AACA;AACH,KALI,MAMA,IAAIU,KAAK,KAAK,GAAd,EAAmB;AACpB,UAAIT,MAAM,KAAKJ,QAAf,EAAyB;AACrBjB,QAAAA,cAAc;AACd;AACH;;AACD,UAAI,EAAEuB,gBAAgB,YAAYQ,KAA9B,CAAJ,EAA0C;AACtC/B,QAAAA,cAAc;AACd;AACH;;AACDuB,MAAAA,gBAAgB,CAACX,IAAjB,CAAsB,CAACL,MAAM,CAAC,EAAExB,CAAH,CAA7B;AACA;AACH,KAXI,MAYA,IAAI+C,KAAK,CAACI,OAAN,CAAc,KAAd,KAAwB,CAA5B,EAA+B;AAChC,UAAIb,MAAM,KAAKL,WAAX,CACJ;AADI,SAEDK,MAAM,KAAKF,aAFd,EAE6B;AACzBnB,QAAAA,cAAc;AACd;AACH;;AACDqB,MAAAA,MAAM,GAAGJ,QAAT;AACAM,MAAAA,gBAAgB,GAAG,EAAnB;AACA;AACH,KAVI,MAWA,IAAIF,MAAM,KAAKL,WAAf,EAA4B;AAC7B,UAAIZ,IAAI,KAAK,MAAb,EAAqB;AACjBkB,QAAAA,YAAY,CAACE,kBAAD,CAAZ,CAAiCQ,KAAjC,GAAyCF,KAAK,KAAK,MAAnD;AACH,OAFD,MAGK;AACDR,QAAAA,YAAY,CAACE,kBAAD,CAAZ,CAAiCQ,KAAjC,GAAyCG,UAAU,CAACL,KAAD,CAAnD;AACH;;AACDP,MAAAA,gBAAgB,GAAG,IAAnB;AACA;AACH,KATI,MAUA,IAAIF,MAAM,KAAKF,aAAf,EAA8B;AAC/B,UAAIiB,QAAQ,GAAGN,KAAf;;AACA,UAAI7C,kBAAkB,CAACiD,OAAnB,CAA2BE,QAA3B,KAAwC,CAAxC,IACGlD,gBAAgB,CAACgD,OAAjB,CAAyBE,QAAzB,KAAsC,CADzC,IAEGjD,eAAe,CAAC+C,OAAhB,CAAwBE,QAAxB,KAAqC,CAF5C,EAGE;AACEd,QAAAA,YAAY,CAACE,kBAAD,CAAZ,CAAiCY,QAAjC,GAA4CA,QAA5C;AACH,OALD,MAMK,IAAIA,QAAQ,KAAK,QAAb,IAAyBA,QAAQ,KAAK,gBAA1C,EAA4D;AAC7Dd,QAAAA,YAAY,CAACE,kBAAD,CAAZ,CAAiCa,MAAjC,GAA0C,IAA1C;AACH,OAFI,MAGA;AACD;AACA,YAAIjC,IAAI,KAAK,MAAb,EAAqB;AACjBkB,UAAAA,YAAY,CAACE,kBAAD,CAAZ,CAAiCQ,KAAjC,GAAyCI,QAAQ,KAAK,MAAtD;AACH,SAFD,MAGK;AACDd,UAAAA,YAAY,CAACE,kBAAD,CAAZ,CAAiCQ,KAAjC,GAAyCG,UAAU,CAACC,QAAD,CAAnD;AACH;AACJ;;AACD;AACH,KA9FmC,CAgGpC;;;AACAX,IAAAA,SAAS,CAACK,KAAD,CAAT;AACAT,IAAAA,MAAM,GAAGN,WAAT;AACH;;AAED,SAAOO,YAAP;AACH;AAGD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASgB,MAAT,CAAgB9C,MAAhB,EAAwBC,QAAxB,EAAkC;AAC9B;AACA,MAAI,QAAOD,MAAP,MAAkB,QAAtB,EAAgC;AAC5BC,IAAAA,QAAQ,GAAGD,MAAM,CAACC,QAAlB;AACAD,IAAAA,MAAM,GAAGA,MAAM,CAACA,MAAhB;AACH;;AAEDA,EAAAA,MAAM,GAAGK,aAAa,CAACL,MAAD,CAAtB;AACAC,EAAAA,QAAQ,GAAGI,aAAa,CAACJ,QAAD,CAAxB;AAEA,OAAK8C,SAAL,GAAiBhD,WAAW,CAACC,MAAD,EAASC,QAAT,CAA5B;AAEA,OAAK+C,WAAL,GAAmBF,MAAM,CAACG,WAAP,CAAmBjD,MAAnB,CAAnB;AACA,OAAKkD,aAAL,GAAqBJ,MAAM,CAACG,WAAP,CAAmBhD,QAAnB,CAArB;AAEA;AACJ;AACA;;AACI,OAAKR,kBAAL,GAA0B,EAA1B;AACA;AACJ;AACA;;AACI,OAAKE,eAAL,GAAuB,EAAvB;AACA;AACJ;AACA;;AACI,OAAKD,gBAAL,GAAwB,EAAxB;AACA;AACJ;AACA;;AACI,OAAKyD,kBAAL,GAA0B,EAA1B;AACA;AACJ;AACA;;AACI,OAAKC,gBAAL,GAAwB,EAAxB;AACA;AACJ;AACA;;AACI,OAAKC,UAAL,GAAkB,EAAlB;AACA;AACJ;AACA;;AACI,OAAKC,QAAL,GAAgB,EAAhB;AACA;AACJ;AACA;;AACI,OAAKC,aAAL,GAAqB,EAArB;AACA;AACJ;AACA;;AACI,OAAKC,eAAL,GAAuB,EAAvB;;AAEA,OAAKC,gBAAL;;AACA,OAAKC,cAAL;;AACA,OAAKC,aAAL;AACH;;AAEDb,MAAM,CAACc,SAAP,GAAmB;AAEfC,EAAAA,WAAW,EAAEf,MAFE;AAIf;AACAgB,EAAAA,cAAc,EAAE,0BAAY;AACxB,QAAIC,QAAQ,GAAG,EAAf;;AAEA,SAAK,IAAI7B,MAAT,IAAmB,KAAKkB,gBAAxB,EAAyC;AACrC,UAAIY,UAAU,GAAG,KAAKZ,gBAAL,CAAsBlB,MAAtB,CAAjB;AACA6B,MAAAA,QAAQ,CAAC7B,MAAD,CAAR,GAAmB;AACftB,QAAAA,IAAI,EAAEoD,UAAU,CAACpD,IADF;AAEf4B,QAAAA,KAAK,EAAEwB,UAAU,CAACxB,KAAX;AAFQ,OAAnB;AAIH;;AAED,WAAOuB,QAAP;AACH,GAjBc;AAmBfE,EAAAA,YAAY,EAAE,wBAAY;AACtB,SAAKjB,WAAL,GAAmBF,MAAM,CAACG,WAAP,CAAmB,KAAKjD,MAAxB,CAAnB;AACA,SAAKkD,aAAL,GAAqBJ,MAAM,CAACG,WAAP,CAAmB,KAAKhD,QAAxB,CAArB;AACH,GAtBc;AAwBfiE,EAAAA,mBAAmB,EAAE,6BAAUhC,MAAV,EAAkBiC,WAAlB,EAA+BvB,QAA/B,EAAyC;AAC1D;AACA;AACA,QAAInD,kBAAkB,CAACiD,OAAnB,CAA2BE,QAA3B,KAAwC,CAA5C,EAA+C;AAC3C,WAAKnD,kBAAL,CAAwBmD,QAAxB,IAAoC;AAChCV,QAAAA,MAAM,EAAEA,MADwB;AAEhCtB,QAAAA,IAAI,EAAEuD;AAF0B,OAApC;AAIH,KALD,MAMK,IAAIxE,eAAe,CAAC+C,OAAhB,CAAwBE,QAAxB,KAAqC,CAAzC,EAA4C;AAC7C,UAAIwB,WAAW,GAAG,KAAlB;AACA,UAAIC,mBAAmB,GAAGzB,QAA1B;;AACA,UAAIA,QAAQ,CAACzB,KAAT,CAAe,YAAf,CAAJ,EAAkC;AAC9BiD,QAAAA,WAAW,GAAG,IAAd;AACAC,QAAAA,mBAAmB,GAAGzB,QAAQ,CAACtB,KAAT,CAAe,CAAf,EAAkB,CAAC,CAAnB,CAAtB;AACH;;AACD,WAAK3B,eAAL,CAAqBiD,QAArB,IAAiC;AAC7BV,QAAAA,MAAM,EAAEA,MADqB;AAE7BtB,QAAAA,IAAI,EAAEuD,WAFuB;AAG7BC,QAAAA,WAAW,EAAEA,WAHgB;AAI7BC,QAAAA,mBAAmB,EAAEA;AAJQ,OAAjC;AAMH,KAbI,MAcA,IAAI3E,gBAAgB,CAACgD,OAAjB,CAAyBE,QAAzB,KAAsC,CAA1C,EAA6C;AAC9C,WAAKlD,gBAAL,CAAsBkD,QAAtB,IAAkC;AAC9BV,QAAAA,MAAM,EAAEA,MADsB;AAE9BtB,QAAAA,IAAI,EAAEuD;AAFwB,OAAlC;AAIH;AACJ,GArDc;AAuDfG,EAAAA,mBAAmB,EAAE,6BAAUpC,MAAV,EAAkBtB,IAAlB,EAAwBuD,WAAxB,EAAqCI,gBAArC,EAAuDnC,OAAvD,EAAgEoC,gBAAhE,EAAkF;AACnGA,IAAAA,gBAAgB,CAACtC,MAAD,CAAhB,GAA2B;AACvBtB,MAAAA,IAAI,EAAEuD,WADiB;AAEvB3B,MAAAA,KAAK,EAAEJ,OAAO,GAAG5C,uBAAuB,CAAC,OAAD,CAA1B,GAAuC+E,gBAAgB,IAAI/E,uBAAuB,CAACoB,IAAD,CAFzE;AAGvBgC,MAAAA,QAAQ,EAAE;AAHa,KAA3B;AAKH,GA7Dc;AA+Dfc,EAAAA,cAAc,EAAE,0BAAY;AACxB,QAAIK,QAAQ,GAAG,EAAf;AACA,QAAIU,IAAI,GAAG,IAAX;AACA,QAAIC,UAAU,GAAG,QAAjB;AACA,SAAKC,YAAL,GAAoB,EAApB;AAEA,SAAK3B,WAAL,GAAmB,KAAKA,WAAL,CAAiBzC,OAAjB,CAAyBvB,YAAzB,EAAuC4F,cAAvC,CAAnB;AACAF,IAAAA,UAAU,GAAG,UAAb;AACA,SAAKxB,aAAL,GAAqB,KAAKA,aAAL,CAAmB3C,OAAnB,CAA2BvB,YAA3B,EAAyC4F,cAAzC,CAArB;AAEAH,IAAAA,IAAI,CAACtB,kBAAL,GAA0B0B,MAAM,CAACC,IAAP,CAAY,KAAKnF,eAAjB,CAA1B;;AAEA,aAASoF,oBAAT,CAA8BvC,KAA9B,EAAqC;AACjC,aAAOA,KAAK,IAAI,IAAT,GAAgB,YAAY;AAAE,eAAOA,KAAP;AAAe,OAA7C,GAAgD,IAAvD;AACH;;AAED,aAASoC,cAAT,CAAwBI,GAAxB,EAA6BpE,IAA7B,EAAmCqE,OAAnC,EAA4C;AACxC,UAAIC,gBAAgB,GAAGvE,iBAAiB,CAACC,IAAD,EAAOqE,OAAP,CAAxC;AACA,UAAIE,cAAc,GAAG,EAArB;;AACA,WAAK,IAAIjD,MAAT,IAAmBgD,gBAAnB,EAAqC;AAEjC,YAAIE,WAAW,GAAGF,gBAAgB,CAAChD,MAAD,CAAlC;AACA,YAAIU,QAAQ,GAAGwC,WAAW,CAACxC,QAA3B;AACA,YAAIyC,MAAM,GAAGnD,MAAb;AACA,YAAIiC,WAAW,GAAGhF,cAAc,CAACyB,IAAD,CAAhC;AACA,YAAI2D,gBAAgB,GAAGQ,oBAAoB,CAACG,gBAAgB,CAAChD,MAAD,CAAhB,CAAyBM,KAA1B,CAA3C;;AACA,YAAI0C,gBAAgB,CAAChD,MAAD,CAAhB,CAAyBE,OAA7B,EAAsC;AAClCiD,UAAAA,MAAM,IAAI,MAAMH,gBAAgB,CAAChD,MAAD,CAAhB,CAAyBG,SAA/B,GAA2C,GAArD;AACA8B,UAAAA,WAAW,IAAI,GAAf;AACH;;AAEDgB,QAAAA,cAAc,CAAC/D,IAAf,CAAoBiE,MAApB;;AAEAZ,QAAAA,IAAI,CAACE,YAAL,CAAkBvD,IAAlB,CAAuBc,MAAvB;;AAEA,YAAI,CAACkD,WAAW,CAACvC,MAAjB,EAAyB;AACrB,cAAIjC,IAAI,KAAK,WAAT,IAAwBA,IAAI,KAAK,aAArC,EAAoD;AAChD;AACA6D,YAAAA,IAAI,CAACnB,QAAL,CAAcpB,MAAd,IAAwB;AACpBwC,cAAAA,UAAU,EAAEA,UADQ;AAEpB9D,cAAAA,IAAI,EAAEA;AAFc,aAAxB;AAIH;;AAED,cAAIgC,QAAJ,EAAc;AACV;AACA6B,YAAAA,IAAI,CAACP,mBAAL,CAAyBhC,MAAzB,EAAiCiC,WAAjC,EAA8CvB,QAA9C;AACH,WAHD,MAIK;AACD6B,YAAAA,IAAI,CAACH,mBAAL,CACIpC,MADJ,EACYtB,IADZ,EACkBuD,WADlB,EAC+BI,gBAD/B,EAEIW,gBAAgB,CAAChD,MAAD,CAAhB,CAAyBE,OAF7B,EAEsC2B,QAFtC;AAIH;AACJ;AACJ;;AACD,aAAOoB,cAAc,CAACjE,MAAf,GAAwB,CAAxB,GACD,aAAaN,IAAb,GAAoB,GAApB,GAA0BuE,cAAc,CAACG,IAAf,CAAoB,GAApB,CAA1B,GAAqD,KADpD,GAC4D,EADnE;AAEH;;AAED,SAAKlC,gBAAL,GAAwBW,QAAxB;AACH,GA5Hc;AA8HfN,EAAAA,gBAAgB,EAAE,4BAAY;AAC1B,QAAIJ,UAAU,GAAG,EAAjB;AACA,QAAIoB,IAAI,GAAG,IAAX;AACA,SAAKzB,WAAL,GAAmB,KAAKA,WAAL,CAAiBzC,OAAjB,CAAyBtB,cAAzB,EAAyCsG,gBAAzC,CAAnB;;AAEA,aAASA,gBAAT,CAA0BP,GAA1B,EAA+BpE,IAA/B,EAAqCqE,OAArC,EAA8C;AAC1C,UAAIO,kBAAkB,GAAG7E,iBAAiB,CAACC,IAAD,EAAOqE,OAAP,CAA1C;AAEA,UAAIQ,IAAI,GAAG7F,gBAAgB,CAACgB,IAAD,CAAhB,IAA0B,CAArC;AACA,UAAI8E,gBAAgB,GAAG,EAAvB;;AACA,WAAK,IAAIxD,MAAT,IAAmBsD,kBAAnB,EAAuC;AACnC,YAAI5C,QAAQ,GAAG4C,kBAAkB,CAACtD,MAAD,CAAlB,CAA2BU,QAA1C;AACAS,QAAAA,UAAU,CAACnB,MAAD,CAAV,GAAqB;AACjB;AACAtB,UAAAA,IAAI,EAAE,OAFW;AAGjB6E,UAAAA,IAAI,EAAEA,IAHW;AAIjB7C,UAAAA,QAAQ,EAAEA,QAAQ,IAAI;AAJL,SAArB,CAFmC,CAQnC;;AACA,YAAIA,QAAJ,EAAc;AACV,cAAInD,kBAAkB,CAACiD,OAAnB,CAA2BE,QAA3B,IAAuC,CAA3C,EAA8C;AAC1C,kBAAM,IAAI+C,KAAJ,CAAU,sBAAsB/C,QAAtB,GAAiC,GAA3C,CAAN;AACH,WAFD,MAGK;AACD6B,YAAAA,IAAI,CAAChF,kBAAL,CAAwBmD,QAAxB,IAAoC;AAChCV,cAAAA,MAAM,EAAEA,MADwB;AAEhCtB,cAAAA,IAAI,EAAEA;AAF0B,aAApC;AAIH;AACJ;;AACD8E,QAAAA,gBAAgB,CAACtE,IAAjB,CAAsBc,MAAtB;AACH;;AAED,aAAO,eAAetB,IAAf,GAAsB,GAAtB,GAA4B8E,gBAAgB,CAACJ,IAAjB,CAAsB,GAAtB,CAA5B,GAAyD,KAAhE;AACH;;AAED,SAAKjC,UAAL,GAAkBA,UAAlB;AACH,GAnKc;AAqKfM,EAAAA,aAAa,EAAE,yBAAY;AACvB,QAAIc,IAAI,GAAG,IAAX;AACA,QAAIC,UAAU,GAAG,QAAjB;AACA,SAAK1B,WAAL,GAAmB,KAAKA,WAAL,CAAiBzC,OAAjB,CAAyBrB,WAAzB,EAAsC0G,aAAtC,CAAnB;AACAlB,IAAAA,UAAU,GAAG,UAAb;AACA,SAAKxB,aAAL,GAAqB,KAAKA,aAAL,CAAmB3C,OAAnB,CAA2BrB,WAA3B,EAAwC0G,aAAxC,CAArB;;AAEA,aAASA,aAAT,CAAuBZ,GAAvB,EAA4B9C,MAA5B,EAAoCM,KAApC,EAA2C;AACvC,UAAIqD,OAAO,GAAGnB,UAAU,KAAK,QAAf,GAA0BD,IAAI,CAAClB,aAA/B,GAA+CkB,IAAI,CAACjB,eAAlE;;AACA,UAAI,CAACqC,OAAO,CAAC3D,MAAD,CAAZ,EAAsB;AAAE;AACpB,YAAIM,KAAK,KAAK,OAAd,EAAuB;AACnBqD,UAAAA,OAAO,CAAC3D,MAAD,CAAP,GAAkB,KAAlB;AACH,SAFD,MAGK,IAAIM,KAAK,KAAK,MAAd,EAAsB;AACvBqD,UAAAA,OAAO,CAAC3D,MAAD,CAAP,GAAkB,IAAlB;AACH,SAFI,MAGA;AACD2D,UAAAA,OAAO,CAAC3D,MAAD,CAAP,GAAkBM,KAAK,CACnB;AADmB,YAEhBsD,KAAK,CAACnD,UAAU,CAACH,KAAD,CAAX,CAAL,GAA2BA,KAAK,CAACuD,IAAN,EAA3B,GAA0CpD,UAAU,CAACH,KAAD,CAFpC,GAGjB,IAHN;AAIH;AACJ;;AACD,aAAO,EAAP;AACH;AACJ,GA9Lc;;AAgMf;AACJ;AACA;AACA;AACIwD,EAAAA,KAAK,EAAE,iBAAY;AACf,QAAI1F,IAAI,GAAGR,eAAe,CAAC,KAAKiD,SAAN,CAA1B;AACA,QAAIkD,MAAM,GAAG,IAAInD,MAAJ,CAAWxC,IAAI,CAACN,MAAhB,EAAwBM,IAAI,CAACL,QAA7B,CAAb;AACA,WAAOgG,MAAP;AACH;AAxMc,CAAnB;;AA2MA,IAAIpB,MAAM,CAACqB,cAAX,EAA2B;AACvBrB,EAAAA,MAAM,CAACqB,cAAP,CAAsBpD,MAAM,CAACc,SAA7B,EAAwC,UAAxC,EAAoD;AAChDuC,IAAAA,GAAG,EAAE,eAAY;AACb,aAAO,KAAKpD,SAAZ;AACH;AAH+C,GAApD;AAKA8B,EAAAA,MAAM,CAACqB,cAAP,CAAsBpD,MAAM,CAACc,SAA7B,EAAwC,QAAxC,EAAkD;AAC9CuC,IAAAA,GAAG,EAAE,eAAY;AACb,aAAO,KAAKnD,WAAZ;AACH;AAH6C,GAAlD;AAKA6B,EAAAA,MAAM,CAACqB,cAAP,CAAsBpD,MAAM,CAACc,SAA7B,EAAwC,UAAxC,EAAoD;AAChDuC,IAAAA,GAAG,EAAE,eAAY;AACb,aAAO,KAAKjD,aAAZ;AACH;AAH+C,GAApD;AAKA2B,EAAAA,MAAM,CAACqB,cAAP,CAAsBpD,MAAM,CAACc,SAA7B,EAAwC,UAAxC,EAAoD;AAChDuC,IAAAA,GAAG,EAAE,eAAY;AACb,aAAO,KAAKxB,YAAZ;AACH;AAH+C,GAApD;AAKH;;AAED,IAAIyB,WAAW,GAAG,kCAAlB;;AACAtD,MAAM,CAACG,WAAP,GAAqB,UAAUoD,SAAV,EAAqB;AACtCA,EAAAA,SAAS,GAAGA,SAAS,CAAC9F,OAAV,CAAkB6F,WAAlB,EAA+B,UAAUpB,GAAV,EAAesB,YAAf,EAA6BC,UAA7B,EAAyC;AAChF,QAAIvB,GAAG,GAAGlC,MAAM,CAAC0D,MAAP,CAAcD,UAAd,CAAV;;AACA,QAAIvB,GAAJ,EAAS;AACL;AACA,aAAOlC,MAAM,CAACG,WAAP,CAAmB+B,GAAnB,CAAP;AACH,KAHD,MAIK;AACDvE,MAAAA,OAAO,CAACC,KAAR,CAAc,mBAAmB6F,UAAnB,GAAgC,0BAA9C;AACA,aAAO,EAAP;AACH;AACJ,GAVW,CAAZ;AAWA,SAAOF,SAAP;AACH,CAbD;;AAeA,IAAII,WAAW,GAAG,qDAAlB;AAEA;AACA;AACA;AACA;AACA;;AACA3D,MAAM,CAAC,QAAD,CAAN,GAAmB,UAAUuD,SAAV,EAAqB;AACpCA,EAAAA,SAAS,CAAC9F,OAAV,CAAkBkG,WAAlB,EAA+B,UAAUzB,GAAV,EAAe0B,YAAf,EAA6BC,UAA7B,EAAyCrG,IAAzC,EAA+C;AAC1E,QAAIA,IAAI,GAAGA,IAAI,CAACC,OAAL,CAAa,+CAAb,EAA8D,EAA9D,CAAX;;AACA,QAAID,IAAJ,EAAU;AACN,UAAIsG,KAAK,GAAGD,UAAU,CAAC3F,KAAX,CAAiB,GAAjB,CAAZ;AACA,UAAI6F,GAAG,GAAG/D,MAAM,CAACgE,KAAjB;AACA,UAAIvH,CAAC,GAAG,CAAR;AACA,UAAIW,GAAJ;;AACA,aAAOX,CAAC,GAAGqH,KAAK,CAAC1F,MAAN,GAAe,CAA1B,EAA6B;AACzBhB,QAAAA,GAAG,GAAG0G,KAAK,CAACrH,CAAC,EAAF,CAAX;;AACA,YAAI,CAACsH,GAAG,CAAC3G,GAAD,CAAR,EAAe;AACX2G,UAAAA,GAAG,CAAC3G,GAAD,CAAH,GAAW,EAAX;AACH;;AACD2G,QAAAA,GAAG,GAAGA,GAAG,CAAC3G,GAAD,CAAT;AACH;;AACDA,MAAAA,GAAG,GAAG0G,KAAK,CAACrH,CAAD,CAAX;AACAsH,MAAAA,GAAG,CAAC3G,GAAD,CAAH,GAAWI,IAAX;AACH;;AACD,WAAOA,IAAP;AACH,GAlBD;AAmBH,CApBD;AAsBA;AACA;AACA;AACA;AACA;AACA;;;AACAwC,MAAM,CAACgE,KAAP,GAAe,EAAf;AAEA;AACA;AACA;AACA;AACA;;AACAhE,MAAM,CAAC0D,MAAP,GAAgB,UAAUO,IAAV,EAAgB;AAC5B,MAAIH,KAAK,GAAGG,IAAI,CAAC/F,KAAL,CAAW,GAAX,CAAZ;AACA,MAAI6F,GAAG,GAAG/D,MAAM,CAACgE,KAAjB;AACA,MAAIvH,CAAC,GAAG,CAAR;;AACA,SAAOsH,GAAG,IAAItH,CAAC,GAAGqH,KAAK,CAAC1F,MAAxB,EAAgC;AAC5B,QAAIhB,GAAG,GAAG0G,KAAK,CAACrH,CAAC,EAAF,CAAf;AACAsH,IAAAA,GAAG,GAAGA,GAAG,CAAC3G,GAAD,CAAT;AACH;;AACD,MAAI,OAAO2G,GAAP,KAAe,QAAnB,EAA6B;AACzB;AACApG,IAAAA,OAAO,CAACC,KAAR,CAAc,aAAaqG,IAAb,GAAoB,0BAAlC;AACA,WAAO,EAAP;AACH;;AACD,SAAOF,GAAP;AACH,CAdD;;AAgBA,eAAe/D,MAAf","sourcesContent":["/**\n * Mainly do the parse and compile of shader string\n * Support shader code chunk import and export\n * Support shader semantics\n * http://www.nvidia.com/object/using_sas.html\n * https://github.com/KhronosGroup/collada2json/issues/45\n */\nimport util from './core/util';\nimport vendor from './core/vendor';\n\nvar uniformRegex = /uniform\\s+(bool|float|int|vec2|vec3|vec4|ivec2|ivec3|ivec4|mat2|mat3|mat4|sampler2D|samplerCube)\\s+([\\s\\S]*?);/g;\nvar attributeRegex = /attribute\\s+(float|int|vec2|vec3|vec4)\\s+([\\s\\S]*?);/g;\n// Only parse number define.\nvar defineRegex = /#define\\s+(\\w+)?(\\s+[\\d-.]+)?\\s*;?\\s*\\n/g;\n\nvar uniformTypeMap = {\n    'bool': '1i',\n    'int': '1i',\n    'sampler2D': 't',\n    'samplerCube': 't',\n    'float': '1f',\n    'vec2': '2f',\n    'vec3': '3f',\n    'vec4': '4f',\n    'ivec2': '2i',\n    'ivec3': '3i',\n    'ivec4': '4i',\n    'mat2': 'm2',\n    'mat3': 'm3',\n    'mat4': 'm4'\n};\n\nfunction createZeroArray(len) {\n    var arr = [];\n    for (var i = 0; i < len; i++) {\n        arr[i] = 0;\n    }\n    return arr;\n}\n\nvar uniformValueConstructor = {\n    'bool': function () { return true; },\n    'int': function () { return 0; },\n    'float': function () { return 0; },\n    'sampler2D': function () { return null; },\n    'samplerCube': function () { return null; },\n\n    'vec2': function () { return createZeroArray(2); },\n    'vec3': function () { return createZeroArray(3); },\n    'vec4': function () { return createZeroArray(4); },\n\n    'ivec2': function () { return createZeroArray(2); },\n    'ivec3': function () { return createZeroArray(3); },\n    'ivec4': function () { return createZeroArray(4); },\n\n    'mat2': function () { return createZeroArray(4); },\n    'mat3': function () { return createZeroArray(9); },\n    'mat4': function () { return createZeroArray(16); },\n\n    'array': function () { return []; }\n};\n\nvar attributeSemantics = [\n    'POSITION',\n    'NORMAL',\n    'BINORMAL',\n    'TANGENT',\n    'TEXCOORD',\n    'TEXCOORD_0',\n    'TEXCOORD_1',\n    'COLOR',\n    // Skinning\n    // https://github.com/KhronosGroup/glTF/blob/master/specification/README.md#semantics\n    'JOINT',\n    'WEIGHT'\n];\nvar uniformSemantics = [\n    'SKIN_MATRIX',\n    // Information about viewport\n    'VIEWPORT_SIZE',\n    'VIEWPORT',\n    'DEVICEPIXELRATIO',\n    // Window size for window relative coordinate\n    // https://www.opengl.org/sdk/docs/man/html/gl_FragCoord.xhtml\n    'WINDOW_SIZE',\n    // Infomation about camera\n    'NEAR',\n    'FAR',\n    // Time\n    'TIME'\n];\nvar matrixSemantics = [\n    'WORLD',\n    'VIEW',\n    'PROJECTION',\n    'WORLDVIEW',\n    'VIEWPROJECTION',\n    'WORLDVIEWPROJECTION',\n    'WORLDINVERSE',\n    'VIEWINVERSE',\n    'PROJECTIONINVERSE',\n    'WORLDVIEWINVERSE',\n    'VIEWPROJECTIONINVERSE',\n    'WORLDVIEWPROJECTIONINVERSE',\n    'WORLDTRANSPOSE',\n    'VIEWTRANSPOSE',\n    'PROJECTIONTRANSPOSE',\n    'WORLDVIEWTRANSPOSE',\n    'VIEWPROJECTIONTRANSPOSE',\n    'WORLDVIEWPROJECTIONTRANSPOSE',\n    'WORLDINVERSETRANSPOSE',\n    'VIEWINVERSETRANSPOSE',\n    'PROJECTIONINVERSETRANSPOSE',\n    'WORLDVIEWINVERSETRANSPOSE',\n    'VIEWPROJECTIONINVERSETRANSPOSE',\n    'WORLDVIEWPROJECTIONINVERSETRANSPOSE'\n];\n\nvar attributeSizeMap = {\n    // WebGL does not support integer attributes\n    'vec4': 4,\n    'vec3': 3,\n    'vec2': 2,\n    'float': 1\n};\n\n\nvar shaderIDCache = {};\nvar shaderCodeCache = {};\n\nfunction getShaderID(vertex, fragment) {\n    var key = 'vertex:' + vertex + 'fragment:' + fragment;\n    if (shaderIDCache[key]) {\n        return shaderIDCache[key];\n    }\n    var id = util.genGUID();\n    shaderIDCache[key] = id;\n\n    shaderCodeCache[id] = {\n        vertex: vertex,\n        fragment: fragment\n    };\n\n    return id;\n}\n\nfunction removeComment(code) {\n    return code.replace(/[ \\t]*\\/\\/.*\\n/g, '' )   // remove //\n        .replace(/[ \\t]*\\/\\*[\\s\\S]*?\\*\\//g, '' ); // remove /* */\n}\n\nfunction logSyntaxError() {\n    console.error('Wrong uniform/attributes syntax');\n}\n\nfunction parseDeclarations(type, line) {\n    var speratorsRegexp = /[,=\\(\\):]/;\n    var tokens = line\n        // Convert `symbol: [1,2,3]` to `symbol: vec3(1,2,3)`\n        .replace(/:\\s*\\[\\s*(.*)\\s*\\]/g, '=' + type + '($1)')\n        .replace(/\\s+/g, '')\n        .split(/(?=[,=\\(\\):])/g);\n\n    var newTokens = [];\n    for (var i = 0; i < tokens.length; i++) {\n        if (tokens[i].match(speratorsRegexp)) {\n            newTokens.push(\n                tokens[i].charAt(0),\n                tokens[i].slice(1)\n            );\n        }\n        else {\n            newTokens.push(tokens[i]);\n        }\n    }\n    tokens = newTokens;\n\n    var TYPE_SYMBOL = 0;\n    var TYPE_ASSIGN = 1;\n    var TYPE_VEC = 2;\n    var TYPE_ARR = 3;\n    var TYPE_SEMANTIC = 4;\n    var TYPE_NORMAL = 5;\n\n    var opType = TYPE_SYMBOL;\n    var declarations = {};\n    var declarationValue = null;\n    var currentDeclaration;\n\n    addSymbol(tokens[0]);\n\n    function addSymbol(symbol) {\n        if (!symbol) {\n            logSyntaxError();\n        }\n        var arrResult = symbol.match(/\\[(.*?)\\]/);\n        currentDeclaration = symbol.replace(/\\[(.*?)\\]/, '');\n        declarations[currentDeclaration] = {};\n        if (arrResult) {\n            declarations[currentDeclaration].isArray = true;\n            declarations[currentDeclaration].arraySize = arrResult[1];\n        }\n    }\n\n    for (var i = 1; i < tokens.length; i++) {\n        var token = tokens[i];\n        if (!token) {   // Empty token;\n            continue;\n        }\n        if (token === '=') {\n            if (opType !== TYPE_SYMBOL\n            && opType !== TYPE_ARR) {\n                logSyntaxError();\n                break;\n            }\n            opType = TYPE_ASSIGN;\n\n            continue;\n        }\n        else if (token === ':') {\n            opType = TYPE_SEMANTIC;\n\n            continue;\n        }\n        else if (token === ',') {\n            if (opType === TYPE_VEC) {\n                if (!(declarationValue instanceof Array)) {\n                    logSyntaxError();\n                    break;\n                }\n                declarationValue.push(+tokens[++i]);\n            }\n            else {\n                opType = TYPE_NORMAL;\n            }\n\n            continue;\n        }\n        else if (token === ')') {\n            declarations[currentDeclaration].value = new vendor.Float32Array(declarationValue);\n            declarationValue = null;\n            opType = TYPE_NORMAL;\n            continue;\n        }\n        else if (token === '(') {\n            if (opType !== TYPE_VEC) {\n                logSyntaxError();\n                break;\n            }\n            if (!(declarationValue instanceof Array)) {\n                logSyntaxError();\n                break;\n            }\n            declarationValue.push(+tokens[++i]);\n            continue;\n        }\n        else if (token.indexOf('vec') >= 0) {\n            if (opType !== TYPE_ASSIGN\n            // Compatitable with old syntax `symbol: [1,2,3]`\n            && opType !== TYPE_SEMANTIC) {\n                logSyntaxError();\n                break;\n            }\n            opType = TYPE_VEC;\n            declarationValue = [];\n            continue;\n        }\n        else if (opType === TYPE_ASSIGN) {\n            if (type === 'bool') {\n                declarations[currentDeclaration].value = token === 'true';\n            }\n            else {\n                declarations[currentDeclaration].value = parseFloat(token);\n            }\n            declarationValue = null;\n            continue;\n        }\n        else if (opType === TYPE_SEMANTIC) {\n            var semantic = token;\n            if (attributeSemantics.indexOf(semantic) >= 0\n                || uniformSemantics.indexOf(semantic) >= 0\n                || matrixSemantics.indexOf(semantic) >= 0\n            ) {\n                declarations[currentDeclaration].semantic = semantic;\n            }\n            else if (semantic === 'ignore' || semantic === 'unconfigurable') {\n                declarations[currentDeclaration].ignore = true;\n            }\n            else {\n                // Try to parse as a default tvalue.\n                if (type === 'bool') {\n                    declarations[currentDeclaration].value = semantic === 'true';\n                }\n                else {\n                    declarations[currentDeclaration].value = parseFloat(semantic);\n                }\n            }\n            continue;\n        }\n\n        // treat as symbol.\n        addSymbol(token);\n        opType = TYPE_SYMBOL;\n    }\n\n    return declarations;\n}\n\n\n/**\n * @constructor\n * @extends clay.core.Base\n * @alias clay.Shader\n * @param {string} vertex\n * @param {string} fragment\n * @example\n * // Create a phong shader\n * var shader = new clay.Shader(\n *      clay.Shader.source('clay.standard.vertex'),\n *      clay.Shader.source('clay.standard.fragment')\n * );\n */\nfunction Shader(vertex, fragment) {\n    // First argument can be { vertex, fragment }\n    if (typeof vertex === 'object') {\n        fragment = vertex.fragment;\n        vertex = vertex.vertex;\n    }\n\n    vertex = removeComment(vertex);\n    fragment = removeComment(fragment);\n\n    this._shaderID = getShaderID(vertex, fragment);\n\n    this._vertexCode = Shader.parseImport(vertex);\n    this._fragmentCode = Shader.parseImport(fragment);\n\n    /**\n     * @readOnly\n     */\n    this.attributeSemantics = {};\n    /**\n     * @readOnly\n     */\n    this.matrixSemantics = {};\n    /**\n     * @readOnly\n     */\n    this.uniformSemantics = {};\n    /**\n     * @readOnly\n     */\n    this.matrixSemanticKeys = [];\n    /**\n     * @readOnly\n     */\n    this.uniformTemplates = {};\n    /**\n     * @readOnly\n     */\n    this.attributes = {};\n    /**\n     * @readOnly\n     */\n    this.textures = {};\n    /**\n     * @readOnly\n     */\n    this.vertexDefines = {};\n    /**\n     * @readOnly\n     */\n    this.fragmentDefines = {};\n\n    this._parseAttributes();\n    this._parseUniforms();\n    this._parseDefines();\n}\n\nShader.prototype = {\n\n    constructor: Shader,\n\n    // Create a new uniform instance for material\n    createUniforms: function () {\n        var uniforms = {};\n\n        for (var symbol in this.uniformTemplates){\n            var uniformTpl = this.uniformTemplates[symbol];\n            uniforms[symbol] = {\n                type: uniformTpl.type,\n                value: uniformTpl.value()\n            };\n        }\n\n        return uniforms;\n    },\n\n    _parseImport: function () {\n        this._vertexCode = Shader.parseImport(this.vertex);\n        this._fragmentCode = Shader.parseImport(this.fragment);\n    },\n\n    _addSemanticUniform: function (symbol, uniformType, semantic) {\n        // This case is only for SKIN_MATRIX\n        // TODO\n        if (attributeSemantics.indexOf(semantic) >= 0) {\n            this.attributeSemantics[semantic] = {\n                symbol: symbol,\n                type: uniformType\n            };\n        }\n        else if (matrixSemantics.indexOf(semantic) >= 0) {\n            var isTranspose = false;\n            var semanticNoTranspose = semantic;\n            if (semantic.match(/TRANSPOSE$/)) {\n                isTranspose = true;\n                semanticNoTranspose = semantic.slice(0, -9);\n            }\n            this.matrixSemantics[semantic] = {\n                symbol: symbol,\n                type: uniformType,\n                isTranspose: isTranspose,\n                semanticNoTranspose: semanticNoTranspose\n            };\n        }\n        else if (uniformSemantics.indexOf(semantic) >= 0) {\n            this.uniformSemantics[semantic] = {\n                symbol: symbol,\n                type: uniformType\n            };\n        }\n    },\n\n    _addMaterialUniform: function (symbol, type, uniformType, defaultValueFunc, isArray, materialUniforms) {\n        materialUniforms[symbol] = {\n            type: uniformType,\n            value: isArray ? uniformValueConstructor['array'] : (defaultValueFunc || uniformValueConstructor[type]),\n            semantic: null\n        };\n    },\n\n    _parseUniforms: function () {\n        var uniforms = {};\n        var self = this;\n        var shaderType = 'vertex';\n        this._uniformList = [];\n\n        this._vertexCode = this._vertexCode.replace(uniformRegex, _uniformParser);\n        shaderType = 'fragment';\n        this._fragmentCode = this._fragmentCode.replace(uniformRegex, _uniformParser);\n\n        self.matrixSemanticKeys = Object.keys(this.matrixSemantics);\n\n        function makeDefaultValueFunc(value) {\n            return value != null ? function () { return value; } : null;\n        }\n\n        function _uniformParser(str, type, content) {\n            var declaredUniforms = parseDeclarations(type, content);\n            var uniformMainStr = [];\n            for (var symbol in declaredUniforms) {\n\n                var uniformInfo = declaredUniforms[symbol];\n                var semantic = uniformInfo.semantic;\n                var tmpStr = symbol;\n                var uniformType = uniformTypeMap[type];\n                var defaultValueFunc = makeDefaultValueFunc(declaredUniforms[symbol].value);\n                if (declaredUniforms[symbol].isArray) {\n                    tmpStr += '[' + declaredUniforms[symbol].arraySize + ']';\n                    uniformType += 'v';\n                }\n\n                uniformMainStr.push(tmpStr);\n\n                self._uniformList.push(symbol);\n\n                if (!uniformInfo.ignore) {\n                    if (type === 'sampler2D' || type === 'samplerCube') {\n                        // Texture is default disabled\n                        self.textures[symbol] = {\n                            shaderType: shaderType,\n                            type: type\n                        };\n                    }\n\n                    if (semantic) {\n                        // TODO Should not declare multiple symbols if have semantic.\n                        self._addSemanticUniform(symbol, uniformType, semantic);\n                    }\n                    else {\n                        self._addMaterialUniform(\n                            symbol, type, uniformType, defaultValueFunc,\n                            declaredUniforms[symbol].isArray, uniforms\n                        );\n                    }\n                }\n            }\n            return uniformMainStr.length > 0\n                ? 'uniform ' + type + ' ' + uniformMainStr.join(',') + ';\\n' : '';\n        }\n\n        this.uniformTemplates = uniforms;\n    },\n\n    _parseAttributes: function () {\n        var attributes = {};\n        var self = this;\n        this._vertexCode = this._vertexCode.replace(attributeRegex, _attributeParser);\n\n        function _attributeParser(str, type, content) {\n            var declaredAttributes = parseDeclarations(type, content);\n\n            var size = attributeSizeMap[type] || 1;\n            var attributeMainStr = [];\n            for (var symbol in declaredAttributes) {\n                var semantic = declaredAttributes[symbol].semantic;\n                attributes[symbol] = {\n                    // TODO Can only be float\n                    type: 'float',\n                    size: size,\n                    semantic: semantic || null\n                };\n                // TODO Should not declare multiple symbols if have semantic.\n                if (semantic) {\n                    if (attributeSemantics.indexOf(semantic) < 0) {\n                        throw new Error('Unkown semantic \"' + semantic + '\"');\n                    }\n                    else {\n                        self.attributeSemantics[semantic] = {\n                            symbol: symbol,\n                            type: type\n                        };\n                    }\n                }\n                attributeMainStr.push(symbol);\n            }\n\n            return 'attribute ' + type + ' ' + attributeMainStr.join(',') + ';\\n';\n        }\n\n        this.attributes = attributes;\n    },\n\n    _parseDefines: function () {\n        var self = this;\n        var shaderType = 'vertex';\n        this._vertexCode = this._vertexCode.replace(defineRegex, _defineParser);\n        shaderType = 'fragment';\n        this._fragmentCode = this._fragmentCode.replace(defineRegex, _defineParser);\n\n        function _defineParser(str, symbol, value) {\n            var defines = shaderType === 'vertex' ? self.vertexDefines : self.fragmentDefines;\n            if (!defines[symbol]) { // Haven't been defined by user\n                if (value === 'false') {\n                    defines[symbol] = false;\n                }\n                else if (value === 'true') {\n                    defines[symbol] = true;\n                }\n                else {\n                    defines[symbol] = value\n                        // If can parse to float\n                        ? (isNaN(parseFloat(value)) ? value.trim() : parseFloat(value))\n                        : null;\n                }\n            }\n            return '';\n        }\n    },\n\n    /**\n     * Clone a new shader\n     * @return {clay.Shader}\n     */\n    clone: function () {\n        var code = shaderCodeCache[this._shaderID];\n        var shader = new Shader(code.vertex, code.fragment);\n        return shader;\n    }\n};\n\nif (Object.defineProperty) {\n    Object.defineProperty(Shader.prototype, 'shaderID', {\n        get: function () {\n            return this._shaderID;\n        }\n    });\n    Object.defineProperty(Shader.prototype, 'vertex', {\n        get: function () {\n            return this._vertexCode;\n        }\n    });\n    Object.defineProperty(Shader.prototype, 'fragment', {\n        get: function () {\n            return this._fragmentCode;\n        }\n    });\n    Object.defineProperty(Shader.prototype, 'uniforms', {\n        get: function () {\n            return this._uniformList;\n        }\n    });\n}\n\nvar importRegex = /(@import)\\s*([0-9a-zA-Z_\\-\\.]*)/g;\nShader.parseImport = function (shaderStr) {\n    shaderStr = shaderStr.replace(importRegex, function (str, importSymbol, importName) {\n        var str = Shader.source(importName);\n        if (str) {\n            // Recursively parse\n            return Shader.parseImport(str);\n        }\n        else {\n            console.error('Shader chunk \"' + importName + '\" not existed in library');\n            return '';\n        }\n    });\n    return shaderStr;\n};\n\nvar exportRegex = /(@export)\\s*([0-9a-zA-Z_\\-\\.]*)\\s*\\n([\\s\\S]*?)@end/g;\n\n/**\n * Import shader source\n * @param  {string} shaderStr\n * @memberOf clay.Shader\n */\nShader['import'] = function (shaderStr) {\n    shaderStr.replace(exportRegex, function (str, exportSymbol, exportName, code) {\n        var code = code.replace(/(^[\\s\\t\\xa0\\u3000]+)|([\\u3000\\xa0\\s\\t]+\\x24)/g, '');\n        if (code) {\n            var parts = exportName.split('.');\n            var obj = Shader.codes;\n            var i = 0;\n            var key;\n            while (i < parts.length - 1) {\n                key = parts[i++];\n                if (!obj[key]) {\n                    obj[key] = {};\n                }\n                obj = obj[key];\n            }\n            key = parts[i];\n            obj[key] = code;\n        }\n        return code;\n    });\n};\n\n/**\n * Library to store all the loaded shader codes\n * @type {Object}\n * @readOnly\n * @memberOf clay.Shader\n */\nShader.codes = {};\n\n/**\n * Get shader source\n * @param  {string} name\n * @return {string}\n */\nShader.source = function (name) {\n    var parts = name.split('.');\n    var obj = Shader.codes;\n    var i = 0;\n    while (obj && i < parts.length) {\n        var key = parts[i++];\n        obj = obj[key];\n    }\n    if (typeof obj !== 'string') {\n        // FIXME Use default instead\n        console.error('Shader \"' + name + '\" not existed in library');\n        return '';\n    }\n    return obj;\n};\n\nexport default Shader;\n"]},"metadata":{},"sourceType":"module"}