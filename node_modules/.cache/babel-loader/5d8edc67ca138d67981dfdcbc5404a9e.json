{"ast":null,"code":"import \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.typed-array.float32-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport * as echarts from 'echarts/lib/echarts';\nimport graphicGL from '../../util/graphicGL';\nimport OrbitControl from '../../util/OrbitControl';\nimport SceneHelper from '../common/SceneHelper';\nimport sunCalc from '../../util/sunCalc';\nimport retrieve from '../../util/retrieve';\nimport utilShaderCode from 'claygl/src/shader/source/util.glsl.js';\nimport atmosphereShaderCode from './atmosphere.glsl.js';\ngraphicGL.Shader['import'](utilShaderCode);\ngraphicGL.Shader['import'](atmosphereShaderCode);\nexport default echarts.ComponentView.extend({\n  type: 'globe',\n  __ecgl__: true,\n  _displacementScale: 0,\n  init: function init(ecModel, api) {\n    this.groupGL = new graphicGL.Node();\n    /**\n     * @type {clay.geometry.Sphere}\n     * @private\n     */\n\n    this._sphereGeometry = new graphicGL.SphereGeometry({\n      widthSegments: 200,\n      heightSegments: 100,\n      dynamic: true\n    });\n    this._overlayGeometry = new graphicGL.SphereGeometry({\n      widthSegments: 80,\n      heightSegments: 40\n    });\n    /**\n     * @type {clay.geometry.Plane}\n     */\n\n    this._planeGeometry = new graphicGL.PlaneGeometry();\n    /**\n     * @type {clay.geometry.Mesh}\n     */\n\n    this._earthMesh = new graphicGL.Mesh({\n      renderNormal: true\n    });\n    /**\n     * @type {clay.geometry.Mesh}\n     */\n\n    this._atmosphereMesh = new graphicGL.Mesh();\n    this._atmosphereGeometry = new graphicGL.SphereGeometry({\n      widthSegments: 80,\n      heightSegments: 40\n    });\n    this._atmosphereMaterial = new graphicGL.Material({\n      shader: new graphicGL.Shader(graphicGL.Shader.source('ecgl.atmosphere.vertex'), graphicGL.Shader.source('ecgl.atmosphere.fragment')),\n      transparent: true\n    });\n    this._atmosphereMesh.geometry = this._atmosphereGeometry;\n    this._atmosphereMesh.material = this._atmosphereMaterial;\n    this._atmosphereMesh.frontFace = graphicGL.Mesh.CW;\n    this._lightRoot = new graphicGL.Node();\n    this._sceneHelper = new SceneHelper();\n\n    this._sceneHelper.initLight(this._lightRoot);\n\n    this.groupGL.add(this._atmosphereMesh);\n    this.groupGL.add(this._earthMesh);\n    this._control = new OrbitControl({\n      zr: api.getZr()\n    });\n\n    this._control.init();\n\n    this._layerMeshes = {};\n  },\n  render: function render(globeModel, ecModel, api) {\n    var coordSys = globeModel.coordinateSystem;\n    var shading = globeModel.get('shading'); // Always have light.\n\n    coordSys.viewGL.add(this._lightRoot);\n\n    if (globeModel.get('show')) {\n      // Add self to scene;\n      coordSys.viewGL.add(this.groupGL);\n    } else {\n      coordSys.viewGL.remove(this.groupGL);\n    }\n\n    this._sceneHelper.setScene(coordSys.viewGL.scene); // Set post effect\n\n\n    coordSys.viewGL.setPostEffect(globeModel.getModel('postEffect'), api);\n    coordSys.viewGL.setTemporalSuperSampling(globeModel.getModel('temporalSuperSampling'));\n    var earthMesh = this._earthMesh;\n    earthMesh.geometry = this._sphereGeometry;\n    var shadingPrefix = 'ecgl.' + shading;\n\n    if (!earthMesh.material || earthMesh.material.shader.name !== shadingPrefix) {\n      earthMesh.material = graphicGL.createMaterial(shadingPrefix);\n    }\n\n    graphicGL.setMaterialFromModel(shading, earthMesh.material, globeModel, api);\n    ['roughnessMap', 'metalnessMap', 'detailMap', 'normalMap'].forEach(function (texName) {\n      var texture = earthMesh.material.get(texName);\n\n      if (texture) {\n        texture.flipY = false;\n      }\n    });\n    earthMesh.material.set('color', graphicGL.parseColor(globeModel.get('baseColor'))); // shrink a little\n\n    var scale = coordSys.radius * 0.99;\n    earthMesh.scale.set(scale, scale, scale);\n\n    if (globeModel.get('atmosphere.show')) {\n      earthMesh.material.define('both', 'ATMOSPHERE_ENABLED');\n      this._atmosphereMesh.invisible = false;\n\n      this._atmosphereMaterial.setUniforms({\n        glowPower: globeModel.get('atmosphere.glowPower') || 6.0,\n        glowColor: globeModel.get('atmosphere.color') || '#ffffff'\n      });\n\n      earthMesh.material.setUniforms({\n        glowPower: globeModel.get('atmosphere.innerGlowPower') || 2.0,\n        glowColor: globeModel.get('atmosphere.color') || '#ffffff'\n      });\n      var offset = globeModel.get('atmosphere.offset') || 5;\n\n      this._atmosphereMesh.scale.set(scale + offset, scale + offset, scale + offset);\n    } else {\n      earthMesh.material.undefine('both', 'ATMOSPHERE_ENABLED');\n      this._atmosphereMesh.invisible = true;\n    }\n\n    var diffuseTexture = earthMesh.material.setTextureImage('diffuseMap', globeModel.get('baseTexture'), api, {\n      flipY: false,\n      anisotropic: 8\n    });\n\n    if (diffuseTexture && diffuseTexture.surface) {\n      diffuseTexture.surface.attachToMesh(earthMesh);\n    } // Update bump map\n\n\n    var bumpTexture = earthMesh.material.setTextureImage('bumpMap', globeModel.get('heightTexture'), api, {\n      flipY: false,\n      anisotropic: 8\n    });\n\n    if (bumpTexture && bumpTexture.surface) {\n      bumpTexture.surface.attachToMesh(earthMesh);\n    }\n\n    earthMesh.material[globeModel.get('postEffect.enable') ? 'define' : 'undefine']('fragment', 'SRGB_DECODE');\n\n    this._updateLight(globeModel, api);\n\n    this._displaceVertices(globeModel, api);\n\n    this._updateViewControl(globeModel, api);\n\n    this._updateLayers(globeModel, api);\n  },\n  afterRender: function afterRender(globeModel, ecModel, api, layerGL) {\n    // Create ambient cubemap after render because we need to know the renderer.\n    // TODO\n    var renderer = layerGL.renderer;\n\n    this._sceneHelper.updateAmbientCubemap(renderer, globeModel, api);\n\n    this._sceneHelper.updateSkybox(renderer, globeModel, api);\n  },\n  _updateLayers: function _updateLayers(globeModel, api) {\n    var coordSys = globeModel.coordinateSystem;\n    var layers = globeModel.get('layers');\n    var lastDistance = coordSys.radius;\n    var layerDiffuseTextures = [];\n    var layerDiffuseIntensity = [];\n    var layerEmissiveTextures = [];\n    var layerEmissionIntensity = [];\n    echarts.util.each(layers, function (layerOption) {\n      var layerModel = new echarts.Model(layerOption);\n      var layerType = layerModel.get('type');\n      var texture = graphicGL.loadTexture(layerModel.get('texture'), api, {\n        flipY: false,\n        anisotropic: 8\n      });\n\n      if (texture.surface) {\n        texture.surface.attachToMesh(this._earthMesh);\n      }\n\n      if (layerType === 'blend') {\n        var blendTo = layerModel.get('blendTo');\n        var intensity = retrieve.firstNotNull(layerModel.get('intensity'), 1.0);\n\n        if (blendTo === 'emission') {\n          layerEmissiveTextures.push(texture);\n          layerEmissionIntensity.push(intensity);\n        } else {\n          // Default is albedo\n          layerDiffuseTextures.push(texture);\n          layerDiffuseIntensity.push(intensity);\n        }\n      } else {\n        // Default use overlay\n        var id = layerModel.get('id');\n        var overlayMesh = this._layerMeshes[id];\n\n        if (!overlayMesh) {\n          overlayMesh = this._layerMeshes[id] = new graphicGL.Mesh({\n            geometry: this._overlayGeometry,\n            castShadow: false,\n            ignorePicking: true\n          });\n        }\n\n        var shading = layerModel.get('shading');\n\n        if (shading === 'lambert') {\n          overlayMesh.material = overlayMesh.__lambertMaterial || new graphicGL.Material({\n            autoUpdateTextureStatus: false,\n            shader: graphicGL.createShader('ecgl.lambert'),\n            transparent: true,\n            depthMask: false\n          });\n          overlayMesh.__lambertMaterial = overlayMesh.material;\n        } else {\n          // color\n          overlayMesh.material = overlayMesh.__colorMaterial || new graphicGL.Material({\n            autoUpdateTextureStatus: false,\n            shader: graphicGL.createShader('ecgl.color'),\n            transparent: true,\n            depthMask: false\n          });\n          overlayMesh.__colorMaterial = overlayMesh.material;\n        } // overlay should be transparent if texture is not loaded yet.\n\n\n        overlayMesh.material.enableTexture('diffuseMap');\n        var distance = layerModel.get('distance'); // Based on distance of last layer\n\n        var radius = lastDistance + (distance == null ? coordSys.radius / 100 : distance);\n        overlayMesh.scale.set(radius, radius, radius);\n        lastDistance = radius; // FIXME Exists blink.\n\n        var blankTexture = this._blankTexture || (this._blankTexture = graphicGL.createBlankTexture('rgba(255, 255, 255, 0)'));\n        overlayMesh.material.set('diffuseMap', blankTexture);\n        graphicGL.loadTexture(layerModel.get('texture'), api, {\n          flipY: false,\n          anisotropic: 8\n        }, function (texture) {\n          if (texture.surface) {\n            texture.surface.attachToMesh(overlayMesh);\n          }\n\n          overlayMesh.material.set('diffuseMap', texture);\n          api.getZr().refresh();\n        });\n        layerModel.get('show') ? this.groupGL.add(overlayMesh) : this.groupGL.remove(overlayMesh);\n      }\n    }, this);\n    var earthMaterial = this._earthMesh.material;\n    earthMaterial.define('fragment', 'LAYER_DIFFUSEMAP_COUNT', layerDiffuseTextures.length);\n    earthMaterial.define('fragment', 'LAYER_EMISSIVEMAP_COUNT', layerEmissiveTextures.length);\n    earthMaterial.set('layerDiffuseMap', layerDiffuseTextures);\n    earthMaterial.set('layerDiffuseIntensity', layerDiffuseIntensity);\n    earthMaterial.set('layerEmissiveMap', layerEmissiveTextures);\n    earthMaterial.set('layerEmissionIntensity', layerEmissionIntensity);\n    var debugWireframeModel = globeModel.getModel('debug.wireframe');\n\n    if (debugWireframeModel.get('show')) {\n      earthMaterial.define('both', 'WIREFRAME_TRIANGLE');\n      var color = graphicGL.parseColor(debugWireframeModel.get('lineStyle.color') || 'rgba(0,0,0,0.5)');\n      var width = retrieve.firstNotNull(debugWireframeModel.get('lineStyle.width'), 1);\n      earthMaterial.set('wireframeLineWidth', width);\n      earthMaterial.set('wireframeLineColor', color);\n    } else {\n      earthMaterial.undefine('both', 'WIREFRAME_TRIANGLE');\n    }\n  },\n  _updateViewControl: function _updateViewControl(globeModel, api) {\n    var coordSys = globeModel.coordinateSystem; // Update camera\n\n    var viewControlModel = globeModel.getModel('viewControl');\n    var camera = coordSys.viewGL.camera;\n    var self = this;\n\n    function makeAction() {\n      return {\n        type: 'globeChangeCamera',\n        alpha: control.getAlpha(),\n        beta: control.getBeta(),\n        distance: control.getDistance() - coordSys.radius,\n        center: control.getCenter(),\n        from: self.uid,\n        globeId: globeModel.id\n      };\n    } // Update control\n\n\n    var control = this._control;\n    control.setViewGL(coordSys.viewGL);\n    var coord = viewControlModel.get('targetCoord');\n    var alpha, beta;\n\n    if (coord != null) {\n      beta = coord[0] + 90;\n      alpha = coord[1];\n    }\n\n    control.setFromViewControlModel(viewControlModel, {\n      baseDistance: coordSys.radius,\n      alpha: alpha,\n      beta: beta\n    });\n    control.off('update');\n    control.on('update', function () {\n      api.dispatchAction(makeAction());\n    });\n  },\n  _displaceVertices: function _displaceVertices(globeModel, api) {\n    var displacementQuality = globeModel.get('displacementQuality');\n    var showDebugWireframe = globeModel.get('debug.wireframe.show');\n    var globe = globeModel.coordinateSystem;\n\n    if (!globeModel.isDisplacementChanged() && displacementQuality === this._displacementQuality && showDebugWireframe === this._showDebugWireframe) {\n      return;\n    }\n\n    this._displacementQuality = displacementQuality;\n    this._showDebugWireframe = showDebugWireframe;\n    var geometry = this._sphereGeometry;\n    var widthSegments = {\n      low: 100,\n      medium: 200,\n      high: 400,\n      ultra: 800\n    }[displacementQuality] || 200;\n    var heightSegments = widthSegments / 2;\n\n    if (geometry.widthSegments !== widthSegments || showDebugWireframe) {\n      geometry.widthSegments = widthSegments;\n      geometry.heightSegments = heightSegments;\n      geometry.build();\n    }\n\n    this._doDisplaceVertices(geometry, globe);\n\n    if (showDebugWireframe) {\n      geometry.generateBarycentric();\n    }\n  },\n  _doDisplaceVertices: function _doDisplaceVertices(geometry, globe) {\n    var positionArr = geometry.attributes.position.value;\n    var uvArr = geometry.attributes.texcoord0.value;\n    var originalPositionArr = geometry.__originalPosition;\n\n    if (!originalPositionArr || originalPositionArr.length !== positionArr.length) {\n      originalPositionArr = new Float32Array(positionArr.length);\n      originalPositionArr.set(positionArr);\n      geometry.__originalPosition = originalPositionArr;\n    }\n\n    var width = globe.displacementWidth;\n    var height = globe.displacementHeight;\n    var data = globe.displacementData;\n\n    for (var i = 0; i < geometry.vertexCount; i++) {\n      var i3 = i * 3;\n      var i2 = i * 2;\n      var x = originalPositionArr[i3 + 1];\n      var y = originalPositionArr[i3 + 2];\n      var z = originalPositionArr[i3 + 3];\n      var u = uvArr[i2++];\n      var v = uvArr[i2++];\n      var j = Math.round(u * (width - 1));\n      var k = Math.round(v * (height - 1));\n      var idx = k * width + j;\n      var scale = data ? data[idx] : 0;\n      positionArr[i3 + 1] = x + x * scale;\n      positionArr[i3 + 2] = y + y * scale;\n      positionArr[i3 + 3] = z + z * scale;\n    }\n\n    geometry.generateVertexNormals();\n    geometry.dirty();\n    geometry.updateBoundingBox();\n  },\n  _updateLight: function _updateLight(globeModel, api) {\n    var earthMesh = this._earthMesh;\n\n    this._sceneHelper.updateLight(globeModel);\n\n    var mainLight = this._sceneHelper.mainLight; // Put sun in the right position\n\n    var time = globeModel.get('light.main.time') || new Date(); // http://en.wikipedia.org/wiki/Azimuth\n\n    var pos = sunCalc.getPosition(echarts.number.parseDate(time), 0, 0);\n    var r0 = Math.cos(pos.altitude); // FIXME How to calculate the y ?\n\n    mainLight.position.y = -r0 * Math.cos(pos.azimuth);\n    mainLight.position.x = Math.sin(pos.altitude);\n    mainLight.position.z = r0 * Math.sin(pos.azimuth);\n    mainLight.lookAt(earthMesh.getWorldPosition());\n  },\n  dispose: function dispose(ecModel, api) {\n    this.groupGL.removeAll();\n\n    this._control.dispose();\n  }\n});","map":{"version":3,"sources":["C:/Users/Administrator/Desktop/data_view/my_project/vue2_app/myapp/node_modules/_echarts-gl@2.0.9@echarts-gl/lib/component/globe/GlobeView.js"],"names":["echarts","graphicGL","OrbitControl","SceneHelper","sunCalc","retrieve","utilShaderCode","atmosphereShaderCode","Shader","ComponentView","extend","type","__ecgl__","_displacementScale","init","ecModel","api","groupGL","Node","_sphereGeometry","SphereGeometry","widthSegments","heightSegments","dynamic","_overlayGeometry","_planeGeometry","PlaneGeometry","_earthMesh","Mesh","renderNormal","_atmosphereMesh","_atmosphereGeometry","_atmosphereMaterial","Material","shader","source","transparent","geometry","material","frontFace","CW","_lightRoot","_sceneHelper","initLight","add","_control","zr","getZr","_layerMeshes","render","globeModel","coordSys","coordinateSystem","shading","get","viewGL","remove","setScene","scene","setPostEffect","getModel","setTemporalSuperSampling","earthMesh","shadingPrefix","name","createMaterial","setMaterialFromModel","forEach","texName","texture","flipY","set","parseColor","scale","radius","define","invisible","setUniforms","glowPower","glowColor","offset","undefine","diffuseTexture","setTextureImage","anisotropic","surface","attachToMesh","bumpTexture","_updateLight","_displaceVertices","_updateViewControl","_updateLayers","afterRender","layerGL","renderer","updateAmbientCubemap","updateSkybox","layers","lastDistance","layerDiffuseTextures","layerDiffuseIntensity","layerEmissiveTextures","layerEmissionIntensity","util","each","layerOption","layerModel","Model","layerType","loadTexture","blendTo","intensity","firstNotNull","push","id","overlayMesh","castShadow","ignorePicking","__lambertMaterial","autoUpdateTextureStatus","createShader","depthMask","__colorMaterial","enableTexture","distance","blankTexture","_blankTexture","createBlankTexture","refresh","earthMaterial","length","debugWireframeModel","color","width","viewControlModel","camera","self","makeAction","alpha","control","getAlpha","beta","getBeta","getDistance","center","getCenter","from","uid","globeId","setViewGL","coord","setFromViewControlModel","baseDistance","off","on","dispatchAction","displacementQuality","showDebugWireframe","globe","isDisplacementChanged","_displacementQuality","_showDebugWireframe","low","medium","high","ultra","build","_doDisplaceVertices","generateBarycentric","positionArr","attributes","position","value","uvArr","texcoord0","originalPositionArr","__originalPosition","Float32Array","displacementWidth","height","displacementHeight","data","displacementData","i","vertexCount","i3","i2","x","y","z","u","v","j","Math","round","k","idx","generateVertexNormals","dirty","updateBoundingBox","updateLight","mainLight","time","Date","pos","getPosition","number","parseDate","r0","cos","altitude","azimuth","sin","lookAt","getWorldPosition","dispose","removeAll"],"mappings":"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","sourcesContent":["import * as echarts from 'echarts/lib/echarts';\nimport graphicGL from '../../util/graphicGL';\nimport OrbitControl from '../../util/OrbitControl';\nimport SceneHelper from '../common/SceneHelper';\nimport sunCalc from '../../util/sunCalc';\nimport retrieve from '../../util/retrieve';\nimport utilShaderCode from 'claygl/src/shader/source/util.glsl.js';\nimport atmosphereShaderCode from './atmosphere.glsl.js';\ngraphicGL.Shader['import'](utilShaderCode);\ngraphicGL.Shader['import'](atmosphereShaderCode);\nexport default echarts.ComponentView.extend({\n  type: 'globe',\n  __ecgl__: true,\n  _displacementScale: 0,\n  init: function (ecModel, api) {\n    this.groupGL = new graphicGL.Node();\n    /**\n     * @type {clay.geometry.Sphere}\n     * @private\n     */\n\n    this._sphereGeometry = new graphicGL.SphereGeometry({\n      widthSegments: 200,\n      heightSegments: 100,\n      dynamic: true\n    });\n    this._overlayGeometry = new graphicGL.SphereGeometry({\n      widthSegments: 80,\n      heightSegments: 40\n    });\n    /**\n     * @type {clay.geometry.Plane}\n     */\n\n    this._planeGeometry = new graphicGL.PlaneGeometry();\n    /**\n     * @type {clay.geometry.Mesh}\n     */\n\n    this._earthMesh = new graphicGL.Mesh({\n      renderNormal: true\n    });\n    /**\n     * @type {clay.geometry.Mesh}\n     */\n\n    this._atmosphereMesh = new graphicGL.Mesh();\n    this._atmosphereGeometry = new graphicGL.SphereGeometry({\n      widthSegments: 80,\n      heightSegments: 40\n    });\n    this._atmosphereMaterial = new graphicGL.Material({\n      shader: new graphicGL.Shader(graphicGL.Shader.source('ecgl.atmosphere.vertex'), graphicGL.Shader.source('ecgl.atmosphere.fragment')),\n      transparent: true\n    });\n    this._atmosphereMesh.geometry = this._atmosphereGeometry;\n    this._atmosphereMesh.material = this._atmosphereMaterial;\n    this._atmosphereMesh.frontFace = graphicGL.Mesh.CW;\n    this._lightRoot = new graphicGL.Node();\n    this._sceneHelper = new SceneHelper();\n\n    this._sceneHelper.initLight(this._lightRoot);\n\n    this.groupGL.add(this._atmosphereMesh);\n    this.groupGL.add(this._earthMesh);\n    this._control = new OrbitControl({\n      zr: api.getZr()\n    });\n\n    this._control.init();\n\n    this._layerMeshes = {};\n  },\n  render: function (globeModel, ecModel, api) {\n    var coordSys = globeModel.coordinateSystem;\n    var shading = globeModel.get('shading'); // Always have light.\n\n    coordSys.viewGL.add(this._lightRoot);\n\n    if (globeModel.get('show')) {\n      // Add self to scene;\n      coordSys.viewGL.add(this.groupGL);\n    } else {\n      coordSys.viewGL.remove(this.groupGL);\n    }\n\n    this._sceneHelper.setScene(coordSys.viewGL.scene); // Set post effect\n\n\n    coordSys.viewGL.setPostEffect(globeModel.getModel('postEffect'), api);\n    coordSys.viewGL.setTemporalSuperSampling(globeModel.getModel('temporalSuperSampling'));\n    var earthMesh = this._earthMesh;\n    earthMesh.geometry = this._sphereGeometry;\n    var shadingPrefix = 'ecgl.' + shading;\n\n    if (!earthMesh.material || earthMesh.material.shader.name !== shadingPrefix) {\n      earthMesh.material = graphicGL.createMaterial(shadingPrefix);\n    }\n\n    graphicGL.setMaterialFromModel(shading, earthMesh.material, globeModel, api);\n    ['roughnessMap', 'metalnessMap', 'detailMap', 'normalMap'].forEach(function (texName) {\n      var texture = earthMesh.material.get(texName);\n\n      if (texture) {\n        texture.flipY = false;\n      }\n    });\n    earthMesh.material.set('color', graphicGL.parseColor(globeModel.get('baseColor'))); // shrink a little\n\n    var scale = coordSys.radius * 0.99;\n    earthMesh.scale.set(scale, scale, scale);\n\n    if (globeModel.get('atmosphere.show')) {\n      earthMesh.material.define('both', 'ATMOSPHERE_ENABLED');\n      this._atmosphereMesh.invisible = false;\n\n      this._atmosphereMaterial.setUniforms({\n        glowPower: globeModel.get('atmosphere.glowPower') || 6.0,\n        glowColor: globeModel.get('atmosphere.color') || '#ffffff'\n      });\n\n      earthMesh.material.setUniforms({\n        glowPower: globeModel.get('atmosphere.innerGlowPower') || 2.0,\n        glowColor: globeModel.get('atmosphere.color') || '#ffffff'\n      });\n      var offset = globeModel.get('atmosphere.offset') || 5;\n\n      this._atmosphereMesh.scale.set(scale + offset, scale + offset, scale + offset);\n    } else {\n      earthMesh.material.undefine('both', 'ATMOSPHERE_ENABLED');\n      this._atmosphereMesh.invisible = true;\n    }\n\n    var diffuseTexture = earthMesh.material.setTextureImage('diffuseMap', globeModel.get('baseTexture'), api, {\n      flipY: false,\n      anisotropic: 8\n    });\n\n    if (diffuseTexture && diffuseTexture.surface) {\n      diffuseTexture.surface.attachToMesh(earthMesh);\n    } // Update bump map\n\n\n    var bumpTexture = earthMesh.material.setTextureImage('bumpMap', globeModel.get('heightTexture'), api, {\n      flipY: false,\n      anisotropic: 8\n    });\n\n    if (bumpTexture && bumpTexture.surface) {\n      bumpTexture.surface.attachToMesh(earthMesh);\n    }\n\n    earthMesh.material[globeModel.get('postEffect.enable') ? 'define' : 'undefine']('fragment', 'SRGB_DECODE');\n\n    this._updateLight(globeModel, api);\n\n    this._displaceVertices(globeModel, api);\n\n    this._updateViewControl(globeModel, api);\n\n    this._updateLayers(globeModel, api);\n  },\n  afterRender: function (globeModel, ecModel, api, layerGL) {\n    // Create ambient cubemap after render because we need to know the renderer.\n    // TODO\n    var renderer = layerGL.renderer;\n\n    this._sceneHelper.updateAmbientCubemap(renderer, globeModel, api);\n\n    this._sceneHelper.updateSkybox(renderer, globeModel, api);\n  },\n  _updateLayers: function (globeModel, api) {\n    var coordSys = globeModel.coordinateSystem;\n    var layers = globeModel.get('layers');\n    var lastDistance = coordSys.radius;\n    var layerDiffuseTextures = [];\n    var layerDiffuseIntensity = [];\n    var layerEmissiveTextures = [];\n    var layerEmissionIntensity = [];\n    echarts.util.each(layers, function (layerOption) {\n      var layerModel = new echarts.Model(layerOption);\n      var layerType = layerModel.get('type');\n      var texture = graphicGL.loadTexture(layerModel.get('texture'), api, {\n        flipY: false,\n        anisotropic: 8\n      });\n\n      if (texture.surface) {\n        texture.surface.attachToMesh(this._earthMesh);\n      }\n\n      if (layerType === 'blend') {\n        var blendTo = layerModel.get('blendTo');\n        var intensity = retrieve.firstNotNull(layerModel.get('intensity'), 1.0);\n\n        if (blendTo === 'emission') {\n          layerEmissiveTextures.push(texture);\n          layerEmissionIntensity.push(intensity);\n        } else {\n          // Default is albedo\n          layerDiffuseTextures.push(texture);\n          layerDiffuseIntensity.push(intensity);\n        }\n      } else {\n        // Default use overlay\n        var id = layerModel.get('id');\n        var overlayMesh = this._layerMeshes[id];\n\n        if (!overlayMesh) {\n          overlayMesh = this._layerMeshes[id] = new graphicGL.Mesh({\n            geometry: this._overlayGeometry,\n            castShadow: false,\n            ignorePicking: true\n          });\n        }\n\n        var shading = layerModel.get('shading');\n\n        if (shading === 'lambert') {\n          overlayMesh.material = overlayMesh.__lambertMaterial || new graphicGL.Material({\n            autoUpdateTextureStatus: false,\n            shader: graphicGL.createShader('ecgl.lambert'),\n            transparent: true,\n            depthMask: false\n          });\n          overlayMesh.__lambertMaterial = overlayMesh.material;\n        } else {\n          // color\n          overlayMesh.material = overlayMesh.__colorMaterial || new graphicGL.Material({\n            autoUpdateTextureStatus: false,\n            shader: graphicGL.createShader('ecgl.color'),\n            transparent: true,\n            depthMask: false\n          });\n          overlayMesh.__colorMaterial = overlayMesh.material;\n        } // overlay should be transparent if texture is not loaded yet.\n\n\n        overlayMesh.material.enableTexture('diffuseMap');\n        var distance = layerModel.get('distance'); // Based on distance of last layer\n\n        var radius = lastDistance + (distance == null ? coordSys.radius / 100 : distance);\n        overlayMesh.scale.set(radius, radius, radius);\n        lastDistance = radius; // FIXME Exists blink.\n\n        var blankTexture = this._blankTexture || (this._blankTexture = graphicGL.createBlankTexture('rgba(255, 255, 255, 0)'));\n        overlayMesh.material.set('diffuseMap', blankTexture);\n        graphicGL.loadTexture(layerModel.get('texture'), api, {\n          flipY: false,\n          anisotropic: 8\n        }, function (texture) {\n          if (texture.surface) {\n            texture.surface.attachToMesh(overlayMesh);\n          }\n\n          overlayMesh.material.set('diffuseMap', texture);\n          api.getZr().refresh();\n        });\n        layerModel.get('show') ? this.groupGL.add(overlayMesh) : this.groupGL.remove(overlayMesh);\n      }\n    }, this);\n    var earthMaterial = this._earthMesh.material;\n    earthMaterial.define('fragment', 'LAYER_DIFFUSEMAP_COUNT', layerDiffuseTextures.length);\n    earthMaterial.define('fragment', 'LAYER_EMISSIVEMAP_COUNT', layerEmissiveTextures.length);\n    earthMaterial.set('layerDiffuseMap', layerDiffuseTextures);\n    earthMaterial.set('layerDiffuseIntensity', layerDiffuseIntensity);\n    earthMaterial.set('layerEmissiveMap', layerEmissiveTextures);\n    earthMaterial.set('layerEmissionIntensity', layerEmissionIntensity);\n    var debugWireframeModel = globeModel.getModel('debug.wireframe');\n\n    if (debugWireframeModel.get('show')) {\n      earthMaterial.define('both', 'WIREFRAME_TRIANGLE');\n      var color = graphicGL.parseColor(debugWireframeModel.get('lineStyle.color') || 'rgba(0,0,0,0.5)');\n      var width = retrieve.firstNotNull(debugWireframeModel.get('lineStyle.width'), 1);\n      earthMaterial.set('wireframeLineWidth', width);\n      earthMaterial.set('wireframeLineColor', color);\n    } else {\n      earthMaterial.undefine('both', 'WIREFRAME_TRIANGLE');\n    }\n  },\n  _updateViewControl: function (globeModel, api) {\n    var coordSys = globeModel.coordinateSystem; // Update camera\n\n    var viewControlModel = globeModel.getModel('viewControl');\n    var camera = coordSys.viewGL.camera;\n    var self = this;\n\n    function makeAction() {\n      return {\n        type: 'globeChangeCamera',\n        alpha: control.getAlpha(),\n        beta: control.getBeta(),\n        distance: control.getDistance() - coordSys.radius,\n        center: control.getCenter(),\n        from: self.uid,\n        globeId: globeModel.id\n      };\n    } // Update control\n\n\n    var control = this._control;\n    control.setViewGL(coordSys.viewGL);\n    var coord = viewControlModel.get('targetCoord');\n    var alpha, beta;\n\n    if (coord != null) {\n      beta = coord[0] + 90;\n      alpha = coord[1];\n    }\n\n    control.setFromViewControlModel(viewControlModel, {\n      baseDistance: coordSys.radius,\n      alpha: alpha,\n      beta: beta\n    });\n    control.off('update');\n    control.on('update', function () {\n      api.dispatchAction(makeAction());\n    });\n  },\n  _displaceVertices: function (globeModel, api) {\n    var displacementQuality = globeModel.get('displacementQuality');\n    var showDebugWireframe = globeModel.get('debug.wireframe.show');\n    var globe = globeModel.coordinateSystem;\n\n    if (!globeModel.isDisplacementChanged() && displacementQuality === this._displacementQuality && showDebugWireframe === this._showDebugWireframe) {\n      return;\n    }\n\n    this._displacementQuality = displacementQuality;\n    this._showDebugWireframe = showDebugWireframe;\n    var geometry = this._sphereGeometry;\n    var widthSegments = {\n      low: 100,\n      medium: 200,\n      high: 400,\n      ultra: 800\n    }[displacementQuality] || 200;\n    var heightSegments = widthSegments / 2;\n\n    if (geometry.widthSegments !== widthSegments || showDebugWireframe) {\n      geometry.widthSegments = widthSegments;\n      geometry.heightSegments = heightSegments;\n      geometry.build();\n    }\n\n    this._doDisplaceVertices(geometry, globe);\n\n    if (showDebugWireframe) {\n      geometry.generateBarycentric();\n    }\n  },\n  _doDisplaceVertices: function (geometry, globe) {\n    var positionArr = geometry.attributes.position.value;\n    var uvArr = geometry.attributes.texcoord0.value;\n    var originalPositionArr = geometry.__originalPosition;\n\n    if (!originalPositionArr || originalPositionArr.length !== positionArr.length) {\n      originalPositionArr = new Float32Array(positionArr.length);\n      originalPositionArr.set(positionArr);\n      geometry.__originalPosition = originalPositionArr;\n    }\n\n    var width = globe.displacementWidth;\n    var height = globe.displacementHeight;\n    var data = globe.displacementData;\n\n    for (var i = 0; i < geometry.vertexCount; i++) {\n      var i3 = i * 3;\n      var i2 = i * 2;\n      var x = originalPositionArr[i3 + 1];\n      var y = originalPositionArr[i3 + 2];\n      var z = originalPositionArr[i3 + 3];\n      var u = uvArr[i2++];\n      var v = uvArr[i2++];\n      var j = Math.round(u * (width - 1));\n      var k = Math.round(v * (height - 1));\n      var idx = k * width + j;\n      var scale = data ? data[idx] : 0;\n      positionArr[i3 + 1] = x + x * scale;\n      positionArr[i3 + 2] = y + y * scale;\n      positionArr[i3 + 3] = z + z * scale;\n    }\n\n    geometry.generateVertexNormals();\n    geometry.dirty();\n    geometry.updateBoundingBox();\n  },\n  _updateLight: function (globeModel, api) {\n    var earthMesh = this._earthMesh;\n\n    this._sceneHelper.updateLight(globeModel);\n\n    var mainLight = this._sceneHelper.mainLight; // Put sun in the right position\n\n    var time = globeModel.get('light.main.time') || new Date(); // http://en.wikipedia.org/wiki/Azimuth\n\n    var pos = sunCalc.getPosition(echarts.number.parseDate(time), 0, 0);\n    var r0 = Math.cos(pos.altitude); // FIXME How to calculate the y ?\n\n    mainLight.position.y = -r0 * Math.cos(pos.azimuth);\n    mainLight.position.x = Math.sin(pos.altitude);\n    mainLight.position.z = r0 * Math.sin(pos.azimuth);\n    mainLight.lookAt(earthMesh.getWorldPosition());\n  },\n  dispose: function (ecModel, api) {\n    this.groupGL.removeAll();\n\n    this._control.dispose();\n  }\n});"]},"metadata":{},"sourceType":"module"}