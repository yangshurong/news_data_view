{"ast":null,"code":"import \"core-js/modules/es.object.keys.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport Node from './Node';\nimport Light from './Light';\nimport Camera from './Camera';\nimport BoundingBox from './math/BoundingBox';\nimport util from './core/util';\nimport mat4 from './glmatrix/mat4';\nimport LRUCache from './core/LRU';\nimport Matrix4 from './math/Matrix4';\nvar IDENTITY = mat4.create();\nvar WORLDVIEW = mat4.create();\nvar programKeyCache = {};\n\nfunction getProgramKey(lightNumbers) {\n  var defineStr = [];\n  var lightTypes = Object.keys(lightNumbers);\n  lightTypes.sort();\n\n  for (var i = 0; i < lightTypes.length; i++) {\n    var lightType = lightTypes[i];\n    defineStr.push(lightType + ' ' + lightNumbers[lightType]);\n  }\n\n  var key = defineStr.join('\\n');\n\n  if (programKeyCache[key]) {\n    return programKeyCache[key];\n  }\n\n  var id = util.genGUID();\n  programKeyCache[key] = id;\n  return id;\n}\n\nfunction RenderList() {\n  this.opaque = [];\n  this.transparent = [];\n  this._opaqueCount = 0;\n  this._transparentCount = 0;\n}\n\nRenderList.prototype.startCount = function () {\n  this._opaqueCount = 0;\n  this._transparentCount = 0;\n};\n\nRenderList.prototype.add = function (object, isTransparent) {\n  if (isTransparent) {\n    this.transparent[this._transparentCount++] = object;\n  } else {\n    this.opaque[this._opaqueCount++] = object;\n  }\n};\n\nRenderList.prototype.endCount = function () {\n  this.transparent.length = this._transparentCount;\n  this.opaque.length = this._opaqueCount;\n};\n/**\n * @typedef {Object} clay.Scene.RenderList\n * @property {Array.<clay.Renderable>} opaque\n * @property {Array.<clay.Renderable>} transparent\n */\n\n/**\n * @constructor clay.Scene\n * @extends clay.Node\n */\n\n\nvar Scene = Node.extend(function () {\n  return (\n    /** @lends clay.Scene# */\n    {\n      /**\n       * Global material of scene\n       * @type {clay.Material}\n       */\n      material: null,\n      lights: [],\n\n      /**\n       * Scene bounding box in view space.\n       * Used when camera needs to adujst the near and far plane automatically\n       * so that the view frustum contains the visible objects as tightly as possible.\n       * Notice:\n       *  It is updated after rendering (in the step of frustum culling passingly). So may be not so accurate, but saves a lot of calculation\n       *\n       * @type {clay.BoundingBox}\n       */\n      viewBoundingBoxLastFrame: new BoundingBox(),\n      // Uniforms for shadow map.\n      shadowUniforms: {},\n      _cameraList: [],\n      // Properties to save the light information in the scene\n      // Will be set in the render function\n      _lightUniforms: {},\n      _previousLightNumber: {},\n      _lightNumber: {// groupId: {\n        // POINT_LIGHT: 0,\n        // DIRECTIONAL_LIGHT: 0,\n        // SPOT_LIGHT: 0,\n        // AMBIENT_LIGHT: 0,\n        // AMBIENT_SH_LIGHT: 0\n        // }\n      },\n      _lightProgramKeys: {},\n      _nodeRepository: {},\n      _renderLists: new LRUCache(20)\n    }\n  );\n}, function () {\n  this._scene = this;\n},\n/** @lends clay.Scene.prototype. */\n{\n  // Add node to scene\n  addToScene: function addToScene(node) {\n    if (node instanceof Camera) {\n      if (this._cameraList.length > 0) {\n        console.warn('Found multiple camera in one scene. Use the fist one.');\n      }\n\n      this._cameraList.push(node);\n    } else if (node instanceof Light) {\n      this.lights.push(node);\n    }\n\n    if (node.name) {\n      this._nodeRepository[node.name] = node;\n    }\n  },\n  // Remove node from scene\n  removeFromScene: function removeFromScene(node) {\n    var idx;\n\n    if (node instanceof Camera) {\n      idx = this._cameraList.indexOf(node);\n\n      if (idx >= 0) {\n        this._cameraList.splice(idx, 1);\n      }\n    } else if (node instanceof Light) {\n      idx = this.lights.indexOf(node);\n\n      if (idx >= 0) {\n        this.lights.splice(idx, 1);\n      }\n    }\n\n    if (node.name) {\n      delete this._nodeRepository[node.name];\n    }\n  },\n\n  /**\n   * Get node by name\n   * @param  {string} name\n   * @return {Node}\n   * @DEPRECATED\n   */\n  getNode: function getNode(name) {\n    return this._nodeRepository[name];\n  },\n\n  /**\n   * Set main camera of the scene.\n   * @param {claygl.Camera} camera\n   */\n  setMainCamera: function setMainCamera(camera) {\n    var idx = this._cameraList.indexOf(camera);\n\n    if (idx >= 0) {\n      this._cameraList.splice(idx, 1);\n    }\n\n    this._cameraList.unshift(camera);\n  },\n\n  /**\n   * Get main camera of the scene.\n   */\n  getMainCamera: function getMainCamera() {\n    return this._cameraList[0];\n  },\n  getLights: function getLights() {\n    return this.lights;\n  },\n  updateLights: function updateLights() {\n    var lights = this.lights;\n    this._previousLightNumber = this._lightNumber;\n    var lightNumber = {};\n\n    for (var i = 0; i < lights.length; i++) {\n      var light = lights[i];\n\n      if (light.invisible) {\n        continue;\n      }\n\n      var group = light.group;\n\n      if (!lightNumber[group]) {\n        lightNumber[group] = {};\n      } // User can use any type of light\n\n\n      lightNumber[group][light.type] = lightNumber[group][light.type] || 0;\n      lightNumber[group][light.type]++;\n    }\n\n    this._lightNumber = lightNumber;\n\n    for (var groupId in lightNumber) {\n      this._lightProgramKeys[groupId] = getProgramKey(lightNumber[groupId]);\n    }\n\n    this._updateLightUniforms();\n  },\n\n  /**\n   * Clone a node and it's children, including mesh, camera, light, etc.\n   * Unlike using `Node#clone`. It will clone skeleton and remap the joints. Material will also be cloned.\n   *\n   * @param {clay.Node} node\n   * @return {clay.Node}\n   */\n  cloneNode: function cloneNode(node) {\n    var newNode = node.clone();\n    var clonedNodesMap = {};\n\n    function buildNodesMap(sNode, tNode) {\n      clonedNodesMap[sNode.__uid__] = tNode;\n\n      for (var i = 0; i < sNode._children.length; i++) {\n        var sChild = sNode._children[i];\n        var tChild = tNode._children[i];\n        buildNodesMap(sChild, tChild);\n      }\n    }\n\n    buildNodesMap(node, newNode);\n    newNode.traverse(function (newChild) {\n      if (newChild.skeleton) {\n        newChild.skeleton = newChild.skeleton.clone(clonedNodesMap);\n      }\n\n      if (newChild.material) {\n        newChild.material = newChild.material.clone();\n      }\n    });\n    return newNode;\n  },\n\n  /**\n   * Traverse the scene and add the renderable object to the render list.\n   * It needs camera for the frustum culling.\n   *\n   * @param {clay.Camera} camera\n   * @param {boolean} updateSceneBoundingBox\n   * @return {clay.Scene.RenderList}\n   */\n  updateRenderList: function updateRenderList(camera, updateSceneBoundingBox) {\n    var id = camera.__uid__;\n\n    var renderList = this._renderLists.get(id);\n\n    if (!renderList) {\n      renderList = new RenderList();\n\n      this._renderLists.put(id, renderList);\n    }\n\n    renderList.startCount();\n\n    if (updateSceneBoundingBox) {\n      this.viewBoundingBoxLastFrame.min.set(Infinity, Infinity, Infinity);\n      this.viewBoundingBoxLastFrame.max.set(-Infinity, -Infinity, -Infinity);\n    }\n\n    var sceneMaterialTransparent = this.material && this.material.transparent || false;\n\n    this._doUpdateRenderList(this, camera, sceneMaterialTransparent, renderList, updateSceneBoundingBox);\n\n    renderList.endCount();\n    return renderList;\n  },\n\n  /**\n   * Get render list. Used after {@link clay.Scene#updateRenderList}\n   * @param {clay.Camera} camera\n   * @return {clay.Scene.RenderList}\n   */\n  getRenderList: function getRenderList(camera) {\n    return this._renderLists.get(camera.__uid__);\n  },\n  _doUpdateRenderList: function _doUpdateRenderList(parent, camera, sceneMaterialTransparent, renderList, updateSceneBoundingBox) {\n    if (parent.invisible) {\n      return;\n    } // TODO Optimize\n\n\n    for (var i = 0; i < parent._children.length; i++) {\n      var child = parent._children[i];\n\n      if (child.isRenderable()) {\n        // Frustum culling\n        var worldM = child.isSkinnedMesh() ? IDENTITY : child.worldTransform.array;\n        var geometry = child.geometry;\n        mat4.multiplyAffine(WORLDVIEW, camera.viewMatrix.array, worldM);\n\n        if (updateSceneBoundingBox && !geometry.boundingBox || !this.isFrustumCulled(child, camera, WORLDVIEW)) {\n          renderList.add(child, child.material.transparent || sceneMaterialTransparent);\n        }\n      }\n\n      if (child._children.length > 0) {\n        this._doUpdateRenderList(child, camera, sceneMaterialTransparent, renderList, updateSceneBoundingBox);\n      }\n    }\n  },\n\n  /**\n   * If an scene object is culled by camera frustum\n   *\n   * Object can be a renderable or a light\n   *\n   * @param {clay.Node} object\n   * @param {clay.Camera} camera\n   * @param {Array.<number>} worldViewMat represented with array\n   * @param {Array.<number>} projectionMat represented with array\n   */\n  isFrustumCulled: function () {\n    // Frustum culling\n    // http://www.cse.chalmers.se/~uffe/vfc_bbox.pdf\n    var cullingBoundingBox = new BoundingBox();\n    var cullingMatrix = new Matrix4();\n    return function (object, camera, worldViewMat) {\n      // Bounding box can be a property of object(like light) or renderable.geometry\n      // PENDING\n      var geoBBox = object.boundingBox;\n\n      if (!geoBBox) {\n        if (object.skeleton && object.skeleton.boundingBox) {\n          geoBBox = object.skeleton.boundingBox;\n        } else {\n          geoBBox = object.geometry.boundingBox;\n        }\n      }\n\n      if (!geoBBox) {\n        return false;\n      }\n\n      cullingMatrix.array = worldViewMat;\n      cullingBoundingBox.transformFrom(geoBBox, cullingMatrix); // Passingly update the scene bounding box\n      // FIXME exclude very large mesh like ground plane or terrain ?\n      // FIXME Only rendererable which cast shadow ?\n      // FIXME boundingBox becomes much larger after transformd.\n\n      if (object.castShadow) {\n        this.viewBoundingBoxLastFrame.union(cullingBoundingBox);\n      } // Ignore frustum culling if object is skinned mesh.\n\n\n      if (object.frustumCulling) {\n        if (!cullingBoundingBox.intersectBoundingBox(camera.frustum.boundingBox)) {\n          return true;\n        }\n\n        cullingMatrix.array = camera.projectionMatrix.array;\n\n        if (cullingBoundingBox.max.array[2] > 0 && cullingBoundingBox.min.array[2] < 0) {\n          // Clip in the near plane\n          cullingBoundingBox.max.array[2] = -1e-20;\n        }\n\n        cullingBoundingBox.applyProjection(cullingMatrix);\n        var min = cullingBoundingBox.min.array;\n        var max = cullingBoundingBox.max.array;\n\n        if (max[0] < -1 || min[0] > 1 || max[1] < -1 || min[1] > 1 || max[2] < -1 || min[2] > 1) {\n          return true;\n        }\n      }\n\n      return false;\n    };\n  }(),\n  _updateLightUniforms: function _updateLightUniforms() {\n    var lights = this.lights; // Put the light cast shadow before the light not cast shadow\n\n    lights.sort(lightSortFunc);\n    var lightUniforms = this._lightUniforms;\n\n    for (var group in lightUniforms) {\n      for (var symbol in lightUniforms[group]) {\n        lightUniforms[group][symbol].value.length = 0;\n      }\n    }\n\n    for (var i = 0; i < lights.length; i++) {\n      var light = lights[i];\n\n      if (light.invisible) {\n        continue;\n      }\n\n      var group = light.group;\n\n      for (var symbol in light.uniformTemplates) {\n        var uniformTpl = light.uniformTemplates[symbol];\n        var value = uniformTpl.value(light);\n\n        if (value == null) {\n          continue;\n        }\n\n        if (!lightUniforms[group]) {\n          lightUniforms[group] = {};\n        }\n\n        if (!lightUniforms[group][symbol]) {\n          lightUniforms[group][symbol] = {\n            type: '',\n            value: []\n          };\n        }\n\n        var lu = lightUniforms[group][symbol];\n        lu.type = uniformTpl.type + 'v';\n\n        switch (uniformTpl.type) {\n          case '1i':\n          case '1f':\n          case 't':\n            lu.value.push(value);\n            break;\n\n          case '2f':\n          case '3f':\n          case '4f':\n            for (var j = 0; j < value.length; j++) {\n              lu.value.push(value[j]);\n            }\n\n            break;\n\n          default:\n            console.error('Unkown light uniform type ' + uniformTpl.type);\n        }\n      }\n    }\n  },\n  getLightGroups: function getLightGroups() {\n    var lightGroups = [];\n\n    for (var groupId in this._lightNumber) {\n      lightGroups.push(groupId);\n    }\n\n    return lightGroups;\n  },\n  getNumberChangedLightGroups: function getNumberChangedLightGroups() {\n    var lightGroups = [];\n\n    for (var groupId in this._lightNumber) {\n      if (this.isLightNumberChanged(groupId)) {\n        lightGroups.push(groupId);\n      }\n    }\n\n    return lightGroups;\n  },\n  // Determine if light group is different with since last frame\n  // Used to determine whether to update shader and scene's uniforms in Renderer.render\n  isLightNumberChanged: function isLightNumberChanged(lightGroup) {\n    var prevLightNumber = this._previousLightNumber;\n    var currentLightNumber = this._lightNumber; // PENDING Performance\n\n    for (var type in currentLightNumber[lightGroup]) {\n      if (!prevLightNumber[lightGroup]) {\n        return true;\n      }\n\n      if (currentLightNumber[lightGroup][type] !== prevLightNumber[lightGroup][type]) {\n        return true;\n      }\n    }\n\n    for (var type in prevLightNumber[lightGroup]) {\n      if (!currentLightNumber[lightGroup]) {\n        return true;\n      }\n\n      if (currentLightNumber[lightGroup][type] !== prevLightNumber[lightGroup][type]) {\n        return true;\n      }\n    }\n\n    return false;\n  },\n  getLightsNumbers: function getLightsNumbers(lightGroup) {\n    return this._lightNumber[lightGroup];\n  },\n  getProgramKey: function getProgramKey(lightGroup) {\n    return this._lightProgramKeys[lightGroup];\n  },\n  setLightUniforms: function () {\n    function setUniforms(uniforms, program, renderer) {\n      for (var symbol in uniforms) {\n        var lu = uniforms[symbol];\n\n        if (lu.type === 'tv') {\n          if (!program.hasUniform(symbol)) {\n            continue;\n          }\n\n          var texSlots = [];\n\n          for (var i = 0; i < lu.value.length; i++) {\n            var texture = lu.value[i];\n            var slot = program.takeCurrentTextureSlot(renderer, texture);\n            texSlots.push(slot);\n          }\n\n          program.setUniform(renderer.gl, '1iv', symbol, texSlots);\n        } else {\n          program.setUniform(renderer.gl, lu.type, symbol, lu.value);\n        }\n      }\n    }\n\n    return function (program, lightGroup, renderer) {\n      setUniforms(this._lightUniforms[lightGroup], program, renderer); // Set shadows\n\n      setUniforms(this.shadowUniforms, program, renderer);\n    };\n  }(),\n\n  /**\n   * Dispose self, clear all the scene objects\n   * But resources of gl like texuture, shader will not be disposed.\n   * Mostly you should use disposeScene method in Renderer to do dispose.\n   */\n  dispose: function dispose() {\n    this.material = null;\n    this._opaqueList = [];\n    this._transparentList = [];\n    this.lights = [];\n    this._lightUniforms = {};\n    this._lightNumber = {};\n    this._nodeRepository = {};\n  }\n});\n\nfunction lightSortFunc(a, b) {\n  if (b.castShadow && !a.castShadow) {\n    return true;\n  }\n}\n\nexport default Scene;","map":{"version":3,"sources":["C:/Users/Administrator/Desktop/data_view/my_project/vue2_app/myapp/node_modules/_claygl@1.3.0@claygl/src/Scene.js"],"names":["Node","Light","Camera","BoundingBox","util","mat4","LRUCache","Matrix4","IDENTITY","create","WORLDVIEW","programKeyCache","getProgramKey","lightNumbers","defineStr","lightTypes","Object","keys","sort","i","length","lightType","push","key","join","id","genGUID","RenderList","opaque","transparent","_opaqueCount","_transparentCount","prototype","startCount","add","object","isTransparent","endCount","Scene","extend","material","lights","viewBoundingBoxLastFrame","shadowUniforms","_cameraList","_lightUniforms","_previousLightNumber","_lightNumber","_lightProgramKeys","_nodeRepository","_renderLists","_scene","addToScene","node","console","warn","name","removeFromScene","idx","indexOf","splice","getNode","setMainCamera","camera","unshift","getMainCamera","getLights","updateLights","lightNumber","light","invisible","group","type","groupId","_updateLightUniforms","cloneNode","newNode","clone","clonedNodesMap","buildNodesMap","sNode","tNode","__uid__","_children","sChild","tChild","traverse","newChild","skeleton","updateRenderList","updateSceneBoundingBox","renderList","get","put","min","set","Infinity","max","sceneMaterialTransparent","_doUpdateRenderList","getRenderList","parent","child","isRenderable","worldM","isSkinnedMesh","worldTransform","array","geometry","multiplyAffine","viewMatrix","boundingBox","isFrustumCulled","cullingBoundingBox","cullingMatrix","worldViewMat","geoBBox","transformFrom","castShadow","union","frustumCulling","intersectBoundingBox","frustum","projectionMatrix","applyProjection","lightSortFunc","lightUniforms","symbol","value","uniformTemplates","uniformTpl","lu","j","error","getLightGroups","lightGroups","getNumberChangedLightGroups","isLightNumberChanged","lightGroup","prevLightNumber","currentLightNumber","getLightsNumbers","setLightUniforms","setUniforms","uniforms","program","renderer","hasUniform","texSlots","texture","slot","takeCurrentTextureSlot","setUniform","gl","dispose","_opaqueList","_transparentList","a","b"],"mappings":"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","sourcesContent":["import Node from './Node';\nimport Light from './Light';\nimport Camera from './Camera';\nimport BoundingBox from './math/BoundingBox';\nimport util from './core/util';\nimport mat4 from './glmatrix/mat4';\nimport LRUCache from './core/LRU';\nimport Matrix4 from './math/Matrix4';\n\nvar IDENTITY = mat4.create();\nvar WORLDVIEW = mat4.create();\n\nvar programKeyCache = {};\n\nfunction getProgramKey(lightNumbers) {\n    var defineStr = [];\n    var lightTypes = Object.keys(lightNumbers);\n    lightTypes.sort();\n    for (var i = 0; i < lightTypes.length; i++) {\n        var lightType = lightTypes[i];\n        defineStr.push(lightType + ' ' + lightNumbers[lightType]);\n    }\n    var key = defineStr.join('\\n');\n\n    if (programKeyCache[key]) {\n        return programKeyCache[key];\n    }\n\n    var id = util.genGUID();\n    programKeyCache[key] = id;\n    return id;\n}\n\nfunction RenderList() {\n\n    this.opaque = [];\n    this.transparent = [];\n\n    this._opaqueCount = 0;\n    this._transparentCount = 0;\n}\n\nRenderList.prototype.startCount = function () {\n    this._opaqueCount = 0;\n    this._transparentCount = 0;\n};\n\nRenderList.prototype.add = function (object, isTransparent) {\n    if (isTransparent) {\n        this.transparent[this._transparentCount++] = object;\n    }\n    else {\n        this.opaque[this._opaqueCount++] = object;\n    }\n};\n\nRenderList.prototype.endCount = function () {\n    this.transparent.length = this._transparentCount;\n    this.opaque.length = this._opaqueCount;\n};\n\n/**\n * @typedef {Object} clay.Scene.RenderList\n * @property {Array.<clay.Renderable>} opaque\n * @property {Array.<clay.Renderable>} transparent\n */\n\n/**\n * @constructor clay.Scene\n * @extends clay.Node\n */\nvar Scene = Node.extend(function () {\n    return /** @lends clay.Scene# */ {\n        /**\n         * Global material of scene\n         * @type {clay.Material}\n         */\n        material: null,\n\n        lights: [],\n\n        /**\n         * Scene bounding box in view space.\n         * Used when camera needs to adujst the near and far plane automatically\n         * so that the view frustum contains the visible objects as tightly as possible.\n         * Notice:\n         *  It is updated after rendering (in the step of frustum culling passingly). So may be not so accurate, but saves a lot of calculation\n         *\n         * @type {clay.BoundingBox}\n         */\n        viewBoundingBoxLastFrame: new BoundingBox(),\n\n        // Uniforms for shadow map.\n        shadowUniforms: {},\n\n        _cameraList: [],\n\n        // Properties to save the light information in the scene\n        // Will be set in the render function\n        _lightUniforms: {},\n\n        _previousLightNumber: {},\n\n        _lightNumber: {\n            // groupId: {\n                // POINT_LIGHT: 0,\n                // DIRECTIONAL_LIGHT: 0,\n                // SPOT_LIGHT: 0,\n                // AMBIENT_LIGHT: 0,\n                // AMBIENT_SH_LIGHT: 0\n            // }\n        },\n\n        _lightProgramKeys: {},\n\n        _nodeRepository: {},\n\n        _renderLists: new LRUCache(20)\n\n    };\n}, function () {\n    this._scene = this;\n},\n/** @lends clay.Scene.prototype. */\n{\n\n    // Add node to scene\n    addToScene: function (node) {\n        if (node instanceof Camera) {\n            if (this._cameraList.length > 0) {\n                console.warn('Found multiple camera in one scene. Use the fist one.');\n            }\n            this._cameraList.push(node);\n        }\n        else if (node instanceof Light) {\n            this.lights.push(node);\n        }\n        if (node.name) {\n            this._nodeRepository[node.name] = node;\n        }\n    },\n\n    // Remove node from scene\n    removeFromScene: function (node) {\n        var idx;\n        if (node instanceof Camera) {\n            idx = this._cameraList.indexOf(node);\n            if (idx >= 0) {\n                this._cameraList.splice(idx, 1);\n            }\n        }\n        else if (node instanceof Light) {\n            idx = this.lights.indexOf(node);\n            if (idx >= 0) {\n                this.lights.splice(idx, 1);\n            }\n        }\n        if (node.name) {\n            delete this._nodeRepository[node.name];\n        }\n    },\n\n    /**\n     * Get node by name\n     * @param  {string} name\n     * @return {Node}\n     * @DEPRECATED\n     */\n    getNode: function (name) {\n        return this._nodeRepository[name];\n    },\n\n    /**\n     * Set main camera of the scene.\n     * @param {claygl.Camera} camera\n     */\n    setMainCamera: function (camera) {\n        var idx = this._cameraList.indexOf(camera);\n        if (idx >= 0) {\n            this._cameraList.splice(idx, 1);\n        }\n        this._cameraList.unshift(camera);\n    },\n    /**\n     * Get main camera of the scene.\n     */\n    getMainCamera: function () {\n        return this._cameraList[0];\n    },\n\n    getLights: function () {\n        return this.lights;\n    },\n\n    updateLights: function () {\n        var lights = this.lights;\n        this._previousLightNumber = this._lightNumber;\n\n        var lightNumber = {};\n        for (var i = 0; i < lights.length; i++) {\n            var light = lights[i];\n            if (light.invisible) {\n                continue;\n            }\n            var group = light.group;\n            if (!lightNumber[group]) {\n                lightNumber[group] = {};\n            }\n            // User can use any type of light\n            lightNumber[group][light.type] = lightNumber[group][light.type] || 0;\n            lightNumber[group][light.type]++;\n        }\n        this._lightNumber = lightNumber;\n\n        for (var groupId in lightNumber) {\n            this._lightProgramKeys[groupId] = getProgramKey(lightNumber[groupId]);\n        }\n\n        this._updateLightUniforms();\n    },\n\n    /**\n     * Clone a node and it's children, including mesh, camera, light, etc.\n     * Unlike using `Node#clone`. It will clone skeleton and remap the joints. Material will also be cloned.\n     *\n     * @param {clay.Node} node\n     * @return {clay.Node}\n     */\n    cloneNode: function (node) {\n        var newNode = node.clone();\n        var clonedNodesMap = {};\n        function buildNodesMap(sNode, tNode) {\n            clonedNodesMap[sNode.__uid__] = tNode;\n\n            for (var i = 0; i < sNode._children.length; i++) {\n                var sChild = sNode._children[i];\n                var tChild = tNode._children[i];\n                buildNodesMap(sChild, tChild);\n            }\n        }\n        buildNodesMap(node, newNode);\n\n        newNode.traverse(function (newChild) {\n            if (newChild.skeleton) {\n                newChild.skeleton = newChild.skeleton.clone(clonedNodesMap);\n            }\n            if (newChild.material) {\n                newChild.material = newChild.material.clone();\n            }\n        });\n\n        return newNode;\n    },\n\n    /**\n     * Traverse the scene and add the renderable object to the render list.\n     * It needs camera for the frustum culling.\n     *\n     * @param {clay.Camera} camera\n     * @param {boolean} updateSceneBoundingBox\n     * @return {clay.Scene.RenderList}\n     */\n    updateRenderList: function (camera, updateSceneBoundingBox) {\n        var id = camera.__uid__;\n        var renderList = this._renderLists.get(id);\n        if (!renderList) {\n            renderList = new RenderList();\n            this._renderLists.put(id, renderList);\n        }\n        renderList.startCount();\n\n        if (updateSceneBoundingBox) {\n            this.viewBoundingBoxLastFrame.min.set(Infinity, Infinity, Infinity);\n            this.viewBoundingBoxLastFrame.max.set(-Infinity, -Infinity, -Infinity);\n        }\n\n        var sceneMaterialTransparent = this.material && this.material.transparent || false;\n        this._doUpdateRenderList(this, camera, sceneMaterialTransparent, renderList, updateSceneBoundingBox);\n\n        renderList.endCount();\n\n        return renderList;\n    },\n\n    /**\n     * Get render list. Used after {@link clay.Scene#updateRenderList}\n     * @param {clay.Camera} camera\n     * @return {clay.Scene.RenderList}\n     */\n    getRenderList: function (camera) {\n        return this._renderLists.get(camera.__uid__);\n    },\n\n    _doUpdateRenderList: function (parent, camera, sceneMaterialTransparent, renderList, updateSceneBoundingBox) {\n        if (parent.invisible) {\n            return;\n        }\n        // TODO Optimize\n        for (var i = 0; i < parent._children.length; i++) {\n            var child = parent._children[i];\n\n            if (child.isRenderable()) {\n                // Frustum culling\n                var worldM = child.isSkinnedMesh() ? IDENTITY : child.worldTransform.array;\n                var geometry = child.geometry;\n\n                mat4.multiplyAffine(WORLDVIEW, camera.viewMatrix.array, worldM);\n                if (updateSceneBoundingBox && !geometry.boundingBox || !this.isFrustumCulled(child, camera, WORLDVIEW)) {\n                    renderList.add(child, child.material.transparent || sceneMaterialTransparent);\n                }\n            }\n            if (child._children.length > 0) {\n                this._doUpdateRenderList(child, camera, sceneMaterialTransparent, renderList, updateSceneBoundingBox);\n            }\n        }\n    },\n\n    /**\n     * If an scene object is culled by camera frustum\n     *\n     * Object can be a renderable or a light\n     *\n     * @param {clay.Node} object\n     * @param {clay.Camera} camera\n     * @param {Array.<number>} worldViewMat represented with array\n     * @param {Array.<number>} projectionMat represented with array\n     */\n    isFrustumCulled: (function () {\n        // Frustum culling\n        // http://www.cse.chalmers.se/~uffe/vfc_bbox.pdf\n        var cullingBoundingBox = new BoundingBox();\n        var cullingMatrix = new Matrix4();\n        return function(object, camera, worldViewMat) {\n            // Bounding box can be a property of object(like light) or renderable.geometry\n            // PENDING\n            var geoBBox = object.boundingBox;\n            if (!geoBBox) {\n                if (object.skeleton && object.skeleton.boundingBox) {\n                    geoBBox = object.skeleton.boundingBox;\n                }\n                else {\n                    geoBBox = object.geometry.boundingBox;\n                }\n            }\n\n            if (!geoBBox) {\n                return false;\n            }\n\n            cullingMatrix.array = worldViewMat;\n            cullingBoundingBox.transformFrom(geoBBox, cullingMatrix);\n\n            // Passingly update the scene bounding box\n            // FIXME exclude very large mesh like ground plane or terrain ?\n            // FIXME Only rendererable which cast shadow ?\n\n            // FIXME boundingBox becomes much larger after transformd.\n            if (object.castShadow) {\n                this.viewBoundingBoxLastFrame.union(cullingBoundingBox);\n            }\n            // Ignore frustum culling if object is skinned mesh.\n            if (object.frustumCulling)  {\n                if (!cullingBoundingBox.intersectBoundingBox(camera.frustum.boundingBox)) {\n                    return true;\n                }\n\n                cullingMatrix.array = camera.projectionMatrix.array;\n                if (\n                    cullingBoundingBox.max.array[2] > 0 &&\n                    cullingBoundingBox.min.array[2] < 0\n                ) {\n                    // Clip in the near plane\n                    cullingBoundingBox.max.array[2] = -1e-20;\n                }\n\n                cullingBoundingBox.applyProjection(cullingMatrix);\n\n                var min = cullingBoundingBox.min.array;\n                var max = cullingBoundingBox.max.array;\n\n                if (\n                    max[0] < -1 || min[0] > 1\n                    || max[1] < -1 || min[1] > 1\n                    || max[2] < -1 || min[2] > 1\n                ) {\n                    return true;\n                }\n            }\n\n            return false;\n        };\n    })(),\n\n    _updateLightUniforms: function () {\n        var lights = this.lights;\n        // Put the light cast shadow before the light not cast shadow\n        lights.sort(lightSortFunc);\n\n        var lightUniforms = this._lightUniforms;\n        for (var group in lightUniforms) {\n            for (var symbol in lightUniforms[group]) {\n                lightUniforms[group][symbol].value.length = 0;\n            }\n        }\n        for (var i = 0; i < lights.length; i++) {\n\n            var light = lights[i];\n\n            if (light.invisible) {\n                continue;\n            }\n\n            var group = light.group;\n\n            for (var symbol in light.uniformTemplates) {\n                var uniformTpl = light.uniformTemplates[symbol];\n                var value = uniformTpl.value(light);\n                if (value == null) {\n                    continue;\n                }\n                if (!lightUniforms[group]) {\n                    lightUniforms[group] = {};\n                }\n                if (!lightUniforms[group][symbol]) {\n                    lightUniforms[group][symbol] = {\n                        type: '',\n                        value: []\n                    };\n                }\n                var lu = lightUniforms[group][symbol];\n                lu.type = uniformTpl.type + 'v';\n                switch (uniformTpl.type) {\n                    case '1i':\n                    case '1f':\n                    case 't':\n                        lu.value.push(value);\n                        break;\n                    case '2f':\n                    case '3f':\n                    case '4f':\n                        for (var j = 0; j < value.length; j++) {\n                            lu.value.push(value[j]);\n                        }\n                        break;\n                    default:\n                        console.error('Unkown light uniform type ' + uniformTpl.type);\n                }\n            }\n        }\n    },\n\n    getLightGroups: function () {\n        var lightGroups = [];\n        for (var groupId in this._lightNumber) {\n            lightGroups.push(groupId);\n        }\n        return lightGroups;\n    },\n\n    getNumberChangedLightGroups: function () {\n        var lightGroups = [];\n        for (var groupId in this._lightNumber) {\n            if (this.isLightNumberChanged(groupId)) {\n                lightGroups.push(groupId);\n            }\n        }\n        return lightGroups;\n    },\n\n    // Determine if light group is different with since last frame\n    // Used to determine whether to update shader and scene's uniforms in Renderer.render\n    isLightNumberChanged: function (lightGroup) {\n        var prevLightNumber = this._previousLightNumber;\n        var currentLightNumber = this._lightNumber;\n        // PENDING Performance\n        for (var type in currentLightNumber[lightGroup]) {\n            if (!prevLightNumber[lightGroup]) {\n                return true;\n            }\n            if (currentLightNumber[lightGroup][type] !== prevLightNumber[lightGroup][type]) {\n                return true;\n            }\n        }\n        for (var type in prevLightNumber[lightGroup]) {\n            if (!currentLightNumber[lightGroup]) {\n                return true;\n            }\n            if (currentLightNumber[lightGroup][type] !== prevLightNumber[lightGroup][type]) {\n                return true;\n            }\n        }\n        return false;\n    },\n\n    getLightsNumbers: function (lightGroup) {\n        return this._lightNumber[lightGroup];\n    },\n\n    getProgramKey: function (lightGroup) {\n        return this._lightProgramKeys[lightGroup];\n    },\n\n    setLightUniforms: (function () {\n        function setUniforms(uniforms, program, renderer) {\n            for (var symbol in uniforms) {\n                var lu = uniforms[symbol];\n                if (lu.type === 'tv') {\n                    if (!program.hasUniform(symbol)) {\n                        continue;\n                    }\n                    var texSlots = [];\n                    for (var i = 0; i < lu.value.length; i++) {\n                        var texture = lu.value[i];\n                        var slot = program.takeCurrentTextureSlot(renderer, texture);\n                        texSlots.push(slot);\n                    }\n                    program.setUniform(renderer.gl, '1iv', symbol, texSlots);\n                }\n                else {\n                    program.setUniform(renderer.gl, lu.type, symbol, lu.value);\n                }\n            }\n        }\n\n        return function (program, lightGroup, renderer) {\n            setUniforms(this._lightUniforms[lightGroup], program, renderer);\n            // Set shadows\n            setUniforms(this.shadowUniforms, program, renderer);\n        };\n    })(),\n\n    /**\n     * Dispose self, clear all the scene objects\n     * But resources of gl like texuture, shader will not be disposed.\n     * Mostly you should use disposeScene method in Renderer to do dispose.\n     */\n    dispose: function () {\n        this.material = null;\n        this._opaqueList = [];\n        this._transparentList = [];\n\n        this.lights = [];\n\n        this._lightUniforms = {};\n\n        this._lightNumber = {};\n        this._nodeRepository = {};\n    }\n});\n\nfunction lightSortFunc(a, b) {\n    if (b.castShadow && !a.castShadow) {\n        return true;\n    }\n}\n\nexport default Scene;\n"]},"metadata":{},"sourceType":"module"}