{"ast":null,"code":"'use strict';\n\nvar _typeof2 = require(\"C:/Users/Administrator/Desktop/data_view/my_project/vue2_app/myapp/node_modules/@babel/runtime/helpers/typeof.js\").default;\n\nrequire(\"core-js/modules/es.symbol.js\");\n\nrequire(\"core-js/modules/es.symbol.description.js\");\n\nrequire(\"core-js/modules/es.object.to-string.js\");\n\nrequire(\"core-js/modules/es.symbol.iterator.js\");\n\nrequire(\"core-js/modules/es.string.iterator.js\");\n\nrequire(\"core-js/modules/web.dom-collections.iterator.js\");\n\nrequire(\"core-js/modules/es.error.cause.js\");\n\nrequire(\"core-js/modules/es.array.map.js\");\n\nrequire(\"core-js/modules/es.json.stringify.js\");\n\nrequire(\"core-js/modules/es.regexp.to-string.js\");\n\nrequire(\"core-js/modules/web.url.to-json.js\");\n\nrequire(\"core-js/modules/es.regexp.exec.js\");\n\nrequire(\"core-js/modules/es.string.replace.js\");\n\nexports.__esModule = true;\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _typeof = typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\" ? function (obj) {\n  return _typeof2(obj);\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : _typeof2(obj);\n};\n\nvar _cssSyntaxError = require('./css-syntax-error');\n\nvar _cssSyntaxError2 = _interopRequireDefault(_cssSyntaxError);\n\nvar _stringifier = require('./stringifier');\n\nvar _stringifier2 = _interopRequireDefault(_stringifier);\n\nvar _stringify = require('./stringify');\n\nvar _stringify2 = _interopRequireDefault(_stringify);\n\nvar _warnOnce = require('./warn-once');\n\nvar _warnOnce2 = _interopRequireDefault(_warnOnce);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar cloneNode = function cloneNode(obj, parent) {\n  var cloned = new obj.constructor();\n\n  for (var i in obj) {\n    if (!obj.hasOwnProperty(i)) continue;\n    var value = obj[i];\n    var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);\n\n    if (i === 'parent' && type === 'object') {\n      if (parent) cloned[i] = parent;\n    } else if (i === 'source') {\n      cloned[i] = value;\n    } else if (value instanceof Array) {\n      cloned[i] = value.map(function (j) {\n        return cloneNode(j, cloned);\n      });\n    } else if (i !== 'before' && i !== 'after' && i !== 'between' && i !== 'semicolon') {\n      if (type === 'object' && value !== null) value = cloneNode(value);\n      cloned[i] = value;\n    }\n  }\n\n  return cloned;\n};\n/**\n * All node classes inherit the following common methods.\n *\n * @abstract\n */\n\n\nvar Node = function () {\n  /**\n   * @param {object} [defaults] - value for node properties\n   */\n  function Node() {\n    var defaults = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Node);\n\n    this.raws = {};\n\n    if ((typeof defaults === 'undefined' ? 'undefined' : _typeof(defaults)) !== 'object' && typeof defaults !== 'undefined') {\n      throw new Error('PostCSS nodes constructor accepts object, not ' + JSON.stringify(defaults));\n    }\n\n    for (var name in defaults) {\n      this[name] = defaults[name];\n    }\n  }\n  /**\n   * Returns a CssSyntaxError instance containing the original position\n   * of the node in the source, showing line and column numbers and also\n   * a small excerpt to facilitate debugging.\n   *\n   * If present, an input source map will be used to get the original position\n   * of the source, even from a previous compilation step\n   * (e.g., from Sass compilation).\n   *\n   * This method produces very useful error messages.\n   *\n   * @param {string} message     - error description\n   * @param {object} [opts]      - options\n   * @param {string} opts.plugin - plugin name that created this error.\n   *                               PostCSS will set it automatically.\n   * @param {string} opts.word   - a word inside a node’s string that should\n   *                               be highlighted as the source of the error\n   * @param {number} opts.index  - an index inside a node’s string that should\n   *                               be highlighted as the source of the error\n   *\n   * @return {CssSyntaxError} error object to throw it\n   *\n   * @example\n   * if ( !variables[name] ) {\n   *   throw decl.error('Unknown variable ' + name, { word: name });\n   *   // CssSyntaxError: postcss-vars:a.sass:4:3: Unknown variable $black\n   *   //   color: $black\n   *   // a\n   *   //          ^\n   *   //   background: white\n   * }\n   */\n\n\n  Node.prototype.error = function error(message) {\n    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (this.source) {\n      var pos = this.positionBy(opts);\n      return this.source.input.error(message, pos.line, pos.column, opts);\n    } else {\n      return new _cssSyntaxError2.default(message);\n    }\n  };\n  /**\n   * This method is provided as a convenience wrapper for {@link Result#warn}.\n   *\n   * @param {Result} result      - the {@link Result} instance\n   *                               that will receive the warning\n   * @param {string} text        - warning message\n   * @param {object} [opts]      - options\n   * @param {string} opts.plugin - plugin name that created this warning.\n   *                               PostCSS will set it automatically.\n   * @param {string} opts.word   - a word inside a node’s string that should\n   *                               be highlighted as the source of the warning\n   * @param {number} opts.index  - an index inside a node’s string that should\n   *                               be highlighted as the source of the warning\n   *\n   * @return {Warning} created warning object\n   *\n   * @example\n   * const plugin = postcss.plugin('postcss-deprecated', () => {\n   *   return (root, result) => {\n   *     root.walkDecls('bad', decl => {\n   *       decl.warn(result, 'Deprecated property bad');\n   *     });\n   *   };\n   * });\n   */\n\n\n  Node.prototype.warn = function warn(result, text, opts) {\n    var data = {\n      node: this\n    };\n\n    for (var i in opts) {\n      data[i] = opts[i];\n    }\n\n    return result.warn(text, data);\n  };\n  /**\n   * Removes the node from its parent and cleans the parent properties\n   * from the node and its children.\n   *\n   * @example\n   * if ( decl.prop.match(/^-webkit-/) ) {\n   *   decl.remove();\n   * }\n   *\n   * @return {Node} node to make calls chain\n   */\n\n\n  Node.prototype.remove = function remove() {\n    if (this.parent) {\n      this.parent.removeChild(this);\n    }\n\n    this.parent = undefined;\n    return this;\n  };\n  /**\n   * Returns a CSS string representing the node.\n   *\n   * @param {stringifier|syntax} [stringifier] - a syntax to use\n   *                                             in string generation\n   *\n   * @return {string} CSS string of this node\n   *\n   * @example\n   * postcss.rule({ selector: 'a' }).toString() //=> \"a {}\"\n   */\n\n\n  Node.prototype.toString = function toString() {\n    var stringifier = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _stringify2.default;\n    if (stringifier.stringify) stringifier = stringifier.stringify;\n    var result = '';\n    stringifier(this, function (i) {\n      result += i;\n    });\n    return result;\n  };\n  /**\n   * Returns a clone of the node.\n   *\n   * The resulting cloned node and its (cloned) children will have\n   * a clean parent and code style properties.\n   *\n   * @param {object} [overrides] - new properties to override in the clone.\n   *\n   * @example\n   * const cloned = decl.clone({ prop: '-moz-' + decl.prop });\n   * cloned.raws.before  //=> undefined\n   * cloned.parent       //=> undefined\n   * cloned.toString()   //=> -moz-transform: scale(0)\n   *\n   * @return {Node} clone of the node\n   */\n\n\n  Node.prototype.clone = function clone() {\n    var overrides = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var cloned = cloneNode(this);\n\n    for (var name in overrides) {\n      cloned[name] = overrides[name];\n    }\n\n    return cloned;\n  };\n  /**\n   * Shortcut to clone the node and insert the resulting cloned node\n   * before the current node.\n   *\n   * @param {object} [overrides] - new properties to override in the clone.\n   *\n   * @example\n   * decl.cloneBefore({ prop: '-moz-' + decl.prop });\n   *\n   * @return {Node} - new node\n   */\n\n\n  Node.prototype.cloneBefore = function cloneBefore() {\n    var overrides = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var cloned = this.clone(overrides);\n    this.parent.insertBefore(this, cloned);\n    return cloned;\n  };\n  /**\n   * Shortcut to clone the node and insert the resulting cloned node\n   * after the current node.\n   *\n   * @param {object} [overrides] - new properties to override in the clone.\n   *\n   * @return {Node} - new node\n   */\n\n\n  Node.prototype.cloneAfter = function cloneAfter() {\n    var overrides = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var cloned = this.clone(overrides);\n    this.parent.insertAfter(this, cloned);\n    return cloned;\n  };\n  /**\n   * Inserts node(s) before the current node and removes the current node.\n   *\n   * @param {...Node} nodes - node(s) to replace current one\n   *\n   * @example\n   * if ( atrule.name == 'mixin' ) {\n   *   atrule.replaceWith(mixinRules[atrule.params]);\n   * }\n   *\n   * @return {Node} current node to methods chain\n   */\n\n\n  Node.prototype.replaceWith = function replaceWith() {\n    if (this.parent) {\n      for (var _len = arguments.length, nodes = Array(_len), _key = 0; _key < _len; _key++) {\n        nodes[_key] = arguments[_key];\n      }\n\n      for (var _iterator = nodes, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n        var _ref;\n\n        if (_isArray) {\n          if (_i >= _iterator.length) break;\n          _ref = _iterator[_i++];\n        } else {\n          _i = _iterator.next();\n          if (_i.done) break;\n          _ref = _i.value;\n        }\n\n        var node = _ref;\n        this.parent.insertBefore(this, node);\n      }\n\n      this.remove();\n    }\n\n    return this;\n  };\n  /**\n   * Removes the node from its current parent and inserts it\n   * at the end of `newParent`.\n   *\n   * This will clean the `before` and `after` code {@link Node#raws} data\n   * from the node and replace them with the indentation style of `newParent`.\n   * It will also clean the `between` property\n   * if `newParent` is in another {@link Root}.\n   *\n   * @param {Container} newParent - container node where the current node\n   *                                will be moved\n   *\n   * @example\n   * atrule.moveTo(atrule.root());\n   *\n   * @return {Node} current node to methods chain\n   */\n\n\n  Node.prototype.moveTo = function moveTo(newParent) {\n    this.cleanRaws(this.root() === newParent.root());\n    this.remove();\n    newParent.append(this);\n    return this;\n  };\n  /**\n   * Removes the node from its current parent and inserts it into\n   * a new parent before `otherNode`.\n   *\n   * This will also clean the node’s code style properties just as it would\n   * in {@link Node#moveTo}.\n   *\n   * @param {Node} otherNode - node that will be before current node\n   *\n   * @return {Node} current node to methods chain\n   */\n\n\n  Node.prototype.moveBefore = function moveBefore(otherNode) {\n    this.cleanRaws(this.root() === otherNode.root());\n    this.remove();\n    otherNode.parent.insertBefore(otherNode, this);\n    return this;\n  };\n  /**\n   * Removes the node from its current parent and inserts it into\n   * a new parent after `otherNode`.\n   *\n   * This will also clean the node’s code style properties just as it would\n   * in {@link Node#moveTo}.\n   *\n   * @param {Node} otherNode - node that will be after current node\n   *\n   * @return {Node} current node to methods chain\n   */\n\n\n  Node.prototype.moveAfter = function moveAfter(otherNode) {\n    this.cleanRaws(this.root() === otherNode.root());\n    this.remove();\n    otherNode.parent.insertAfter(otherNode, this);\n    return this;\n  };\n  /**\n   * Returns the next child of the node’s parent.\n   * Returns `undefined` if the current node is the last child.\n   *\n   * @return {Node|undefined} next node\n   *\n   * @example\n   * if ( comment.text === 'delete next' ) {\n   *   const next = comment.next();\n   *   if ( next ) {\n   *     next.remove();\n   *   }\n   * }\n   */\n\n\n  Node.prototype.next = function next() {\n    var index = this.parent.index(this);\n    return this.parent.nodes[index + 1];\n  };\n  /**\n   * Returns the previous child of the node’s parent.\n   * Returns `undefined` if the current node is the first child.\n   *\n   * @return {Node|undefined} previous node\n   *\n   * @example\n   * const annotation = decl.prev();\n   * if ( annotation.type == 'comment' ) {\n   *  readAnnotation(annotation.text);\n   * }\n   */\n\n\n  Node.prototype.prev = function prev() {\n    var index = this.parent.index(this);\n    return this.parent.nodes[index - 1];\n  };\n\n  Node.prototype.toJSON = function toJSON() {\n    var fixed = {};\n\n    for (var name in this) {\n      if (!this.hasOwnProperty(name)) continue;\n      if (name === 'parent') continue;\n      var value = this[name];\n\n      if (value instanceof Array) {\n        fixed[name] = value.map(function (i) {\n          if ((typeof i === 'undefined' ? 'undefined' : _typeof(i)) === 'object' && i.toJSON) {\n            return i.toJSON();\n          } else {\n            return i;\n          }\n        });\n      } else if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value.toJSON) {\n        fixed[name] = value.toJSON();\n      } else {\n        fixed[name] = value;\n      }\n    }\n\n    return fixed;\n  };\n  /**\n   * Returns a {@link Node#raws} value. If the node is missing\n   * the code style property (because the node was manually built or cloned),\n   * PostCSS will try to autodetect the code style property by looking\n   * at other nodes in the tree.\n   *\n   * @param {string} prop          - name of code style property\n   * @param {string} [defaultType] - name of default value, it can be missed\n   *                                 if the value is the same as prop\n   *\n   * @example\n   * const root = postcss.parse('a { background: white }');\n   * root.nodes[0].append({ prop: 'color', value: 'black' });\n   * root.nodes[0].nodes[1].raws.before   //=> undefined\n   * root.nodes[0].nodes[1].raw('before') //=> ' '\n   *\n   * @return {string} code style value\n   */\n\n\n  Node.prototype.raw = function raw(prop, defaultType) {\n    var str = new _stringifier2.default();\n    return str.raw(this, prop, defaultType);\n  };\n  /**\n   * Finds the Root instance of the node’s tree.\n   *\n   * @example\n   * root.nodes[0].nodes[0].root() === root\n   *\n   * @return {Root} root parent\n   */\n\n\n  Node.prototype.root = function root() {\n    var result = this;\n\n    while (result.parent) {\n      result = result.parent;\n    }\n\n    return result;\n  };\n\n  Node.prototype.cleanRaws = function cleanRaws(keepBetween) {\n    delete this.raws.before;\n    delete this.raws.after;\n    if (!keepBetween) delete this.raws.between;\n  };\n\n  Node.prototype.positionInside = function positionInside(index) {\n    var string = this.toString();\n    var column = this.source.start.column;\n    var line = this.source.start.line;\n\n    for (var i = 0; i < index; i++) {\n      if (string[i] === '\\n') {\n        column = 1;\n        line += 1;\n      } else {\n        column += 1;\n      }\n    }\n\n    return {\n      line: line,\n      column: column\n    };\n  };\n\n  Node.prototype.positionBy = function positionBy(opts) {\n    var pos = this.source.start;\n\n    if (opts.index) {\n      pos = this.positionInside(opts.index);\n    } else if (opts.word) {\n      var index = this.toString().indexOf(opts.word);\n      if (index !== -1) pos = this.positionInside(index);\n    }\n\n    return pos;\n  };\n\n  Node.prototype.removeSelf = function removeSelf() {\n    (0, _warnOnce2.default)('Node#removeSelf is deprecated. Use Node#remove.');\n    return this.remove();\n  };\n\n  Node.prototype.replace = function replace(nodes) {\n    (0, _warnOnce2.default)('Node#replace is deprecated. Use Node#replaceWith');\n    return this.replaceWith(nodes);\n  };\n\n  Node.prototype.style = function style(own, detect) {\n    (0, _warnOnce2.default)('Node#style() is deprecated. Use Node#raw()');\n    return this.raw(own, detect);\n  };\n\n  Node.prototype.cleanStyles = function cleanStyles(keepBetween) {\n    (0, _warnOnce2.default)('Node#cleanStyles() is deprecated. Use Node#cleanRaws()');\n    return this.cleanRaws(keepBetween);\n  };\n\n  _createClass(Node, [{\n    key: 'before',\n    get: function get() {\n      (0, _warnOnce2.default)('Node#before is deprecated. Use Node#raws.before');\n      return this.raws.before;\n    },\n    set: function set(val) {\n      (0, _warnOnce2.default)('Node#before is deprecated. Use Node#raws.before');\n      this.raws.before = val;\n    }\n  }, {\n    key: 'between',\n    get: function get() {\n      (0, _warnOnce2.default)('Node#between is deprecated. Use Node#raws.between');\n      return this.raws.between;\n    },\n    set: function set(val) {\n      (0, _warnOnce2.default)('Node#between is deprecated. Use Node#raws.between');\n      this.raws.between = val;\n    }\n    /**\n     * @memberof Node#\n     * @member {string} type - String representing the node’s type.\n     *                         Possible values are `root`, `atrule`, `rule`,\n     *                         `decl`, or `comment`.\n     *\n     * @example\n     * postcss.decl({ prop: 'color', value: 'black' }).type //=> 'decl'\n     */\n\n    /**\n     * @memberof Node#\n     * @member {Container} parent - the node’s parent node.\n     *\n     * @example\n     * root.nodes[0].parent == root;\n     */\n\n    /**\n     * @memberof Node#\n     * @member {source} source - the input source of the node\n     *\n     * The property is used in source map generation.\n     *\n     * If you create a node manually (e.g., with `postcss.decl()`),\n     * that node will not have a `source` property and will be absent\n     * from the source map. For this reason, the plugin developer should\n     * consider cloning nodes to create new ones (in which case the new node’s\n     * source will reference the original, cloned node) or setting\n     * the `source` property manually.\n     *\n     * ```js\n     * // Bad\n     * const prefixed = postcss.decl({\n     *   prop: '-moz-' + decl.prop,\n     *   value: decl.value\n     * });\n     *\n     * // Good\n     * const prefixed = decl.clone({ prop: '-moz-' + decl.prop });\n     * ```\n     *\n     * ```js\n     * if ( atrule.name == 'add-link' ) {\n     *   const rule = postcss.rule({ selector: 'a', source: atrule.source });\n     *   atrule.parent.insertBefore(atrule, rule);\n     * }\n     * ```\n     *\n     * @example\n     * decl.source.input.from //=> '/home/ai/a.sass'\n     * decl.source.start      //=> { line: 10, column: 2 }\n     * decl.source.end        //=> { line: 10, column: 12 }\n     */\n\n    /**\n     * @memberof Node#\n     * @member {object} raws - Information to generate byte-to-byte equal\n     *                         node string as it was in the origin input.\n     *\n     * Every parser saves its own properties,\n     * but the default CSS parser uses:\n     *\n     * * `before`: the space symbols before the node. It also stores `*`\n     *   and `_` symbols before the declaration (IE hack).\n     * * `after`: the space symbols after the last child of the node\n     *   to the end of the node.\n     * * `between`: the symbols between the property and value\n     *   for declarations, selector and `{` for rules, or last parameter\n     *   and `{` for at-rules.\n     * * `semicolon`: contains true if the last child has\n     *   an (optional) semicolon.\n     * * `afterName`: the space between the at-rule name and its parameters.\n     * * `left`: the space symbols between `/*` and the comment’s text.\n     * * `right`: the space symbols between the comment’s text\n     *   and <code>*&#47;</code>.\n     * * `important`: the content of the important statement,\n     *   if it is not just `!important`.\n     *\n     * PostCSS cleans selectors, declaration values and at-rule parameters\n     * from comments and extra spaces, but it stores origin content in raws\n     * properties. As such, if you don’t change a declaration’s value,\n     * PostCSS will use the raw value with comments.\n     *\n     * @example\n     * const root = postcss.parse('a {\\n  color:black\\n}')\n     * root.first.first.raws //=> { before: '\\n  ', between: ':' }\n     */\n\n  }]);\n\n  return Node;\n}();\n\nexports.default = Node;\n/**\n * @typedef {object} position\n * @property {number} line   - source line in file\n * @property {number} column - source column in file\n */\n\n/**\n * @typedef {object} source\n * @property {Input} input    - {@link Input} with input file\n * @property {position} start - The starting position of the node’s source\n * @property {position} end   - The ending position of the node’s source\n */\n\nmodule.exports = exports['default'];","map":{"version":3,"mappings":"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","names":["cloneNode","obj","parent","cloned","constructor","i","hasOwnProperty","value","type","Array","map","j","Node","defaults","_classCallCheck","raws","Error","JSON","stringify","name","error","message","opts","source","pos","positionBy","input","line","column","warn","result","text","data","node","remove","removeChild","undefined","toString","stringifier","clone","overrides","cloneBefore","insertBefore","cloneAfter","insertAfter","replaceWith","nodes","arguments","_ref","_i","moveTo","newParent","cleanRaws","root","append","moveBefore","otherNode","moveAfter","next","index","prev","toJSON","fixed","raw","prop","defaultType","str","keepBetween","before","after","between","positionInside","string","start","word","indexOf","removeSelf","replace","style","own","detect","cleanStyles","val"],"sources":["node.es6"],"sourcesContent":["import CssSyntaxError from './css-syntax-error';\nimport Stringifier    from './stringifier';\nimport stringify      from './stringify';\nimport warnOnce       from './warn-once';\n\nlet cloneNode = function (obj, parent) {\n    let cloned = new obj.constructor();\n\n    for ( let i in obj ) {\n        if ( !obj.hasOwnProperty(i) ) continue;\n        let value = obj[i];\n        let type  = typeof value;\n\n        if ( i === 'parent' && type === 'object' ) {\n            if (parent) cloned[i] = parent;\n        } else if ( i === 'source' ) {\n            cloned[i] = value;\n        } else if ( value instanceof Array ) {\n            cloned[i] = value.map( j => cloneNode(j, cloned) );\n        } else if ( i !== 'before'  && i !== 'after' &&\n                    i !== 'between' && i !== 'semicolon' ) {\n            if ( type === 'object' && value !== null ) value = cloneNode(value);\n            cloned[i] = value;\n        }\n    }\n\n    return cloned;\n};\n\n/**\n * All node classes inherit the following common methods.\n *\n * @abstract\n */\nclass Node {\n\n    /**\n     * @param {object} [defaults] - value for node properties\n     */\n    constructor(defaults = { }) {\n        this.raws = { };\n        if ( typeof defaults !== 'object' && typeof defaults !== 'undefined' ) {\n            throw new Error(\n                'PostCSS nodes constructor accepts object, not ' +\n                JSON.stringify(defaults));\n        }\n        for ( let name in defaults ) {\n            this[name] = defaults[name];\n        }\n    }\n\n    /**\n     * Returns a CssSyntaxError instance containing the original position\n     * of the node in the source, showing line and column numbers and also\n     * a small excerpt to facilitate debugging.\n     *\n     * If present, an input source map will be used to get the original position\n     * of the source, even from a previous compilation step\n     * (e.g., from Sass compilation).\n     *\n     * This method produces very useful error messages.\n     *\n     * @param {string} message     - error description\n     * @param {object} [opts]      - options\n     * @param {string} opts.plugin - plugin name that created this error.\n     *                               PostCSS will set it automatically.\n     * @param {string} opts.word   - a word inside a node’s string that should\n     *                               be highlighted as the source of the error\n     * @param {number} opts.index  - an index inside a node’s string that should\n     *                               be highlighted as the source of the error\n     *\n     * @return {CssSyntaxError} error object to throw it\n     *\n     * @example\n     * if ( !variables[name] ) {\n     *   throw decl.error('Unknown variable ' + name, { word: name });\n     *   // CssSyntaxError: postcss-vars:a.sass:4:3: Unknown variable $black\n     *   //   color: $black\n     *   // a\n     *   //          ^\n     *   //   background: white\n     * }\n     */\n    error(message, opts = { }) {\n        if ( this.source ) {\n            let pos = this.positionBy(opts);\n            return this.source.input.error(message, pos.line, pos.column, opts);\n        } else {\n            return new CssSyntaxError(message);\n        }\n    }\n\n    /**\n     * This method is provided as a convenience wrapper for {@link Result#warn}.\n     *\n     * @param {Result} result      - the {@link Result} instance\n     *                               that will receive the warning\n     * @param {string} text        - warning message\n     * @param {object} [opts]      - options\n     * @param {string} opts.plugin - plugin name that created this warning.\n     *                               PostCSS will set it automatically.\n     * @param {string} opts.word   - a word inside a node’s string that should\n     *                               be highlighted as the source of the warning\n     * @param {number} opts.index  - an index inside a node’s string that should\n     *                               be highlighted as the source of the warning\n     *\n     * @return {Warning} created warning object\n     *\n     * @example\n     * const plugin = postcss.plugin('postcss-deprecated', () => {\n     *   return (root, result) => {\n     *     root.walkDecls('bad', decl => {\n     *       decl.warn(result, 'Deprecated property bad');\n     *     });\n     *   };\n     * });\n     */\n    warn(result, text, opts) {\n        let data = { node: this };\n        for ( let i in opts ) data[i] = opts[i];\n        return result.warn(text, data);\n    }\n\n    /**\n     * Removes the node from its parent and cleans the parent properties\n     * from the node and its children.\n     *\n     * @example\n     * if ( decl.prop.match(/^-webkit-/) ) {\n     *   decl.remove();\n     * }\n     *\n     * @return {Node} node to make calls chain\n     */\n    remove() {\n        if ( this.parent ) {\n            this.parent.removeChild(this);\n        }\n        this.parent = undefined;\n        return this;\n    }\n\n    /**\n     * Returns a CSS string representing the node.\n     *\n     * @param {stringifier|syntax} [stringifier] - a syntax to use\n     *                                             in string generation\n     *\n     * @return {string} CSS string of this node\n     *\n     * @example\n     * postcss.rule({ selector: 'a' }).toString() //=> \"a {}\"\n     */\n    toString(stringifier = stringify) {\n        if ( stringifier.stringify ) stringifier = stringifier.stringify;\n        let result  = '';\n        stringifier(this, i => {\n            result += i;\n        });\n        return result;\n    }\n\n    /**\n     * Returns a clone of the node.\n     *\n     * The resulting cloned node and its (cloned) children will have\n     * a clean parent and code style properties.\n     *\n     * @param {object} [overrides] - new properties to override in the clone.\n     *\n     * @example\n     * const cloned = decl.clone({ prop: '-moz-' + decl.prop });\n     * cloned.raws.before  //=> undefined\n     * cloned.parent       //=> undefined\n     * cloned.toString()   //=> -moz-transform: scale(0)\n     *\n     * @return {Node} clone of the node\n     */\n    clone(overrides = { }) {\n        let cloned = cloneNode(this);\n        for ( let name in overrides ) {\n            cloned[name] = overrides[name];\n        }\n        return cloned;\n    }\n\n    /**\n     * Shortcut to clone the node and insert the resulting cloned node\n     * before the current node.\n     *\n     * @param {object} [overrides] - new properties to override in the clone.\n     *\n     * @example\n     * decl.cloneBefore({ prop: '-moz-' + decl.prop });\n     *\n     * @return {Node} - new node\n     */\n    cloneBefore(overrides = { }) {\n        let cloned = this.clone(overrides);\n        this.parent.insertBefore(this, cloned);\n        return cloned;\n    }\n\n    /**\n     * Shortcut to clone the node and insert the resulting cloned node\n     * after the current node.\n     *\n     * @param {object} [overrides] - new properties to override in the clone.\n     *\n     * @return {Node} - new node\n     */\n    cloneAfter(overrides = { }) {\n        let cloned = this.clone(overrides);\n        this.parent.insertAfter(this, cloned);\n        return cloned;\n    }\n\n    /**\n     * Inserts node(s) before the current node and removes the current node.\n     *\n     * @param {...Node} nodes - node(s) to replace current one\n     *\n     * @example\n     * if ( atrule.name == 'mixin' ) {\n     *   atrule.replaceWith(mixinRules[atrule.params]);\n     * }\n     *\n     * @return {Node} current node to methods chain\n     */\n    replaceWith(...nodes) {\n        if (this.parent) {\n            for (let node of nodes) {\n                this.parent.insertBefore(this, node);\n            }\n\n            this.remove();\n        }\n\n        return this;\n    }\n\n    /**\n     * Removes the node from its current parent and inserts it\n     * at the end of `newParent`.\n     *\n     * This will clean the `before` and `after` code {@link Node#raws} data\n     * from the node and replace them with the indentation style of `newParent`.\n     * It will also clean the `between` property\n     * if `newParent` is in another {@link Root}.\n     *\n     * @param {Container} newParent - container node where the current node\n     *                                will be moved\n     *\n     * @example\n     * atrule.moveTo(atrule.root());\n     *\n     * @return {Node} current node to methods chain\n     */\n    moveTo(newParent) {\n        this.cleanRaws(this.root() === newParent.root());\n        this.remove();\n        newParent.append(this);\n        return this;\n    }\n\n    /**\n     * Removes the node from its current parent and inserts it into\n     * a new parent before `otherNode`.\n     *\n     * This will also clean the node’s code style properties just as it would\n     * in {@link Node#moveTo}.\n     *\n     * @param {Node} otherNode - node that will be before current node\n     *\n     * @return {Node} current node to methods chain\n     */\n    moveBefore(otherNode) {\n        this.cleanRaws(this.root() === otherNode.root());\n        this.remove();\n        otherNode.parent.insertBefore(otherNode, this);\n        return this;\n    }\n\n    /**\n     * Removes the node from its current parent and inserts it into\n     * a new parent after `otherNode`.\n     *\n     * This will also clean the node’s code style properties just as it would\n     * in {@link Node#moveTo}.\n     *\n     * @param {Node} otherNode - node that will be after current node\n     *\n     * @return {Node} current node to methods chain\n     */\n    moveAfter(otherNode) {\n        this.cleanRaws(this.root() === otherNode.root());\n        this.remove();\n        otherNode.parent.insertAfter(otherNode, this);\n        return this;\n    }\n\n    /**\n     * Returns the next child of the node’s parent.\n     * Returns `undefined` if the current node is the last child.\n     *\n     * @return {Node|undefined} next node\n     *\n     * @example\n     * if ( comment.text === 'delete next' ) {\n     *   const next = comment.next();\n     *   if ( next ) {\n     *     next.remove();\n     *   }\n     * }\n     */\n    next() {\n        let index = this.parent.index(this);\n        return this.parent.nodes[index + 1];\n    }\n\n    /**\n     * Returns the previous child of the node’s parent.\n     * Returns `undefined` if the current node is the first child.\n     *\n     * @return {Node|undefined} previous node\n     *\n     * @example\n     * const annotation = decl.prev();\n     * if ( annotation.type == 'comment' ) {\n     *  readAnnotation(annotation.text);\n     * }\n     */\n    prev() {\n        let index = this.parent.index(this);\n        return this.parent.nodes[index - 1];\n    }\n\n    toJSON() {\n        let fixed = { };\n\n        for ( let name in this ) {\n            if ( !this.hasOwnProperty(name) ) continue;\n            if ( name === 'parent' ) continue;\n            let value = this[name];\n\n            if ( value instanceof Array ) {\n                fixed[name] = value.map( i => {\n                    if ( typeof i === 'object' && i.toJSON ) {\n                        return i.toJSON();\n                    } else {\n                        return i;\n                    }\n                });\n            } else if ( typeof value === 'object' && value.toJSON ) {\n                fixed[name] = value.toJSON();\n            } else {\n                fixed[name] = value;\n            }\n        }\n\n        return fixed;\n    }\n\n    /**\n     * Returns a {@link Node#raws} value. If the node is missing\n     * the code style property (because the node was manually built or cloned),\n     * PostCSS will try to autodetect the code style property by looking\n     * at other nodes in the tree.\n     *\n     * @param {string} prop          - name of code style property\n     * @param {string} [defaultType] - name of default value, it can be missed\n     *                                 if the value is the same as prop\n     *\n     * @example\n     * const root = postcss.parse('a { background: white }');\n     * root.nodes[0].append({ prop: 'color', value: 'black' });\n     * root.nodes[0].nodes[1].raws.before   //=> undefined\n     * root.nodes[0].nodes[1].raw('before') //=> ' '\n     *\n     * @return {string} code style value\n     */\n    raw(prop, defaultType) {\n        let str = new Stringifier();\n        return str.raw(this, prop, defaultType);\n    }\n\n    /**\n     * Finds the Root instance of the node’s tree.\n     *\n     * @example\n     * root.nodes[0].nodes[0].root() === root\n     *\n     * @return {Root} root parent\n     */\n    root() {\n        let result = this;\n        while ( result.parent ) result = result.parent;\n        return result;\n    }\n\n    cleanRaws(keepBetween) {\n        delete this.raws.before;\n        delete this.raws.after;\n        if ( !keepBetween ) delete this.raws.between;\n    }\n\n    positionInside(index) {\n        let string = this.toString();\n        let column = this.source.start.column;\n        let line   = this.source.start.line;\n\n        for ( let i = 0; i < index; i++ ) {\n            if ( string[i] === '\\n' ) {\n                column = 1;\n                line  += 1;\n            } else {\n                column += 1;\n            }\n        }\n\n        return { line, column };\n    }\n\n    positionBy(opts) {\n        let pos = this.source.start;\n        if ( opts.index ) {\n            pos = this.positionInside(opts.index);\n        } else if ( opts.word ) {\n            let index = this.toString().indexOf(opts.word);\n            if ( index !== -1 ) pos = this.positionInside(index);\n        }\n        return pos;\n    }\n\n    removeSelf() {\n        warnOnce('Node#removeSelf is deprecated. Use Node#remove.');\n        return this.remove();\n    }\n\n    replace(nodes) {\n        warnOnce('Node#replace is deprecated. Use Node#replaceWith');\n        return this.replaceWith(nodes);\n    }\n\n    style(own, detect) {\n        warnOnce('Node#style() is deprecated. Use Node#raw()');\n        return this.raw(own, detect);\n    }\n\n    cleanStyles(keepBetween) {\n        warnOnce('Node#cleanStyles() is deprecated. Use Node#cleanRaws()');\n        return this.cleanRaws(keepBetween);\n    }\n\n    get before() {\n        warnOnce('Node#before is deprecated. Use Node#raws.before');\n        return this.raws.before;\n    }\n\n    set before(val) {\n        warnOnce('Node#before is deprecated. Use Node#raws.before');\n        this.raws.before = val;\n    }\n\n    get between() {\n        warnOnce('Node#between is deprecated. Use Node#raws.between');\n        return this.raws.between;\n    }\n\n    set between(val) {\n        warnOnce('Node#between is deprecated. Use Node#raws.between');\n        this.raws.between = val;\n    }\n\n    /**\n     * @memberof Node#\n     * @member {string} type - String representing the node’s type.\n     *                         Possible values are `root`, `atrule`, `rule`,\n     *                         `decl`, or `comment`.\n     *\n     * @example\n     * postcss.decl({ prop: 'color', value: 'black' }).type //=> 'decl'\n     */\n\n    /**\n     * @memberof Node#\n     * @member {Container} parent - the node’s parent node.\n     *\n     * @example\n     * root.nodes[0].parent == root;\n     */\n\n    /**\n     * @memberof Node#\n     * @member {source} source - the input source of the node\n     *\n     * The property is used in source map generation.\n     *\n     * If you create a node manually (e.g., with `postcss.decl()`),\n     * that node will not have a `source` property and will be absent\n     * from the source map. For this reason, the plugin developer should\n     * consider cloning nodes to create new ones (in which case the new node’s\n     * source will reference the original, cloned node) or setting\n     * the `source` property manually.\n     *\n     * ```js\n     * // Bad\n     * const prefixed = postcss.decl({\n     *   prop: '-moz-' + decl.prop,\n     *   value: decl.value\n     * });\n     *\n     * // Good\n     * const prefixed = decl.clone({ prop: '-moz-' + decl.prop });\n     * ```\n     *\n     * ```js\n     * if ( atrule.name == 'add-link' ) {\n     *   const rule = postcss.rule({ selector: 'a', source: atrule.source });\n     *   atrule.parent.insertBefore(atrule, rule);\n     * }\n     * ```\n     *\n     * @example\n     * decl.source.input.from //=> '/home/ai/a.sass'\n     * decl.source.start      //=> { line: 10, column: 2 }\n     * decl.source.end        //=> { line: 10, column: 12 }\n     */\n\n    /**\n     * @memberof Node#\n     * @member {object} raws - Information to generate byte-to-byte equal\n     *                         node string as it was in the origin input.\n     *\n     * Every parser saves its own properties,\n     * but the default CSS parser uses:\n     *\n     * * `before`: the space symbols before the node. It also stores `*`\n     *   and `_` symbols before the declaration (IE hack).\n     * * `after`: the space symbols after the last child of the node\n     *   to the end of the node.\n     * * `between`: the symbols between the property and value\n     *   for declarations, selector and `{` for rules, or last parameter\n     *   and `{` for at-rules.\n     * * `semicolon`: contains true if the last child has\n     *   an (optional) semicolon.\n     * * `afterName`: the space between the at-rule name and its parameters.\n     * * `left`: the space symbols between `/*` and the comment’s text.\n     * * `right`: the space symbols between the comment’s text\n     *   and <code>*&#47;</code>.\n     * * `important`: the content of the important statement,\n     *   if it is not just `!important`.\n     *\n     * PostCSS cleans selectors, declaration values and at-rule parameters\n     * from comments and extra spaces, but it stores origin content in raws\n     * properties. As such, if you don’t change a declaration’s value,\n     * PostCSS will use the raw value with comments.\n     *\n     * @example\n     * const root = postcss.parse('a {\\n  color:black\\n}')\n     * root.first.first.raws //=> { before: '\\n  ', between: ':' }\n     */\n\n}\n\nexport default Node;\n\n/**\n * @typedef {object} position\n * @property {number} line   - source line in file\n * @property {number} column - source column in file\n */\n\n/**\n * @typedef {object} source\n * @property {Input} input    - {@link Input} with input file\n * @property {position} start - The starting position of the node’s source\n * @property {position} end   - The ending position of the node’s source\n */\n"]},"metadata":{},"sourceType":"script"}