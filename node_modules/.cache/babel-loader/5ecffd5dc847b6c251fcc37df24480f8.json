{"ast":null,"code":"// TODO Shader library\nimport Pass from './Pass';\nimport CompositorNode from './CompositorNode'; // TODO curlnoise demo wrong\n// PENDING\n// Use topological sort ?\n\n/**\n * Filter node\n *\n * @constructor clay.compositor.FilterNode\n * @extends clay.compositor.CompositorNode\n *\n * @example\n    var node = new clay.compositor.FilterNode({\n        name: 'fxaa',\n        shader: clay.Shader.source('clay.compositor.fxaa'),\n        inputs: {\n            texture: {\n                    node: 'scene',\n                    pin: 'color'\n            }\n        },\n        // Multiple outputs is preserved for MRT support in WebGL2.0\n        outputs: {\n            color: {\n                attachment: clay.FrameBuffer.COLOR_ATTACHMENT0\n                parameters: {\n                    format: clay.Texture.RGBA,\n                    width: 512,\n                    height: 512\n                },\n                // Node will keep the RTT rendered in last frame\n                keepLastFrame: true,\n                // Force the node output the RTT rendered in last frame\n                outputLastFrame: true\n            }\n        }\n    });\n    *\n    */\n\nvar FilterNode = CompositorNode.extend(function () {\n  return (\n    /** @lends clay.compositor.FilterNode# */\n    {\n      /**\n       * @type {string}\n       */\n      name: '',\n\n      /**\n       * @type {Object}\n       */\n      inputs: {},\n\n      /**\n       * @type {Object}\n       */\n      outputs: null,\n\n      /**\n       * @type {string}\n       */\n      shader: '',\n\n      /**\n       * Input links, will be updated by the graph\n       * @example:\n       *     inputName: {\n       *         node: someNode,\n       *         pin: 'xxxx'\n       *     }\n       * @type {Object}\n       */\n      inputLinks: {},\n\n      /**\n       * Output links, will be updated by the graph\n       * @example:\n       *     outputName: {\n       *         node: someNode,\n       *         pin: 'xxxx'\n       *     }\n       * @type {Object}\n       */\n      outputLinks: {},\n\n      /**\n       * @type {clay.compositor.Pass}\n       */\n      pass: null,\n      // Save the output texture of previous frame\n      // Will be used when there exist a circular reference\n      _prevOutputTextures: {},\n      _outputTextures: {},\n      // Example: { name: 2 }\n      _outputReferences: {},\n      _rendering: false,\n      // If rendered in this frame\n      _rendered: false,\n      _compositor: null\n    }\n  );\n}, function () {\n  var pass = new Pass({\n    fragment: this.shader\n  });\n  this.pass = pass;\n},\n/** @lends clay.compositor.FilterNode.prototype */\n{\n  /**\n   * @param  {clay.Renderer} renderer\n   */\n  render: function render(renderer, frameBuffer) {\n    this.trigger('beforerender', renderer);\n    this._rendering = true;\n    var _gl = renderer.gl;\n\n    for (var inputName in this.inputLinks) {\n      var link = this.inputLinks[inputName];\n      var inputTexture = link.node.getOutput(renderer, link.pin);\n      this.pass.setUniform(inputName, inputTexture);\n    } // Output\n\n\n    if (!this.outputs) {\n      this.pass.outputs = null;\n\n      this._compositor.getFrameBuffer().unbind(renderer);\n\n      this.pass.render(renderer, frameBuffer);\n    } else {\n      this.pass.outputs = {};\n      var attachedTextures = {};\n\n      for (var name in this.outputs) {\n        var parameters = this.updateParameter(name, renderer);\n\n        if (isNaN(parameters.width)) {\n          this.updateParameter(name, renderer);\n        }\n\n        var outputInfo = this.outputs[name];\n\n        var texture = this._compositor.allocateTexture(parameters);\n\n        this._outputTextures[name] = texture;\n        var attachment = outputInfo.attachment || _gl.COLOR_ATTACHMENT0;\n\n        if (typeof attachment === 'string') {\n          attachment = _gl[attachment];\n        }\n\n        attachedTextures[attachment] = texture;\n      }\n\n      this._compositor.getFrameBuffer().bind(renderer);\n\n      for (var attachment in attachedTextures) {\n        // FIXME attachment changes in different nodes\n        this._compositor.getFrameBuffer().attach(attachedTextures[attachment], attachment);\n      }\n\n      this.pass.render(renderer); // Because the data of texture is changed over time,\n      // Here update the mipmaps of texture each time after rendered;\n\n      this._compositor.getFrameBuffer().updateMipmap(renderer);\n    }\n\n    for (var inputName in this.inputLinks) {\n      var link = this.inputLinks[inputName];\n      link.node.removeReference(link.pin);\n    }\n\n    this._rendering = false;\n    this._rendered = true;\n    this.trigger('afterrender', renderer);\n  },\n  // TODO Remove parameter function callback\n  updateParameter: function updateParameter(outputName, renderer) {\n    var outputInfo = this.outputs[outputName];\n    var parameters = outputInfo.parameters;\n    var parametersCopy = outputInfo._parametersCopy;\n\n    if (!parametersCopy) {\n      parametersCopy = outputInfo._parametersCopy = {};\n    }\n\n    if (parameters) {\n      for (var key in parameters) {\n        if (key !== 'width' && key !== 'height') {\n          parametersCopy[key] = parameters[key];\n        }\n      }\n    }\n\n    var width, height;\n\n    if (typeof parameters.width === 'function') {\n      width = parameters.width.call(this, renderer);\n    } else {\n      width = parameters.width;\n    }\n\n    if (typeof parameters.height === 'function') {\n      height = parameters.height.call(this, renderer);\n    } else {\n      height = parameters.height;\n    }\n\n    width = Math.ceil(width);\n    height = Math.ceil(height);\n\n    if (parametersCopy.width !== width || parametersCopy.height !== height) {\n      if (this._outputTextures[outputName]) {\n        this._outputTextures[outputName].dispose(renderer);\n      }\n    }\n\n    parametersCopy.width = width;\n    parametersCopy.height = height;\n    return parametersCopy;\n  },\n\n  /**\n   * Set parameter\n   * @param {string} name\n   * @param {} value\n   */\n  setParameter: function setParameter(name, value) {\n    this.pass.setUniform(name, value);\n  },\n\n  /**\n   * Get parameter value\n   * @param  {string} name\n   * @return {}\n   */\n  getParameter: function getParameter(name) {\n    return this.pass.getUniform(name);\n  },\n\n  /**\n   * Set parameters\n   * @param {Object} obj\n   */\n  setParameters: function setParameters(obj) {\n    for (var name in obj) {\n      this.setParameter(name, obj[name]);\n    }\n  },\n  // /**\n  //  * Set shader code\n  //  * @param {string} shaderStr\n  //  */\n  // setShader: function (shaderStr) {\n  //     var material = this.pass.material;\n  //     material.shader.setFragment(shaderStr);\n  //     material.attachShader(material.shader, true);\n  // },\n\n  /**\n   * Proxy of pass.material.define('fragment', xxx);\n   * @param  {string} symbol\n   * @param  {number} [val]\n   */\n  define: function define(symbol, val) {\n    this.pass.material.define('fragment', symbol, val);\n  },\n\n  /**\n   * Proxy of pass.material.undefine('fragment', xxx)\n   * @param  {string} symbol\n   */\n  undefine: function undefine(symbol) {\n    this.pass.material.undefine('fragment', symbol);\n  },\n  removeReference: function removeReference(outputName) {\n    this._outputReferences[outputName]--;\n\n    if (this._outputReferences[outputName] === 0) {\n      var outputInfo = this.outputs[outputName];\n\n      if (outputInfo.keepLastFrame) {\n        if (this._prevOutputTextures[outputName]) {\n          this._compositor.releaseTexture(this._prevOutputTextures[outputName]);\n        }\n\n        this._prevOutputTextures[outputName] = this._outputTextures[outputName];\n      } else {\n        // Output of this node have alreay been used by all other nodes\n        // Put the texture back to the pool.\n        this._compositor.releaseTexture(this._outputTextures[outputName]);\n      }\n    }\n  },\n  clear: function clear() {\n    CompositorNode.prototype.clear.call(this); // Default disable all texture\n\n    this.pass.material.disableTexturesAll();\n  }\n});\nexport default FilterNode;","map":{"version":3,"sources":["C:/Users/Administrator/Desktop/data_view/my_project/vue2_app/myapp/node_modules/claygl/src/compositor/FilterNode.js"],"names":["Pass","CompositorNode","FilterNode","extend","name","inputs","outputs","shader","inputLinks","outputLinks","pass","_prevOutputTextures","_outputTextures","_outputReferences","_rendering","_rendered","_compositor","fragment","render","renderer","frameBuffer","trigger","_gl","gl","inputName","link","inputTexture","node","getOutput","pin","setUniform","getFrameBuffer","unbind","attachedTextures","parameters","updateParameter","isNaN","width","outputInfo","texture","allocateTexture","attachment","COLOR_ATTACHMENT0","bind","attach","updateMipmap","removeReference","outputName","parametersCopy","_parametersCopy","key","height","call","Math","ceil","dispose","setParameter","value","getParameter","getUniform","setParameters","obj","define","symbol","val","material","undefine","keepLastFrame","releaseTexture","clear","prototype","disableTexturesAll"],"mappings":"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","sourcesContent":["// TODO Shader library\nimport Pass from './Pass';\nimport CompositorNode from './CompositorNode';\n\n// TODO curlnoise demo wrong\n\n// PENDING\n// Use topological sort ?\n\n/**\n * Filter node\n *\n * @constructor clay.compositor.FilterNode\n * @extends clay.compositor.CompositorNode\n *\n * @example\n    var node = new clay.compositor.FilterNode({\n        name: 'fxaa',\n        shader: clay.Shader.source('clay.compositor.fxaa'),\n        inputs: {\n            texture: {\n                    node: 'scene',\n                    pin: 'color'\n            }\n        },\n        // Multiple outputs is preserved for MRT support in WebGL2.0\n        outputs: {\n            color: {\n                attachment: clay.FrameBuffer.COLOR_ATTACHMENT0\n                parameters: {\n                    format: clay.Texture.RGBA,\n                    width: 512,\n                    height: 512\n                },\n                // Node will keep the RTT rendered in last frame\n                keepLastFrame: true,\n                // Force the node output the RTT rendered in last frame\n                outputLastFrame: true\n            }\n        }\n    });\n    *\n    */\nvar FilterNode = CompositorNode.extend(function () {\n    return /** @lends clay.compositor.FilterNode# */ {\n        /**\n         * @type {string}\n         */\n        name: '',\n\n        /**\n         * @type {Object}\n         */\n        inputs: {},\n\n        /**\n         * @type {Object}\n         */\n        outputs: null,\n\n        /**\n         * @type {string}\n         */\n        shader: '',\n\n        /**\n         * Input links, will be updated by the graph\n         * @example:\n         *     inputName: {\n         *         node: someNode,\n         *         pin: 'xxxx'\n         *     }\n         * @type {Object}\n         */\n        inputLinks: {},\n\n        /**\n         * Output links, will be updated by the graph\n         * @example:\n         *     outputName: {\n         *         node: someNode,\n         *         pin: 'xxxx'\n         *     }\n         * @type {Object}\n         */\n        outputLinks: {},\n\n        /**\n         * @type {clay.compositor.Pass}\n         */\n        pass: null,\n\n        // Save the output texture of previous frame\n        // Will be used when there exist a circular reference\n        _prevOutputTextures: {},\n        _outputTextures: {},\n\n        // Example: { name: 2 }\n        _outputReferences: {},\n\n        _rendering: false,\n        // If rendered in this frame\n        _rendered: false,\n\n        _compositor: null\n    };\n}, function () {\n\n    var pass = new Pass({\n        fragment: this.shader\n    });\n    this.pass = pass;\n},\n/** @lends clay.compositor.FilterNode.prototype */\n{\n    /**\n     * @param  {clay.Renderer} renderer\n     */\n    render: function (renderer, frameBuffer) {\n        this.trigger('beforerender', renderer);\n\n        this._rendering = true;\n\n        var _gl = renderer.gl;\n\n        for (var inputName in this.inputLinks) {\n            var link = this.inputLinks[inputName];\n            var inputTexture = link.node.getOutput(renderer, link.pin);\n            this.pass.setUniform(inputName, inputTexture);\n        }\n        // Output\n        if (!this.outputs) {\n            this.pass.outputs = null;\n\n            this._compositor.getFrameBuffer().unbind(renderer);\n\n            this.pass.render(renderer, frameBuffer);\n        }\n        else {\n            this.pass.outputs = {};\n\n            var attachedTextures = {};\n            for (var name in this.outputs) {\n                var parameters = this.updateParameter(name, renderer);\n                if (isNaN(parameters.width)) {\n                    this.updateParameter(name, renderer);\n                }\n                var outputInfo = this.outputs[name];\n                var texture = this._compositor.allocateTexture(parameters);\n                this._outputTextures[name] = texture;\n                var attachment = outputInfo.attachment || _gl.COLOR_ATTACHMENT0;\n                if (typeof(attachment) === 'string') {\n                    attachment = _gl[attachment];\n                }\n                attachedTextures[attachment] = texture;\n            }\n            this._compositor.getFrameBuffer().bind(renderer);\n\n            for (var attachment in attachedTextures) {\n                // FIXME attachment changes in different nodes\n                this._compositor.getFrameBuffer().attach(\n                    attachedTextures[attachment], attachment\n                );\n            }\n\n            this.pass.render(renderer);\n\n            // Because the data of texture is changed over time,\n            // Here update the mipmaps of texture each time after rendered;\n            this._compositor.getFrameBuffer().updateMipmap(renderer);\n        }\n\n        for (var inputName in this.inputLinks) {\n            var link = this.inputLinks[inputName];\n            link.node.removeReference(link.pin);\n        }\n\n        this._rendering = false;\n        this._rendered = true;\n\n        this.trigger('afterrender', renderer);\n    },\n\n    // TODO Remove parameter function callback\n    updateParameter: function (outputName, renderer) {\n        var outputInfo = this.outputs[outputName];\n        var parameters = outputInfo.parameters;\n        var parametersCopy = outputInfo._parametersCopy;\n        if (!parametersCopy) {\n            parametersCopy = outputInfo._parametersCopy = {};\n        }\n        if (parameters) {\n            for (var key in parameters) {\n                if (key !== 'width' && key !== 'height') {\n                    parametersCopy[key] = parameters[key];\n                }\n            }\n        }\n        var width, height;\n        if (typeof parameters.width === 'function') {\n            width = parameters.width.call(this, renderer);\n        }\n        else {\n            width = parameters.width;\n        }\n        if (typeof parameters.height === 'function') {\n            height = parameters.height.call(this, renderer);\n        }\n        else {\n            height = parameters.height;\n        }\n        width = Math.ceil(width);\n        height = Math.ceil(height);\n        if (\n            parametersCopy.width !== width\n            || parametersCopy.height !== height\n        ) {\n            if (this._outputTextures[outputName]) {\n                this._outputTextures[outputName].dispose(renderer);\n            }\n        }\n        parametersCopy.width = width;\n        parametersCopy.height = height;\n\n        return parametersCopy;\n    },\n\n    /**\n     * Set parameter\n     * @param {string} name\n     * @param {} value\n     */\n    setParameter: function (name, value) {\n        this.pass.setUniform(name, value);\n    },\n    /**\n     * Get parameter value\n     * @param  {string} name\n     * @return {}\n     */\n    getParameter: function (name) {\n        return this.pass.getUniform(name);\n    },\n    /**\n     * Set parameters\n     * @param {Object} obj\n     */\n    setParameters: function (obj) {\n        for (var name in obj) {\n            this.setParameter(name, obj[name]);\n        }\n    },\n    // /**\n    //  * Set shader code\n    //  * @param {string} shaderStr\n    //  */\n    // setShader: function (shaderStr) {\n    //     var material = this.pass.material;\n    //     material.shader.setFragment(shaderStr);\n    //     material.attachShader(material.shader, true);\n    // },\n    /**\n     * Proxy of pass.material.define('fragment', xxx);\n     * @param  {string} symbol\n     * @param  {number} [val]\n     */\n    define: function (symbol, val) {\n        this.pass.material.define('fragment', symbol, val);\n    },\n\n    /**\n     * Proxy of pass.material.undefine('fragment', xxx)\n     * @param  {string} symbol\n     */\n    undefine: function (symbol) {\n        this.pass.material.undefine('fragment', symbol);\n    },\n\n    removeReference: function (outputName) {\n        this._outputReferences[outputName]--;\n        if (this._outputReferences[outputName] === 0) {\n            var outputInfo = this.outputs[outputName];\n            if (outputInfo.keepLastFrame) {\n                if (this._prevOutputTextures[outputName]) {\n                    this._compositor.releaseTexture(this._prevOutputTextures[outputName]);\n                }\n                this._prevOutputTextures[outputName] = this._outputTextures[outputName];\n            }\n            else {\n                // Output of this node have alreay been used by all other nodes\n                // Put the texture back to the pool.\n                this._compositor.releaseTexture(this._outputTextures[outputName]);\n            }\n        }\n    },\n\n    clear: function () {\n        CompositorNode.prototype.clear.call(this);\n\n        // Default disable all texture\n        this.pass.material.disableTexturesAll();\n    }\n});\n\nexport default FilterNode;\n"]},"metadata":{},"sourceType":"module"}