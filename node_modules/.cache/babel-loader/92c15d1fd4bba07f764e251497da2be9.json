{"ast":null,"code":"import \"core-js/modules/es.string.trim.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport util from './core/util';\nimport Compositor from './compositor/Compositor';\nimport CompoSceneNode from './compositor/SceneNode';\nimport CompoTextureNode from './compositor/TextureNode';\nimport CompoFilterNode from './compositor/FilterNode';\nimport Shader from './Shader';\nimport Texture from './Texture';\nimport Texture2D from './Texture2D';\nimport TextureCube from './TextureCube';\nimport registerBuiltinCompositor from './shader/registerBuiltinCompositor';\nregisterBuiltinCompositor(Shader);\nvar shaderSourceReg = /^#source\\((.*?)\\)/;\n/**\n * @name clay.createCompositor\n * @function\n * @param {Object} json\n * @param {Object} [opts]\n * @return {clay.compositor.Compositor}\n */\n\nfunction createCompositor(json, opts) {\n  var compositor = new Compositor();\n  opts = opts || {};\n  var lib = {\n    textures: {},\n    parameters: {}\n  };\n\n  var afterLoad = function afterLoad(shaderLib, textureLib) {\n    for (var i = 0; i < json.nodes.length; i++) {\n      var nodeInfo = json.nodes[i];\n      var node = createNode(nodeInfo, lib, opts);\n\n      if (node) {\n        compositor.addNode(node);\n      }\n    }\n  };\n\n  for (var name in json.parameters) {\n    var paramInfo = json.parameters[name];\n    lib.parameters[name] = convertParameter(paramInfo);\n  } // TODO load texture asynchronous\n\n\n  loadTextures(json, lib, opts, function (textureLib) {\n    lib.textures = textureLib;\n    afterLoad();\n  });\n  return compositor;\n}\n\nfunction createNode(nodeInfo, lib, opts) {\n  var type = nodeInfo.type || 'filter';\n  var shaderSource;\n  var inputs;\n  var outputs;\n\n  if (type === 'filter') {\n    var shaderExp = nodeInfo.shader.trim();\n    var res = shaderSourceReg.exec(shaderExp);\n\n    if (res) {\n      shaderSource = Shader.source(res[1].trim());\n    } else if (shaderExp.charAt(0) === '#') {\n      shaderSource = lib.shaders[shaderExp.substr(1)];\n    }\n\n    if (!shaderSource) {\n      shaderSource = shaderExp;\n    }\n\n    if (!shaderSource) {\n      return;\n    }\n  }\n\n  if (nodeInfo.inputs) {\n    inputs = {};\n\n    for (var name in nodeInfo.inputs) {\n      if (typeof nodeInfo.inputs[name] === 'string') {\n        inputs[name] = nodeInfo.inputs[name];\n      } else {\n        inputs[name] = {\n          node: nodeInfo.inputs[name].node,\n          pin: nodeInfo.inputs[name].pin\n        };\n      }\n    }\n  }\n\n  if (nodeInfo.outputs) {\n    outputs = {};\n\n    for (var name in nodeInfo.outputs) {\n      var outputInfo = nodeInfo.outputs[name];\n      outputs[name] = {};\n\n      if (outputInfo.attachment != null) {\n        outputs[name].attachment = outputInfo.attachment;\n      }\n\n      if (outputInfo.keepLastFrame != null) {\n        outputs[name].keepLastFrame = outputInfo.keepLastFrame;\n      }\n\n      if (outputInfo.outputLastFrame != null) {\n        outputs[name].outputLastFrame = outputInfo.outputLastFrame;\n      }\n\n      if (outputInfo.parameters) {\n        outputs[name].parameters = convertParameter(outputInfo.parameters);\n      }\n    }\n  }\n\n  var node;\n\n  if (type === 'scene') {\n    node = new CompoSceneNode({\n      name: nodeInfo.name,\n      scene: opts.scene,\n      camera: opts.camera,\n      outputs: outputs\n    });\n  } else if (type === 'texture') {\n    node = new CompoTextureNode({\n      name: nodeInfo.name,\n      outputs: outputs\n    });\n  } // Default is filter\n  else {\n    node = new CompoFilterNode({\n      name: nodeInfo.name,\n      shader: shaderSource,\n      inputs: inputs,\n      outputs: outputs\n    });\n  }\n\n  if (node) {\n    if (nodeInfo.parameters) {\n      for (var name in nodeInfo.parameters) {\n        var val = nodeInfo.parameters[name];\n\n        if (typeof val === 'string') {\n          val = val.trim();\n\n          if (val.charAt(0) === '#') {\n            val = lib.textures[val.substr(1)];\n          } else {\n            node.on('beforerender', createSizeSetHandler(name, tryConvertExpr(val)));\n          }\n        } else if (typeof val === 'function') {\n          node.on('beforerender', val);\n        }\n\n        node.setParameter(name, val);\n      }\n    }\n\n    if (nodeInfo.defines && node.pass) {\n      for (var name in nodeInfo.defines) {\n        var val = nodeInfo.defines[name];\n        node.pass.material.define('fragment', name, val);\n      }\n    }\n  }\n\n  return node;\n}\n\nfunction defaultWidthFunc(width, height) {\n  return width;\n}\n\nfunction defaultHeightFunc(width, height) {\n  return height;\n}\n\nfunction convertParameter(paramInfo) {\n  var param = {};\n\n  if (!paramInfo) {\n    return param;\n  }\n\n  ['type', 'minFilter', 'magFilter', 'wrapS', 'wrapT', 'flipY', 'useMipmap'].forEach(function (name) {\n    var val = paramInfo[name];\n\n    if (val != null) {\n      // Convert string to enum\n      if (typeof val === 'string') {\n        val = Texture[val];\n      }\n\n      param[name] = val;\n    }\n  });\n  var sizeScale = paramInfo.scale || 1;\n  ['width', 'height'].forEach(function (name) {\n    if (paramInfo[name] != null) {\n      var val = paramInfo[name];\n\n      if (typeof val === 'string') {\n        val = val.trim();\n        param[name] = createSizeParser(name, tryConvertExpr(val), sizeScale);\n      } else {\n        param[name] = val;\n      }\n    }\n  });\n\n  if (!param.width) {\n    param.width = defaultWidthFunc;\n  }\n\n  if (!param.height) {\n    param.height = defaultHeightFunc;\n  }\n\n  if (paramInfo.useMipmap != null) {\n    param.useMipmap = paramInfo.useMipmap;\n  }\n\n  return param;\n}\n\nfunction loadTextures(json, lib, opts, callback) {\n  if (!json.textures) {\n    callback({});\n    return;\n  }\n\n  var textures = {};\n  var loading = 0;\n  var cbd = false;\n  var textureRootPath = opts.textureRootPath;\n  util.each(json.textures, function (textureInfo, name) {\n    var texture;\n    var path = textureInfo.path;\n    var parameters = convertParameter(textureInfo.parameters);\n\n    if (Array.isArray(path) && path.length === 6) {\n      if (textureRootPath) {\n        path = path.map(function (item) {\n          return util.relative2absolute(item, textureRootPath);\n        });\n      }\n\n      texture = new TextureCube(parameters);\n    } else if (typeof path === 'string') {\n      if (textureRootPath) {\n        path = util.relative2absolute(path, textureRootPath);\n      }\n\n      texture = new Texture2D(parameters);\n    } else {\n      return;\n    }\n\n    texture.load(path);\n    loading++;\n    texture.once('success', function () {\n      textures[name] = texture;\n      loading--;\n\n      if (loading === 0) {\n        callback(textures);\n        cbd = true;\n      }\n    });\n  });\n\n  if (loading === 0 && !cbd) {\n    callback(textures);\n  }\n}\n\nfunction createSizeSetHandler(name, exprFunc) {\n  return function (renderer) {\n    // PENDING viewport size or window size\n    var dpr = renderer.getDevicePixelRatio(); // PENDING If multiply dpr ?\n\n    var width = renderer.getWidth();\n    var height = renderer.getHeight();\n    var result = exprFunc(width, height, dpr);\n    this.setParameter(name, result);\n  };\n}\n\nfunction createSizeParser(name, exprFunc, scale) {\n  scale = scale || 1;\n  return function (renderer) {\n    var dpr = renderer.getDevicePixelRatio();\n    var width = renderer.getWidth() * scale;\n    var height = renderer.getHeight() * scale;\n    return exprFunc(width, height, dpr);\n  };\n}\n\nfunction tryConvertExpr(string) {\n  // PENDING\n  var exprRes = /^expr\\((.*)\\)$/.exec(string);\n\n  if (exprRes) {\n    try {\n      var func = new Function('width', 'height', 'dpr', 'return ' + exprRes[1]); // Try run t\n\n      func(1, 1);\n      return func;\n    } catch (e) {\n      throw new Error('Invalid expression.');\n    }\n  }\n}\n\nexport default createCompositor;","map":{"version":3,"sources":["C:/Users/Administrator/Desktop/data_view/my_project/vue2_app/myapp/node_modules/claygl/src/createCompositor.js"],"names":["util","Compositor","CompoSceneNode","CompoTextureNode","CompoFilterNode","Shader","Texture","Texture2D","TextureCube","registerBuiltinCompositor","shaderSourceReg","createCompositor","json","opts","compositor","lib","textures","parameters","afterLoad","shaderLib","textureLib","i","nodes","length","nodeInfo","node","createNode","addNode","name","paramInfo","convertParameter","loadTextures","type","shaderSource","inputs","outputs","shaderExp","shader","trim","res","exec","source","charAt","shaders","substr","pin","outputInfo","attachment","keepLastFrame","outputLastFrame","scene","camera","val","on","createSizeSetHandler","tryConvertExpr","setParameter","defines","pass","material","define","defaultWidthFunc","width","height","defaultHeightFunc","param","forEach","sizeScale","scale","createSizeParser","useMipmap","callback","loading","cbd","textureRootPath","each","textureInfo","texture","path","Array","isArray","map","item","relative2absolute","load","once","exprFunc","renderer","dpr","getDevicePixelRatio","getWidth","getHeight","result","string","exprRes","func","Function","e","Error"],"mappings":"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","sourcesContent":["import util from './core/util';\nimport Compositor from './compositor/Compositor';\nimport CompoSceneNode from './compositor/SceneNode';\nimport CompoTextureNode from './compositor/TextureNode';\nimport CompoFilterNode from './compositor/FilterNode';\nimport Shader from './Shader';\nimport Texture from './Texture';\nimport Texture2D from './Texture2D';\nimport TextureCube from './TextureCube';\n\nimport registerBuiltinCompositor from './shader/registerBuiltinCompositor';\n\nregisterBuiltinCompositor(Shader);\n\nvar shaderSourceReg = /^#source\\((.*?)\\)/;\n\n/**\n * @name clay.createCompositor\n * @function\n * @param {Object} json\n * @param {Object} [opts]\n * @return {clay.compositor.Compositor}\n */\nfunction createCompositor(json, opts) {\n    var compositor = new Compositor();\n    opts = opts || {};\n\n    var lib = {\n        textures: {},\n        parameters: {}\n    };\n    var afterLoad = function(shaderLib, textureLib) {\n        for (var i = 0; i < json.nodes.length; i++) {\n            var nodeInfo = json.nodes[i];\n            var node = createNode(nodeInfo, lib, opts);\n            if (node) {\n                compositor.addNode(node);\n            }\n        }\n    };\n\n    for (var name in json.parameters) {\n        var paramInfo = json.parameters[name];\n        lib.parameters[name] = convertParameter(paramInfo);\n    }\n    // TODO load texture asynchronous\n    loadTextures(json, lib, opts, function(textureLib) {\n        lib.textures = textureLib;\n        afterLoad();\n    });\n\n    return compositor;\n}\n\nfunction createNode(nodeInfo, lib, opts) {\n    var type = nodeInfo.type || 'filter';\n    var shaderSource;\n    var inputs;\n    var outputs;\n\n    if (type === 'filter') {\n        var shaderExp = nodeInfo.shader.trim();\n        var res = shaderSourceReg.exec(shaderExp);\n        if (res) {\n            shaderSource = Shader.source(res[1].trim());\n        }\n        else if (shaderExp.charAt(0) === '#') {\n            shaderSource = lib.shaders[shaderExp.substr(1)];\n        }\n        if (!shaderSource) {\n            shaderSource = shaderExp;\n        }\n        if (!shaderSource) {\n            return;\n        }\n    }\n\n    if (nodeInfo.inputs) {\n        inputs = {};\n        for (var name in nodeInfo.inputs) {\n            if (typeof nodeInfo.inputs[name] === 'string') {\n                inputs[name] = nodeInfo.inputs[name];\n            }\n            else {\n                inputs[name] = {\n                    node: nodeInfo.inputs[name].node,\n                    pin: nodeInfo.inputs[name].pin\n                };\n            }\n        }\n    }\n    if (nodeInfo.outputs) {\n        outputs = {};\n        for (var name in nodeInfo.outputs) {\n            var outputInfo = nodeInfo.outputs[name];\n            outputs[name] = {};\n            if (outputInfo.attachment != null) {\n                outputs[name].attachment = outputInfo.attachment;\n            }\n            if (outputInfo.keepLastFrame != null) {\n                outputs[name].keepLastFrame = outputInfo.keepLastFrame;\n            }\n            if (outputInfo.outputLastFrame != null) {\n                outputs[name].outputLastFrame = outputInfo.outputLastFrame;\n            }\n            if (outputInfo.parameters) {\n                outputs[name].parameters = convertParameter(outputInfo.parameters);\n            }\n        }\n    }\n    var node;\n    if (type === 'scene') {\n        node = new CompoSceneNode({\n            name: nodeInfo.name,\n            scene: opts.scene,\n            camera: opts.camera,\n            outputs: outputs\n        });\n    }\n    else if (type === 'texture') {\n        node = new CompoTextureNode({\n            name: nodeInfo.name,\n            outputs: outputs\n        });\n    }\n    // Default is filter\n    else {\n        node = new CompoFilterNode({\n            name: nodeInfo.name,\n            shader: shaderSource,\n            inputs: inputs,\n            outputs: outputs\n        });\n    }\n    if (node) {\n        if (nodeInfo.parameters) {\n            for (var name in nodeInfo.parameters) {\n                var val = nodeInfo.parameters[name];\n                if (typeof val === 'string') {\n                    val = val.trim();\n                    if (val.charAt(0) === '#') {\n                        val = lib.textures[val.substr(1)];\n                    }\n                    else {\n                        node.on(\n                            'beforerender', createSizeSetHandler(\n                                name, tryConvertExpr(val)\n                            )\n                        );\n                    }\n                }\n                else if (typeof val === 'function') {\n                    node.on('beforerender', val);\n                }\n                node.setParameter(name, val);\n            }\n        }\n        if (nodeInfo.defines && node.pass) {\n            for (var name in nodeInfo.defines) {\n                var val = nodeInfo.defines[name];\n                node.pass.material.define('fragment', name, val);\n            }\n        }\n    }\n    return node;\n}\n\nfunction defaultWidthFunc(width, height) {\n    return width;\n}\nfunction defaultHeightFunc(width, height) {\n    return height;\n}\n\nfunction convertParameter(paramInfo) {\n    var param = {};\n    if (!paramInfo) {\n        return param;\n    }\n    ['type', 'minFilter', 'magFilter', 'wrapS', 'wrapT', 'flipY', 'useMipmap']\n        .forEach(function(name) {\n            var val = paramInfo[name];\n            if (val != null) {\n                // Convert string to enum\n                if (typeof val === 'string') {\n                    val = Texture[val];\n                }\n                param[name] = val;\n            }\n        });\n\n    var sizeScale = paramInfo.scale || 1;\n    ['width', 'height']\n        .forEach(function(name) {\n            if (paramInfo[name] != null) {\n                var val = paramInfo[name];\n                if (typeof val === 'string') {\n                    val = val.trim();\n                    param[name] = createSizeParser(\n                        name, tryConvertExpr(val), sizeScale\n                    );\n                }\n                else {\n                    param[name] = val;\n                }\n            }\n        });\n    if (!param.width) {\n        param.width = defaultWidthFunc;\n    }\n    if (!param.height) {\n        param.height = defaultHeightFunc;\n    }\n\n    if (paramInfo.useMipmap != null) {\n        param.useMipmap = paramInfo.useMipmap;\n    }\n    return param;\n}\n\nfunction loadTextures(json, lib, opts, callback) {\n    if (!json.textures) {\n        callback({});\n        return;\n    }\n    var textures = {};\n    var loading = 0;\n\n    var cbd = false;\n    var textureRootPath = opts.textureRootPath;\n    util.each(json.textures, function(textureInfo, name) {\n        var texture;\n        var path = textureInfo.path;\n        var parameters = convertParameter(textureInfo.parameters);\n        if (Array.isArray(path) && path.length === 6) {\n            if (textureRootPath) {\n                path = path.map(function(item) {\n                    return util.relative2absolute(item, textureRootPath);\n                });\n            }\n            texture = new TextureCube(parameters);\n        }\n        else if(typeof path === 'string') {\n            if (textureRootPath) {\n                path = util.relative2absolute(path, textureRootPath);\n            }\n            texture = new Texture2D(parameters);\n        }\n        else {\n            return;\n        }\n\n        texture.load(path);\n        loading++;\n        texture.once('success', function() {\n            textures[name] = texture;\n            loading--;\n            if (loading === 0) {\n                callback(textures);\n                cbd = true;\n            }\n        });\n    });\n\n    if (loading === 0 && !cbd) {\n        callback(textures);\n    }\n}\n\nfunction createSizeSetHandler(name, exprFunc) {\n    return function (renderer) {\n        // PENDING viewport size or window size\n        var dpr = renderer.getDevicePixelRatio();\n        // PENDING If multiply dpr ?\n        var width = renderer.getWidth();\n        var height = renderer.getHeight();\n        var result = exprFunc(width, height, dpr);\n        this.setParameter(name, result);\n    };\n}\n\nfunction createSizeParser(name, exprFunc, scale) {\n    scale = scale || 1;\n    return function (renderer) {\n        var dpr = renderer.getDevicePixelRatio();\n        var width = renderer.getWidth() * scale;\n        var height = renderer.getHeight() * scale;\n        return exprFunc(width, height, dpr);\n    };\n}\n\nfunction tryConvertExpr(string) {\n    // PENDING\n    var exprRes = /^expr\\((.*)\\)$/.exec(string);\n    if (exprRes) {\n        try {\n            var func = new Function('width', 'height', 'dpr', 'return ' + exprRes[1]);\n            // Try run t\n            func(1, 1);\n\n            return func;\n        }\n        catch (e) {\n            throw new Error('Invalid expression.');\n        }\n    }\n}\n\nexport default createCompositor;\n"]},"metadata":{},"sourceType":"module"}