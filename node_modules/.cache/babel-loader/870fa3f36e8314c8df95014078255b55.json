{"ast":null,"code":"/**\n * Texture Atlas for the sprites.\n * It uses zrender for 2d element management and rendering\n * @module echarts-gl/util/ZRTextureAtlasSurface\n */\n// TODO Expand.\nimport * as echarts from 'echarts/lib/echarts';\nimport Texture2D from 'claygl/src/Texture2D';\n\nfunction ZRTextureAtlasSurfaceNode(zr, offsetX, offsetY, width, height, gap, dpr) {\n  this._zr = zr;\n  /**\n   * Current cursor x\n   * @type {number}\n   * @private\n   */\n\n  this._x = 0;\n  /**\n   * Current cursor y\n   * @type {number}\n   */\n\n  this._y = 0;\n  this._rowHeight = 0;\n  /**\n   * width without dpr.\n   * @type {number}\n   * @private\n   */\n\n  this.width = width;\n  /**\n   * height without dpr.\n   * @type {number}\n   * @private\n   */\n\n  this.height = height;\n  /**\n   * offsetX without dpr\n   * @type {number}\n   */\n\n  this.offsetX = offsetX;\n  /**\n   * offsetY without dpr\n   * @type {number}\n   */\n\n  this.offsetY = offsetY;\n  this.dpr = dpr;\n  this.gap = gap;\n}\n\nZRTextureAtlasSurfaceNode.prototype = {\n  constructor: ZRTextureAtlasSurfaceNode,\n  clear: function () {\n    this._x = 0;\n    this._y = 0;\n    this._rowHeight = 0;\n  },\n\n  /**\n   * Add shape to atlas\n   * @param {module:zrender/graphic/Displayable} shape\n   * @param {number} width\n   * @param {number} height\n   * @return {Array}\n   */\n  add: function (el, width, height) {\n    // FIXME Text element not consider textAlign and textVerticalAlign.\n    // TODO, inner text, shadow\n    var rect = el.getBoundingRect(); // FIXME aspect ratio\n\n    if (width == null) {\n      width = rect.width;\n    }\n\n    if (height == null) {\n      height = rect.height;\n    }\n\n    width *= this.dpr;\n    height *= this.dpr;\n\n    this._fitElement(el, width, height); // var aspect = el.scale[1] / el.scale[0];\n    // Adjust aspect ratio to make the text more clearly\n    // FIXME If height > width, width is useless ?\n    // width = height * aspect;\n    // el.position[0] *= aspect;\n    // el.scale[0] = el.scale[1];\n\n\n    var x = this._x;\n    var y = this._y;\n    var canvasWidth = this.width * this.dpr;\n    var canvasHeight = this.height * this.dpr;\n    var gap = this.gap;\n\n    if (x + width + gap > canvasWidth) {\n      // Change a new row\n      x = this._x = 0;\n      y += this._rowHeight + gap;\n      this._y = y; // Reset row height\n\n      this._rowHeight = 0;\n    }\n\n    this._x += width + gap;\n    this._rowHeight = Math.max(this._rowHeight, height);\n\n    if (y + height + gap > canvasHeight) {\n      // There is no space anymore\n      return null;\n    } // Shift the el\n\n\n    el.x += this.offsetX * this.dpr + x;\n    el.y += this.offsetY * this.dpr + y;\n\n    this._zr.add(el);\n\n    var coordsOffset = [this.offsetX / this.width, this.offsetY / this.height];\n    var coords = [[x / canvasWidth + coordsOffset[0], y / canvasHeight + coordsOffset[1]], [(x + width) / canvasWidth + coordsOffset[0], (y + height) / canvasHeight + coordsOffset[1]]];\n    return coords;\n  },\n\n  /**\n   * Fit element size by correct its position and scaling\n   * @param {module:zrender/graphic/Displayable} el\n   * @param {number} spriteWidth\n   * @param {number} spriteHeight\n   */\n  _fitElement: function (el, spriteWidth, spriteHeight) {\n    // TODO, inner text, shadow\n    var rect = el.getBoundingRect();\n    var scaleX = spriteWidth / rect.width;\n    var scaleY = spriteHeight / rect.height;\n    el.x = -rect.x * scaleX;\n    el.y = -rect.y * scaleY;\n    el.scaleX = scaleX;\n    el.scaleY = scaleY;\n    el.update();\n  }\n};\n/**\n * constructor\n * @alias module:echarts-gl/util/ZRTextureAtlasSurface\n * @param {number} opt.width\n * @param {number} opt.height\n * @param {number} opt.devicePixelRatio\n * @param {number} opt.gap Gap for safe.\n * @param {Function} opt.onupdate\n */\n\nfunction ZRTextureAtlasSurface(opt) {\n  opt = opt || {};\n  opt.width = opt.width || 512;\n  opt.height = opt.height || 512;\n  opt.devicePixelRatio = opt.devicePixelRatio || 1;\n  opt.gap = opt.gap == null ? 2 : opt.gap;\n  var canvas = document.createElement('canvas');\n  canvas.width = opt.width * opt.devicePixelRatio;\n  canvas.height = opt.height * opt.devicePixelRatio;\n  this._canvas = canvas;\n  this._texture = new Texture2D({\n    image: canvas,\n    flipY: false\n  });\n  var self = this;\n  /**\n   * zrender instance in the Chart\n   * @type {zrender~ZRender}\n   */\n\n  this._zr = echarts.zrender.init(canvas);\n  var oldRefreshImmediately = this._zr.refreshImmediately;\n\n  this._zr.refreshImmediately = function () {\n    oldRefreshImmediately.call(this);\n\n    self._texture.dirty();\n\n    self.onupdate && self.onupdate();\n  };\n\n  this._dpr = opt.devicePixelRatio;\n  /**\n   * Texture coords map for each sprite image\n   * @type {Object}\n   */\n\n  this._coords = {};\n  this.onupdate = opt.onupdate;\n  this._gap = opt.gap; // Left sub atlas.\n\n  this._textureAtlasNodes = [new ZRTextureAtlasSurfaceNode(this._zr, 0, 0, opt.width, opt.height, this._gap, this._dpr)];\n  this._nodeWidth = opt.width;\n  this._nodeHeight = opt.height;\n  this._currentNodeIdx = 0;\n}\n\nZRTextureAtlasSurface.prototype = {\n  /**\n   * Clear the texture atlas\n   */\n  clear: function () {\n    for (var i = 0; i < this._textureAtlasNodes.length; i++) {\n      this._textureAtlasNodes[i].clear();\n    }\n\n    this._currentNodeIdx = 0;\n\n    this._zr.clear();\n\n    this._coords = {};\n  },\n\n  /**\n   * @return {number}\n   */\n  getWidth: function () {\n    return this._width;\n  },\n\n  /**\n   * @return {number}\n   */\n  getHeight: function () {\n    return this._height;\n  },\n\n  /**\n   * @return {number}\n   */\n  getTexture: function () {\n    return this._texture;\n  },\n\n  /**\n   * @return {number}\n   */\n  getDevicePixelRatio: function () {\n    return this._dpr;\n  },\n  getZr: function () {\n    return this._zr;\n  },\n  _getCurrentNode: function () {\n    return this._textureAtlasNodes[this._currentNodeIdx];\n  },\n  _expand: function () {\n    this._currentNodeIdx++;\n\n    if (this._textureAtlasNodes[this._currentNodeIdx]) {\n      // Use the node created previously.\n      return this._textureAtlasNodes[this._currentNodeIdx];\n    }\n\n    var maxSize = 4096 / this._dpr;\n    var textureAtlasNodes = this._textureAtlasNodes;\n    var nodeLen = textureAtlasNodes.length;\n    var offsetX = nodeLen * this._nodeWidth % maxSize;\n\n    var offsetY = Math.floor(nodeLen * this._nodeWidth / maxSize) * this._nodeHeight;\n\n    if (offsetY >= maxSize) {\n      // Failed if image is too large.\n      if (process.env.NODE_ENV !== 'production') {\n        console.error('Too much labels. Some will be ignored.');\n      }\n\n      return;\n    }\n\n    var width = (offsetX + this._nodeWidth) * this._dpr;\n    var height = (offsetY + this._nodeHeight) * this._dpr;\n\n    try {\n      // Resize will error in node.\n      this._zr.resize({\n        width: width,\n        height: height\n      });\n    } catch (e) {\n      this._canvas.width = width;\n      this._canvas.height = height;\n    }\n\n    var newNode = new ZRTextureAtlasSurfaceNode(this._zr, offsetX, offsetY, this._nodeWidth, this._nodeHeight, this._gap, this._dpr);\n\n    this._textureAtlasNodes.push(newNode);\n\n    return newNode;\n  },\n  add: function (el, width, height) {\n    if (this._coords[el.id]) {\n      if (process.env.NODE_ENV !== 'production') {\n        console.warn('Element already been add');\n      }\n\n      return this._coords[el.id];\n    }\n\n    var coords = this._getCurrentNode().add(el, width, height);\n\n    if (!coords) {\n      var newNode = this._expand();\n\n      if (!newNode) {\n        // To maximum\n        return;\n      }\n\n      coords = newNode.add(el, width, height);\n    }\n\n    this._coords[el.id] = coords;\n    return coords;\n  },\n\n  /**\n   * Get coord scale after texture atlas is expanded.\n   * @return {Array.<number>}\n   */\n  getCoordsScale: function () {\n    var dpr = this._dpr;\n    return [this._nodeWidth / this._canvas.width * dpr, this._nodeHeight / this._canvas.height * dpr];\n  },\n\n  /**\n   * Get texture coords of sprite image\n   * @param  {string} id Image id\n   * @return {Array}\n   */\n  getCoords: function (id) {\n    return this._coords[id];\n  },\n  dispose: function () {\n    this._zr.dispose();\n  }\n};\nexport default ZRTextureAtlasSurface;","map":{"version":3,"sources":["C:/Users/Administrator/Desktop/data_view/my_project/vue2_app/myapp/node_modules/echarts-gl/lib/util/ZRTextureAtlasSurface.js"],"names":["echarts","Texture2D","ZRTextureAtlasSurfaceNode","zr","offsetX","offsetY","width","height","gap","dpr","_zr","_x","_y","_rowHeight","prototype","constructor","clear","add","el","rect","getBoundingRect","_fitElement","x","y","canvasWidth","canvasHeight","Math","max","coordsOffset","coords","spriteWidth","spriteHeight","scaleX","scaleY","update","ZRTextureAtlasSurface","opt","devicePixelRatio","canvas","document","createElement","_canvas","_texture","image","flipY","self","zrender","init","oldRefreshImmediately","refreshImmediately","call","dirty","onupdate","_dpr","_coords","_gap","_textureAtlasNodes","_nodeWidth","_nodeHeight","_currentNodeIdx","i","length","getWidth","_width","getHeight","_height","getTexture","getDevicePixelRatio","getZr","_getCurrentNode","_expand","maxSize","textureAtlasNodes","nodeLen","floor","process","env","NODE_ENV","console","error","resize","e","newNode","push","id","warn","getCoordsScale","getCoords","dispose"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,KAAKA,OAAZ,MAAyB,qBAAzB;AACA,OAAOC,SAAP,MAAsB,sBAAtB;;AAEA,SAASC,yBAAT,CAAmCC,EAAnC,EAAuCC,OAAvC,EAAgDC,OAAhD,EAAyDC,KAAzD,EAAgEC,MAAhE,EAAwEC,GAAxE,EAA6EC,GAA7E,EAAkF;AAChF,OAAKC,GAAL,GAAWP,EAAX;AACA;AACF;AACA;AACA;AACA;;AAEE,OAAKQ,EAAL,GAAU,CAAV;AACA;AACF;AACA;AACA;;AAEE,OAAKC,EAAL,GAAU,CAAV;AACA,OAAKC,UAAL,GAAkB,CAAlB;AACA;AACF;AACA;AACA;AACA;;AAEE,OAAKP,KAAL,GAAaA,KAAb;AACA;AACF;AACA;AACA;AACA;;AAEE,OAAKC,MAAL,GAAcA,MAAd;AACA;AACF;AACA;AACA;;AAEE,OAAKH,OAAL,GAAeA,OAAf;AACA;AACF;AACA;AACA;;AAEE,OAAKC,OAAL,GAAeA,OAAf;AACA,OAAKI,GAAL,GAAWA,GAAX;AACA,OAAKD,GAAL,GAAWA,GAAX;AACD;;AAEDN,yBAAyB,CAACY,SAA1B,GAAsC;AACpCC,EAAAA,WAAW,EAAEb,yBADuB;AAEpCc,EAAAA,KAAK,EAAE,YAAY;AACjB,SAAKL,EAAL,GAAU,CAAV;AACA,SAAKC,EAAL,GAAU,CAAV;AACA,SAAKC,UAAL,GAAkB,CAAlB;AACD,GANmC;;AAQpC;AACF;AACA;AACA;AACA;AACA;AACA;AACEI,EAAAA,GAAG,EAAE,UAAUC,EAAV,EAAcZ,KAAd,EAAqBC,MAArB,EAA6B;AAChC;AACA;AACA,QAAIY,IAAI,GAAGD,EAAE,CAACE,eAAH,EAAX,CAHgC,CAGC;;AAEjC,QAAId,KAAK,IAAI,IAAb,EAAmB;AACjBA,MAAAA,KAAK,GAAGa,IAAI,CAACb,KAAb;AACD;;AAED,QAAIC,MAAM,IAAI,IAAd,EAAoB;AAClBA,MAAAA,MAAM,GAAGY,IAAI,CAACZ,MAAd;AACD;;AAEDD,IAAAA,KAAK,IAAI,KAAKG,GAAd;AACAF,IAAAA,MAAM,IAAI,KAAKE,GAAf;;AAEA,SAAKY,WAAL,CAAiBH,EAAjB,EAAqBZ,KAArB,EAA4BC,MAA5B,EAhBgC,CAgBK;AACrC;AACA;AACA;AACA;AACA;;;AAGA,QAAIe,CAAC,GAAG,KAAKX,EAAb;AACA,QAAIY,CAAC,GAAG,KAAKX,EAAb;AACA,QAAIY,WAAW,GAAG,KAAKlB,KAAL,GAAa,KAAKG,GAApC;AACA,QAAIgB,YAAY,GAAG,KAAKlB,MAAL,GAAc,KAAKE,GAAtC;AACA,QAAID,GAAG,GAAG,KAAKA,GAAf;;AAEA,QAAIc,CAAC,GAAGhB,KAAJ,GAAYE,GAAZ,GAAkBgB,WAAtB,EAAmC;AACjC;AACAF,MAAAA,CAAC,GAAG,KAAKX,EAAL,GAAU,CAAd;AACAY,MAAAA,CAAC,IAAI,KAAKV,UAAL,GAAkBL,GAAvB;AACA,WAAKI,EAAL,GAAUW,CAAV,CAJiC,CAIpB;;AAEb,WAAKV,UAAL,GAAkB,CAAlB;AACD;;AAED,SAAKF,EAAL,IAAWL,KAAK,GAAGE,GAAnB;AACA,SAAKK,UAAL,GAAkBa,IAAI,CAACC,GAAL,CAAS,KAAKd,UAAd,EAA0BN,MAA1B,CAAlB;;AAEA,QAAIgB,CAAC,GAAGhB,MAAJ,GAAaC,GAAb,GAAmBiB,YAAvB,EAAqC;AACnC;AACA,aAAO,IAAP;AACD,KA7C+B,CA6C9B;;;AAGFP,IAAAA,EAAE,CAACI,CAAH,IAAQ,KAAKlB,OAAL,GAAe,KAAKK,GAApB,GAA0Ba,CAAlC;AACAJ,IAAAA,EAAE,CAACK,CAAH,IAAQ,KAAKlB,OAAL,GAAe,KAAKI,GAApB,GAA0Bc,CAAlC;;AAEA,SAAKb,GAAL,CAASO,GAAT,CAAaC,EAAb;;AAEA,QAAIU,YAAY,GAAG,CAAC,KAAKxB,OAAL,GAAe,KAAKE,KAArB,EAA4B,KAAKD,OAAL,GAAe,KAAKE,MAAhD,CAAnB;AACA,QAAIsB,MAAM,GAAG,CAAC,CAACP,CAAC,GAAGE,WAAJ,GAAkBI,YAAY,CAAC,CAAD,CAA/B,EAAoCL,CAAC,GAAGE,YAAJ,GAAmBG,YAAY,CAAC,CAAD,CAAnE,CAAD,EAA0E,CAAC,CAACN,CAAC,GAAGhB,KAAL,IAAckB,WAAd,GAA4BI,YAAY,CAAC,CAAD,CAAzC,EAA8C,CAACL,CAAC,GAAGhB,MAAL,IAAekB,YAAf,GAA8BG,YAAY,CAAC,CAAD,CAAxF,CAA1E,CAAb;AACA,WAAOC,MAAP;AACD,GAvEmC;;AAyEpC;AACF;AACA;AACA;AACA;AACA;AACER,EAAAA,WAAW,EAAE,UAAUH,EAAV,EAAcY,WAAd,EAA2BC,YAA3B,EAAyC;AACpD;AACA,QAAIZ,IAAI,GAAGD,EAAE,CAACE,eAAH,EAAX;AACA,QAAIY,MAAM,GAAGF,WAAW,GAAGX,IAAI,CAACb,KAAhC;AACA,QAAI2B,MAAM,GAAGF,YAAY,GAAGZ,IAAI,CAACZ,MAAjC;AACAW,IAAAA,EAAE,CAACI,CAAH,GAAO,CAACH,IAAI,CAACG,CAAN,GAAUU,MAAjB;AACAd,IAAAA,EAAE,CAACK,CAAH,GAAO,CAACJ,IAAI,CAACI,CAAN,GAAUU,MAAjB;AACAf,IAAAA,EAAE,CAACc,MAAH,GAAYA,MAAZ;AACAd,IAAAA,EAAE,CAACe,MAAH,GAAYA,MAAZ;AACAf,IAAAA,EAAE,CAACgB,MAAH;AACD;AAzFmC,CAAtC;AA2FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASC,qBAAT,CAA+BC,GAA/B,EAAoC;AAClCA,EAAAA,GAAG,GAAGA,GAAG,IAAI,EAAb;AACAA,EAAAA,GAAG,CAAC9B,KAAJ,GAAY8B,GAAG,CAAC9B,KAAJ,IAAa,GAAzB;AACA8B,EAAAA,GAAG,CAAC7B,MAAJ,GAAa6B,GAAG,CAAC7B,MAAJ,IAAc,GAA3B;AACA6B,EAAAA,GAAG,CAACC,gBAAJ,GAAuBD,GAAG,CAACC,gBAAJ,IAAwB,CAA/C;AACAD,EAAAA,GAAG,CAAC5B,GAAJ,GAAU4B,GAAG,CAAC5B,GAAJ,IAAW,IAAX,GAAkB,CAAlB,GAAsB4B,GAAG,CAAC5B,GAApC;AACA,MAAI8B,MAAM,GAAGC,QAAQ,CAACC,aAAT,CAAuB,QAAvB,CAAb;AACAF,EAAAA,MAAM,CAAChC,KAAP,GAAe8B,GAAG,CAAC9B,KAAJ,GAAY8B,GAAG,CAACC,gBAA/B;AACAC,EAAAA,MAAM,CAAC/B,MAAP,GAAgB6B,GAAG,CAAC7B,MAAJ,GAAa6B,GAAG,CAACC,gBAAjC;AACA,OAAKI,OAAL,GAAeH,MAAf;AACA,OAAKI,QAAL,GAAgB,IAAIzC,SAAJ,CAAc;AAC5B0C,IAAAA,KAAK,EAAEL,MADqB;AAE5BM,IAAAA,KAAK,EAAE;AAFqB,GAAd,CAAhB;AAIA,MAAIC,IAAI,GAAG,IAAX;AACA;AACF;AACA;AACA;;AAEE,OAAKnC,GAAL,GAAWV,OAAO,CAAC8C,OAAR,CAAgBC,IAAhB,CAAqBT,MAArB,CAAX;AACA,MAAIU,qBAAqB,GAAG,KAAKtC,GAAL,CAASuC,kBAArC;;AAEA,OAAKvC,GAAL,CAASuC,kBAAT,GAA8B,YAAY;AACxCD,IAAAA,qBAAqB,CAACE,IAAtB,CAA2B,IAA3B;;AAEAL,IAAAA,IAAI,CAACH,QAAL,CAAcS,KAAd;;AAEAN,IAAAA,IAAI,CAACO,QAAL,IAAiBP,IAAI,CAACO,QAAL,EAAjB;AACD,GAND;;AAQA,OAAKC,IAAL,GAAYjB,GAAG,CAACC,gBAAhB;AACA;AACF;AACA;AACA;;AAEE,OAAKiB,OAAL,GAAe,EAAf;AACA,OAAKF,QAAL,GAAgBhB,GAAG,CAACgB,QAApB;AACA,OAAKG,IAAL,GAAYnB,GAAG,CAAC5B,GAAhB,CAvCkC,CAuCb;;AAErB,OAAKgD,kBAAL,GAA0B,CAAC,IAAItD,yBAAJ,CAA8B,KAAKQ,GAAnC,EAAwC,CAAxC,EAA2C,CAA3C,EAA8C0B,GAAG,CAAC9B,KAAlD,EAAyD8B,GAAG,CAAC7B,MAA7D,EAAqE,KAAKgD,IAA1E,EAAgF,KAAKF,IAArF,CAAD,CAA1B;AACA,OAAKI,UAAL,GAAkBrB,GAAG,CAAC9B,KAAtB;AACA,OAAKoD,WAAL,GAAmBtB,GAAG,CAAC7B,MAAvB;AACA,OAAKoD,eAAL,GAAuB,CAAvB;AACD;;AAEDxB,qBAAqB,CAACrB,SAAtB,GAAkC;AAChC;AACF;AACA;AACEE,EAAAA,KAAK,EAAE,YAAY;AACjB,SAAK,IAAI4C,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKJ,kBAAL,CAAwBK,MAA5C,EAAoDD,CAAC,EAArD,EAAyD;AACvD,WAAKJ,kBAAL,CAAwBI,CAAxB,EAA2B5C,KAA3B;AACD;;AAED,SAAK2C,eAAL,GAAuB,CAAvB;;AAEA,SAAKjD,GAAL,CAASM,KAAT;;AAEA,SAAKsC,OAAL,GAAe,EAAf;AACD,GAd+B;;AAgBhC;AACF;AACA;AACEQ,EAAAA,QAAQ,EAAE,YAAY;AACpB,WAAO,KAAKC,MAAZ;AACD,GArB+B;;AAuBhC;AACF;AACA;AACEC,EAAAA,SAAS,EAAE,YAAY;AACrB,WAAO,KAAKC,OAAZ;AACD,GA5B+B;;AA8BhC;AACF;AACA;AACEC,EAAAA,UAAU,EAAE,YAAY;AACtB,WAAO,KAAKxB,QAAZ;AACD,GAnC+B;;AAqChC;AACF;AACA;AACEyB,EAAAA,mBAAmB,EAAE,YAAY;AAC/B,WAAO,KAAKd,IAAZ;AACD,GA1C+B;AA2ChCe,EAAAA,KAAK,EAAE,YAAY;AACjB,WAAO,KAAK1D,GAAZ;AACD,GA7C+B;AA8ChC2D,EAAAA,eAAe,EAAE,YAAY;AAC3B,WAAO,KAAKb,kBAAL,CAAwB,KAAKG,eAA7B,CAAP;AACD,GAhD+B;AAiDhCW,EAAAA,OAAO,EAAE,YAAY;AACnB,SAAKX,eAAL;;AAEA,QAAI,KAAKH,kBAAL,CAAwB,KAAKG,eAA7B,CAAJ,EAAmD;AACjD;AACA,aAAO,KAAKH,kBAAL,CAAwB,KAAKG,eAA7B,CAAP;AACD;;AAED,QAAIY,OAAO,GAAG,OAAO,KAAKlB,IAA1B;AACA,QAAImB,iBAAiB,GAAG,KAAKhB,kBAA7B;AACA,QAAIiB,OAAO,GAAGD,iBAAiB,CAACX,MAAhC;AACA,QAAIzD,OAAO,GAAGqE,OAAO,GAAG,KAAKhB,UAAf,GAA4Bc,OAA1C;;AAEA,QAAIlE,OAAO,GAAGqB,IAAI,CAACgD,KAAL,CAAWD,OAAO,GAAG,KAAKhB,UAAf,GAA4Bc,OAAvC,IAAkD,KAAKb,WAArE;;AAEA,QAAIrD,OAAO,IAAIkE,OAAf,EAAwB;AACtB;AACA,UAAII,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;AACzCC,QAAAA,OAAO,CAACC,KAAR,CAAc,wCAAd;AACD;;AAED;AACD;;AAED,QAAIzE,KAAK,GAAG,CAACF,OAAO,GAAG,KAAKqD,UAAhB,IAA8B,KAAKJ,IAA/C;AACA,QAAI9C,MAAM,GAAG,CAACF,OAAO,GAAG,KAAKqD,WAAhB,IAA+B,KAAKL,IAAjD;;AAEA,QAAI;AACF;AACA,WAAK3C,GAAL,CAASsE,MAAT,CAAgB;AACd1E,QAAAA,KAAK,EAAEA,KADO;AAEdC,QAAAA,MAAM,EAAEA;AAFM,OAAhB;AAID,KAND,CAME,OAAO0E,CAAP,EAAU;AACV,WAAKxC,OAAL,CAAanC,KAAb,GAAqBA,KAArB;AACA,WAAKmC,OAAL,CAAalC,MAAb,GAAsBA,MAAtB;AACD;;AAED,QAAI2E,OAAO,GAAG,IAAIhF,yBAAJ,CAA8B,KAAKQ,GAAnC,EAAwCN,OAAxC,EAAiDC,OAAjD,EAA0D,KAAKoD,UAA/D,EAA2E,KAAKC,WAAhF,EAA6F,KAAKH,IAAlG,EAAwG,KAAKF,IAA7G,CAAd;;AAEA,SAAKG,kBAAL,CAAwB2B,IAAxB,CAA6BD,OAA7B;;AAEA,WAAOA,OAAP;AACD,GA5F+B;AA6FhCjE,EAAAA,GAAG,EAAE,UAAUC,EAAV,EAAcZ,KAAd,EAAqBC,MAArB,EAA6B;AAChC,QAAI,KAAK+C,OAAL,CAAapC,EAAE,CAACkE,EAAhB,CAAJ,EAAyB;AACvB,UAAIT,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;AACzCC,QAAAA,OAAO,CAACO,IAAR,CAAa,0BAAb;AACD;;AAED,aAAO,KAAK/B,OAAL,CAAapC,EAAE,CAACkE,EAAhB,CAAP;AACD;;AAED,QAAIvD,MAAM,GAAG,KAAKwC,eAAL,GAAuBpD,GAAvB,CAA2BC,EAA3B,EAA+BZ,KAA/B,EAAsCC,MAAtC,CAAb;;AAEA,QAAI,CAACsB,MAAL,EAAa;AACX,UAAIqD,OAAO,GAAG,KAAKZ,OAAL,EAAd;;AAEA,UAAI,CAACY,OAAL,EAAc;AACZ;AACA;AACD;;AAEDrD,MAAAA,MAAM,GAAGqD,OAAO,CAACjE,GAAR,CAAYC,EAAZ,EAAgBZ,KAAhB,EAAuBC,MAAvB,CAAT;AACD;;AAED,SAAK+C,OAAL,CAAapC,EAAE,CAACkE,EAAhB,IAAsBvD,MAAtB;AACA,WAAOA,MAAP;AACD,GArH+B;;AAuHhC;AACF;AACA;AACA;AACEyD,EAAAA,cAAc,EAAE,YAAY;AAC1B,QAAI7E,GAAG,GAAG,KAAK4C,IAAf;AACA,WAAO,CAAC,KAAKI,UAAL,GAAkB,KAAKhB,OAAL,CAAanC,KAA/B,GAAuCG,GAAxC,EAA6C,KAAKiD,WAAL,GAAmB,KAAKjB,OAAL,CAAalC,MAAhC,GAAyCE,GAAtF,CAAP;AACD,GA9H+B;;AAgIhC;AACF;AACA;AACA;AACA;AACE8E,EAAAA,SAAS,EAAE,UAAUH,EAAV,EAAc;AACvB,WAAO,KAAK9B,OAAL,CAAa8B,EAAb,CAAP;AACD,GAvI+B;AAwIhCI,EAAAA,OAAO,EAAE,YAAY;AACnB,SAAK9E,GAAL,CAAS8E,OAAT;AACD;AA1I+B,CAAlC;AA4IA,eAAerD,qBAAf","sourcesContent":["/**\n * Texture Atlas for the sprites.\n * It uses zrender for 2d element management and rendering\n * @module echarts-gl/util/ZRTextureAtlasSurface\n */\n// TODO Expand.\nimport * as echarts from 'echarts/lib/echarts';\nimport Texture2D from 'claygl/src/Texture2D';\n\nfunction ZRTextureAtlasSurfaceNode(zr, offsetX, offsetY, width, height, gap, dpr) {\n  this._zr = zr;\n  /**\n   * Current cursor x\n   * @type {number}\n   * @private\n   */\n\n  this._x = 0;\n  /**\n   * Current cursor y\n   * @type {number}\n   */\n\n  this._y = 0;\n  this._rowHeight = 0;\n  /**\n   * width without dpr.\n   * @type {number}\n   * @private\n   */\n\n  this.width = width;\n  /**\n   * height without dpr.\n   * @type {number}\n   * @private\n   */\n\n  this.height = height;\n  /**\n   * offsetX without dpr\n   * @type {number}\n   */\n\n  this.offsetX = offsetX;\n  /**\n   * offsetY without dpr\n   * @type {number}\n   */\n\n  this.offsetY = offsetY;\n  this.dpr = dpr;\n  this.gap = gap;\n}\n\nZRTextureAtlasSurfaceNode.prototype = {\n  constructor: ZRTextureAtlasSurfaceNode,\n  clear: function () {\n    this._x = 0;\n    this._y = 0;\n    this._rowHeight = 0;\n  },\n\n  /**\n   * Add shape to atlas\n   * @param {module:zrender/graphic/Displayable} shape\n   * @param {number} width\n   * @param {number} height\n   * @return {Array}\n   */\n  add: function (el, width, height) {\n    // FIXME Text element not consider textAlign and textVerticalAlign.\n    // TODO, inner text, shadow\n    var rect = el.getBoundingRect(); // FIXME aspect ratio\n\n    if (width == null) {\n      width = rect.width;\n    }\n\n    if (height == null) {\n      height = rect.height;\n    }\n\n    width *= this.dpr;\n    height *= this.dpr;\n\n    this._fitElement(el, width, height); // var aspect = el.scale[1] / el.scale[0];\n    // Adjust aspect ratio to make the text more clearly\n    // FIXME If height > width, width is useless ?\n    // width = height * aspect;\n    // el.position[0] *= aspect;\n    // el.scale[0] = el.scale[1];\n\n\n    var x = this._x;\n    var y = this._y;\n    var canvasWidth = this.width * this.dpr;\n    var canvasHeight = this.height * this.dpr;\n    var gap = this.gap;\n\n    if (x + width + gap > canvasWidth) {\n      // Change a new row\n      x = this._x = 0;\n      y += this._rowHeight + gap;\n      this._y = y; // Reset row height\n\n      this._rowHeight = 0;\n    }\n\n    this._x += width + gap;\n    this._rowHeight = Math.max(this._rowHeight, height);\n\n    if (y + height + gap > canvasHeight) {\n      // There is no space anymore\n      return null;\n    } // Shift the el\n\n\n    el.x += this.offsetX * this.dpr + x;\n    el.y += this.offsetY * this.dpr + y;\n\n    this._zr.add(el);\n\n    var coordsOffset = [this.offsetX / this.width, this.offsetY / this.height];\n    var coords = [[x / canvasWidth + coordsOffset[0], y / canvasHeight + coordsOffset[1]], [(x + width) / canvasWidth + coordsOffset[0], (y + height) / canvasHeight + coordsOffset[1]]];\n    return coords;\n  },\n\n  /**\n   * Fit element size by correct its position and scaling\n   * @param {module:zrender/graphic/Displayable} el\n   * @param {number} spriteWidth\n   * @param {number} spriteHeight\n   */\n  _fitElement: function (el, spriteWidth, spriteHeight) {\n    // TODO, inner text, shadow\n    var rect = el.getBoundingRect();\n    var scaleX = spriteWidth / rect.width;\n    var scaleY = spriteHeight / rect.height;\n    el.x = -rect.x * scaleX;\n    el.y = -rect.y * scaleY;\n    el.scaleX = scaleX;\n    el.scaleY = scaleY;\n    el.update();\n  }\n};\n/**\n * constructor\n * @alias module:echarts-gl/util/ZRTextureAtlasSurface\n * @param {number} opt.width\n * @param {number} opt.height\n * @param {number} opt.devicePixelRatio\n * @param {number} opt.gap Gap for safe.\n * @param {Function} opt.onupdate\n */\n\nfunction ZRTextureAtlasSurface(opt) {\n  opt = opt || {};\n  opt.width = opt.width || 512;\n  opt.height = opt.height || 512;\n  opt.devicePixelRatio = opt.devicePixelRatio || 1;\n  opt.gap = opt.gap == null ? 2 : opt.gap;\n  var canvas = document.createElement('canvas');\n  canvas.width = opt.width * opt.devicePixelRatio;\n  canvas.height = opt.height * opt.devicePixelRatio;\n  this._canvas = canvas;\n  this._texture = new Texture2D({\n    image: canvas,\n    flipY: false\n  });\n  var self = this;\n  /**\n   * zrender instance in the Chart\n   * @type {zrender~ZRender}\n   */\n\n  this._zr = echarts.zrender.init(canvas);\n  var oldRefreshImmediately = this._zr.refreshImmediately;\n\n  this._zr.refreshImmediately = function () {\n    oldRefreshImmediately.call(this);\n\n    self._texture.dirty();\n\n    self.onupdate && self.onupdate();\n  };\n\n  this._dpr = opt.devicePixelRatio;\n  /**\n   * Texture coords map for each sprite image\n   * @type {Object}\n   */\n\n  this._coords = {};\n  this.onupdate = opt.onupdate;\n  this._gap = opt.gap; // Left sub atlas.\n\n  this._textureAtlasNodes = [new ZRTextureAtlasSurfaceNode(this._zr, 0, 0, opt.width, opt.height, this._gap, this._dpr)];\n  this._nodeWidth = opt.width;\n  this._nodeHeight = opt.height;\n  this._currentNodeIdx = 0;\n}\n\nZRTextureAtlasSurface.prototype = {\n  /**\n   * Clear the texture atlas\n   */\n  clear: function () {\n    for (var i = 0; i < this._textureAtlasNodes.length; i++) {\n      this._textureAtlasNodes[i].clear();\n    }\n\n    this._currentNodeIdx = 0;\n\n    this._zr.clear();\n\n    this._coords = {};\n  },\n\n  /**\n   * @return {number}\n   */\n  getWidth: function () {\n    return this._width;\n  },\n\n  /**\n   * @return {number}\n   */\n  getHeight: function () {\n    return this._height;\n  },\n\n  /**\n   * @return {number}\n   */\n  getTexture: function () {\n    return this._texture;\n  },\n\n  /**\n   * @return {number}\n   */\n  getDevicePixelRatio: function () {\n    return this._dpr;\n  },\n  getZr: function () {\n    return this._zr;\n  },\n  _getCurrentNode: function () {\n    return this._textureAtlasNodes[this._currentNodeIdx];\n  },\n  _expand: function () {\n    this._currentNodeIdx++;\n\n    if (this._textureAtlasNodes[this._currentNodeIdx]) {\n      // Use the node created previously.\n      return this._textureAtlasNodes[this._currentNodeIdx];\n    }\n\n    var maxSize = 4096 / this._dpr;\n    var textureAtlasNodes = this._textureAtlasNodes;\n    var nodeLen = textureAtlasNodes.length;\n    var offsetX = nodeLen * this._nodeWidth % maxSize;\n\n    var offsetY = Math.floor(nodeLen * this._nodeWidth / maxSize) * this._nodeHeight;\n\n    if (offsetY >= maxSize) {\n      // Failed if image is too large.\n      if (process.env.NODE_ENV !== 'production') {\n        console.error('Too much labels. Some will be ignored.');\n      }\n\n      return;\n    }\n\n    var width = (offsetX + this._nodeWidth) * this._dpr;\n    var height = (offsetY + this._nodeHeight) * this._dpr;\n\n    try {\n      // Resize will error in node.\n      this._zr.resize({\n        width: width,\n        height: height\n      });\n    } catch (e) {\n      this._canvas.width = width;\n      this._canvas.height = height;\n    }\n\n    var newNode = new ZRTextureAtlasSurfaceNode(this._zr, offsetX, offsetY, this._nodeWidth, this._nodeHeight, this._gap, this._dpr);\n\n    this._textureAtlasNodes.push(newNode);\n\n    return newNode;\n  },\n  add: function (el, width, height) {\n    if (this._coords[el.id]) {\n      if (process.env.NODE_ENV !== 'production') {\n        console.warn('Element already been add');\n      }\n\n      return this._coords[el.id];\n    }\n\n    var coords = this._getCurrentNode().add(el, width, height);\n\n    if (!coords) {\n      var newNode = this._expand();\n\n      if (!newNode) {\n        // To maximum\n        return;\n      }\n\n      coords = newNode.add(el, width, height);\n    }\n\n    this._coords[el.id] = coords;\n    return coords;\n  },\n\n  /**\n   * Get coord scale after texture atlas is expanded.\n   * @return {Array.<number>}\n   */\n  getCoordsScale: function () {\n    var dpr = this._dpr;\n    return [this._nodeWidth / this._canvas.width * dpr, this._nodeHeight / this._canvas.height * dpr];\n  },\n\n  /**\n   * Get texture coords of sprite image\n   * @param  {string} id Image id\n   * @return {Array}\n   */\n  getCoords: function (id) {\n    return this._coords[id];\n  },\n  dispose: function () {\n    this._zr.dispose();\n  }\n};\nexport default ZRTextureAtlasSurface;"]},"metadata":{},"sourceType":"module"}