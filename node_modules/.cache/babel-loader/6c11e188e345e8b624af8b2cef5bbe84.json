{"ast":null,"code":"import \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.typed-array.uint8-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.split.js\";\nimport \"core-js/modules/es.typed-array.float32-array.js\";\nimport Texture from '../Texture';\nimport Texture2D from '../Texture2D';\nvar toChar = String.fromCharCode;\nvar MINELEN = 8;\nvar MAXELEN = 0x7fff;\n\nfunction rgbe2float(rgbe, buffer, offset, exposure) {\n  if (rgbe[3] > 0) {\n    var f = Math.pow(2.0, rgbe[3] - 128 - 8 + exposure);\n    buffer[offset + 0] = rgbe[0] * f;\n    buffer[offset + 1] = rgbe[1] * f;\n    buffer[offset + 2] = rgbe[2] * f;\n  } else {\n    buffer[offset + 0] = 0;\n    buffer[offset + 1] = 0;\n    buffer[offset + 2] = 0;\n  }\n\n  buffer[offset + 3] = 1.0;\n  return buffer;\n}\n\nfunction uint82string(array, offset, size) {\n  var str = '';\n\n  for (var i = offset; i < size; i++) {\n    str += toChar(array[i]);\n  }\n\n  return str;\n}\n\nfunction copyrgbe(s, t) {\n  t[0] = s[0];\n  t[1] = s[1];\n  t[2] = s[2];\n  t[3] = s[3];\n} // TODO : check\n\n\nfunction oldReadColors(scan, buffer, offset, xmax) {\n  var rshift = 0,\n      x = 0,\n      len = xmax;\n\n  while (len > 0) {\n    scan[x][0] = buffer[offset++];\n    scan[x][1] = buffer[offset++];\n    scan[x][2] = buffer[offset++];\n    scan[x][3] = buffer[offset++];\n\n    if (scan[x][0] === 1 && scan[x][1] === 1 && scan[x][2] === 1) {\n      // exp is count of repeated pixels\n      for (var i = scan[x][3] << rshift >>> 0; i > 0; i--) {\n        copyrgbe(scan[x - 1], scan[x]);\n        x++;\n        len--;\n      }\n\n      rshift += 8;\n    } else {\n      x++;\n      len--;\n      rshift = 0;\n    }\n  }\n\n  return offset;\n}\n\nfunction readColors(scan, buffer, offset, xmax) {\n  if (xmax < MINELEN | xmax > MAXELEN) {\n    return oldReadColors(scan, buffer, offset, xmax);\n  }\n\n  var i = buffer[offset++];\n\n  if (i != 2) {\n    return oldReadColors(scan, buffer, offset - 1, xmax);\n  }\n\n  scan[0][1] = buffer[offset++];\n  scan[0][2] = buffer[offset++];\n  i = buffer[offset++];\n\n  if ((scan[0][2] << 8 >>> 0 | i) >>> 0 !== xmax) {\n    return null;\n  }\n\n  for (var i = 0; i < 4; i++) {\n    for (var x = 0; x < xmax;) {\n      var code = buffer[offset++];\n\n      if (code > 128) {\n        code = (code & 127) >>> 0;\n        var val = buffer[offset++];\n\n        while (code--) {\n          scan[x++][i] = val;\n        }\n      } else {\n        while (code--) {\n          scan[x++][i] = buffer[offset++];\n        }\n      }\n    }\n  }\n\n  return offset;\n}\n\nvar ret = {\n  // http://www.graphics.cornell.edu/~bjw/rgbe.html\n  // Blender source\n  // http://radsite.lbl.gov/radiance/refer/Notes/picture_format.html\n  parseRGBE: function parseRGBE(arrayBuffer, texture, exposure) {\n    if (exposure == null) {\n      exposure = 0;\n    }\n\n    var data = new Uint8Array(arrayBuffer);\n    var size = data.length;\n\n    if (uint82string(data, 0, 2) !== '#?') {\n      return;\n    } // find empty line, next line is resolution info\n\n\n    for (var i = 2; i < size; i++) {\n      if (toChar(data[i]) === '\\n' && toChar(data[i + 1]) === '\\n') {\n        break;\n      }\n    }\n\n    if (i >= size) {\n      // not found\n      return;\n    } // find resolution info line\n\n\n    i += 2;\n    var str = '';\n\n    for (; i < size; i++) {\n      var _char = toChar(data[i]);\n\n      if (_char === '\\n') {\n        break;\n      }\n\n      str += _char;\n    } // -Y M +X N\n\n\n    var tmp = str.split(' ');\n    var height = parseInt(tmp[1]);\n    var width = parseInt(tmp[3]);\n\n    if (!width || !height) {\n      return;\n    } // read and decode actual data\n\n\n    var offset = i + 1;\n    var scanline = []; // memzero\n\n    for (var x = 0; x < width; x++) {\n      scanline[x] = [];\n\n      for (var j = 0; j < 4; j++) {\n        scanline[x][j] = 0;\n      }\n    }\n\n    var pixels = new Float32Array(width * height * 4);\n    var offset2 = 0;\n\n    for (var y = 0; y < height; y++) {\n      var offset = readColors(scanline, data, offset, width);\n\n      if (!offset) {\n        return null;\n      }\n\n      for (var x = 0; x < width; x++) {\n        rgbe2float(scanline[x], pixels, offset2, exposure);\n        offset2 += 4;\n      }\n    }\n\n    if (!texture) {\n      texture = new Texture2D();\n    }\n\n    texture.width = width;\n    texture.height = height;\n    texture.pixels = pixels; // HALF_FLOAT can't use Float32Array\n\n    texture.type = Texture.FLOAT;\n    return texture;\n  },\n  parseRGBEFromPNG: function parseRGBEFromPNG(png) {}\n};\nexport default ret;","map":{"version":3,"sources":["C:/Users/Administrator/Desktop/data_view/my_project/vue2_app/myapp/node_modules/_claygl@1.3.0@claygl/src/util/hdr.js"],"names":["Texture","Texture2D","toChar","String","fromCharCode","MINELEN","MAXELEN","rgbe2float","rgbe","buffer","offset","exposure","f","Math","pow","uint82string","array","size","str","i","copyrgbe","s","t","oldReadColors","scan","xmax","rshift","x","len","readColors","code","val","ret","parseRGBE","arrayBuffer","texture","data","Uint8Array","length","_char","tmp","split","height","parseInt","width","scanline","j","pixels","Float32Array","offset2","y","type","FLOAT","parseRGBEFromPNG","png"],"mappings":"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","sourcesContent":["import Texture from '../Texture';\nimport Texture2D from '../Texture2D';\nvar toChar = String.fromCharCode;\n\nvar MINELEN = 8;\nvar MAXELEN = 0x7fff;\nfunction rgbe2float(rgbe, buffer, offset, exposure) {\n    if (rgbe[3] > 0) {\n        var f = Math.pow(2.0, rgbe[3] - 128 - 8 + exposure);\n        buffer[offset + 0] = rgbe[0] * f;\n        buffer[offset + 1] = rgbe[1] * f;\n        buffer[offset + 2] = rgbe[2] * f;\n    }\n    else {\n        buffer[offset + 0] = 0;\n        buffer[offset + 1] = 0;\n        buffer[offset + 2] = 0;\n    }\n    buffer[offset + 3] = 1.0;\n    return buffer;\n}\n\nfunction uint82string(array, offset, size) {\n    var str = '';\n    for (var i = offset; i < size; i++) {\n        str += toChar(array[i]);\n    }\n    return str;\n}\n\nfunction copyrgbe(s, t) {\n    t[0] = s[0];\n    t[1] = s[1];\n    t[2] = s[2];\n    t[3] = s[3];\n}\n\n// TODO : check\nfunction oldReadColors(scan, buffer, offset, xmax) {\n    var rshift = 0, x = 0, len = xmax;\n    while (len > 0) {\n        scan[x][0] = buffer[offset++];\n        scan[x][1] = buffer[offset++];\n        scan[x][2] = buffer[offset++];\n        scan[x][3] = buffer[offset++];\n        if (scan[x][0] === 1 && scan[x][1] === 1 && scan[x][2] === 1) {\n            // exp is count of repeated pixels\n            for (var i = (scan[x][3] << rshift) >>> 0; i > 0; i--) {\n                copyrgbe(scan[x-1], scan[x]);\n                x++;\n                len--;\n            }\n            rshift += 8;\n        } else {\n            x++;\n            len--;\n            rshift = 0;\n        }\n    }\n    return offset;\n}\n\nfunction readColors(scan, buffer, offset, xmax) {\n    if ((xmax < MINELEN) | (xmax > MAXELEN)) {\n        return oldReadColors(scan, buffer, offset, xmax);\n    }\n    var i = buffer[offset++];\n    if (i != 2) {\n        return oldReadColors(scan, buffer, offset - 1, xmax);\n    }\n    scan[0][1] = buffer[offset++];\n    scan[0][2] = buffer[offset++];\n\n    i = buffer[offset++];\n    if ((((scan[0][2] << 8) >>> 0) | i) >>> 0 !== xmax) {\n        return null;\n    }\n    for (var i = 0; i < 4; i++) {\n        for (var x = 0; x < xmax;) {\n            var code = buffer[offset++];\n            if (code > 128) {\n                code = (code & 127) >>> 0;\n                var val = buffer[offset++];\n                while (code--) {\n                    scan[x++][i] = val;\n                }\n            } else {\n                while (code--) {\n                    scan[x++][i] = buffer[offset++];\n                }\n            }\n        }\n    }\n    return offset;\n}\n\n\nvar ret = {\n    // http://www.graphics.cornell.edu/~bjw/rgbe.html\n    // Blender source\n    // http://radsite.lbl.gov/radiance/refer/Notes/picture_format.html\n    parseRGBE: function(arrayBuffer, texture, exposure) {\n        if (exposure == null) {\n            exposure = 0;\n        }\n        var data = new Uint8Array(arrayBuffer);\n        var size = data.length;\n        if (uint82string(data, 0, 2) !== '#?') {\n            return;\n        }\n        // find empty line, next line is resolution info\n        for (var i = 2; i < size; i++) {\n            if (toChar(data[i]) === '\\n' && toChar(data[i+1]) === '\\n') {\n                break;\n            }\n        }\n        if (i >= size) { // not found\n            return;\n        }\n        // find resolution info line\n        i += 2;\n        var str = '';\n        for (; i < size; i++) {\n            var _char = toChar(data[i]);\n            if (_char === '\\n') {\n                break;\n            }\n            str += _char;\n        }\n        // -Y M +X N\n        var tmp = str.split(' ');\n        var height = parseInt(tmp[1]);\n        var width = parseInt(tmp[3]);\n        if (!width || !height) {\n            return;\n        }\n\n        // read and decode actual data\n        var offset = i+1;\n        var scanline = [];\n        // memzero\n        for (var x = 0; x < width; x++) {\n            scanline[x] = [];\n            for (var j = 0; j < 4; j++) {\n                scanline[x][j] = 0;\n            }\n        }\n        var pixels = new Float32Array(width * height * 4);\n        var offset2 = 0;\n        for (var y = 0; y < height; y++) {\n            var offset = readColors(scanline, data, offset, width);\n            if (!offset) {\n                return null;\n            }\n            for (var x = 0; x < width; x++) {\n                rgbe2float(scanline[x], pixels, offset2, exposure);\n                offset2 += 4;\n            }\n        }\n\n        if (!texture) {\n            texture = new Texture2D();\n        }\n        texture.width = width;\n        texture.height = height;\n        texture.pixels = pixels;\n        // HALF_FLOAT can't use Float32Array\n        texture.type = Texture.FLOAT;\n        return texture;\n    },\n\n    parseRGBEFromPNG: function(png) {\n\n    }\n};\n\nexport default ret;\n"]},"metadata":{},"sourceType":"module"}