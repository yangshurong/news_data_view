{"ast":null,"code":"import \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport vendor from './core/vendor';\nimport vec3 from './glmatrix/vec3';\nimport mat4 from './glmatrix/mat4';\nimport BoundingBox from './math/BoundingBox';\nimport GeometryBase from './GeometryBase';\nvar vec3Create = vec3.create;\nvar vec3Add = vec3.add;\nvar vec3Set = vec3.set;\nvar Attribute = GeometryBase.Attribute;\n/**\n * Geometry in ClayGL contains vertex attributes of mesh. These vertex attributes will be finally provided to the {@link clay.Shader}.\n * Different {@link clay.Shader} needs different attributes. Here is a list of attributes used in the builtin shaders.\n *\n * + position: `clay.basic`, `clay.lambert`, `clay.standard`\n * + texcoord0: `clay.basic`, `clay.lambert`, `clay.standard`\n * + color: `clay.basic`, `clay.lambert`, `clay.standard`\n * + weight: `clay.basic`, `clay.lambert`, `clay.standard`\n * + joint: `clay.basic`, `clay.lambert`, `clay.standard`\n * + normal: `clay.lambert`, `clay.standard`\n * + tangent: `clay.standard`\n *\n * #### Create a procedural geometry\n *\n * ClayGL provides a couple of builtin procedural geometries. Inlcuding:\n *\n *  + {@link clay.geometry.Cube}\n *  + {@link clay.geometry.Sphere}\n *  + {@link clay.geometry.Plane}\n *  + {@link clay.geometry.Cylinder}\n *  + {@link clay.geometry.Cone}\n *  + {@link clay.geometry.ParametricSurface}\n *\n * It's simple to create a basic geometry with these classes.\n *\n```js\nvar sphere = new clay.geometry.Sphere({\n    radius: 2\n});\n```\n *\n * #### Create the geometry data by yourself\n *\n * Usually the vertex attributes data are created by the {@link clay.loader.GLTF} or procedural geometries like {@link clay.geometry.Sphere}.\n * Besides these, you can create the data manually. Here is a simple example to create a triangle.\n```js\nvar TRIANGLE_POSITIONS = [\n    [-0.5, -0.5, 0],\n    [0.5, -0.5, 0],\n    [0, 0.5, 0]\n];\nvar geometry = new clay.StaticGeometryBase();\n// Add triangle vertices to position attribute.\ngeometry.attributes.position.fromArray(TRIANGLE_POSITIONS);\n```\n * Then you can use the utility methods like `generateVertexNormals`, `generateTangents` to create the remaining necessary attributes.\n *\n *\n * #### Use with custom shaders\n *\n * If you wan't to write custom shaders. Don't forget to add SEMANTICS to these attributes. For example\n *\n ```glsl\nuniform mat4 worldViewProjection : WORLDVIEWPROJECTION;\nuniform mat4 worldInverseTranspose : WORLDINVERSETRANSPOSE;\nuniform mat4 world : WORLD;\n\nattribute vec3 position : POSITION;\nattribute vec2 texcoord : TEXCOORD_0;\nattribute vec3 normal : NORMAL;\n```\n * These `POSITION`, `TEXCOORD_0`, `NORMAL` are SEMANTICS which will map the attributes in shader to the attributes in the GeometryBase\n *\n * Available attributes SEMANTICS includes `POSITION`, `TEXCOORD_0`, `TEXCOORD_1` `NORMAL`, `TANGENT`, `COLOR`, `WEIGHT`, `JOINT`.\n *\n *\n * @constructor clay.Geometry\n * @extends clay.GeometryBase\n */\n\nvar Geometry = GeometryBase.extend(function () {\n  return (\n    /** @lends clay.Geometry# */\n    {\n      /**\n       * Attributes of geometry. Including:\n       *  + `position`\n       *  + `texcoord0`\n       *  + `texcoord1`\n       *  + `normal`\n       *  + `tangent`\n       *  + `color`\n       *  + `weight`\n       *  + `joint`\n       *  + `barycentric`\n       *\n       * @type {Object.<string, clay.Geometry.Attribute>}\n       */\n      attributes: {\n        position: new Attribute('position', 'float', 3, 'POSITION'),\n        texcoord0: new Attribute('texcoord0', 'float', 2, 'TEXCOORD_0'),\n        texcoord1: new Attribute('texcoord1', 'float', 2, 'TEXCOORD_1'),\n        normal: new Attribute('normal', 'float', 3, 'NORMAL'),\n        tangent: new Attribute('tangent', 'float', 4, 'TANGENT'),\n        color: new Attribute('color', 'float', 4, 'COLOR'),\n        // Skinning attributes\n        // Each vertex can be bind to 4 bones, because the\n        // sum of weights is 1, so the weights is stored in vec3 and the last\n        // can be calculated by 1-w.x-w.y-w.z\n        weight: new Attribute('weight', 'float', 3, 'WEIGHT'),\n        joint: new Attribute('joint', 'float', 4, 'JOINT'),\n        // For wireframe display\n        // http://codeflow.org/entries/2012/aug/02/easy-wireframe-display-with-barycentric-coordinates/\n        barycentric: new Attribute('barycentric', 'float', 3, null)\n      },\n\n      /**\n       * Calculated bounding box of geometry.\n       * @type {clay.BoundingBox}\n       */\n      boundingBox: null\n    }\n  );\n},\n/** @lends clay.Geometry.prototype */\n{\n  mainAttribute: 'position',\n\n  /**\n   * Update boundingBox of Geometry\n   */\n  updateBoundingBox: function () {\n    var bbox = this.boundingBox;\n\n    if (!bbox) {\n      bbox = this.boundingBox = new BoundingBox();\n    }\n\n    var posArr = this.attributes.position.value;\n\n    if (posArr && posArr.length) {\n      var min = bbox.min;\n      var max = bbox.max;\n      var minArr = min.array;\n      var maxArr = max.array;\n      vec3.set(minArr, posArr[0], posArr[1], posArr[2]);\n      vec3.set(maxArr, posArr[0], posArr[1], posArr[2]);\n\n      for (var i = 3; i < posArr.length;) {\n        var x = posArr[i++];\n        var y = posArr[i++];\n        var z = posArr[i++];\n\n        if (x < minArr[0]) {\n          minArr[0] = x;\n        }\n\n        if (y < minArr[1]) {\n          minArr[1] = y;\n        }\n\n        if (z < minArr[2]) {\n          minArr[2] = z;\n        }\n\n        if (x > maxArr[0]) {\n          maxArr[0] = x;\n        }\n\n        if (y > maxArr[1]) {\n          maxArr[1] = y;\n        }\n\n        if (z > maxArr[2]) {\n          maxArr[2] = z;\n        }\n      }\n\n      min._dirty = true;\n      max._dirty = true;\n    }\n  },\n\n  /**\n   * Generate normals per vertex.\n   */\n  generateVertexNormals: function () {\n    if (!this.vertexCount) {\n      return;\n    }\n\n    var indices = this.indices;\n    var attributes = this.attributes;\n    var positions = attributes.position.value;\n    var normals = attributes.normal.value;\n\n    if (!normals || normals.length !== positions.length) {\n      normals = attributes.normal.value = new vendor.Float32Array(positions.length);\n    } else {\n      // Reset\n      for (var i = 0; i < normals.length; i++) {\n        normals[i] = 0;\n      }\n    }\n\n    var p1 = vec3Create();\n    var p2 = vec3Create();\n    var p3 = vec3Create();\n    var v21 = vec3Create();\n    var v32 = vec3Create();\n    var n = vec3Create();\n    var len = indices ? indices.length : this.vertexCount;\n    var i1, i2, i3;\n\n    for (var f = 0; f < len;) {\n      if (indices) {\n        i1 = indices[f++];\n        i2 = indices[f++];\n        i3 = indices[f++];\n      } else {\n        i1 = f++;\n        i2 = f++;\n        i3 = f++;\n      }\n\n      vec3Set(p1, positions[i1 * 3], positions[i1 * 3 + 1], positions[i1 * 3 + 2]);\n      vec3Set(p2, positions[i2 * 3], positions[i2 * 3 + 1], positions[i2 * 3 + 2]);\n      vec3Set(p3, positions[i3 * 3], positions[i3 * 3 + 1], positions[i3 * 3 + 2]);\n      vec3.sub(v21, p1, p2);\n      vec3.sub(v32, p2, p3);\n      vec3.cross(n, v21, v32); // Already be weighted by the triangle area\n\n      for (var i = 0; i < 3; i++) {\n        normals[i1 * 3 + i] = normals[i1 * 3 + i] + n[i];\n        normals[i2 * 3 + i] = normals[i2 * 3 + i] + n[i];\n        normals[i3 * 3 + i] = normals[i3 * 3 + i] + n[i];\n      }\n    }\n\n    for (var i = 0; i < normals.length;) {\n      vec3Set(n, normals[i], normals[i + 1], normals[i + 2]);\n      vec3.normalize(n, n);\n      normals[i++] = n[0];\n      normals[i++] = n[1];\n      normals[i++] = n[2];\n    }\n\n    this.dirty();\n  },\n\n  /**\n   * Generate normals per face.\n   */\n  generateFaceNormals: function () {\n    if (!this.vertexCount) {\n      return;\n    }\n\n    if (!this.isUniqueVertex()) {\n      this.generateUniqueVertex();\n    }\n\n    var indices = this.indices;\n    var attributes = this.attributes;\n    var positions = attributes.position.value;\n    var normals = attributes.normal.value;\n    var p1 = vec3Create();\n    var p2 = vec3Create();\n    var p3 = vec3Create();\n    var v21 = vec3Create();\n    var v32 = vec3Create();\n    var n = vec3Create();\n\n    if (!normals) {\n      normals = attributes.normal.value = new Float32Array(positions.length);\n    }\n\n    var len = indices ? indices.length : this.vertexCount;\n    var i1, i2, i3;\n\n    for (var f = 0; f < len;) {\n      if (indices) {\n        i1 = indices[f++];\n        i2 = indices[f++];\n        i3 = indices[f++];\n      } else {\n        i1 = f++;\n        i2 = f++;\n        i3 = f++;\n      }\n\n      vec3Set(p1, positions[i1 * 3], positions[i1 * 3 + 1], positions[i1 * 3 + 2]);\n      vec3Set(p2, positions[i2 * 3], positions[i2 * 3 + 1], positions[i2 * 3 + 2]);\n      vec3Set(p3, positions[i3 * 3], positions[i3 * 3 + 1], positions[i3 * 3 + 2]);\n      vec3.sub(v21, p1, p2);\n      vec3.sub(v32, p2, p3);\n      vec3.cross(n, v21, v32);\n      vec3.normalize(n, n);\n\n      for (var i = 0; i < 3; i++) {\n        normals[i1 * 3 + i] = n[i];\n        normals[i2 * 3 + i] = n[i];\n        normals[i3 * 3 + i] = n[i];\n      }\n    }\n\n    this.dirty();\n  },\n\n  /**\n   * Generate tangents attributes.\n   */\n  generateTangents: function () {\n    if (!this.vertexCount) {\n      return;\n    }\n\n    var nVertex = this.vertexCount;\n    var attributes = this.attributes;\n\n    if (!attributes.tangent.value) {\n      attributes.tangent.value = new Float32Array(nVertex * 4);\n    }\n\n    var texcoords = attributes.texcoord0.value;\n    var positions = attributes.position.value;\n    var tangents = attributes.tangent.value;\n    var normals = attributes.normal.value;\n\n    if (!texcoords) {\n      console.warn('Geometry without texcoords can\\'t generate tangents.');\n      return;\n    }\n\n    var tan1 = [];\n    var tan2 = [];\n\n    for (var i = 0; i < nVertex; i++) {\n      tan1[i] = [0.0, 0.0, 0.0];\n      tan2[i] = [0.0, 0.0, 0.0];\n    }\n\n    var sdir = [0.0, 0.0, 0.0];\n    var tdir = [0.0, 0.0, 0.0];\n    var indices = this.indices;\n    var len = indices ? indices.length : this.vertexCount;\n    var i1, i2, i3;\n\n    for (var i = 0; i < len;) {\n      if (indices) {\n        i1 = indices[i++];\n        i2 = indices[i++];\n        i3 = indices[i++];\n      } else {\n        i1 = i++;\n        i2 = i++;\n        i3 = i++;\n      }\n\n      var st1s = texcoords[i1 * 2],\n          st2s = texcoords[i2 * 2],\n          st3s = texcoords[i3 * 2],\n          st1t = texcoords[i1 * 2 + 1],\n          st2t = texcoords[i2 * 2 + 1],\n          st3t = texcoords[i3 * 2 + 1],\n          p1x = positions[i1 * 3],\n          p2x = positions[i2 * 3],\n          p3x = positions[i3 * 3],\n          p1y = positions[i1 * 3 + 1],\n          p2y = positions[i2 * 3 + 1],\n          p3y = positions[i3 * 3 + 1],\n          p1z = positions[i1 * 3 + 2],\n          p2z = positions[i2 * 3 + 2],\n          p3z = positions[i3 * 3 + 2];\n      var x1 = p2x - p1x,\n          x2 = p3x - p1x,\n          y1 = p2y - p1y,\n          y2 = p3y - p1y,\n          z1 = p2z - p1z,\n          z2 = p3z - p1z;\n      var s1 = st2s - st1s,\n          s2 = st3s - st1s,\n          t1 = st2t - st1t,\n          t2 = st3t - st1t;\n      var r = 1.0 / (s1 * t2 - t1 * s2);\n      sdir[0] = (t2 * x1 - t1 * x2) * r;\n      sdir[1] = (t2 * y1 - t1 * y2) * r;\n      sdir[2] = (t2 * z1 - t1 * z2) * r;\n      tdir[0] = (s1 * x2 - s2 * x1) * r;\n      tdir[1] = (s1 * y2 - s2 * y1) * r;\n      tdir[2] = (s1 * z2 - s2 * z1) * r;\n      vec3Add(tan1[i1], tan1[i1], sdir);\n      vec3Add(tan1[i2], tan1[i2], sdir);\n      vec3Add(tan1[i3], tan1[i3], sdir);\n      vec3Add(tan2[i1], tan2[i1], tdir);\n      vec3Add(tan2[i2], tan2[i2], tdir);\n      vec3Add(tan2[i3], tan2[i3], tdir);\n    }\n\n    var tmp = vec3Create();\n    var nCrossT = vec3Create();\n    var n = vec3Create();\n\n    for (var i = 0; i < nVertex; i++) {\n      n[0] = normals[i * 3];\n      n[1] = normals[i * 3 + 1];\n      n[2] = normals[i * 3 + 2];\n      var t = tan1[i]; // Gram-Schmidt orthogonalize\n\n      vec3.scale(tmp, n, vec3.dot(n, t));\n      vec3.sub(tmp, t, tmp);\n      vec3.normalize(tmp, tmp); // Calculate handedness.\n\n      vec3.cross(nCrossT, n, t);\n      tangents[i * 4] = tmp[0];\n      tangents[i * 4 + 1] = tmp[1];\n      tangents[i * 4 + 2] = tmp[2]; // PENDING can config ?\n\n      tangents[i * 4 + 3] = vec3.dot(nCrossT, tan2[i]) < 0.0 ? -1.0 : 1.0;\n    }\n\n    this.dirty();\n  },\n\n  /**\n   * If vertices are not shared by different indices.\n   */\n  isUniqueVertex: function () {\n    if (this.isUseIndices()) {\n      return this.vertexCount === this.indices.length;\n    } else {\n      return true;\n    }\n  },\n\n  /**\n   * Create a unique vertex for each index.\n   */\n  generateUniqueVertex: function () {\n    if (!this.vertexCount || !this.indices) {\n      return;\n    }\n\n    if (this.indices.length > 0xffff) {\n      this.indices = new vendor.Uint32Array(this.indices);\n    }\n\n    var attributes = this.attributes;\n    var indices = this.indices;\n    var attributeNameList = this.getEnabledAttributes();\n    var oldAttrValues = {};\n\n    for (var a = 0; a < attributeNameList.length; a++) {\n      var name = attributeNameList[a];\n      oldAttrValues[name] = attributes[name].value;\n      attributes[name].init(this.indices.length);\n    }\n\n    var cursor = 0;\n\n    for (var i = 0; i < indices.length; i++) {\n      var ii = indices[i];\n\n      for (var a = 0; a < attributeNameList.length; a++) {\n        var name = attributeNameList[a];\n        var array = attributes[name].value;\n        var size = attributes[name].size;\n\n        for (var k = 0; k < size; k++) {\n          array[cursor * size + k] = oldAttrValues[name][ii * size + k];\n        }\n      }\n\n      indices[i] = cursor;\n      cursor++;\n    }\n\n    this.dirty();\n  },\n\n  /**\n   * Generate barycentric coordinates for wireframe draw.\n   */\n  generateBarycentric: function () {\n    if (!this.vertexCount) {\n      return;\n    }\n\n    if (!this.isUniqueVertex()) {\n      this.generateUniqueVertex();\n    }\n\n    var attributes = this.attributes;\n    var array = attributes.barycentric.value;\n    var indices = this.indices; // Already existed;\n\n    if (array && array.length === indices.length * 3) {\n      return;\n    }\n\n    array = attributes.barycentric.value = new Float32Array(indices.length * 3);\n\n    for (var i = 0; i < (indices ? indices.length : this.vertexCount / 3);) {\n      for (var j = 0; j < 3; j++) {\n        var ii = indices ? indices[i++] : i * 3 + j;\n        array[ii * 3 + j] = 1;\n      }\n    }\n\n    this.dirty();\n  },\n\n  /**\n   * Apply transform to geometry attributes.\n   * @param {clay.Matrix4} matrix\n   */\n  applyTransform: function (matrix) {\n    var attributes = this.attributes;\n    var positions = attributes.position.value;\n    var normals = attributes.normal.value;\n    var tangents = attributes.tangent.value;\n    matrix = matrix.array; // Normal Matrix\n\n    var inverseTransposeMatrix = mat4.create();\n    mat4.invert(inverseTransposeMatrix, matrix);\n    mat4.transpose(inverseTransposeMatrix, inverseTransposeMatrix);\n    var vec3TransformMat4 = vec3.transformMat4;\n    var vec3ForEach = vec3.forEach;\n    vec3ForEach(positions, 3, 0, null, vec3TransformMat4, matrix);\n\n    if (normals) {\n      vec3ForEach(normals, 3, 0, null, vec3TransformMat4, inverseTransposeMatrix);\n    }\n\n    if (tangents) {\n      vec3ForEach(tangents, 4, 0, null, vec3TransformMat4, inverseTransposeMatrix);\n    }\n\n    if (this.boundingBox) {\n      this.updateBoundingBox();\n    }\n  },\n\n  /**\n   * Dispose geometry data in GL context.\n   * @param {clay.Renderer} renderer\n   */\n  dispose: function (renderer) {\n    var cache = this._cache;\n    cache.use(renderer.__uid__);\n    var chunks = cache.get('chunks');\n\n    if (chunks) {\n      for (var c = 0; c < chunks.length; c++) {\n        var chunk = chunks[c];\n\n        for (var k = 0; k < chunk.attributeBuffers.length; k++) {\n          var attribs = chunk.attributeBuffers[k];\n          renderer.gl.deleteBuffer(attribs.buffer);\n        }\n\n        if (chunk.indicesBuffer) {\n          renderer.gl.deleteBuffer(chunk.indicesBuffer.buffer);\n        }\n      }\n    }\n\n    if (this.__vaoCache) {\n      var vaoExt = renderer.getGLExtension('OES_vertex_array_object');\n\n      for (var id in this.__vaoCache) {\n        var vao = this.__vaoCache[id].vao;\n\n        if (vao) {\n          vaoExt.deleteVertexArrayOES(vao);\n        }\n      }\n    }\n\n    this.__vaoCache = {};\n    cache.deleteContext(renderer.__uid__);\n  }\n});\nGeometry.STATIC_DRAW = GeometryBase.STATIC_DRAW;\nGeometry.DYNAMIC_DRAW = GeometryBase.DYNAMIC_DRAW;\nGeometry.STREAM_DRAW = GeometryBase.STREAM_DRAW;\nGeometry.AttributeBuffer = GeometryBase.AttributeBuffer;\nGeometry.IndicesBuffer = GeometryBase.IndicesBuffer;\nGeometry.Attribute = Attribute;\nexport default Geometry;","map":{"version":3,"sources":["C:/Users/Administrator/Desktop/data_view/my_project/vue2_app/myapp/node_modules/claygl/src/Geometry.js"],"names":["vendor","vec3","mat4","BoundingBox","GeometryBase","vec3Create","create","vec3Add","add","vec3Set","set","Attribute","Geometry","extend","attributes","position","texcoord0","texcoord1","normal","tangent","color","weight","joint","barycentric","boundingBox","mainAttribute","updateBoundingBox","bbox","posArr","value","length","min","max","minArr","array","maxArr","i","x","y","z","_dirty","generateVertexNormals","vertexCount","indices","positions","normals","Float32Array","p1","p2","p3","v21","v32","n","len","i1","i2","i3","f","sub","cross","normalize","dirty","generateFaceNormals","isUniqueVertex","generateUniqueVertex","generateTangents","nVertex","texcoords","tangents","console","warn","tan1","tan2","sdir","tdir","st1s","st2s","st3s","st1t","st2t","st3t","p1x","p2x","p3x","p1y","p2y","p3y","p1z","p2z","p3z","x1","x2","y1","y2","z1","z2","s1","s2","t1","t2","r","tmp","nCrossT","t","scale","dot","isUseIndices","Uint32Array","attributeNameList","getEnabledAttributes","oldAttrValues","a","name","init","cursor","ii","size","k","generateBarycentric","j","applyTransform","matrix","inverseTransposeMatrix","invert","transpose","vec3TransformMat4","transformMat4","vec3ForEach","forEach","dispose","renderer","cache","_cache","use","__uid__","chunks","get","c","chunk","attributeBuffers","attribs","gl","deleteBuffer","buffer","indicesBuffer","__vaoCache","vaoExt","getGLExtension","id","vao","deleteVertexArrayOES","deleteContext","STATIC_DRAW","DYNAMIC_DRAW","STREAM_DRAW","AttributeBuffer","IndicesBuffer"],"mappings":"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","sourcesContent":["import vendor from './core/vendor';\nimport vec3 from './glmatrix/vec3';\nimport mat4 from './glmatrix/mat4';\nimport BoundingBox from './math/BoundingBox';\nimport GeometryBase from './GeometryBase';\n\nvar vec3Create = vec3.create;\nvar vec3Add = vec3.add;\nvar vec3Set = vec3.set;\n\nvar Attribute = GeometryBase.Attribute;\n\n/**\n * Geometry in ClayGL contains vertex attributes of mesh. These vertex attributes will be finally provided to the {@link clay.Shader}.\n * Different {@link clay.Shader} needs different attributes. Here is a list of attributes used in the builtin shaders.\n *\n * + position: `clay.basic`, `clay.lambert`, `clay.standard`\n * + texcoord0: `clay.basic`, `clay.lambert`, `clay.standard`\n * + color: `clay.basic`, `clay.lambert`, `clay.standard`\n * + weight: `clay.basic`, `clay.lambert`, `clay.standard`\n * + joint: `clay.basic`, `clay.lambert`, `clay.standard`\n * + normal: `clay.lambert`, `clay.standard`\n * + tangent: `clay.standard`\n *\n * #### Create a procedural geometry\n *\n * ClayGL provides a couple of builtin procedural geometries. Inlcuding:\n *\n *  + {@link clay.geometry.Cube}\n *  + {@link clay.geometry.Sphere}\n *  + {@link clay.geometry.Plane}\n *  + {@link clay.geometry.Cylinder}\n *  + {@link clay.geometry.Cone}\n *  + {@link clay.geometry.ParametricSurface}\n *\n * It's simple to create a basic geometry with these classes.\n *\n```js\nvar sphere = new clay.geometry.Sphere({\n    radius: 2\n});\n```\n *\n * #### Create the geometry data by yourself\n *\n * Usually the vertex attributes data are created by the {@link clay.loader.GLTF} or procedural geometries like {@link clay.geometry.Sphere}.\n * Besides these, you can create the data manually. Here is a simple example to create a triangle.\n```js\nvar TRIANGLE_POSITIONS = [\n    [-0.5, -0.5, 0],\n    [0.5, -0.5, 0],\n    [0, 0.5, 0]\n];\nvar geometry = new clay.StaticGeometryBase();\n// Add triangle vertices to position attribute.\ngeometry.attributes.position.fromArray(TRIANGLE_POSITIONS);\n```\n * Then you can use the utility methods like `generateVertexNormals`, `generateTangents` to create the remaining necessary attributes.\n *\n *\n * #### Use with custom shaders\n *\n * If you wan't to write custom shaders. Don't forget to add SEMANTICS to these attributes. For example\n *\n ```glsl\nuniform mat4 worldViewProjection : WORLDVIEWPROJECTION;\nuniform mat4 worldInverseTranspose : WORLDINVERSETRANSPOSE;\nuniform mat4 world : WORLD;\n\nattribute vec3 position : POSITION;\nattribute vec2 texcoord : TEXCOORD_0;\nattribute vec3 normal : NORMAL;\n```\n * These `POSITION`, `TEXCOORD_0`, `NORMAL` are SEMANTICS which will map the attributes in shader to the attributes in the GeometryBase\n *\n * Available attributes SEMANTICS includes `POSITION`, `TEXCOORD_0`, `TEXCOORD_1` `NORMAL`, `TANGENT`, `COLOR`, `WEIGHT`, `JOINT`.\n *\n *\n * @constructor clay.Geometry\n * @extends clay.GeometryBase\n */\nvar Geometry = GeometryBase.extend(function () {\n    return /** @lends clay.Geometry# */ {\n        /**\n         * Attributes of geometry. Including:\n         *  + `position`\n         *  + `texcoord0`\n         *  + `texcoord1`\n         *  + `normal`\n         *  + `tangent`\n         *  + `color`\n         *  + `weight`\n         *  + `joint`\n         *  + `barycentric`\n         *\n         * @type {Object.<string, clay.Geometry.Attribute>}\n         */\n        attributes: {\n            position: new Attribute('position', 'float', 3, 'POSITION'),\n            texcoord0: new Attribute('texcoord0', 'float', 2, 'TEXCOORD_0'),\n            texcoord1: new Attribute('texcoord1', 'float', 2, 'TEXCOORD_1'),\n            normal: new Attribute('normal', 'float', 3, 'NORMAL'),\n            tangent: new Attribute('tangent', 'float', 4, 'TANGENT'),\n            color: new Attribute('color', 'float', 4, 'COLOR'),\n            // Skinning attributes\n            // Each vertex can be bind to 4 bones, because the\n            // sum of weights is 1, so the weights is stored in vec3 and the last\n            // can be calculated by 1-w.x-w.y-w.z\n            weight: new Attribute('weight', 'float', 3, 'WEIGHT'),\n            joint: new Attribute('joint', 'float', 4, 'JOINT'),\n            // For wireframe display\n            // http://codeflow.org/entries/2012/aug/02/easy-wireframe-display-with-barycentric-coordinates/\n            barycentric: new Attribute('barycentric', 'float', 3, null),\n        },\n        /**\n         * Calculated bounding box of geometry.\n         * @type {clay.BoundingBox}\n         */\n        boundingBox: null\n    };\n},\n/** @lends clay.Geometry.prototype */\n{\n\n    mainAttribute: 'position',\n\n    /**\n     * Update boundingBox of Geometry\n     */\n    updateBoundingBox: function () {\n        var bbox = this.boundingBox;\n        if (!bbox) {\n            bbox = this.boundingBox = new BoundingBox();\n        }\n        var posArr = this.attributes.position.value;\n        if (posArr && posArr.length) {\n            var min = bbox.min;\n            var max = bbox.max;\n            var minArr = min.array;\n            var maxArr = max.array;\n            vec3.set(minArr, posArr[0], posArr[1], posArr[2]);\n            vec3.set(maxArr, posArr[0], posArr[1], posArr[2]);\n            for (var i = 3; i < posArr.length;) {\n                var x = posArr[i++];\n                var y = posArr[i++];\n                var z = posArr[i++];\n                if (x < minArr[0]) { minArr[0] = x; }\n                if (y < minArr[1]) { minArr[1] = y; }\n                if (z < minArr[2]) { minArr[2] = z; }\n\n                if (x > maxArr[0]) { maxArr[0] = x; }\n                if (y > maxArr[1]) { maxArr[1] = y; }\n                if (z > maxArr[2]) { maxArr[2] = z; }\n            }\n            min._dirty = true;\n            max._dirty = true;\n        }\n    },\n\n    /**\n     * Generate normals per vertex.\n     */\n    generateVertexNormals: function () {\n        if (!this.vertexCount) {\n            return;\n        }\n\n        var indices = this.indices;\n        var attributes = this.attributes;\n        var positions = attributes.position.value;\n        var normals = attributes.normal.value;\n\n        if (!normals || normals.length !== positions.length) {\n            normals = attributes.normal.value = new vendor.Float32Array(positions.length);\n        }\n        else {\n            // Reset\n            for (var i = 0; i < normals.length; i++) {\n                normals[i] = 0;\n            }\n        }\n\n        var p1 = vec3Create();\n        var p2 = vec3Create();\n        var p3 = vec3Create();\n\n        var v21 = vec3Create();\n        var v32 = vec3Create();\n\n        var n = vec3Create();\n\n        var len = indices ? indices.length : this.vertexCount;\n        var i1, i2, i3;\n        for (var f = 0; f < len;) {\n            if (indices) {\n                i1 = indices[f++];\n                i2 = indices[f++];\n                i3 = indices[f++];\n            }\n            else {\n                i1 = f++;\n                i2 = f++;\n                i3 = f++;\n            }\n\n            vec3Set(p1, positions[i1*3], positions[i1*3+1], positions[i1*3+2]);\n            vec3Set(p2, positions[i2*3], positions[i2*3+1], positions[i2*3+2]);\n            vec3Set(p3, positions[i3*3], positions[i3*3+1], positions[i3*3+2]);\n\n            vec3.sub(v21, p1, p2);\n            vec3.sub(v32, p2, p3);\n            vec3.cross(n, v21, v32);\n            // Already be weighted by the triangle area\n            for (var i = 0; i < 3; i++) {\n                normals[i1*3+i] = normals[i1*3+i] + n[i];\n                normals[i2*3+i] = normals[i2*3+i] + n[i];\n                normals[i3*3+i] = normals[i3*3+i] + n[i];\n            }\n        }\n\n        for (var i = 0; i < normals.length;) {\n            vec3Set(n, normals[i], normals[i+1], normals[i+2]);\n            vec3.normalize(n, n);\n            normals[i++] = n[0];\n            normals[i++] = n[1];\n            normals[i++] = n[2];\n        }\n        this.dirty();\n    },\n\n    /**\n     * Generate normals per face.\n     */\n    generateFaceNormals: function () {\n        if (!this.vertexCount) {\n            return;\n        }\n\n        if (!this.isUniqueVertex()) {\n            this.generateUniqueVertex();\n        }\n\n        var indices = this.indices;\n        var attributes = this.attributes;\n        var positions = attributes.position.value;\n        var normals = attributes.normal.value;\n\n        var p1 = vec3Create();\n        var p2 = vec3Create();\n        var p3 = vec3Create();\n\n        var v21 = vec3Create();\n        var v32 = vec3Create();\n        var n = vec3Create();\n\n        if (!normals) {\n            normals = attributes.normal.value = new Float32Array(positions.length);\n        }\n        var len = indices ? indices.length : this.vertexCount;\n        var i1, i2, i3;\n        for (var f = 0; f < len;) {\n            if (indices) {\n                i1 = indices[f++];\n                i2 = indices[f++];\n                i3 = indices[f++];\n            }\n            else {\n                i1 = f++;\n                i2 = f++;\n                i3 = f++;\n            }\n\n            vec3Set(p1, positions[i1*3], positions[i1*3+1], positions[i1*3+2]);\n            vec3Set(p2, positions[i2*3], positions[i2*3+1], positions[i2*3+2]);\n            vec3Set(p3, positions[i3*3], positions[i3*3+1], positions[i3*3+2]);\n\n            vec3.sub(v21, p1, p2);\n            vec3.sub(v32, p2, p3);\n            vec3.cross(n, v21, v32);\n\n            vec3.normalize(n, n);\n\n            for (var i = 0; i < 3; i++) {\n                normals[i1*3 + i] = n[i];\n                normals[i2*3 + i] = n[i];\n                normals[i3*3 + i] = n[i];\n            }\n        }\n        this.dirty();\n    },\n\n    /**\n     * Generate tangents attributes.\n     */\n    generateTangents: function () {\n        if (!this.vertexCount) {\n            return;\n        }\n\n        var nVertex = this.vertexCount;\n        var attributes = this.attributes;\n        if (!attributes.tangent.value) {\n            attributes.tangent.value = new Float32Array(nVertex * 4);\n        }\n        var texcoords = attributes.texcoord0.value;\n        var positions = attributes.position.value;\n        var tangents = attributes.tangent.value;\n        var normals = attributes.normal.value;\n\n        if (!texcoords) {\n            console.warn('Geometry without texcoords can\\'t generate tangents.');\n            return;\n        }\n\n        var tan1 = [];\n        var tan2 = [];\n        for (var i = 0; i < nVertex; i++) {\n            tan1[i] = [0.0, 0.0, 0.0];\n            tan2[i] = [0.0, 0.0, 0.0];\n        }\n\n        var sdir = [0.0, 0.0, 0.0];\n        var tdir = [0.0, 0.0, 0.0];\n        var indices = this.indices;\n\n        var len = indices ? indices.length : this.vertexCount;\n        var i1, i2, i3;\n        for (var i = 0; i < len;) {\n            if (indices) {\n                i1 = indices[i++];\n                i2 = indices[i++];\n                i3 = indices[i++];\n            }\n            else {\n                i1 = i++;\n                i2 = i++;\n                i3 = i++;\n            }\n\n            var st1s = texcoords[i1 * 2],\n                st2s = texcoords[i2 * 2],\n                st3s = texcoords[i3 * 2],\n                st1t = texcoords[i1 * 2 + 1],\n                st2t = texcoords[i2 * 2 + 1],\n                st3t = texcoords[i3 * 2 + 1],\n\n                p1x = positions[i1 * 3],\n                p2x = positions[i2 * 3],\n                p3x = positions[i3 * 3],\n                p1y = positions[i1 * 3 + 1],\n                p2y = positions[i2 * 3 + 1],\n                p3y = positions[i3 * 3 + 1],\n                p1z = positions[i1 * 3 + 2],\n                p2z = positions[i2 * 3 + 2],\n                p3z = positions[i3 * 3 + 2];\n\n            var x1 = p2x - p1x,\n                x2 = p3x - p1x,\n                y1 = p2y - p1y,\n                y2 = p3y - p1y,\n                z1 = p2z - p1z,\n                z2 = p3z - p1z;\n\n            var s1 = st2s - st1s,\n                s2 = st3s - st1s,\n                t1 = st2t - st1t,\n                t2 = st3t - st1t;\n\n            var r = 1.0 / (s1 * t2 - t1 * s2);\n            sdir[0] = (t2 * x1 - t1 * x2) * r;\n            sdir[1] = (t2 * y1 - t1 * y2) * r;\n            sdir[2] = (t2 * z1 - t1 * z2) * r;\n\n            tdir[0] = (s1 * x2 - s2 * x1) * r;\n            tdir[1] = (s1 * y2 - s2 * y1) * r;\n            tdir[2] = (s1 * z2 - s2 * z1) * r;\n\n            vec3Add(tan1[i1], tan1[i1], sdir);\n            vec3Add(tan1[i2], tan1[i2], sdir);\n            vec3Add(tan1[i3], tan1[i3], sdir);\n            vec3Add(tan2[i1], tan2[i1], tdir);\n            vec3Add(tan2[i2], tan2[i2], tdir);\n            vec3Add(tan2[i3], tan2[i3], tdir);\n        }\n        var tmp = vec3Create();\n        var nCrossT = vec3Create();\n        var n = vec3Create();\n        for (var i = 0; i < nVertex; i++) {\n            n[0] = normals[i * 3];\n            n[1] = normals[i * 3 + 1];\n            n[2] = normals[i * 3 + 2];\n            var t = tan1[i];\n\n            // Gram-Schmidt orthogonalize\n            vec3.scale(tmp, n, vec3.dot(n, t));\n            vec3.sub(tmp, t, tmp);\n            vec3.normalize(tmp, tmp);\n            // Calculate handedness.\n            vec3.cross(nCrossT, n, t);\n            tangents[i * 4] = tmp[0];\n            tangents[i * 4 + 1] = tmp[1];\n            tangents[i * 4 + 2] = tmp[2];\n            // PENDING can config ?\n            tangents[i * 4 + 3] = vec3.dot(nCrossT, tan2[i]) < 0.0 ? -1.0 : 1.0;\n        }\n        this.dirty();\n    },\n\n    /**\n     * If vertices are not shared by different indices.\n     */\n    isUniqueVertex: function () {\n        if (this.isUseIndices()) {\n            return this.vertexCount === this.indices.length;\n        }\n        else {\n            return true;\n        }\n    },\n    /**\n     * Create a unique vertex for each index.\n     */\n    generateUniqueVertex: function () {\n        if (!this.vertexCount || !this.indices) {\n            return;\n        }\n\n        if (this.indices.length > 0xffff) {\n            this.indices = new vendor.Uint32Array(this.indices);\n        }\n\n        var attributes = this.attributes;\n        var indices = this.indices;\n\n        var attributeNameList = this.getEnabledAttributes();\n\n        var oldAttrValues = {};\n        for (var a = 0; a < attributeNameList.length; a++) {\n            var name = attributeNameList[a];\n            oldAttrValues[name] = attributes[name].value;\n            attributes[name].init(this.indices.length);\n        }\n\n        var cursor = 0;\n        for (var i = 0; i < indices.length; i++) {\n            var ii = indices[i];\n            for (var a = 0; a < attributeNameList.length; a++) {\n                var name = attributeNameList[a];\n                var array = attributes[name].value;\n                var size = attributes[name].size;\n\n                for (var k = 0; k < size; k++) {\n                    array[cursor * size + k] = oldAttrValues[name][ii * size + k];\n                }\n            }\n            indices[i] = cursor;\n            cursor++;\n        }\n\n        this.dirty();\n    },\n\n    /**\n     * Generate barycentric coordinates for wireframe draw.\n     */\n    generateBarycentric: function () {\n        if (!this.vertexCount) {\n            return;\n        }\n\n        if (!this.isUniqueVertex()) {\n            this.generateUniqueVertex();\n        }\n\n        var attributes = this.attributes;\n        var array = attributes.barycentric.value;\n        var indices = this.indices;\n        // Already existed;\n        if (array && array.length === indices.length * 3) {\n            return;\n        }\n        array = attributes.barycentric.value = new Float32Array(indices.length * 3);\n\n        for (var i = 0; i < (indices ? indices.length : this.vertexCount / 3);) {\n            for (var j = 0; j < 3; j++) {\n                var ii = indices ? indices[i++] : (i * 3 + j);\n                array[ii * 3 + j] = 1;\n            }\n        }\n        this.dirty();\n    },\n\n    /**\n     * Apply transform to geometry attributes.\n     * @param {clay.Matrix4} matrix\n     */\n    applyTransform: function (matrix) {\n\n        var attributes = this.attributes;\n        var positions = attributes.position.value;\n        var normals = attributes.normal.value;\n        var tangents = attributes.tangent.value;\n\n        matrix = matrix.array;\n        // Normal Matrix\n        var inverseTransposeMatrix = mat4.create();\n        mat4.invert(inverseTransposeMatrix, matrix);\n        mat4.transpose(inverseTransposeMatrix, inverseTransposeMatrix);\n\n        var vec3TransformMat4 = vec3.transformMat4;\n        var vec3ForEach = vec3.forEach;\n        vec3ForEach(positions, 3, 0, null, vec3TransformMat4, matrix);\n        if (normals) {\n            vec3ForEach(normals, 3, 0, null, vec3TransformMat4, inverseTransposeMatrix);\n        }\n        if (tangents) {\n            vec3ForEach(tangents, 4, 0, null, vec3TransformMat4, inverseTransposeMatrix);\n        }\n\n        if (this.boundingBox) {\n            this.updateBoundingBox();\n        }\n    },\n    /**\n     * Dispose geometry data in GL context.\n     * @param {clay.Renderer} renderer\n     */\n    dispose: function (renderer) {\n\n        var cache = this._cache;\n\n        cache.use(renderer.__uid__);\n        var chunks = cache.get('chunks');\n        if (chunks) {\n            for (var c = 0; c < chunks.length; c++) {\n                var chunk = chunks[c];\n\n                for (var k = 0; k < chunk.attributeBuffers.length; k++) {\n                    var attribs = chunk.attributeBuffers[k];\n                    renderer.gl.deleteBuffer(attribs.buffer);\n                }\n\n                if (chunk.indicesBuffer) {\n                    renderer.gl.deleteBuffer(chunk.indicesBuffer.buffer);\n                }\n            }\n        }\n        if (this.__vaoCache) {\n            var vaoExt = renderer.getGLExtension('OES_vertex_array_object');\n            for (var id in this.__vaoCache) {\n                var vao = this.__vaoCache[id].vao;\n                if (vao) {\n                    vaoExt.deleteVertexArrayOES(vao);\n                }\n            }\n        }\n        this.__vaoCache = {};\n        cache.deleteContext(renderer.__uid__);\n    }\n\n});\n\nGeometry.STATIC_DRAW = GeometryBase.STATIC_DRAW;\nGeometry.DYNAMIC_DRAW = GeometryBase.DYNAMIC_DRAW;\nGeometry.STREAM_DRAW = GeometryBase.STREAM_DRAW;\n\nGeometry.AttributeBuffer = GeometryBase.AttributeBuffer;\nGeometry.IndicesBuffer = GeometryBase.IndicesBuffer;\n\nGeometry.Attribute = Attribute;\n\nexport default Geometry;\n"]},"metadata":{},"sourceType":"module"}