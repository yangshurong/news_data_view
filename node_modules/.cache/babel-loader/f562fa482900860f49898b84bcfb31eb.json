{"ast":null,"code":"import Base from '../core/Base';\nimport OrthoCamera from '../camera/Orthographic';\nimport Plane from '../geometry/Plane';\nimport Shader from '../Shader';\nimport Material from '../Material';\nimport Mesh from '../Mesh';\nimport glenum from '../core/glenum';\nimport vertexGlsl from '../shader/source/compositor/vertex.glsl.js';\nShader['import'](vertexGlsl);\nvar planeGeo = new Plane();\nvar mesh = new Mesh({\n  geometry: planeGeo,\n  frustumCulling: false\n});\nvar camera = new OrthoCamera();\n/**\n * @constructor clay.compositor.Pass\n * @extends clay.core.Base\n */\n\nvar Pass = Base.extend(function () {\n  return (\n    /** @lends clay.compositor.Pass# */\n    {\n      /**\n       * Fragment shader string\n       * @type {string}\n       */\n      // PENDING shader or fragment ?\n      fragment: '',\n\n      /**\n       * @type {Object}\n       */\n      outputs: null,\n\n      /**\n       * @type {clay.Material}\n       */\n      material: null,\n\n      /**\n       * @type {Boolean}\n       */\n      blendWithPrevious: false,\n\n      /**\n       * @type {Boolean}\n       */\n      clearColor: false,\n\n      /**\n       * @type {Boolean}\n       */\n      clearDepth: true\n    }\n  );\n}, function () {\n  var shader = new Shader(Shader.source('clay.compositor.vertex'), this.fragment);\n  var material = new Material({\n    shader: shader\n  });\n  material.enableTexturesAll();\n  this.material = material;\n},\n/** @lends clay.compositor.Pass.prototype */\n{\n  /**\n   * @param {string} name\n   * @param {} value\n   */\n  setUniform: function setUniform(name, value) {\n    this.material.setUniform(name, value);\n  },\n\n  /**\n   * @param  {string} name\n   * @return {}\n   */\n  getUniform: function getUniform(name) {\n    var uniform = this.material.uniforms[name];\n\n    if (uniform) {\n      return uniform.value;\n    }\n  },\n\n  /**\n   * @param  {clay.Texture} texture\n   * @param  {number} attachment\n   */\n  attachOutput: function attachOutput(texture, attachment) {\n    if (!this.outputs) {\n      this.outputs = {};\n    }\n\n    attachment = attachment || glenum.COLOR_ATTACHMENT0;\n    this.outputs[attachment] = texture;\n  },\n\n  /**\n   * @param  {clay.Texture} texture\n   */\n  detachOutput: function detachOutput(texture) {\n    for (var attachment in this.outputs) {\n      if (this.outputs[attachment] === texture) {\n        this.outputs[attachment] = null;\n      }\n    }\n  },\n  bind: function bind(renderer, frameBuffer) {\n    if (this.outputs) {\n      for (var attachment in this.outputs) {\n        var texture = this.outputs[attachment];\n\n        if (texture) {\n          frameBuffer.attach(texture, attachment);\n        }\n      }\n    }\n\n    if (frameBuffer) {\n      frameBuffer.bind(renderer);\n    }\n  },\n  unbind: function unbind(renderer, frameBuffer) {\n    frameBuffer.unbind(renderer);\n  },\n\n  /**\n   * @param  {clay.Renderer} renderer\n   * @param  {clay.FrameBuffer} [frameBuffer]\n   */\n  render: function render(renderer, frameBuffer) {\n    var _gl = renderer.gl;\n\n    if (frameBuffer) {\n      this.bind(renderer, frameBuffer); // MRT Support in chrome\n      // https://www.khronos.org/registry/webgl/sdk/tests/conformance/extensions/ext-draw-buffers.html\n\n      var ext = renderer.getGLExtension('EXT_draw_buffers');\n\n      if (ext && this.outputs) {\n        var bufs = [];\n\n        for (var attachment in this.outputs) {\n          attachment = +attachment;\n\n          if (attachment >= _gl.COLOR_ATTACHMENT0 && attachment <= _gl.COLOR_ATTACHMENT0 + 8) {\n            bufs.push(attachment);\n          }\n        }\n\n        ext.drawBuffersEXT(bufs);\n      }\n    }\n\n    this.trigger('beforerender', this, renderer); // FIXME Don't clear in each pass in default, let the color overwrite the buffer\n    // FIXME pixels may be discard\n\n    var clearBit = this.clearDepth ? _gl.DEPTH_BUFFER_BIT : 0;\n\n    _gl.depthMask(true);\n\n    if (this.clearColor) {\n      clearBit = clearBit | _gl.COLOR_BUFFER_BIT;\n\n      _gl.colorMask(true, true, true, true);\n\n      var cc = this.clearColor;\n\n      if (Array.isArray(cc)) {\n        _gl.clearColor(cc[0], cc[1], cc[2], cc[3]);\n      }\n    }\n\n    _gl.clear(clearBit);\n\n    if (this.blendWithPrevious) {\n      // Blend with previous rendered scene in the final output\n      // FIXME Configure blend.\n      // FIXME It will cause screen blink？\n      _gl.enable(_gl.BLEND);\n\n      this.material.transparent = true;\n    } else {\n      _gl.disable(_gl.BLEND);\n\n      this.material.transparent = false;\n    }\n\n    this.renderQuad(renderer);\n    this.trigger('afterrender', this, renderer);\n\n    if (frameBuffer) {\n      this.unbind(renderer, frameBuffer);\n    }\n  },\n\n  /**\n   * Simply do quad rendering\n   */\n  renderQuad: function renderQuad(renderer) {\n    mesh.material = this.material;\n    renderer.renderPass([mesh], camera);\n  },\n\n  /**\n   * @param  {clay.Renderer} renderer\n   */\n  dispose: function dispose(renderer) {}\n});\nexport default Pass;","map":{"version":3,"sources":["C:/Users/Administrator/Desktop/data_view/my_project/vue2_app/myapp/node_modules/claygl/src/compositor/Pass.js"],"names":["Base","OrthoCamera","Plane","Shader","Material","Mesh","glenum","vertexGlsl","planeGeo","mesh","geometry","frustumCulling","camera","Pass","extend","fragment","outputs","material","blendWithPrevious","clearColor","clearDepth","shader","source","enableTexturesAll","setUniform","name","value","getUniform","uniform","uniforms","attachOutput","texture","attachment","COLOR_ATTACHMENT0","detachOutput","bind","renderer","frameBuffer","attach","unbind","render","_gl","gl","ext","getGLExtension","bufs","push","drawBuffersEXT","trigger","clearBit","DEPTH_BUFFER_BIT","depthMask","COLOR_BUFFER_BIT","colorMask","cc","Array","isArray","clear","enable","BLEND","transparent","disable","renderQuad","renderPass","dispose"],"mappings":"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","sourcesContent":["import Base from '../core/Base';\nimport OrthoCamera from '../camera/Orthographic';\nimport Plane from '../geometry/Plane';\nimport Shader from '../Shader';\nimport Material from '../Material';\nimport Mesh from '../Mesh';\nimport glenum from '../core/glenum';\nimport vertexGlsl from '../shader/source/compositor/vertex.glsl.js';\n\nShader['import'](vertexGlsl);\n\nvar planeGeo = new Plane();\nvar mesh = new Mesh({\n    geometry: planeGeo,\n    frustumCulling: false\n});\nvar camera = new OrthoCamera();\n\n/**\n * @constructor clay.compositor.Pass\n * @extends clay.core.Base\n */\nvar Pass = Base.extend(function () {\n    return /** @lends clay.compositor.Pass# */ {\n        /**\n         * Fragment shader string\n         * @type {string}\n         */\n        // PENDING shader or fragment ?\n        fragment: '',\n\n        /**\n         * @type {Object}\n         */\n        outputs: null,\n\n        /**\n         * @type {clay.Material}\n         */\n        material: null,\n\n        /**\n         * @type {Boolean}\n         */\n        blendWithPrevious: false,\n\n        /**\n         * @type {Boolean}\n         */\n        clearColor: false,\n\n        /**\n         * @type {Boolean}\n         */\n        clearDepth: true\n    };\n}, function() {\n\n    var shader = new Shader(Shader.source('clay.compositor.vertex'), this.fragment);\n    var material = new Material({\n        shader: shader\n    });\n    material.enableTexturesAll();\n\n    this.material = material;\n\n},\n/** @lends clay.compositor.Pass.prototype */\n{\n    /**\n     * @param {string} name\n     * @param {} value\n     */\n    setUniform: function(name, value) {\n        this.material.setUniform(name, value);\n    },\n    /**\n     * @param  {string} name\n     * @return {}\n     */\n    getUniform: function(name) {\n        var uniform = this.material.uniforms[name];\n        if (uniform) {\n            return uniform.value;\n        }\n    },\n    /**\n     * @param  {clay.Texture} texture\n     * @param  {number} attachment\n     */\n    attachOutput: function(texture, attachment) {\n        if (!this.outputs) {\n            this.outputs = {};\n        }\n        attachment = attachment || glenum.COLOR_ATTACHMENT0;\n        this.outputs[attachment] = texture;\n    },\n    /**\n     * @param  {clay.Texture} texture\n     */\n    detachOutput: function(texture) {\n        for (var attachment in this.outputs) {\n            if (this.outputs[attachment] === texture) {\n                this.outputs[attachment] = null;\n            }\n        }\n    },\n\n    bind: function(renderer, frameBuffer) {\n\n        if (this.outputs) {\n            for (var attachment in this.outputs) {\n                var texture = this.outputs[attachment];\n                if (texture) {\n                    frameBuffer.attach(texture, attachment);\n                }\n            }\n        }\n\n        if (frameBuffer) {\n            frameBuffer.bind(renderer);\n        }\n    },\n\n    unbind: function(renderer, frameBuffer) {\n        frameBuffer.unbind(renderer);\n    },\n    /**\n     * @param  {clay.Renderer} renderer\n     * @param  {clay.FrameBuffer} [frameBuffer]\n     */\n    render: function(renderer, frameBuffer) {\n\n        var _gl = renderer.gl;\n\n        if (frameBuffer) {\n            this.bind(renderer, frameBuffer);\n            // MRT Support in chrome\n            // https://www.khronos.org/registry/webgl/sdk/tests/conformance/extensions/ext-draw-buffers.html\n            var ext = renderer.getGLExtension('EXT_draw_buffers');\n            if (ext && this.outputs) {\n                var bufs = [];\n                for (var attachment in this.outputs) {\n                    attachment = +attachment;\n                    if (attachment >= _gl.COLOR_ATTACHMENT0 && attachment <= _gl.COLOR_ATTACHMENT0 + 8) {\n                        bufs.push(attachment);\n                    }\n                }\n                ext.drawBuffersEXT(bufs);\n            }\n        }\n\n        this.trigger('beforerender', this, renderer);\n\n        // FIXME Don't clear in each pass in default, let the color overwrite the buffer\n        // FIXME pixels may be discard\n        var clearBit = this.clearDepth ? _gl.DEPTH_BUFFER_BIT : 0;\n        _gl.depthMask(true);\n        if (this.clearColor) {\n            clearBit = clearBit | _gl.COLOR_BUFFER_BIT;\n            _gl.colorMask(true, true, true, true);\n            var cc = this.clearColor;\n            if (Array.isArray(cc)) {\n                _gl.clearColor(cc[0], cc[1], cc[2], cc[3]);\n            }\n        }\n        _gl.clear(clearBit);\n\n        if (this.blendWithPrevious) {\n            // Blend with previous rendered scene in the final output\n            // FIXME Configure blend.\n            // FIXME It will cause screen blink？\n            _gl.enable(_gl.BLEND);\n            this.material.transparent = true;\n        }\n        else {\n            _gl.disable(_gl.BLEND);\n            this.material.transparent = false;\n        }\n\n        this.renderQuad(renderer);\n\n        this.trigger('afterrender', this, renderer);\n\n        if (frameBuffer) {\n            this.unbind(renderer, frameBuffer);\n        }\n    },\n\n    /**\n     * Simply do quad rendering\n     */\n    renderQuad: function (renderer) {\n        mesh.material = this.material;\n        renderer.renderPass([mesh], camera);\n    },\n\n    /**\n     * @param  {clay.Renderer} renderer\n     */\n    dispose: function (renderer) {}\n});\n\nexport default Pass;\n"]},"metadata":{},"sourceType":"module"}