{"ast":null,"code":"'use strict';\n\nrequire(\"core-js/modules/es.error.cause.js\");\n\nrequire(\"core-js/modules/es.array.slice.js\");\n\nrequire(\"core-js/modules/es.regexp.exec.js\");\n\nrequire(\"core-js/modules/es.regexp.test.js\");\n\nrequire(\"core-js/modules/es.string.match.js\");\n\nrequire(\"core-js/modules/es.string.trim.js\");\n\nrequire(\"core-js/modules/es.function.name.js\");\n\nrequire(\"core-js/modules/es.object.to-string.js\");\n\nrequire(\"core-js/modules/es.array.splice.js\");\n\nexports.__esModule = true;\n\nvar _declaration = require('./declaration');\n\nvar _declaration2 = _interopRequireDefault(_declaration);\n\nvar _tokenize = require('./tokenize');\n\nvar _tokenize2 = _interopRequireDefault(_tokenize);\n\nvar _comment = require('./comment');\n\nvar _comment2 = _interopRequireDefault(_comment);\n\nvar _atRule = require('./at-rule');\n\nvar _atRule2 = _interopRequireDefault(_atRule);\n\nvar _root = require('./root');\n\nvar _root2 = _interopRequireDefault(_root);\n\nvar _rule = require('./rule');\n\nvar _rule2 = _interopRequireDefault(_rule);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar Parser = function () {\n  function Parser(input) {\n    _classCallCheck(this, Parser);\n\n    this.input = input;\n    this.pos = 0;\n    this.root = new _root2.default();\n    this.current = this.root;\n    this.spaces = '';\n    this.semicolon = false;\n    this.root.source = {\n      input: input,\n      start: {\n        line: 1,\n        column: 1\n      }\n    };\n  }\n\n  Parser.prototype.tokenize = function tokenize() {\n    this.tokens = (0, _tokenize2.default)(this.input);\n  };\n\n  Parser.prototype.loop = function loop() {\n    var token = void 0;\n\n    while (this.pos < this.tokens.length) {\n      token = this.tokens[this.pos];\n\n      switch (token[0]) {\n        case 'space':\n        case ';':\n          this.spaces += token[1];\n          break;\n\n        case '}':\n          this.end(token);\n          break;\n\n        case 'comment':\n          this.comment(token);\n          break;\n\n        case 'at-word':\n          this.atrule(token);\n          break;\n\n        case '{':\n          this.emptyRule(token);\n          break;\n\n        default:\n          this.other();\n          break;\n      }\n\n      this.pos += 1;\n    }\n\n    this.endFile();\n  };\n\n  Parser.prototype.comment = function comment(token) {\n    var node = new _comment2.default();\n    this.init(node, token[2], token[3]);\n    node.source.end = {\n      line: token[4],\n      column: token[5]\n    };\n    var text = token[1].slice(2, -2);\n\n    if (/^\\s*$/.test(text)) {\n      node.text = '';\n      node.raws.left = text;\n      node.raws.right = '';\n    } else {\n      var match = text.match(/^(\\s*)([^]*[^\\s])(\\s*)$/);\n      node.text = match[2];\n      node.raws.left = match[1];\n      node.raws.right = match[3];\n    }\n  };\n\n  Parser.prototype.emptyRule = function emptyRule(token) {\n    var node = new _rule2.default();\n    this.init(node, token[2], token[3]);\n    node.selector = '';\n    node.raws.between = '';\n    this.current = node;\n  };\n\n  Parser.prototype.other = function other() {\n    var token = void 0;\n    var end = false;\n    var type = null;\n    var colon = false;\n    var bracket = null;\n    var brackets = [];\n    var start = this.pos;\n\n    while (this.pos < this.tokens.length) {\n      token = this.tokens[this.pos];\n      type = token[0];\n\n      if (type === '(' || type === '[') {\n        if (!bracket) bracket = token;\n        brackets.push(type === '(' ? ')' : ']');\n      } else if (brackets.length === 0) {\n        if (type === ';') {\n          if (colon) {\n            this.decl(this.tokens.slice(start, this.pos + 1));\n            return;\n          } else {\n            break;\n          }\n        } else if (type === '{') {\n          this.rule(this.tokens.slice(start, this.pos + 1));\n          return;\n        } else if (type === '}') {\n          this.pos -= 1;\n          end = true;\n          break;\n        } else if (type === ':') {\n          colon = true;\n        }\n      } else if (type === brackets[brackets.length - 1]) {\n        brackets.pop();\n        if (brackets.length === 0) bracket = null;\n      }\n\n      this.pos += 1;\n    }\n\n    if (this.pos === this.tokens.length) {\n      this.pos -= 1;\n      end = true;\n    }\n\n    if (brackets.length > 0) this.unclosedBracket(bracket);\n\n    if (end && colon) {\n      while (this.pos > start) {\n        token = this.tokens[this.pos][0];\n        if (token !== 'space' && token !== 'comment') break;\n        this.pos -= 1;\n      }\n\n      this.decl(this.tokens.slice(start, this.pos + 1));\n      return;\n    }\n\n    this.unknownWord(start);\n  };\n\n  Parser.prototype.rule = function rule(tokens) {\n    tokens.pop();\n    var node = new _rule2.default();\n    this.init(node, tokens[0][2], tokens[0][3]);\n    node.raws.between = this.spacesAndCommentsFromEnd(tokens);\n    this.raw(node, 'selector', tokens);\n    this.current = node;\n  };\n\n  Parser.prototype.decl = function decl(tokens) {\n    var node = new _declaration2.default();\n    this.init(node);\n    var last = tokens[tokens.length - 1];\n\n    if (last[0] === ';') {\n      this.semicolon = true;\n      tokens.pop();\n    }\n\n    if (last[4]) {\n      node.source.end = {\n        line: last[4],\n        column: last[5]\n      };\n    } else {\n      node.source.end = {\n        line: last[2],\n        column: last[3]\n      };\n    }\n\n    while (tokens[0][0] !== 'word') {\n      node.raws.before += tokens.shift()[1];\n    }\n\n    node.source.start = {\n      line: tokens[0][2],\n      column: tokens[0][3]\n    };\n    node.prop = '';\n\n    while (tokens.length) {\n      var type = tokens[0][0];\n\n      if (type === ':' || type === 'space' || type === 'comment') {\n        break;\n      }\n\n      node.prop += tokens.shift()[1];\n    }\n\n    node.raws.between = '';\n    var token = void 0;\n\n    while (tokens.length) {\n      token = tokens.shift();\n\n      if (token[0] === ':') {\n        node.raws.between += token[1];\n        break;\n      } else {\n        node.raws.between += token[1];\n      }\n    }\n\n    if (node.prop[0] === '_' || node.prop[0] === '*') {\n      node.raws.before += node.prop[0];\n      node.prop = node.prop.slice(1);\n    }\n\n    node.raws.between += this.spacesAndCommentsFromStart(tokens);\n    this.precheckMissedSemicolon(tokens);\n\n    for (var i = tokens.length - 1; i > 0; i--) {\n      token = tokens[i];\n\n      if (token[1] === '!important') {\n        node.important = true;\n        var string = this.stringFrom(tokens, i);\n        string = this.spacesFromEnd(tokens) + string;\n        if (string !== ' !important') node.raws.important = string;\n        break;\n      } else if (token[1] === 'important') {\n        var cache = tokens.slice(0);\n        var str = '';\n\n        for (var j = i; j > 0; j--) {\n          var _type = cache[j][0];\n\n          if (str.trim().indexOf('!') === 0 && _type !== 'space') {\n            break;\n          }\n\n          str = cache.pop()[1] + str;\n        }\n\n        if (str.trim().indexOf('!') === 0) {\n          node.important = true;\n          node.raws.important = str;\n          tokens = cache;\n        }\n      }\n\n      if (token[0] !== 'space' && token[0] !== 'comment') {\n        break;\n      }\n    }\n\n    this.raw(node, 'value', tokens);\n    if (node.value.indexOf(':') !== -1) this.checkMissedSemicolon(tokens);\n  };\n\n  Parser.prototype.atrule = function atrule(token) {\n    var node = new _atRule2.default();\n    node.name = token[1].slice(1);\n\n    if (node.name === '') {\n      this.unnamedAtrule(node, token);\n    }\n\n    this.init(node, token[2], token[3]);\n    var last = false;\n    var open = false;\n    var params = [];\n    this.pos += 1;\n\n    while (this.pos < this.tokens.length) {\n      token = this.tokens[this.pos];\n\n      if (token[0] === ';') {\n        node.source.end = {\n          line: token[2],\n          column: token[3]\n        };\n        this.semicolon = true;\n        break;\n      } else if (token[0] === '{') {\n        open = true;\n        break;\n      } else if (token[0] === '}') {\n        this.end(token);\n        break;\n      } else {\n        params.push(token);\n      }\n\n      this.pos += 1;\n    }\n\n    if (this.pos === this.tokens.length) {\n      last = true;\n    }\n\n    node.raws.between = this.spacesAndCommentsFromEnd(params);\n\n    if (params.length) {\n      node.raws.afterName = this.spacesAndCommentsFromStart(params);\n      this.raw(node, 'params', params);\n\n      if (last) {\n        token = params[params.length - 1];\n        node.source.end = {\n          line: token[4],\n          column: token[5]\n        };\n        this.spaces = node.raws.between;\n        node.raws.between = '';\n      }\n    } else {\n      node.raws.afterName = '';\n      node.params = '';\n    }\n\n    if (open) {\n      node.nodes = [];\n      this.current = node;\n    }\n  };\n\n  Parser.prototype.end = function end(token) {\n    if (this.current.nodes && this.current.nodes.length) {\n      this.current.raws.semicolon = this.semicolon;\n    }\n\n    this.semicolon = false;\n    this.current.raws.after = (this.current.raws.after || '') + this.spaces;\n    this.spaces = '';\n\n    if (this.current.parent) {\n      this.current.source.end = {\n        line: token[2],\n        column: token[3]\n      };\n      this.current = this.current.parent;\n    } else {\n      this.unexpectedClose(token);\n    }\n  };\n\n  Parser.prototype.endFile = function endFile() {\n    if (this.current.parent) this.unclosedBlock();\n\n    if (this.current.nodes && this.current.nodes.length) {\n      this.current.raws.semicolon = this.semicolon;\n    }\n\n    this.current.raws.after = (this.current.raws.after || '') + this.spaces;\n  }; // Helpers\n\n\n  Parser.prototype.init = function init(node, line, column) {\n    this.current.push(node);\n    node.source = {\n      start: {\n        line: line,\n        column: column\n      },\n      input: this.input\n    };\n    node.raws.before = this.spaces;\n    this.spaces = '';\n    if (node.type !== 'comment') this.semicolon = false;\n  };\n\n  Parser.prototype.raw = function raw(node, prop, tokens) {\n    var token = void 0,\n        type = void 0;\n    var length = tokens.length;\n    var value = '';\n    var clean = true;\n\n    for (var i = 0; i < length; i += 1) {\n      token = tokens[i];\n      type = token[0];\n\n      if (type === 'comment' || type === 'space' && i === length - 1) {\n        clean = false;\n      } else {\n        value += token[1];\n      }\n    }\n\n    if (!clean) {\n      var raw = tokens.reduce(function (all, i) {\n        return all + i[1];\n      }, '');\n      node.raws[prop] = {\n        value: value,\n        raw: raw\n      };\n    }\n\n    node[prop] = value;\n  };\n\n  Parser.prototype.spacesAndCommentsFromEnd = function spacesAndCommentsFromEnd(tokens) {\n    var lastTokenType = void 0;\n    var spaces = '';\n\n    while (tokens.length) {\n      lastTokenType = tokens[tokens.length - 1][0];\n      if (lastTokenType !== 'space' && lastTokenType !== 'comment') break;\n      spaces = tokens.pop()[1] + spaces;\n    }\n\n    return spaces;\n  };\n\n  Parser.prototype.spacesAndCommentsFromStart = function spacesAndCommentsFromStart(tokens) {\n    var next = void 0;\n    var spaces = '';\n\n    while (tokens.length) {\n      next = tokens[0][0];\n      if (next !== 'space' && next !== 'comment') break;\n      spaces += tokens.shift()[1];\n    }\n\n    return spaces;\n  };\n\n  Parser.prototype.spacesFromEnd = function spacesFromEnd(tokens) {\n    var lastTokenType = void 0;\n    var spaces = '';\n\n    while (tokens.length) {\n      lastTokenType = tokens[tokens.length - 1][0];\n      if (lastTokenType !== 'space') break;\n      spaces = tokens.pop()[1] + spaces;\n    }\n\n    return spaces;\n  };\n\n  Parser.prototype.stringFrom = function stringFrom(tokens, from) {\n    var result = '';\n\n    for (var i = from; i < tokens.length; i++) {\n      result += tokens[i][1];\n    }\n\n    tokens.splice(from, tokens.length - from);\n    return result;\n  };\n\n  Parser.prototype.colon = function colon(tokens) {\n    var brackets = 0;\n    var token = void 0,\n        type = void 0,\n        prev = void 0;\n\n    for (var i = 0; i < tokens.length; i++) {\n      token = tokens[i];\n      type = token[0];\n\n      if (type === '(') {\n        brackets += 1;\n      } else if (type === ')') {\n        brackets -= 1;\n      } else if (brackets === 0 && type === ':') {\n        if (!prev) {\n          this.doubleColon(token);\n        } else if (prev[0] === 'word' && prev[1] === 'progid') {\n          continue;\n        } else {\n          return i;\n        }\n      }\n\n      prev = token;\n    }\n\n    return false;\n  }; // Errors\n\n\n  Parser.prototype.unclosedBracket = function unclosedBracket(bracket) {\n    throw this.input.error('Unclosed bracket', bracket[2], bracket[3]);\n  };\n\n  Parser.prototype.unknownWord = function unknownWord(start) {\n    var token = this.tokens[start];\n    throw this.input.error('Unknown word', token[2], token[3]);\n  };\n\n  Parser.prototype.unexpectedClose = function unexpectedClose(token) {\n    throw this.input.error('Unexpected }', token[2], token[3]);\n  };\n\n  Parser.prototype.unclosedBlock = function unclosedBlock() {\n    var pos = this.current.source.start;\n    throw this.input.error('Unclosed block', pos.line, pos.column);\n  };\n\n  Parser.prototype.doubleColon = function doubleColon(token) {\n    throw this.input.error('Double colon', token[2], token[3]);\n  };\n\n  Parser.prototype.unnamedAtrule = function unnamedAtrule(node, token) {\n    throw this.input.error('At-rule without name', token[2], token[3]);\n  };\n\n  Parser.prototype.precheckMissedSemicolon = function precheckMissedSemicolon(tokens) {\n    // Hook for Safe Parser\n    tokens;\n  };\n\n  Parser.prototype.checkMissedSemicolon = function checkMissedSemicolon(tokens) {\n    var colon = this.colon(tokens);\n    if (colon === false) return;\n    var founded = 0;\n    var token = void 0;\n\n    for (var j = colon - 1; j >= 0; j--) {\n      token = tokens[j];\n\n      if (token[0] !== 'space') {\n        founded += 1;\n        if (founded === 2) break;\n      }\n    }\n\n    throw this.input.error('Missed semicolon', token[2], token[3]);\n  };\n\n  return Parser;\n}();\n\nexports.default = Parser;\nmodule.exports = exports['default'];","map":{"version":3,"mappings":"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","names":["Parser","input","_classCallCheck","pos","root","current","spaces","semicolon","source","start","line","column","tokenize","tokens","loop","token","length","end","comment","atrule","emptyRule","other","endFile","node","init","text","slice","test","raws","left","right","match","selector","between","type","colon","bracket","brackets","push","decl","rule","pop","unclosedBracket","unknownWord","spacesAndCommentsFromEnd","raw","last","before","shift","prop","spacesAndCommentsFromStart","precheckMissedSemicolon","i","important","string","stringFrom","spacesFromEnd","cache","str","j","trim","indexOf","value","checkMissedSemicolon","name","unnamedAtrule","open","params","afterName","nodes","after","parent","unexpectedClose","unclosedBlock","clean","reduce","all","lastTokenType","next","from","result","splice","prev","doubleColon","error","founded"],"sources":["parser.es6"],"sourcesContent":["import Declaration from './declaration';\nimport tokenizer   from './tokenize';\nimport Comment     from './comment';\nimport AtRule      from './at-rule';\nimport Root        from './root';\nimport Rule        from './rule';\n\nexport default class Parser {\n\n    constructor(input) {\n        this.input = input;\n\n        this.pos       = 0;\n        this.root      = new Root();\n        this.current   = this.root;\n        this.spaces    = '';\n        this.semicolon = false;\n\n        this.root.source = { input, start: { line: 1, column: 1 } };\n    }\n\n    tokenize() {\n        this.tokens = tokenizer(this.input);\n    }\n\n    loop() {\n        let token;\n        while ( this.pos < this.tokens.length ) {\n            token = this.tokens[this.pos];\n\n            switch ( token[0] ) {\n\n            case 'space':\n            case ';':\n                this.spaces += token[1];\n                break;\n\n            case '}':\n                this.end(token);\n                break;\n\n            case 'comment':\n                this.comment(token);\n                break;\n\n            case 'at-word':\n                this.atrule(token);\n                break;\n\n            case '{':\n                this.emptyRule(token);\n                break;\n\n            default:\n                this.other();\n                break;\n            }\n\n            this.pos += 1;\n        }\n        this.endFile();\n    }\n\n    comment(token) {\n        let node = new Comment();\n        this.init(node, token[2], token[3]);\n        node.source.end = { line: token[4], column: token[5] };\n\n        let text = token[1].slice(2, -2);\n        if ( /^\\s*$/.test(text) ) {\n            node.text       = '';\n            node.raws.left  = text;\n            node.raws.right = '';\n        } else {\n            let match = text.match(/^(\\s*)([^]*[^\\s])(\\s*)$/);\n            node.text       = match[2];\n            node.raws.left  = match[1];\n            node.raws.right = match[3];\n        }\n    }\n\n    emptyRule(token) {\n        let node = new Rule();\n        this.init(node, token[2], token[3]);\n        node.selector = '';\n        node.raws.between = '';\n        this.current = node;\n    }\n\n    other() {\n        let token;\n        let end      = false;\n        let type     = null;\n        let colon    = false;\n        let bracket  = null;\n        let brackets = [];\n\n        let start = this.pos;\n        while ( this.pos < this.tokens.length ) {\n            token = this.tokens[this.pos];\n            type  = token[0];\n\n            if ( type === '(' || type === '[' ) {\n                if ( !bracket ) bracket = token;\n                brackets.push(type === '(' ? ')' : ']');\n\n            } else if ( brackets.length === 0 ) {\n                if ( type === ';' ) {\n                    if ( colon ) {\n                        this.decl(this.tokens.slice(start, this.pos + 1));\n                        return;\n                    } else {\n                        break;\n                    }\n\n                } else if ( type === '{' ) {\n                    this.rule(this.tokens.slice(start, this.pos + 1));\n                    return;\n\n                } else if ( type === '}' ) {\n                    this.pos -= 1;\n                    end = true;\n                    break;\n\n                } else if ( type === ':' ) {\n                    colon = true;\n                }\n\n            } else if ( type === brackets[brackets.length - 1] ) {\n                brackets.pop();\n                if ( brackets.length === 0 ) bracket = null;\n            }\n\n            this.pos += 1;\n        }\n        if ( this.pos === this.tokens.length ) {\n            this.pos -= 1;\n            end = true;\n        }\n\n        if ( brackets.length > 0 ) this.unclosedBracket(bracket);\n\n        if ( end && colon ) {\n            while ( this.pos > start ) {\n                token = this.tokens[this.pos][0];\n                if ( token !== 'space' && token !== 'comment' ) break;\n                this.pos -= 1;\n            }\n            this.decl(this.tokens.slice(start, this.pos + 1));\n            return;\n        }\n\n        this.unknownWord(start);\n    }\n\n    rule(tokens) {\n        tokens.pop();\n\n        let node = new Rule();\n        this.init(node, tokens[0][2], tokens[0][3]);\n\n        node.raws.between = this.spacesAndCommentsFromEnd(tokens);\n        this.raw(node, 'selector', tokens);\n        this.current = node;\n    }\n\n    decl(tokens) {\n        let node = new Declaration();\n        this.init(node);\n\n        let last = tokens[tokens.length - 1];\n        if ( last[0] === ';' ) {\n            this.semicolon = true;\n            tokens.pop();\n        }\n        if ( last[4] ) {\n            node.source.end = { line: last[4], column: last[5] };\n        } else {\n            node.source.end = { line: last[2], column: last[3] };\n        }\n\n        while ( tokens[0][0] !== 'word' ) {\n            node.raws.before += tokens.shift()[1];\n        }\n        node.source.start = { line: tokens[0][2], column: tokens[0][3] };\n\n        node.prop = '';\n        while ( tokens.length ) {\n            let type = tokens[0][0];\n            if ( type === ':' || type === 'space' || type === 'comment' ) {\n                break;\n            }\n            node.prop += tokens.shift()[1];\n        }\n\n        node.raws.between = '';\n\n        let token;\n        while ( tokens.length ) {\n            token = tokens.shift();\n\n            if ( token[0] === ':' ) {\n                node.raws.between += token[1];\n                break;\n            } else {\n                node.raws.between += token[1];\n            }\n        }\n\n        if ( node.prop[0] === '_' || node.prop[0] === '*' ) {\n            node.raws.before += node.prop[0];\n            node.prop = node.prop.slice(1);\n        }\n        node.raws.between += this.spacesAndCommentsFromStart(tokens);\n        this.precheckMissedSemicolon(tokens);\n\n        for ( let i = tokens.length - 1; i > 0; i-- ) {\n            token = tokens[i];\n            if ( token[1] === '!important' ) {\n                node.important = true;\n                let string = this.stringFrom(tokens, i);\n                string = this.spacesFromEnd(tokens) + string;\n                if ( string !== ' !important' ) node.raws.important = string;\n                break;\n\n            } else if (token[1] === 'important') {\n                let cache = tokens.slice(0);\n                let str   = '';\n                for ( let j = i; j > 0; j-- ) {\n                    let type = cache[j][0];\n                    if ( str.trim().indexOf('!') === 0 && type !== 'space' ) {\n                        break;\n                    }\n                    str = cache.pop()[1] + str;\n                }\n                if ( str.trim().indexOf('!') === 0 ) {\n                    node.important = true;\n                    node.raws.important = str;\n                    tokens = cache;\n                }\n            }\n\n            if ( token[0] !== 'space' && token[0] !== 'comment' ) {\n                break;\n            }\n        }\n\n        this.raw(node, 'value', tokens);\n\n        if ( node.value.indexOf(':') !== -1 ) this.checkMissedSemicolon(tokens);\n    }\n\n    atrule(token) {\n        let node  = new AtRule();\n        node.name = token[1].slice(1);\n        if ( node.name === '' ) {\n            this.unnamedAtrule(node, token);\n        }\n        this.init(node, token[2], token[3]);\n\n        let last   = false;\n        let open   = false;\n        let params = [];\n\n        this.pos += 1;\n        while ( this.pos < this.tokens.length ) {\n            token = this.tokens[this.pos];\n\n            if ( token[0] === ';' ) {\n                node.source.end = { line: token[2], column: token[3] };\n                this.semicolon = true;\n                break;\n            } else if ( token[0] === '{' ) {\n                open = true;\n                break;\n            } else if ( token[0] === '}') {\n                this.end(token);\n                break;\n            } else {\n                params.push(token);\n            }\n\n            this.pos += 1;\n        }\n        if ( this.pos === this.tokens.length ) {\n            last = true;\n        }\n\n        node.raws.between = this.spacesAndCommentsFromEnd(params);\n        if ( params.length ) {\n            node.raws.afterName = this.spacesAndCommentsFromStart(params);\n            this.raw(node, 'params', params);\n            if ( last ) {\n                token = params[params.length - 1];\n                node.source.end   = { line: token[4], column: token[5] };\n                this.spaces       = node.raws.between;\n                node.raws.between = '';\n            }\n        } else {\n            node.raws.afterName = '';\n            node.params         = '';\n        }\n\n        if ( open ) {\n            node.nodes   = [];\n            this.current = node;\n        }\n    }\n\n    end(token) {\n        if ( this.current.nodes && this.current.nodes.length ) {\n            this.current.raws.semicolon = this.semicolon;\n        }\n        this.semicolon = false;\n\n        this.current.raws.after = (this.current.raws.after || '') + this.spaces;\n        this.spaces = '';\n\n        if ( this.current.parent ) {\n            this.current.source.end = { line: token[2], column: token[3] };\n            this.current = this.current.parent;\n        } else {\n            this.unexpectedClose(token);\n        }\n    }\n\n    endFile() {\n        if ( this.current.parent ) this.unclosedBlock();\n        if ( this.current.nodes && this.current.nodes.length ) {\n            this.current.raws.semicolon = this.semicolon;\n        }\n        this.current.raws.after = (this.current.raws.after || '') + this.spaces;\n    }\n\n    // Helpers\n\n    init(node, line, column) {\n        this.current.push(node);\n\n        node.source = { start: { line, column }, input: this.input };\n        node.raws.before = this.spaces;\n        this.spaces = '';\n        if ( node.type !== 'comment' ) this.semicolon = false;\n    }\n\n    raw(node, prop, tokens) {\n        let token, type;\n        let length = tokens.length;\n        let value  = '';\n        let clean  = true;\n        for ( let i = 0; i < length; i += 1 ) {\n            token = tokens[i];\n            type  = token[0];\n            if ( type === 'comment' || type === 'space' && i === length - 1 ) {\n                clean = false;\n            } else {\n                value += token[1];\n            }\n        }\n        if ( !clean ) {\n            let raw = tokens.reduce( (all, i) => all + i[1], '');\n            node.raws[prop] = { value, raw };\n        }\n        node[prop] = value;\n    }\n\n    spacesAndCommentsFromEnd(tokens) {\n        let lastTokenType;\n        let spaces = '';\n        while ( tokens.length ) {\n            lastTokenType = tokens[tokens.length - 1][0];\n            if ( lastTokenType !== 'space' &&\n                lastTokenType !== 'comment' ) break;\n            spaces = tokens.pop()[1] + spaces;\n        }\n        return spaces;\n    }\n\n    spacesAndCommentsFromStart(tokens) {\n        let next;\n        let spaces = '';\n        while ( tokens.length ) {\n            next = tokens[0][0];\n            if ( next !== 'space' && next !== 'comment' ) break;\n            spaces += tokens.shift()[1];\n        }\n        return spaces;\n    }\n\n    spacesFromEnd(tokens) {\n        let lastTokenType;\n        let spaces = '';\n        while ( tokens.length ) {\n            lastTokenType = tokens[tokens.length - 1][0];\n            if ( lastTokenType !== 'space' ) break;\n            spaces = tokens.pop()[1] + spaces;\n        }\n        return spaces;\n    }\n\n    stringFrom(tokens, from) {\n        let result = '';\n        for ( let i = from; i < tokens.length; i++ ) {\n            result += tokens[i][1];\n        }\n        tokens.splice(from, tokens.length - from);\n        return result;\n    }\n\n    colon(tokens) {\n        let brackets = 0;\n        let token, type, prev;\n        for ( let i = 0; i < tokens.length; i++ ) {\n            token = tokens[i];\n            type  = token[0];\n\n            if ( type === '(' ) {\n                brackets += 1;\n            } else if ( type === ')' ) {\n                brackets -= 1;\n            } else if ( brackets === 0 && type === ':' ) {\n                if ( !prev ) {\n                    this.doubleColon(token);\n                } else if ( prev[0] === 'word' && prev[1] === 'progid' ) {\n                    continue;\n                } else {\n                    return i;\n                }\n            }\n\n            prev = token;\n        }\n        return false;\n    }\n\n    // Errors\n\n    unclosedBracket(bracket) {\n        throw this.input.error('Unclosed bracket', bracket[2], bracket[3]);\n    }\n\n    unknownWord(start) {\n        let token = this.tokens[start];\n        throw this.input.error('Unknown word', token[2], token[3]);\n    }\n\n    unexpectedClose(token) {\n        throw this.input.error('Unexpected }', token[2], token[3]);\n    }\n\n    unclosedBlock() {\n        let pos = this.current.source.start;\n        throw this.input.error('Unclosed block', pos.line, pos.column);\n    }\n\n    doubleColon(token) {\n        throw this.input.error('Double colon', token[2], token[3]);\n    }\n\n    unnamedAtrule(node, token) {\n        throw this.input.error('At-rule without name', token[2], token[3]);\n    }\n\n    precheckMissedSemicolon(tokens) {\n        // Hook for Safe Parser\n        tokens;\n    }\n\n    checkMissedSemicolon(tokens) {\n        let colon = this.colon(tokens);\n        if ( colon === false ) return;\n\n        let founded = 0;\n        let token;\n        for ( let j = colon - 1; j >= 0; j-- ) {\n            token = tokens[j];\n            if ( token[0] !== 'space' ) {\n                founded += 1;\n                if ( founded === 2 ) break;\n            }\n        }\n        throw this.input.error('Missed semicolon', token[2], token[3]);\n    }\n\n}\n"]},"metadata":{},"sourceType":"script"}