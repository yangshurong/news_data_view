{"ast":null,"code":"import \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.typed-array.float64-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport * as echarts from 'echarts/lib/echarts';\nimport glmatrix from 'claygl/src/dep/glmatrix';\nvar vec3 = glmatrix.vec3;\nvar mat4 = glmatrix.mat4;\nimport textCoord from 'echarts/lib/coord/geo/fix/textCoord';\nimport geoCoord from 'echarts/lib/coord/geo/fix/geoCoord'; // Geo fix functions\n\nvar geoFixFuncs = [textCoord, geoCoord];\n\nfunction Geo3D(name, map, geoJson, specialAreas, nameMap) {\n  this.name = name;\n  this.map = map;\n  this.regionHeight = 0;\n  this.regions = [];\n  this._nameCoordMap = {};\n  this.loadGeoJson(geoJson, specialAreas, nameMap);\n  this.transform = mat4.identity(new Float64Array(16));\n  this.invTransform = mat4.identity(new Float64Array(16)); // Which dimension to extrude. Y or Z\n\n  this.extrudeY = true;\n  this.altitudeAxis;\n}\n\nGeo3D.prototype = {\n  constructor: Geo3D,\n  type: 'geo3D',\n  dimensions: ['lng', 'lat', 'alt'],\n  containPoint: function containPoint() {},\n  loadGeoJson: function loadGeoJson(geoJson, specialAreas, nameMap) {\n    var parseGeoJSON = echarts.parseGeoJSON || echarts.parseGeoJson;\n\n    try {\n      this.regions = geoJson ? parseGeoJSON(geoJson) : [];\n    } catch (e) {\n      throw 'Invalid geoJson format\\n' + e;\n    }\n\n    specialAreas = specialAreas || {};\n    nameMap = nameMap || {};\n    var regions = this.regions;\n    var regionsMap = {};\n\n    for (var i = 0; i < regions.length; i++) {\n      var regionName = regions[i].name; // Try use the alias in nameMap\n\n      regionName = nameMap[regionName] || regionName;\n      regions[i].name = regionName;\n      regionsMap[regionName] = regions[i]; // Add geoJson\n\n      this.addGeoCoord(regionName, regions[i].getCenter()); // Some area like Alaska in USA map needs to be tansformed\n      // to look better\n\n      var specialArea = specialAreas[regionName];\n\n      if (specialArea) {\n        regions[i].transformTo(specialArea.left, specialArea.top, specialArea.width, specialArea.height);\n      }\n    }\n\n    this._regionsMap = regionsMap;\n    this._geoRect = null;\n    geoFixFuncs.forEach(function (fixFunc) {\n      fixFunc(this);\n    }, this);\n  },\n  getGeoBoundingRect: function getGeoBoundingRect() {\n    if (this._geoRect) {\n      return this._geoRect;\n    }\n\n    var rect;\n    var regions = this.regions;\n\n    for (var i = 0; i < regions.length; i++) {\n      var regionRect = regions[i].getBoundingRect();\n      rect = rect || regionRect.clone();\n      rect.union(regionRect);\n    } // FIXME Always return new ?\n\n\n    return this._geoRect = rect || new echarts.graphic.BoundingRect(0, 0, 0, 0);\n  },\n\n  /**\n   * Add geoCoord for indexing by name\n   * @param {string} name\n   * @param {Array.<number>} geoCoord\n   */\n  addGeoCoord: function addGeoCoord(name, geoCoord) {\n    this._nameCoordMap[name] = geoCoord;\n  },\n\n  /**\n   * @param {string} name\n   * @return {module:echarts/coord/geo/Region}\n   */\n  getRegion: function getRegion(name) {\n    return this._regionsMap[name];\n  },\n  getRegionByCoord: function getRegionByCoord(coord) {\n    var regions = this.regions;\n\n    for (var i = 0; i < regions.length; i++) {\n      if (regions[i].contain(coord)) {\n        return regions[i];\n      }\n    }\n  },\n  setSize: function setSize(width, height, depth) {\n    this.size = [width, height, depth];\n    var rect = this.getGeoBoundingRect();\n    var scaleX = width / rect.width;\n    var scaleZ = -depth / rect.height;\n    var translateX = -width / 2 - rect.x * scaleX;\n    var translateZ = depth / 2 - rect.y * scaleZ;\n    var position = this.extrudeY ? [translateX, 0, translateZ] : [translateX, translateZ, 0];\n    var scale = this.extrudeY ? [scaleX, 1, scaleZ] : [scaleX, scaleZ, 1];\n    var m = this.transform;\n    mat4.identity(m);\n    mat4.translate(m, m, position);\n    mat4.scale(m, m, scale);\n    mat4.invert(this.invTransform, m);\n  },\n  dataToPoint: function dataToPoint(data, out) {\n    out = out || [];\n    var extrudeCoordIndex = this.extrudeY ? 1 : 2;\n    var sideCoordIndex = this.extrudeY ? 2 : 1;\n    var altitudeVal = data[2]; // PENDING.\n\n    if (isNaN(altitudeVal)) {\n      altitudeVal = 0;\n    } // lng\n\n\n    out[0] = data[0]; // lat\n\n    out[sideCoordIndex] = data[1];\n\n    if (this.altitudeAxis) {\n      out[extrudeCoordIndex] = this.altitudeAxis.dataToCoord(altitudeVal);\n    } else {\n      out[extrudeCoordIndex] = 0;\n    } // PENDING different region height.\n\n\n    out[extrudeCoordIndex] += this.regionHeight;\n    vec3.transformMat4(out, out, this.transform);\n    return out;\n  },\n  pointToData: function pointToData(point, out) {// TODO\n  }\n};\nexport default Geo3D;","map":{"version":3,"sources":["C:/Users/Administrator/Desktop/data_view/my_project/vue2_app/myapp/node_modules/_echarts-gl@2.0.9@echarts-gl/lib/coord/geo3D/Geo3D.js"],"names":["echarts","glmatrix","vec3","mat4","textCoord","geoCoord","geoFixFuncs","Geo3D","name","map","geoJson","specialAreas","nameMap","regionHeight","regions","_nameCoordMap","loadGeoJson","transform","identity","Float64Array","invTransform","extrudeY","altitudeAxis","prototype","constructor","type","dimensions","containPoint","parseGeoJSON","parseGeoJson","e","regionsMap","i","length","regionName","addGeoCoord","getCenter","specialArea","transformTo","left","top","width","height","_regionsMap","_geoRect","forEach","fixFunc","getGeoBoundingRect","rect","regionRect","getBoundingRect","clone","union","graphic","BoundingRect","getRegion","getRegionByCoord","coord","contain","setSize","depth","size","scaleX","scaleZ","translateX","x","translateZ","y","position","scale","m","translate","invert","dataToPoint","data","out","extrudeCoordIndex","sideCoordIndex","altitudeVal","isNaN","dataToCoord","transformMat4","pointToData","point"],"mappings":"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","sourcesContent":["import * as echarts from 'echarts/lib/echarts';\nimport glmatrix from 'claygl/src/dep/glmatrix';\nvar vec3 = glmatrix.vec3;\nvar mat4 = glmatrix.mat4;\nimport textCoord from 'echarts/lib/coord/geo/fix/textCoord';\nimport geoCoord from 'echarts/lib/coord/geo/fix/geoCoord'; // Geo fix functions\n\nvar geoFixFuncs = [textCoord, geoCoord];\n\nfunction Geo3D(name, map, geoJson, specialAreas, nameMap) {\n  this.name = name;\n  this.map = map;\n  this.regionHeight = 0;\n  this.regions = [];\n  this._nameCoordMap = {};\n  this.loadGeoJson(geoJson, specialAreas, nameMap);\n  this.transform = mat4.identity(new Float64Array(16));\n  this.invTransform = mat4.identity(new Float64Array(16)); // Which dimension to extrude. Y or Z\n\n  this.extrudeY = true;\n  this.altitudeAxis;\n}\n\nGeo3D.prototype = {\n  constructor: Geo3D,\n  type: 'geo3D',\n  dimensions: ['lng', 'lat', 'alt'],\n  containPoint: function () {},\n  loadGeoJson: function (geoJson, specialAreas, nameMap) {\n    var parseGeoJSON = echarts.parseGeoJSON || echarts.parseGeoJson;\n\n    try {\n      this.regions = geoJson ? parseGeoJSON(geoJson) : [];\n    } catch (e) {\n      throw 'Invalid geoJson format\\n' + e;\n    }\n\n    specialAreas = specialAreas || {};\n    nameMap = nameMap || {};\n    var regions = this.regions;\n    var regionsMap = {};\n\n    for (var i = 0; i < regions.length; i++) {\n      var regionName = regions[i].name; // Try use the alias in nameMap\n\n      regionName = nameMap[regionName] || regionName;\n      regions[i].name = regionName;\n      regionsMap[regionName] = regions[i]; // Add geoJson\n\n      this.addGeoCoord(regionName, regions[i].getCenter()); // Some area like Alaska in USA map needs to be tansformed\n      // to look better\n\n      var specialArea = specialAreas[regionName];\n\n      if (specialArea) {\n        regions[i].transformTo(specialArea.left, specialArea.top, specialArea.width, specialArea.height);\n      }\n    }\n\n    this._regionsMap = regionsMap;\n    this._geoRect = null;\n    geoFixFuncs.forEach(function (fixFunc) {\n      fixFunc(this);\n    }, this);\n  },\n  getGeoBoundingRect: function () {\n    if (this._geoRect) {\n      return this._geoRect;\n    }\n\n    var rect;\n    var regions = this.regions;\n\n    for (var i = 0; i < regions.length; i++) {\n      var regionRect = regions[i].getBoundingRect();\n      rect = rect || regionRect.clone();\n      rect.union(regionRect);\n    } // FIXME Always return new ?\n\n\n    return this._geoRect = rect || new echarts.graphic.BoundingRect(0, 0, 0, 0);\n  },\n\n  /**\n   * Add geoCoord for indexing by name\n   * @param {string} name\n   * @param {Array.<number>} geoCoord\n   */\n  addGeoCoord: function (name, geoCoord) {\n    this._nameCoordMap[name] = geoCoord;\n  },\n\n  /**\n   * @param {string} name\n   * @return {module:echarts/coord/geo/Region}\n   */\n  getRegion: function (name) {\n    return this._regionsMap[name];\n  },\n  getRegionByCoord: function (coord) {\n    var regions = this.regions;\n\n    for (var i = 0; i < regions.length; i++) {\n      if (regions[i].contain(coord)) {\n        return regions[i];\n      }\n    }\n  },\n  setSize: function (width, height, depth) {\n    this.size = [width, height, depth];\n    var rect = this.getGeoBoundingRect();\n    var scaleX = width / rect.width;\n    var scaleZ = -depth / rect.height;\n    var translateX = -width / 2 - rect.x * scaleX;\n    var translateZ = depth / 2 - rect.y * scaleZ;\n    var position = this.extrudeY ? [translateX, 0, translateZ] : [translateX, translateZ, 0];\n    var scale = this.extrudeY ? [scaleX, 1, scaleZ] : [scaleX, scaleZ, 1];\n    var m = this.transform;\n    mat4.identity(m);\n    mat4.translate(m, m, position);\n    mat4.scale(m, m, scale);\n    mat4.invert(this.invTransform, m);\n  },\n  dataToPoint: function (data, out) {\n    out = out || [];\n    var extrudeCoordIndex = this.extrudeY ? 1 : 2;\n    var sideCoordIndex = this.extrudeY ? 2 : 1;\n    var altitudeVal = data[2]; // PENDING.\n\n    if (isNaN(altitudeVal)) {\n      altitudeVal = 0;\n    } // lng\n\n\n    out[0] = data[0]; // lat\n\n    out[sideCoordIndex] = data[1];\n\n    if (this.altitudeAxis) {\n      out[extrudeCoordIndex] = this.altitudeAxis.dataToCoord(altitudeVal);\n    } else {\n      out[extrudeCoordIndex] = 0;\n    } // PENDING different region height.\n\n\n    out[extrudeCoordIndex] += this.regionHeight;\n    vec3.transformMat4(out, out, this.transform);\n    return out;\n  },\n  pointToData: function (point, out) {// TODO\n  }\n};\nexport default Geo3D;"]},"metadata":{},"sourceType":"module"}