{"ast":null,"code":"'use strict';\n\nrequire(\"core-js/modules/es.array.slice.js\");\n\nrequire(\"core-js/modules/es.regexp.exec.js\");\n\nrequire(\"core-js/modules/es.regexp.test.js\");\n\nrequire(\"core-js/modules/es.string.split.js\");\n\nexports.__esModule = true;\nexports.default = tokenize;\nvar SINGLE_QUOTE = 39;\nvar DOUBLE_QUOTE = 34;\nvar BACKSLASH = 92;\nvar SLASH = 47;\nvar NEWLINE = 10;\nvar SPACE = 32;\nvar FEED = 12;\nvar TAB = 9;\nvar CR = 13;\nvar OPEN_SQUARE = 91;\nvar CLOSE_SQUARE = 93;\nvar OPEN_PARENTHESES = 40;\nvar CLOSE_PARENTHESES = 41;\nvar OPEN_CURLY = 123;\nvar CLOSE_CURLY = 125;\nvar SEMICOLON = 59;\nvar ASTERISK = 42;\nvar COLON = 58;\nvar AT = 64;\nvar RE_AT_END = /[ \\n\\t\\r\\f\\{\\(\\)'\"\\\\;/\\[\\]#]/g;\nvar RE_WORD_END = /[ \\n\\t\\r\\f\\(\\)\\{\\}:;@!'\"\\\\\\]\\[#]|\\/(?=\\*)/g;\nvar RE_BAD_BRACKET = /.[\\\\\\/\\(\"'\\n]/;\n\nfunction tokenize(input) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var tokens = [];\n  var css = input.css.valueOf();\n  var ignore = options.ignoreErrors;\n  var code = void 0,\n      next = void 0,\n      quote = void 0,\n      lines = void 0,\n      last = void 0,\n      content = void 0,\n      escape = void 0,\n      nextLine = void 0,\n      nextOffset = void 0,\n      escaped = void 0,\n      escapePos = void 0,\n      prev = void 0,\n      n = void 0;\n  var length = css.length;\n  var offset = -1;\n  var line = 1;\n  var pos = 0;\n\n  function unclosed(what) {\n    throw input.error('Unclosed ' + what, line, pos - offset);\n  }\n\n  while (pos < length) {\n    code = css.charCodeAt(pos);\n\n    if (code === NEWLINE || code === FEED || code === CR && css.charCodeAt(pos + 1) !== NEWLINE) {\n      offset = pos;\n      line += 1;\n    }\n\n    switch (code) {\n      case NEWLINE:\n      case SPACE:\n      case TAB:\n      case CR:\n      case FEED:\n        next = pos;\n\n        do {\n          next += 1;\n          code = css.charCodeAt(next);\n\n          if (code === NEWLINE) {\n            offset = next;\n            line += 1;\n          }\n        } while (code === SPACE || code === NEWLINE || code === TAB || code === CR || code === FEED);\n\n        tokens.push(['space', css.slice(pos, next)]);\n        pos = next - 1;\n        break;\n\n      case OPEN_SQUARE:\n        tokens.push(['[', '[', line, pos - offset]);\n        break;\n\n      case CLOSE_SQUARE:\n        tokens.push([']', ']', line, pos - offset]);\n        break;\n\n      case OPEN_CURLY:\n        tokens.push(['{', '{', line, pos - offset]);\n        break;\n\n      case CLOSE_CURLY:\n        tokens.push(['}', '}', line, pos - offset]);\n        break;\n\n      case COLON:\n        tokens.push([':', ':', line, pos - offset]);\n        break;\n\n      case SEMICOLON:\n        tokens.push([';', ';', line, pos - offset]);\n        break;\n\n      case OPEN_PARENTHESES:\n        prev = tokens.length ? tokens[tokens.length - 1][1] : '';\n        n = css.charCodeAt(pos + 1);\n\n        if (prev === 'url' && n !== SINGLE_QUOTE && n !== DOUBLE_QUOTE && n !== SPACE && n !== NEWLINE && n !== TAB && n !== FEED && n !== CR) {\n          next = pos;\n\n          do {\n            escaped = false;\n            next = css.indexOf(')', next + 1);\n\n            if (next === -1) {\n              if (ignore) {\n                next = pos;\n                break;\n              } else {\n                unclosed('bracket');\n              }\n            }\n\n            escapePos = next;\n\n            while (css.charCodeAt(escapePos - 1) === BACKSLASH) {\n              escapePos -= 1;\n              escaped = !escaped;\n            }\n          } while (escaped);\n\n          tokens.push(['brackets', css.slice(pos, next + 1), line, pos - offset, line, next - offset]);\n          pos = next;\n        } else {\n          next = css.indexOf(')', pos + 1);\n          content = css.slice(pos, next + 1);\n\n          if (next === -1 || RE_BAD_BRACKET.test(content)) {\n            tokens.push(['(', '(', line, pos - offset]);\n          } else {\n            tokens.push(['brackets', content, line, pos - offset, line, next - offset]);\n            pos = next;\n          }\n        }\n\n        break;\n\n      case CLOSE_PARENTHESES:\n        tokens.push([')', ')', line, pos - offset]);\n        break;\n\n      case SINGLE_QUOTE:\n      case DOUBLE_QUOTE:\n        quote = code === SINGLE_QUOTE ? '\\'' : '\"';\n        next = pos;\n\n        do {\n          escaped = false;\n          next = css.indexOf(quote, next + 1);\n\n          if (next === -1) {\n            if (ignore) {\n              next = pos + 1;\n              break;\n            } else {\n              unclosed('string');\n            }\n          }\n\n          escapePos = next;\n\n          while (css.charCodeAt(escapePos - 1) === BACKSLASH) {\n            escapePos -= 1;\n            escaped = !escaped;\n          }\n        } while (escaped);\n\n        content = css.slice(pos, next + 1);\n        lines = content.split('\\n');\n        last = lines.length - 1;\n\n        if (last > 0) {\n          nextLine = line + last;\n          nextOffset = next - lines[last].length;\n        } else {\n          nextLine = line;\n          nextOffset = offset;\n        }\n\n        tokens.push(['string', css.slice(pos, next + 1), line, pos - offset, nextLine, next - nextOffset]);\n        offset = nextOffset;\n        line = nextLine;\n        pos = next;\n        break;\n\n      case AT:\n        RE_AT_END.lastIndex = pos + 1;\n        RE_AT_END.test(css);\n\n        if (RE_AT_END.lastIndex === 0) {\n          next = css.length - 1;\n        } else {\n          next = RE_AT_END.lastIndex - 2;\n        }\n\n        tokens.push(['at-word', css.slice(pos, next + 1), line, pos - offset, line, next - offset]);\n        pos = next;\n        break;\n\n      case BACKSLASH:\n        next = pos;\n        escape = true;\n\n        while (css.charCodeAt(next + 1) === BACKSLASH) {\n          next += 1;\n          escape = !escape;\n        }\n\n        code = css.charCodeAt(next + 1);\n\n        if (escape && code !== SLASH && code !== SPACE && code !== NEWLINE && code !== TAB && code !== CR && code !== FEED) {\n          next += 1;\n        }\n\n        tokens.push(['word', css.slice(pos, next + 1), line, pos - offset, line, next - offset]);\n        pos = next;\n        break;\n\n      default:\n        if (code === SLASH && css.charCodeAt(pos + 1) === ASTERISK) {\n          next = css.indexOf('*/', pos + 2) + 1;\n\n          if (next === 0) {\n            if (ignore) {\n              next = css.length;\n            } else {\n              unclosed('comment');\n            }\n          }\n\n          content = css.slice(pos, next + 1);\n          lines = content.split('\\n');\n          last = lines.length - 1;\n\n          if (last > 0) {\n            nextLine = line + last;\n            nextOffset = next - lines[last].length;\n          } else {\n            nextLine = line;\n            nextOffset = offset;\n          }\n\n          tokens.push(['comment', content, line, pos - offset, nextLine, next - nextOffset]);\n          offset = nextOffset;\n          line = nextLine;\n          pos = next;\n        } else {\n          RE_WORD_END.lastIndex = pos + 1;\n          RE_WORD_END.test(css);\n\n          if (RE_WORD_END.lastIndex === 0) {\n            next = css.length - 1;\n          } else {\n            next = RE_WORD_END.lastIndex - 2;\n          }\n\n          tokens.push(['word', css.slice(pos, next + 1), line, pos - offset, line, next - offset]);\n          pos = next;\n        }\n\n        break;\n    }\n\n    pos++;\n  }\n\n  return tokens;\n}\n\nmodule.exports = exports['default'];","map":{"version":3,"mappings":"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","names":["tokenize","SINGLE_QUOTE","DOUBLE_QUOTE","BACKSLASH","SLASH","NEWLINE","SPACE","FEED","TAB","CR","OPEN_SQUARE","CLOSE_SQUARE","OPEN_PARENTHESES","CLOSE_PARENTHESES","OPEN_CURLY","CLOSE_CURLY","SEMICOLON","ASTERISK","COLON","AT","RE_AT_END","RE_WORD_END","RE_BAD_BRACKET","input","options","tokens","css","valueOf","ignore","ignoreErrors","code","next","quote","lines","last","content","escape","nextLine","nextOffset","escaped","escapePos","prev","n","length","offset","line","pos","unclosed","what","error","charCodeAt","push","slice","indexOf","test","split","lastIndex"],"sources":["tokenize.es6"],"sourcesContent":["const SINGLE_QUOTE      = '\\''.charCodeAt(0);\nconst DOUBLE_QUOTE      =  '\"'.charCodeAt(0);\nconst BACKSLASH         = '\\\\'.charCodeAt(0);\nconst SLASH             =  '/'.charCodeAt(0);\nconst NEWLINE           = '\\n'.charCodeAt(0);\nconst SPACE             =  ' '.charCodeAt(0);\nconst FEED              = '\\f'.charCodeAt(0);\nconst TAB               = '\\t'.charCodeAt(0);\nconst CR                = '\\r'.charCodeAt(0);\nconst OPEN_SQUARE       =  '['.charCodeAt(0);\nconst CLOSE_SQUARE      =  ']'.charCodeAt(0);\nconst OPEN_PARENTHESES  =  '('.charCodeAt(0);\nconst CLOSE_PARENTHESES =  ')'.charCodeAt(0);\nconst OPEN_CURLY        =  '{'.charCodeAt(0);\nconst CLOSE_CURLY       =  '}'.charCodeAt(0);\nconst SEMICOLON         =  ';'.charCodeAt(0);\nconst ASTERISK          =  '*'.charCodeAt(0);\nconst COLON             =  ':'.charCodeAt(0);\nconst AT                =  '@'.charCodeAt(0);\n\nconst RE_AT_END      = /[ \\n\\t\\r\\f\\{\\(\\)'\"\\\\;/\\[\\]#]/g;\nconst RE_WORD_END    = /[ \\n\\t\\r\\f\\(\\)\\{\\}:;@!'\"\\\\\\]\\[#]|\\/(?=\\*)/g;\nconst RE_BAD_BRACKET = /.[\\\\\\/\\(\"'\\n]/;\n\nexport default function tokenize(input, options = { }) {\n    let tokens = [];\n    let css    = input.css.valueOf();\n\n    let ignore = options.ignoreErrors;\n\n    let code, next, quote, lines, last, content, escape,\n        nextLine, nextOffset, escaped, escapePos, prev, n;\n\n    let length = css.length;\n    let offset = -1;\n    let line   =  1;\n    let pos    =  0;\n\n    function unclosed(what) {\n        throw input.error('Unclosed ' + what, line, pos - offset);\n    }\n\n    while ( pos < length ) {\n        code = css.charCodeAt(pos);\n\n        if ( code === NEWLINE || code === FEED ||\n             code === CR && css.charCodeAt(pos + 1) !== NEWLINE ) {\n            offset = pos;\n            line  += 1;\n        }\n\n        switch ( code ) {\n        case NEWLINE:\n        case SPACE:\n        case TAB:\n        case CR:\n        case FEED:\n            next = pos;\n            do {\n                next += 1;\n                code = css.charCodeAt(next);\n                if ( code === NEWLINE ) {\n                    offset = next;\n                    line  += 1;\n                }\n            } while ( code === SPACE   ||\n                      code === NEWLINE ||\n                      code === TAB     ||\n                      code === CR      ||\n                      code === FEED );\n\n            tokens.push(['space', css.slice(pos, next)]);\n            pos = next - 1;\n            break;\n\n        case OPEN_SQUARE:\n            tokens.push(['[', '[', line, pos - offset]);\n            break;\n\n        case CLOSE_SQUARE:\n            tokens.push([']', ']', line, pos - offset]);\n            break;\n\n        case OPEN_CURLY:\n            tokens.push(['{', '{', line, pos - offset]);\n            break;\n\n        case CLOSE_CURLY:\n            tokens.push(['}', '}', line, pos - offset]);\n            break;\n\n        case COLON:\n            tokens.push([':', ':', line, pos - offset]);\n            break;\n\n        case SEMICOLON:\n            tokens.push([';', ';', line, pos - offset]);\n            break;\n\n        case OPEN_PARENTHESES:\n            prev = tokens.length ? tokens[tokens.length - 1][1] : '';\n            n    = css.charCodeAt(pos + 1);\n            if ( prev === 'url' && n !== SINGLE_QUOTE && n !== DOUBLE_QUOTE &&\n                                   n !== SPACE && n !== NEWLINE && n !== TAB &&\n                                   n !== FEED && n !== CR ) {\n                next = pos;\n                do {\n                    escaped = false;\n                    next    = css.indexOf(')', next + 1);\n                    if ( next === -1 ) {\n                        if ( ignore ) {\n                            next = pos;\n                            break;\n                        } else {\n                            unclosed('bracket');\n                        }\n                    }\n                    escapePos = next;\n                    while ( css.charCodeAt(escapePos - 1) === BACKSLASH ) {\n                        escapePos -= 1;\n                        escaped = !escaped;\n                    }\n                } while ( escaped );\n\n                tokens.push(['brackets', css.slice(pos, next + 1),\n                    line, pos  - offset,\n                    line, next - offset\n                ]);\n                pos = next;\n\n            } else {\n                next    = css.indexOf(')', pos + 1);\n                content = css.slice(pos, next + 1);\n\n                if ( next === -1 || RE_BAD_BRACKET.test(content) ) {\n                    tokens.push(['(', '(', line, pos - offset]);\n                } else {\n                    tokens.push(['brackets', content,\n                        line, pos  - offset,\n                        line, next - offset\n                    ]);\n                    pos = next;\n                }\n            }\n\n            break;\n\n        case CLOSE_PARENTHESES:\n            tokens.push([')', ')', line, pos - offset]);\n            break;\n\n        case SINGLE_QUOTE:\n        case DOUBLE_QUOTE:\n            quote = code === SINGLE_QUOTE ? '\\'' : '\"';\n            next  = pos;\n            do {\n                escaped = false;\n                next    = css.indexOf(quote, next + 1);\n                if ( next === -1 ) {\n                    if ( ignore ) {\n                        next = pos + 1;\n                        break;\n                    } else {\n                        unclosed('string');\n                    }\n                }\n                escapePos = next;\n                while ( css.charCodeAt(escapePos - 1) === BACKSLASH ) {\n                    escapePos -= 1;\n                    escaped = !escaped;\n                }\n            } while ( escaped );\n\n            content = css.slice(pos, next + 1);\n            lines   = content.split('\\n');\n            last    = lines.length - 1;\n\n            if ( last > 0 ) {\n                nextLine   = line + last;\n                nextOffset = next - lines[last].length;\n            } else {\n                nextLine   = line;\n                nextOffset = offset;\n            }\n\n            tokens.push(['string', css.slice(pos, next + 1),\n                line, pos  - offset,\n                nextLine, next - nextOffset\n            ]);\n\n            offset = nextOffset;\n            line   = nextLine;\n            pos    = next;\n            break;\n\n        case AT:\n            RE_AT_END.lastIndex = pos + 1;\n            RE_AT_END.test(css);\n            if ( RE_AT_END.lastIndex === 0 ) {\n                next = css.length - 1;\n            } else {\n                next = RE_AT_END.lastIndex - 2;\n            }\n            tokens.push(['at-word', css.slice(pos, next + 1),\n                line, pos  - offset,\n                line, next - offset\n            ]);\n            pos = next;\n            break;\n\n        case BACKSLASH:\n            next   = pos;\n            escape = true;\n            while ( css.charCodeAt(next + 1) === BACKSLASH ) {\n                next  += 1;\n                escape = !escape;\n            }\n            code = css.charCodeAt(next + 1);\n            if ( escape && (code !== SLASH   &&\n                            code !== SPACE   &&\n                            code !== NEWLINE &&\n                            code !== TAB     &&\n                            code !== CR      &&\n                            code !== FEED ) ) {\n                next += 1;\n            }\n            tokens.push(['word', css.slice(pos, next + 1),\n                line, pos  - offset,\n                line, next - offset\n            ]);\n            pos = next;\n            break;\n\n        default:\n            if ( code === SLASH && css.charCodeAt(pos + 1) === ASTERISK ) {\n                next = css.indexOf('*/', pos + 2) + 1;\n                if ( next === 0 ) {\n                    if ( ignore ) {\n                        next = css.length;\n                    } else {\n                        unclosed('comment');\n                    }\n                }\n\n                content = css.slice(pos, next + 1);\n                lines   = content.split('\\n');\n                last    = lines.length - 1;\n\n                if ( last > 0 ) {\n                    nextLine   = line + last;\n                    nextOffset = next - lines[last].length;\n                } else {\n                    nextLine   = line;\n                    nextOffset = offset;\n                }\n\n                tokens.push(['comment', content,\n                    line,     pos  - offset,\n                    nextLine, next - nextOffset\n                ]);\n\n                offset = nextOffset;\n                line   = nextLine;\n                pos    = next;\n\n            } else {\n                RE_WORD_END.lastIndex = pos + 1;\n                RE_WORD_END.test(css);\n                if ( RE_WORD_END.lastIndex === 0 ) {\n                    next = css.length - 1;\n                } else {\n                    next = RE_WORD_END.lastIndex - 2;\n                }\n\n                tokens.push(['word', css.slice(pos, next + 1),\n                    line, pos  - offset,\n                    line, next - offset\n                ]);\n                pos = next;\n            }\n\n            break;\n        }\n\n        pos++;\n    }\n\n    return tokens;\n}\n"]},"metadata":{},"sourceType":"script"}