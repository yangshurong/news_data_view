{"ast":null,"code":"import \"core-js/modules/es.array.sort.js\";\nimport Base from '../core/Base';\nimport Ray from '../math/Ray';\nimport Vector2 from '../math/Vector2';\nimport Vector3 from '../math/Vector3';\nimport Matrix4 from '../math/Matrix4';\nimport Renderable from '../Renderable';\nimport glenum from '../core/glenum';\nimport vec3 from '../glmatrix/vec3';\n/**\n * @constructor clay.picking.RayPicking\n * @extends clay.core.Base\n */\n\nvar RayPicking = Base.extend(\n/** @lends clay.picking.RayPicking# */\n{\n  /**\n   * Target scene\n   * @type {clay.Scene}\n   */\n  scene: null,\n\n  /**\n   * Target camera\n   * @type {clay.Camera}\n   */\n  camera: null,\n\n  /**\n   * Target renderer\n   * @type {clay.Renderer}\n   */\n  renderer: null\n}, function () {\n  this._ray = new Ray();\n  this._ndc = new Vector2();\n},\n/** @lends clay.picking.RayPicking.prototype */\n{\n  /**\n   * Pick the nearest intersection object in the scene\n   * @param  {number} x Mouse position x\n   * @param  {number} y Mouse position y\n   * @param  {boolean} [forcePickAll=false] ignore ignorePicking\n   * @return {clay.picking.RayPicking~Intersection}\n   */\n  pick: function pick(x, y, forcePickAll) {\n    var out = this.pickAll(x, y, [], forcePickAll);\n    return out[0] || null;\n  },\n\n  /**\n   * Pick all intersection objects, wich will be sorted from near to far\n   * @param  {number} x Mouse position x\n   * @param  {number} y Mouse position y\n   * @param  {Array} [output]\n   * @param  {boolean} [forcePickAll=false] ignore ignorePicking\n   * @return {Array.<clay.picking.RayPicking~Intersection>}\n   */\n  pickAll: function pickAll(x, y, output, forcePickAll) {\n    this.renderer.screenToNDC(x, y, this._ndc);\n    this.camera.castRay(this._ndc, this._ray);\n    output = output || [];\n\n    this._intersectNode(this.scene, output, forcePickAll || false);\n\n    output.sort(this._intersectionCompareFunc);\n    return output;\n  },\n  _intersectNode: function _intersectNode(node, out, forcePickAll) {\n    if (node instanceof Renderable && node.isRenderable()) {\n      if ((!node.ignorePicking || forcePickAll) && ( // Only triangle mesh support ray picking\n      node.mode === glenum.TRIANGLES && node.geometry.isUseIndices() // Or if geometry has it's own pickByRay, pick, implementation\n      || node.geometry.pickByRay || node.geometry.pick)) {\n        this._intersectRenderable(node, out);\n      }\n    }\n\n    for (var i = 0; i < node._children.length; i++) {\n      this._intersectNode(node._children[i], out, forcePickAll);\n    }\n  },\n  _intersectRenderable: function () {\n    var v1 = new Vector3();\n    var v2 = new Vector3();\n    var v3 = new Vector3();\n    var ray = new Ray();\n    var worldInverse = new Matrix4();\n    return function (renderable, out) {\n      var isSkinnedMesh = renderable.isSkinnedMesh();\n      ray.copy(this._ray);\n      Matrix4.invert(worldInverse, renderable.worldTransform); // Skinned mesh will ignore the world transform.\n\n      if (!isSkinnedMesh) {\n        ray.applyTransform(worldInverse);\n      }\n\n      var geometry = renderable.geometry;\n      var bbox = isSkinnedMesh ? renderable.skeleton.boundingBox : geometry.boundingBox;\n\n      if (bbox && !ray.intersectBoundingBox(bbox)) {\n        return;\n      } // Use user defined picking algorithm\n\n\n      if (geometry.pick) {\n        geometry.pick(this._ndc.x, this._ndc.y, this.renderer, this.camera, renderable, out);\n        return;\n      } // Use user defined ray picking algorithm\n      else if (geometry.pickByRay) {\n        geometry.pickByRay(ray, renderable, out);\n        return;\n      }\n\n      var cullBack = renderable.cullFace === glenum.BACK && renderable.frontFace === glenum.CCW || renderable.cullFace === glenum.FRONT && renderable.frontFace === glenum.CW;\n      var point;\n      var indices = geometry.indices;\n      var positionAttr = geometry.attributes.position;\n      var weightAttr = geometry.attributes.weight;\n      var jointAttr = geometry.attributes.joint;\n      var skinMatricesArray;\n      var skinMatrices = []; // Check if valid.\n\n      if (!positionAttr || !positionAttr.value || !indices) {\n        return;\n      }\n\n      if (isSkinnedMesh) {\n        skinMatricesArray = renderable.skeleton.getSubSkinMatrices(renderable.__uid__, renderable.joints);\n\n        for (var i = 0; i < renderable.joints.length; i++) {\n          skinMatrices[i] = skinMatrices[i] || [];\n\n          for (var k = 0; k < 16; k++) {\n            skinMatrices[i][k] = skinMatricesArray[i * 16 + k];\n          }\n        }\n\n        var pos = [];\n        var weight = [];\n        var joint = [];\n        var skinnedPos = [];\n        var tmp = [];\n        var skinnedPositionAttr = geometry.attributes.skinnedPosition;\n\n        if (!skinnedPositionAttr || !skinnedPositionAttr.value) {\n          geometry.createAttribute('skinnedPosition', 'f', 3);\n          skinnedPositionAttr = geometry.attributes.skinnedPosition;\n          skinnedPositionAttr.init(geometry.vertexCount);\n        }\n\n        for (var i = 0; i < geometry.vertexCount; i++) {\n          positionAttr.get(i, pos);\n          weightAttr.get(i, weight);\n          jointAttr.get(i, joint);\n          weight[3] = 1 - weight[0] - weight[1] - weight[2];\n          vec3.set(skinnedPos, 0, 0, 0);\n\n          for (var k = 0; k < 4; k++) {\n            if (joint[k] >= 0 && weight[k] > 1e-4) {\n              vec3.transformMat4(tmp, pos, skinMatrices[joint[k]]);\n              vec3.scaleAndAdd(skinnedPos, skinnedPos, tmp, weight[k]);\n            }\n          }\n\n          skinnedPositionAttr.set(i, skinnedPos);\n        }\n      }\n\n      for (var i = 0; i < indices.length; i += 3) {\n        var i1 = indices[i];\n        var i2 = indices[i + 1];\n        var i3 = indices[i + 2];\n        var finalPosAttr = isSkinnedMesh ? geometry.attributes.skinnedPosition : positionAttr;\n        finalPosAttr.get(i1, v1.array);\n        finalPosAttr.get(i2, v2.array);\n        finalPosAttr.get(i3, v3.array);\n\n        if (cullBack) {\n          point = ray.intersectTriangle(v1, v2, v3, renderable.culling);\n        } else {\n          point = ray.intersectTriangle(v1, v3, v2, renderable.culling);\n        }\n\n        if (point) {\n          var pointW = new Vector3();\n\n          if (!isSkinnedMesh) {\n            Vector3.transformMat4(pointW, point, renderable.worldTransform);\n          } else {\n            // TODO point maybe not right.\n            Vector3.copy(pointW, point);\n          }\n\n          out.push(new RayPicking.Intersection(point, pointW, renderable, [i1, i2, i3], i / 3, Vector3.dist(pointW, this._ray.origin)));\n        }\n      }\n    };\n  }(),\n  _intersectionCompareFunc: function _intersectionCompareFunc(a, b) {\n    return a.distance - b.distance;\n  }\n});\n/**\n * @constructor clay.picking.RayPicking~Intersection\n * @param {clay.Vector3} point\n * @param {clay.Vector3} pointWorld\n * @param {clay.Node} target\n * @param {Array.<number>} triangle\n * @param {number} triangleIndex\n * @param {number} distance\n */\n\nRayPicking.Intersection = function (point, pointWorld, target, triangle, triangleIndex, distance) {\n  /**\n   * Intersection point in local transform coordinates\n   * @type {clay.Vector3}\n   */\n  this.point = point;\n  /**\n   * Intersection point in world transform coordinates\n   * @type {clay.Vector3}\n   */\n\n  this.pointWorld = pointWorld;\n  /**\n   * Intersection scene node\n   * @type {clay.Node}\n   */\n\n  this.target = target;\n  /**\n   * Intersection triangle, which is an array of vertex index\n   * @type {Array.<number>}\n   */\n\n  this.triangle = triangle;\n  /**\n   * Index of intersection triangle.\n   */\n\n  this.triangleIndex = triangleIndex;\n  /**\n   * Distance from intersection point to ray origin\n   * @type {number}\n   */\n\n  this.distance = distance;\n};\n\nexport default RayPicking;","map":{"version":3,"sources":["C:/Users/Administrator/Desktop/data_view/my_project/vue2_app/myapp/node_modules/claygl/src/picking/RayPicking.js"],"names":["Base","Ray","Vector2","Vector3","Matrix4","Renderable","glenum","vec3","RayPicking","extend","scene","camera","renderer","_ray","_ndc","pick","x","y","forcePickAll","out","pickAll","output","screenToNDC","castRay","_intersectNode","sort","_intersectionCompareFunc","node","isRenderable","ignorePicking","mode","TRIANGLES","geometry","isUseIndices","pickByRay","_intersectRenderable","i","_children","length","v1","v2","v3","ray","worldInverse","renderable","isSkinnedMesh","copy","invert","worldTransform","applyTransform","bbox","skeleton","boundingBox","intersectBoundingBox","cullBack","cullFace","BACK","frontFace","CCW","FRONT","CW","point","indices","positionAttr","attributes","position","weightAttr","weight","jointAttr","joint","skinMatricesArray","skinMatrices","value","getSubSkinMatrices","__uid__","joints","k","pos","skinnedPos","tmp","skinnedPositionAttr","skinnedPosition","createAttribute","init","vertexCount","get","set","transformMat4","scaleAndAdd","i1","i2","i3","finalPosAttr","array","intersectTriangle","culling","pointW","push","Intersection","dist","origin","a","b","distance","pointWorld","target","triangle","triangleIndex"],"mappings":"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","sourcesContent":["import Base from '../core/Base';\nimport Ray from '../math/Ray';\nimport Vector2 from '../math/Vector2';\nimport Vector3 from '../math/Vector3';\nimport Matrix4 from '../math/Matrix4';\nimport Renderable from '../Renderable';\nimport glenum from '../core/glenum';\nimport vec3 from '../glmatrix/vec3';\n\n/**\n * @constructor clay.picking.RayPicking\n * @extends clay.core.Base\n */\nvar RayPicking = Base.extend(/** @lends clay.picking.RayPicking# */{\n    /**\n     * Target scene\n     * @type {clay.Scene}\n     */\n    scene: null,\n    /**\n     * Target camera\n     * @type {clay.Camera}\n     */\n    camera: null,\n    /**\n     * Target renderer\n     * @type {clay.Renderer}\n     */\n    renderer: null\n}, function () {\n    this._ray = new Ray();\n    this._ndc = new Vector2();\n},\n/** @lends clay.picking.RayPicking.prototype */\n{\n\n    /**\n     * Pick the nearest intersection object in the scene\n     * @param  {number} x Mouse position x\n     * @param  {number} y Mouse position y\n     * @param  {boolean} [forcePickAll=false] ignore ignorePicking\n     * @return {clay.picking.RayPicking~Intersection}\n     */\n    pick: function (x, y, forcePickAll) {\n        var out = this.pickAll(x, y, [], forcePickAll);\n        return out[0] || null;\n    },\n\n    /**\n     * Pick all intersection objects, wich will be sorted from near to far\n     * @param  {number} x Mouse position x\n     * @param  {number} y Mouse position y\n     * @param  {Array} [output]\n     * @param  {boolean} [forcePickAll=false] ignore ignorePicking\n     * @return {Array.<clay.picking.RayPicking~Intersection>}\n     */\n    pickAll: function (x, y, output, forcePickAll) {\n        this.renderer.screenToNDC(x, y, this._ndc);\n        this.camera.castRay(this._ndc, this._ray);\n\n        output = output || [];\n\n        this._intersectNode(this.scene, output, forcePickAll || false);\n\n        output.sort(this._intersectionCompareFunc);\n\n        return output;\n    },\n\n    _intersectNode: function (node, out, forcePickAll) {\n        if ((node instanceof Renderable) && node.isRenderable()) {\n            if ((!node.ignorePicking || forcePickAll)\n                && (\n                    // Only triangle mesh support ray picking\n                    (node.mode === glenum.TRIANGLES && node.geometry.isUseIndices())\n                    // Or if geometry has it's own pickByRay, pick, implementation\n                    || node.geometry.pickByRay\n                    || node.geometry.pick\n                )\n            ) {\n                this._intersectRenderable(node, out);\n            }\n        }\n        for (var i = 0; i < node._children.length; i++) {\n            this._intersectNode(node._children[i], out, forcePickAll);\n        }\n    },\n\n    _intersectRenderable: (function () {\n\n        var v1 = new Vector3();\n        var v2 = new Vector3();\n        var v3 = new Vector3();\n        var ray = new Ray();\n        var worldInverse = new Matrix4();\n\n        return function (renderable, out) {\n\n            var isSkinnedMesh = renderable.isSkinnedMesh();\n            ray.copy(this._ray);\n            Matrix4.invert(worldInverse, renderable.worldTransform);\n\n            // Skinned mesh will ignore the world transform.\n            if (!isSkinnedMesh) {\n                ray.applyTransform(worldInverse);\n            }\n\n            var geometry = renderable.geometry;\n\n            var bbox = isSkinnedMesh ? renderable.skeleton.boundingBox : geometry.boundingBox;\n\n            if (bbox && !ray.intersectBoundingBox(bbox)) {\n                return;\n            }\n            // Use user defined picking algorithm\n            if (geometry.pick) {\n                geometry.pick(\n                    this._ndc.x, this._ndc.y,\n                    this.renderer,\n                    this.camera,\n                    renderable, out\n                );\n                return;\n            }\n            // Use user defined ray picking algorithm\n            else if (geometry.pickByRay) {\n                geometry.pickByRay(ray, renderable, out);\n                return;\n            }\n\n            var cullBack = (renderable.cullFace === glenum.BACK && renderable.frontFace === glenum.CCW)\n                        || (renderable.cullFace === glenum.FRONT && renderable.frontFace === glenum.CW);\n\n            var point;\n            var indices = geometry.indices;\n            var positionAttr = geometry.attributes.position;\n            var weightAttr = geometry.attributes.weight;\n            var jointAttr = geometry.attributes.joint;\n            var skinMatricesArray;\n            var skinMatrices = [];\n            // Check if valid.\n            if (!positionAttr || !positionAttr.value || !indices) {\n                return;\n            }\n            if (isSkinnedMesh) {\n                skinMatricesArray = renderable.skeleton.getSubSkinMatrices(renderable.__uid__, renderable.joints);\n                for (var i = 0; i < renderable.joints.length; i++) {\n                    skinMatrices[i] = skinMatrices[i] || [];\n                    for (var k = 0; k < 16; k++) {\n                        skinMatrices[i][k] = skinMatricesArray[i * 16 + k];\n                    }\n                }\n                var pos = [];\n                var weight = [];\n                var joint = [];\n                var skinnedPos = [];\n                var tmp = [];\n                var skinnedPositionAttr = geometry.attributes.skinnedPosition;\n                if (!skinnedPositionAttr || !skinnedPositionAttr.value) {\n                    geometry.createAttribute('skinnedPosition', 'f', 3);\n                    skinnedPositionAttr = geometry.attributes.skinnedPosition;\n                    skinnedPositionAttr.init(geometry.vertexCount);\n                }\n                for (var i = 0; i < geometry.vertexCount; i++) {\n                    positionAttr.get(i, pos);\n                    weightAttr.get(i, weight);\n                    jointAttr.get(i, joint);\n                    weight[3] = 1 - weight[0] - weight[1] - weight[2];\n                    vec3.set(skinnedPos, 0, 0, 0);\n                    for (var k = 0; k < 4; k++) {\n                        if (joint[k] >= 0 && weight[k] > 1e-4) {\n                            vec3.transformMat4(tmp, pos, skinMatrices[joint[k]]);\n                            vec3.scaleAndAdd(skinnedPos, skinnedPos, tmp, weight[k]);\n                        }\n                    }\n                    skinnedPositionAttr.set(i, skinnedPos);\n                }\n            }\n\n            for (var i = 0; i < indices.length; i += 3) {\n                var i1 = indices[i];\n                var i2 = indices[i + 1];\n                var i3 = indices[i + 2];\n                var finalPosAttr = isSkinnedMesh\n                    ? geometry.attributes.skinnedPosition\n                    : positionAttr;\n                finalPosAttr.get(i1, v1.array);\n                finalPosAttr.get(i2, v2.array);\n                finalPosAttr.get(i3, v3.array);\n\n                if (cullBack) {\n                    point = ray.intersectTriangle(v1, v2, v3, renderable.culling);\n                }\n                else {\n                    point = ray.intersectTriangle(v1, v3, v2, renderable.culling);\n                }\n                if (point) {\n                    var pointW = new Vector3();\n                    if (!isSkinnedMesh) {\n                        Vector3.transformMat4(pointW, point, renderable.worldTransform);\n                    }\n                    else {\n                        // TODO point maybe not right.\n                        Vector3.copy(pointW, point);\n                    }\n                    out.push(new RayPicking.Intersection(\n                        point, pointW, renderable, [i1, i2, i3], i / 3,\n                        Vector3.dist(pointW, this._ray.origin)\n                    ));\n                }\n            }\n        };\n    })(),\n\n    _intersectionCompareFunc: function (a, b) {\n        return a.distance - b.distance;\n    }\n});\n\n/**\n * @constructor clay.picking.RayPicking~Intersection\n * @param {clay.Vector3} point\n * @param {clay.Vector3} pointWorld\n * @param {clay.Node} target\n * @param {Array.<number>} triangle\n * @param {number} triangleIndex\n * @param {number} distance\n */\nRayPicking.Intersection = function (point, pointWorld, target, triangle, triangleIndex, distance) {\n    /**\n     * Intersection point in local transform coordinates\n     * @type {clay.Vector3}\n     */\n    this.point = point;\n    /**\n     * Intersection point in world transform coordinates\n     * @type {clay.Vector3}\n     */\n    this.pointWorld = pointWorld;\n    /**\n     * Intersection scene node\n     * @type {clay.Node}\n     */\n    this.target = target;\n    /**\n     * Intersection triangle, which is an array of vertex index\n     * @type {Array.<number>}\n     */\n    this.triangle = triangle;\n    /**\n     * Index of intersection triangle.\n     */\n    this.triangleIndex = triangleIndex;\n    /**\n     * Distance from intersection point to ray origin\n     * @type {number}\n     */\n    this.distance = distance;\n};\n\nexport default RayPicking;\n"]},"metadata":{},"sourceType":"module"}